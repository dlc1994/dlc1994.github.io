{"pages":[{"title":"戴凌成（Lingcheng Dai)","text":"个人信息 手机：(+86)XXXXXXXXX Email：dailingcheng@foxmail.com 技术博客：https://dlc1994.github.io Github: https://github.com/dlc1994 教育经历北京邮电大学 信息与通信工程学院 信息与通信工程 工学硕士 2017.09-2020.06北京邮电大学 信息与通信工程学院 通信工程 工学学士 2013.09-2017.06 竞赛经历中国第二届高性能云计算创新大赛—区块链地址分类数据算法竞赛 二等奖 2019.07 从超过4000 万条比特币交易数据中提取与地址类别相关的交易特征（交易笔数、矿工费、时间等） 根据任务+交易特性结合随机森林模型+多进程搜索进行比特币地址标记分类，预测准确率达99.99% 百度&amp; 西安交大国际大数据竞赛城市功能区域分类 59/2037 2019.06 给定城市9 类功能区域的带噪遥感图像与用户访问数据，对图像进行去噪+访问数据矩阵化 设计双分支网络（ImageNet 预训练模型+微调）进行融合并使特征向量维度相同，预测准确率达0.67 中国“易华录杯”CCF软件服务创新大赛——公交线路准点预测 三等奖 2018.09 对天津市公交车超过4亿条GPS记录进行数据处理，构建天气、日期等特征并进行one-hot编码 调用XGBoost 进行训练，预测结果再与平均值线性叠加后乘以拥堵系数，输出公交车站点间运行时间 北邮、北师、中农大校园大数据竞赛——校园人流量预测 5% 2018.03 提取校园内33个地点10个月内采集的所有手机终端位置的数据，利用数据挖掘平台WEKA，对常用时间序列分析模型比如ARIMA,ARCH等进行分析 考虑课程、节假日对人流量的影响，不断修正预测模型及模型参数，最终对11月和12月校园内33个地点每小时的人数进行预测。 工作经历华为技术有限公司 华为云Cloud BU 调度优化算法工程师 2019.07 - 2019.09 利用PostgreSQL+PostGIS 部署地图查询服务，优化基于交互投票的路网匹配算法、设计关键点提取算法； 调研并初步构建首汽共享汽车的多网点租还需求预测、网点间均衡调度与VRP 问题以解决潮汐现象； 北京佰才帮技术有限公司 协议栈开发工程师 2019.02 - 2019.03 负责5G/LTE小基站上Layer2/Layer3（MAC、PDCP、RLC和RRC等）协议栈的研究、设计工作； 负责在CentOS上编写Makefile完成C代码工程中若干个库的编译和静态库封装； 负责完成一些代码整合、移植和混淆工作。 科研项目华为HIRP项目“基于机器学习的免传模一键式站址规划” 2018.01 - 2019.01独立完成从原始数据文件中用python提取数据，利用开源库Scikit-learn中的机器学习算法比如SVM、k近邻、神经网络等，在CentOS服务器上训练得到电平预测模型，最后利用遗传算法（开源框架GAFT）和贪心算法对基站覆盖率进行在线优化，确定基站最优部署参数。工程代码达上千行。 华为HIRP项目“以用户为中心网络下的资源管理和干扰协同研究” 2017.09-2018.08独立完成在以用户为中心的多天线超密组网下，基于WMMSE设计了一种低复杂度的分布式聚簇和波束赋形算法，通过块对角化方法将原始NP-hard非凸问题分解为各簇各变量的凸优化问题，再采用拉格朗日乘数法求解，最后在Matlab上进行系统级仿真，提升了边缘用户速率。 中兴项目“超密组网下的用户移动性预测研究” 2017.08-2018.06独立完成对现有学术界移动性预测方案的调研，对当前移动性预测采用的方案进行了详细总结，包括（隐）马尔科夫过程、贝叶斯网络、数据挖掘和神经网络等，并提出移动性预测在未来5G及6G路径规划、移动性优化、辅助定位上的应用和挑战，以及深度学习可能带来的巨大性能提升。 发表作品 &lt;学生一作&gt;, “Pricing-Based Semi-Distributed Clustering and Beamforming for User-Centric MIMO Networks,” IEEE Communications Letters, vol. 23, no. 12, pp. 2398-2401, Dec. 2019.（SCI，影响因子3.457） &lt;学生一作&gt;, “Mobility Prediction: A Survey on State-of-the-Art Schemes and Future Applications,” IEEE Access, vol. 7, pp. 802-822, 2019.（SCI，影响因子3.557） &lt;第一作者&gt;, “Decentralized Clustering and Beamforming Based on Interference Pricing in User-Centric Networks,” in IEEE PIMRC, Istanbul, Turkey, 2019, pp. 1-6.（EI，B类会议） &lt;第一作者&gt;, “Propagation-model-free Coverage Evaluation via Machine Learning for Future 5G Networks,” in IEEE PIMRC, Italy, 2018, pp. 1-5.（EI，B类会议） 获奖经历 2018-2019 国家奖学金 2017-2019 一等学业奖学金 2015-2016 国家励志奖学金、校“三好学生”、优秀共青团员 2014 北京邮电大学“明日之星”英语风采大赛 配音组二等奖 技能 程序开发：C++/Python/Matlab 排版编辑：LaTex/Markdown/MS Office 操作系统：Linux/Windows 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"LeetCode--Two Sum","text":"Description of Problem: Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice.Example:1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].&gt; Approach 1: Brute Force1234for i in range(0,len(nums)-1): for j in range(i+1,len(nums)): if nums[i]+nums[j]==target: return [i,j] running time: 5640ms Approach 2: Python List.index1234for i in range(len(nums)): if (target-nums[i]) in nums: if (nums.index(target - nums[i])) != i: return [i, nums.index(target - nums[i])] running time: 1072ms Approach 3: Python Dict123456dict = {}for i in range(len(nums)): if (target-nums[i]) in dict: return [dict[(target-nums[i])], i] else: dict[nums[i]]=i running time: 40ms Approach 4: Enumerate+Hash_Table12345hash_table={}for i, value in enumerate (nums): if target-value in hash_table: return hash_table[target-value], i hash_table[value]=i running time: 40ms","link":"/drafts/LeetCode--Two Sum.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"机器学习笔记","text":"机器学习笔记精编版，秋招时的学习笔记 传统机器学习Logistic Regression和percetron的异同 二者都是线性分类器 损失函数不同，LR是极大似然（交叉熵，对数似然函数，logistic损失（误差平方和损失）目标函数非凸），感知机使用的是均方损失函数（即最小化错误点到分离平面的距离） 逻辑斯蒂比感知机的优点在于对于激活函数的改进。LR为sigmoid函数，连续可导，概率解释能力，分类更好感知机为阶跃函数，分段函数，分类粗糙，线性分类器参数学习，错误驱动的在线学习算法损失函数L(w;x,y)=max(0, -ywx),如果训练集线性可分，算法必定收敛不足：1.泛化能力不能保证；2.样本顺序敏感；3.不线性可分不收敛改进：参数平均：投票感知机、平均感知机拓展到多分类：构建输入输出联合空间特征函数，将样本(x,y)映射到特征向量空间C分类问题，特征函数φ(x,y)=vec(yx),y为类别的one-hot向量表示 LR的最大损失函数推导最大似然概率p(x|θ) 是条件概率的表示方法，θ 是前置条件，理解为在 θ 的前提下，事件 x 发生的概率，相对应的似然为L(θ|x)可以理解为已知结果为 x ，参数为 θ对应的概率，即：L(θ|x)=P(x|θ)需要说明的是两者在数值上相等，但是意义并不相同，L 是关于 θ 的函数，而 P 则是关于 x 的函数机器学习领域，我们更关注的是似然函数的最大值，我们需要根据已知事件来找出产生这种结果最有可能的条件，目的当然是根据这个最有可能的条件去推测未知事件的概率对数函数不改变原函数的单调性和极值位置，而且根据对数函数的性质可以将乘积转换为加减式，这可以大大简化求导的过程： SVM 线性可分支持向量机（硬间隔） 线性支持向量机（软间隔）线性可分支持向量机的解W唯一但b不唯一线性支持向量机学习等价于最小化二阶范数正则化的合页函数合页损失函数（正确分类且函数间隔大于1，损失为0，max(z,0)） 非线性支持向量机通过非线性变换转化为高维特征空间中的线性分类问题，即核函数 序列最小化优化（SMO）算法支持向量机的学习快速算法，固定αi之外的所有参数，然后求αi上的极值；不断重复直至收敛。 和LR的异同（https://www.cnblogs.com/zhizhan/p/5038747.html） 不考虑核函数，LR和SVM都是线性分类算法，分类决策面是线性的 本质是损失函数不同，LR是对数似然函数（基于概率），SVM是合页损失函数（基于几何间隔） SVM只考虑边界点，LR考虑全局，所以LR一般不用核函数 SVM依赖数据距离测度，需要先做normalization，LR不受影响 SVM损失函数自带正则（结构风险最小化），LR需要添加 One-Hot Encoding （dummy variables) 一组编码[0 0 1 0]，一个为1其他为0，处理离散分类特征 许多算法基于向量空间计算，取值拓展到欧氏空间，扩充特征 特征空间大时，可结合PCA 树模型不太需要one-hot编码，对DT来说是增加树的深度 生成模型 监督生成模型朴素贝叶斯、隐马尔科夫、条件随机场 非监督生成模型受限玻尔兹曼机、GAN、自回归、变分自编码器、深度信念网络 模型融合：Stacking 和 Blending Stacking stacking是一种分层模型集成框架。以两层为例，第一层由多个基学习器组成，其输入为原始训练集，第二层的模型则是以第一层基学习器的输出作为特征加入训练集进行再训练，从而得到完整的stacking模型。 样例：假设我们有Training data（有label）和Testing data（无label），我们需要建立起模型对Testing data的label进行预测，我们利用两个基模型KNN和SVM进行stacking，首先我们需要训练好两个基模型 一、KNN（Base model 1） 5-fold Cross-Validation + Grid Search确定K的大小 二、SVM（Base model 2） 5-fold Cross-Validation + Grid Search确定参数 type 和 cost 三、Stacking（Meta Ensembling）将training data划分成5个testing folds为training data和testing中的每一个样本添加空属性M1、M2（model 1、2的输出），记为train_meta 和 test_meta对于每一个test fold:3.1)将其他4个folds作为一个traing fold，将此training fold作为model 1的输入，对test fold进行预测，将结果存放进train_meta的M1中，类似model 2 的结果存在M2中3.2)将整个training data作为base model的输入，对testing data进行预测，model 1、2的结果分别存在test_meta的M1、M2中将train_meta作为一个新模型S（也就是stacking model）的输入，对test_meta进行预测 stacking方法从一开始就得确定一个Kfold，这个Kfold将伴随对基模型的调参、生成元特征以及对元模型的调参，贯穿整个stacking流程 Blending Blending与Stacking大致相同，只是Blending的主要区别在于训练集不是通过K-Fold的CV策略来获得预测值从而生成第二阶段模型的特征，而是建立一个Holdout集，例如10%的训练数据，第二阶段的stacker模型就基于第一阶段模型对这10%训练数据的预测值进行拟合。说白了，就是把Stacking流程中的K-Fold CV 改成 HoldOut CV。 Adaboost,XGBoost,Bagging,LightBoost Boost算法 初始样本权重，每次训练得到模型赋予错分样本更大的权重，N次迭代后对N个模型进行加权叠加或投票，得到预测结果；串行过程，不好并行化，计算复杂度高，不适合高维稀疏特征 XGBoost GBDT以CART作为基分类器，XGBoost支持线性分类器（L1，L2的逻辑回归或线性回归） GBDT优化使用一阶导数，XGBoost对代价函数进行二阶泰勒展开，支持自定义代价函数 XGBoost加入正则项，包括树的叶子节点个数、叶子节点上score值（正则化是从bias-variance考虑，可以降低模型variance，降低模型复杂度，防止过拟合，传统GBDT没有?） 列采样（每个模型随机选取一些列），借鉴随机森林，目的是降低过拟合 Shrinkage（缩减），相当于学习速率（xgboost中的eta）。xgboost在进行完一次迭代后，会将叶子节点的权重乘上该系数，主要是为了削弱每棵树的影响，让后面有更大的学习空间 并行化。不是像bagging，仍然是boost方式，并行是在特征排序上， xgboost在训练之前，预先对数据进行排序，然后保存成block结构，后面的迭代中重复的使用这个结构，大大的减少了计算量。在进行节点分裂时，计算每个特征的信息增益，各个特征的增益计算就可以开多线程计算。 分裂节点公式： lightGBM 训练速度更快，效率更高。 降低内存使用率。 更好的准确性。 支持并行和GPU学习。 能够处理大规模数据。 与XGBoost GBDT区别：xgboost采用预排序算法进行特征分割，比较简单；LightGBM用的是histogram（直方图），将连续特征（属性）值存储到离散的bin中，加快训练速度和减少内存使用量稀疏特征优化xgboost是level-wise，多线程同时分类同一层叶子，但不加区分，开销大；lightGBM是leaf-wise的，每次找分类增益最大进行分裂，限制最大深度，防止过拟合并行优化（feature parallel, data parallel, voting parallel） GBDT GBDT用的回归树 GBDT 是以决策树为基学习器、采用 Boosting 策略的一种集成学习模型 与提升树的区别：残差的计算不同，提升树使用的是真正的残差，梯度提升树用当前模型的负梯度来拟合残差。 核心是每棵树学习的是之前所有树结论和的残差，所有树累加起来做最终结论 本质上，Shrinkage为每棵树设置了一个weight，累加时要乘以这个weight，但和Gradient并没有关系。 随机森林 Bagging的典型应用；随机采样（行、列），防止过拟合；剪枝、限制树深度优点 在当前的很多数据集上，相对其他算法有着很大的优势，表现良好 它能够处理很高维度（feature很多）的数据，并且不用做特征选择 PS：特征子集是随机选择的 在训练完后，它能够给出哪些feature比较重要 PS：http://blog.csdn.net/keepreder/article/details/47277517 在创建随机森林的时候，对generlization error使用的是无偏估计，模型泛化能力强 训练速度快，容易做成并行化方法 PS：训练时树与树之间是相互独立的 在训练过程中，能够检测到feature间的互相影响 实现比较简单 对于不平衡的数据集来说，它可以平衡误差。 如果有很大一部分的特征遗失，仍可以维持准确度。缺点：1、随机森林已经被证明在某些噪音较大的分类或回归问题上会过拟合2、对于有不同取值的属性的数据，取值划分较多的属性会对随机森林产生更大的影响，所以随机森林在这种数据上产出的属性权值是不可信的。 决策树 决策树学习算法：特征选择、决策树的生成、剪枝（条件概率分布） ID3算法：信息增益；C4.5：信息增益比 CART分类：基尼系数；CART回归：平方损失函数，用平方误差最小的准则（最小二乘法）求解每个单元上的最优输出值（每个叶子节点上的预测值为所有样本的平均值）。 决策树的生成通常使用 信息增益最大、信息增益比最大或基尼指数最小作为特征选择的准则。 过拟合和欠拟合 正则化 L1（L=∑|w|）和L2(L=||w||^2)；L1的稀疏性，指的就是在加了L1正则项后，模型的解w，有很多分量都是0。引入L2正则时，代价函数在0处的导数仍是d0，无变化。而引入L1正则后，代价函数在0处的导数有一个突变。从d0+λ到d0−λ，若d0+λ和d0−λ异号，则在0处会是一个极小值点。代价函数求导。因此，优化时，很可能优化到该极小值点上，即w=0处。 提前停止 当测试集误差不再下降时停止可以避免过拟合 dropout 偏差-方差分解 在模型能力和复杂度之间取得一个较好的平衡 偏差高，模型拟合能力不够：增加数据特征、提高模型复杂度、减少正则化系数 方差高，模型过拟合（训练集错误低，验证集错误高）：降低模型复杂度，加大正则化系数，引入先验、集成模型 参数估计 经验风险最小化 真实标签与预测标签的差异；最小二乘估计（最小均方误差）；XX^T必须满秩，即rank(XX^T)=d+1，X中每行特征之间线性不相关；样本数小于特征数也不可逆，存在多组解；当XX^T不可逆时，可用PCA消除相关性 结构风险最小化 正则化；岭回归（w=(XX^T+λI）^(-1)Xy，使其秩不为0，可看出结构风险最小化准则的LSE； 最大似然估计 MLE是指找到一组参数w使得似然函数p(y|X,w, σ) 最大，等价于对数似然函数log p(y|X,w, σ) 最大。 最大后验估计 贝叶斯估计；MAP是指最优参数为后验分布p(w|X, y, ν, σ) 中概率密度最高的参数w。当ν → ∞时，先验分布p(w|ν) 退化为均匀分布，称为无信息先验（non-informative prior），最大后验估计退化为最大似然估计。 损失函数交叉熵（cross entropy) https://blog.csdn.net/mieleizhi0522/article/details/80200126 特征工程 特征选择和特征抽取的优点是可以用较少的特征来表示原始特征中的大部分相关信息，去掉噪声信息，并进而提高计算效率和减小维度灾难 特征选择 选取原始特征集合的一个有效子集，使得基于这个特征子集训练出来的模型准确率最高；子集搜索—前向搜索，反向搜索、L1正则化 特征抽取 构造一个新的特征空间，并将原始特征投影在新的空间中。线性判断分析（LDA，监督）、PCA（无监督） 评价标准分类问题，常见的评价标准有正确率、准确率、召回率和F值，AUC,ROC,PR曲线 混淆矩阵 ROC(Receiver operating characteristic) AUC(Area under the curve)https://tracholar.github.io/machine-learning/2018/01/26/auc.html准确率、召回率、F1值等依赖于判决阈值的评估指标，AUC没有 AUC可以看做随机从正负样本中选取一对正负样本，其中正样本的得分大于负样本的概率！ 超参优化 超参优化 网络结构，包括神经元之间的连接关系、层数、每层的神经元数量、激活函数的类型等； 优化参数，包括优化方法、学习率、小批量的样本数量等； 正则化系数。 超参设置方法：人工搜索、网格搜索和随机搜索。网格搜索和随机搜索都没有利用不同超参数组合之间的相关性，即如果模型的超参数组合比较类似，其模型性能也是比较接近的。因此这两种搜索方式一般都比较低效。 自适应的超参数优化方法：贝叶斯优化和动态资源分配 贝叶斯优化的一个缺点是高斯过程建模需要计算协方差矩阵的逆，时间复杂度是O(n3)，因此不能很好地处理高维情况。深层神经网络的超参数一般比较多，为了使用贝叶斯优化来搜索神经网络的超参数，需要一些更高效的高斯过程建模 动态资源分配通过一组超参数的学习曲线来预估这组超参数配置是否有希望得到比较好的结果。逐次减半，将超参数优化看作是一种非随机的最优臂问题 神经架构搜索 网络正则化传统的机器学习中，提高泛化能力的方法主要是限制模型复杂度，比如采用ℓ1 和ℓ2 正则化等方式。在训练深层神经网络时，特别是在过度参数（Over-Parameterized）（过度参数是指模型参数的数量远远大于训练数据的数量）时，ℓ1 和ℓ2 正则化的效果往往不如浅层机器学习模型中显著。因此训练深度学习模型时，往往还会使用其它的正则化方法，比如数据增强、提前停止、丢弃法、集成法等。 权重衰减 提前停止 丢弃法（dropout) 随机丢弃一部分神经元（对应连接边） 集成学习的解释（每做一次丢弃，相当于从原始的网络中采样得到一个子网络）、贝叶斯学习的解释 循环神经网络上的dropout 当在循环神经网络上应用丢弃法，不能直接对每个时刻的隐状态进行随机丢弃，这样会损害循环网络在时间维度上记忆能力。一种简单的方法是对非时间维度的连接（即非循环连接）进行随机丢失 数据增强 通过数据增强（Data Augmentation）来增加数据量，提高模型鲁棒性，避免过拟合 旋转（Rotation）：将图像按顺时针或逆时针方向随机旋转一定角度； 翻转（Flip）：将图像沿水平或垂直方法随机翻转一定角度； 缩放（Zoom In/Out）：将图像放大或缩小一定比例； 平移（Shift）：将图像沿水平或垂直方法平移一定步长； 加噪声（Noise）：加入随机噪声。 标签平滑 注意力机制一个和注意力有关的例子是鸡尾酒会效应。当一个人在吵闹的鸡尾酒会上和朋友聊天时，尽管周围噪音干扰很多，他还是可以听到朋友的谈话内容，而忽略其他人的声音（聚焦式注意力）。同时，如果未注意到的背景声中有重要的词（比如他的名字），他会马上注意到（显著性注意力）。 可以将最大汇聚（max pooling）、门控（gating）机制来近似地看作是自下而上的基于显著性的注意力机制 注意力机制的计算可以分为两步：一是在所有输入信息上计算注意力分布，二是根据注意力分布来计算输入信息的加权平均 深度学习深层神经网络是一个高度非线性的模型，其风险函数是一个非凸函数，因此风险最小化是一个非凸优化问题，会存在很多局部最优点。 低维空间的非凸优化问题主要是存在一些局部最优点。 在高维空间中，非凸优化的难点并不在于如何逃离局部最优点，而是如何逃离鞍点。鞍点的梯度是0，但是在一些维度上是最高点，在另一些维度上是最低点 深层神经网络的参数非常多，并且有一定的冗余性，这导致每单个参数对最终损失的影响都比较小，这导致了损失函数在局部最优点附近是一个平坦的区域，称为平坦最小值 梯度下降法及其变种优缺点【An overview of gradient descent optimization algorithms】 发展历程——SGD -&gt; SGDM -&gt; NAG -&gt;AdaGrad -&gt; AdaDelta -&gt; Adam -&gt; Nadam BGD的时间复杂度是O(mn)其中m是一次迭代计算的样本数（所有样本），n是样本特征数。 SGB的时间复杂度是O(n)好吧？ SGD一次迭代计算的样本数为1，n为样本特征数 BatchGD 全数据集用于训练，有大量冗余计算；很慢且消耗内存；可以保证到达局部最优（非凸）或全局最优（凸） StochasticGD 一次用一个样本，取消冗余计算；更快、可在线；以高variance更新导致目标函数严重震荡，可能跳出局部最优点找到更好的，也可能不收敛（慢慢减少学习率） Mini-batchGD 一次用一部分，结合两者优势；减少参数更新variance，稳定收敛；利用矩阵优势，计算梯度效率更高？挑战：学习率的选择策略——预定义、动态调整；不同特征的学习率（低频特征步长更大）；鞍点 Momentum 加速相关方向抑制震荡；更新公式与前一次更新值有关；下降像放球一样，在同一个方向上会越来越快，在不同梯度方向会减少更新；更快收敛和更少震荡 NesterovAcceleratedGreadient 动量法盲目跟随斜坡；NAG上升前先减速，对梯度下降方向有粗略预测；用到了二阶信息，上一个下降点的二阶导（黄色部分） Adagrad 调整学习率（低频更新大，高频更新小，词嵌入）；适合处理稀疏数据；鲁棒性提升；参数更新率不同per-parameter update;Gt,ii为对角矩阵，对角元素为过去梯度的平方和，可向量化；不需要人为调整学习率；缺陷在于平方梯度在分母，随着训练学习率会变很小，后面不再更新 123# Adagrad updatecache += dx*82x += - learning_rate * dx / (np.sqrt(cache) + 1e-7) Adagrad updatecache += dx82x += - learning_rate dx / (np.sqrt(cache) + 1e-7) Adadelta Adagrad的拓展，旨在减少它单调递减的学习率；不收集过去所有梯度，而是收集过去固定值w大小的梯度量； RMSprop 也是Adagrad的改进，是Adadelta的第一步推导；一种泄露机制 123# RMSPorpcache = decay_rate * cache + (1 - decay_reate) * dx**2x += - learning_rate * dx / (np.sqrt(cache) + 1e-7) Adaptive Moment Estimation (Adam) Adagrad和RMSprop的结合： m与v分别是梯度的一阶矩（带权平均）和二阶矩（带权有偏方差），初始为0向量。Adam的作者发现它们(接近于0向量)，特别是在衰减因子(衰减率)β1,β2接近于1时。为了改进这个问题，对m与v进行偏差修正(bias-corrected)，偏差修正取决于时间步长t Adam (bias-corrected) 12345m = beta1 * m + (1-beta1) * dxv = beta2 * v + (1-beta2) * (dx**2)m /= 1-beta1**tv /= 1-beta2**tx += - learning_rate * m / (np.sqrt(v)) + le-7) Nadam Adam和NAG的结合（既调整学习率和粗略预测未来方向） 优化器的选择 稀疏数据用自适应学习率方法（ada系列）；RMSprop,Adadelta和Adam比较相似；SGD用的很多？SGD优化时间长，依赖于初始化和退火调度，可能陷于鞍点 用什么优化根本不重要，因为paper的contribution不在优化问题上面。 控制变量法，如果baseline是用SGD的，自然也用SGD去对比，不然怎么知道是model的差异还是optimization的差异？ 选择Adam还是SGD是工程问题不是科学问题。Adam比SGD好，是通过cross validation得出的不是通过数学推导得出的。 SGD和Adam没有本质区别，顶多是自行车和变速山地车的区别，多了一些trick罢了。 SGD在一些场景下效果比其他的好。 一些tricks 随机化 防止样本顺序带来的影响或偏差，更好的学习 Batch normalization（批归一化）在深度神经网络训练过程中使得每一层神经网络的输入保持相同分布，为解决“Internal Covariate Shift”问题——因为深层神经网络在做非线性变换前的激活输入值（就是那个x=WU+B，U是输入）随着网络深度加深或者在训练过程中，其分布逐渐发生偏移或者变动，之所以训练收敛慢，一般是整体分布逐渐往非线性函数的取值区间的上下限两端靠近（对于Sigmoid函数来说，意味着激活输入值WU+B是大的负值或正值），所以这导致反向传播时低层神经网络的梯度消失对于每个隐层神经元，把逐渐向非线性函数映射后向取值区间极限饱和区靠拢的输入分布强制拉回到均值为0方差为1的比较标准的正态分布，使得非线性变换函数的输入值落入对输入比较敏感的区域，以此避免梯度消失问题。位于X=WU+B激活值获得之后，非线性函数变换 Scale and shift: 对净输入z(l) 的标准归一化会使得其取值集中的0 附近，如果使用sigmoid型激活函数时，这个取值区间刚好是接近线性变换的区间，减弱了神经网络的非线性性质。因此，为了使得归一化不对网络的表示能力造成负面影响，通过一个附加的缩放和平移变换改变取值区间。 mini-batch期望和方差：目前主要的训练方法是基于小批量的随机梯度下降方法，z(l) 的期望和方差通常用当前小批量样本集的均值和方差近似估计。 局限性：批量归一化是对一个中间层的单个神经元进行归一化操作，因此要求小批量样本的数量不能太小，否则难以计算单个神经元的统计信息。此外，如果一个神经元的净输入的分布在神经网络中是动态变化的，比如循环神经网络，那么就无法应用批量归一化操作。 层归一化LN：层归一化是对一个中间层的所有神经元进行归一化。对于K 个样本的一个小批量集合Z(l) = [z(1,l); · · · ; z(K,l)]，层归一化是对矩阵Z(l) 对每一列进行归一化，而批量归一化是对每一行进行归一化 权重归一化：对神经网络的连接权重进行归一化，通过再参数化（Reparameterization）方法，将连接权重分解为长度和方向两种参数 局部响应归一化：基于卷积的图像处理中。局部响应归一化和层归一化都是对同层的神经元进行归一化。不同的是局部响应归一化应用在激活函数之后，只是对邻近的神经元进行局部归一化，并且不减去均值。 提前停止 梯度噪声 使网络对于糟糕初始化更鲁棒，对训练复杂很深的网络有用 激活函数 Sigmoid S曲线；值域0-1；求导；两端饱和函数；非零中心化的输出会使得其后一层的神经元的输入发生偏置偏移（Bias Shift），并进一步使得梯度下降的收敛速度变慢。 Logistic函数 σ(x)=(1+exp(-x))^-1 Tanh函数 放大平移的Logistic函数；值域为（-1,1）；tanh(x)=2σ(2x)-1 Logistic 函数和Tanh 函数都是Sigmoid 型函数，具有饱和性，但是计算开销较大。因为这两个函数都是在中间（0 附近）近似线性，两端饱和 ReLU修正线性单元 原始ReLU ReLU(x)=max(0,x)；优点：1.神经元运算简单，计算上更高效；2.单侧抑制、宽兴奋边界；3.Sigmoid会导致非稀疏网络，ReLU稀疏性好；4.ReLU左饱和，右导数为1，缓解梯度消失，加速梯度收敛；缺点：1.输出非0中心化，给后层网络引入偏置偏移，影响梯度下降效率；2.死亡ReLU问题 LeakyReLU LeakyReLU(x)=max(0,x)+γmin(0,x) PReLU PReLU=max(0, x) + γ_i min(0, x),可学习参数 ELU ELU=max(0, x) + min(0, γ(exp(x) − 1)) Softplus函数 Softplus(x) = log(1 + exp(x)).单侧抑制、宽兴奋边界，没有稀疏激活性 Swish函数 自门控激活函数 swish(x) = xσ(βx) Maxout单元 maxout单元的输入是上一层神经元的全部原始输入，是一个向量x = [x1; x2; · · · , xd]； 梯度消失和梯度爆炸原因：深度神经网络和反向传播，根据损失函数计算的误差通过梯度反向传播的方式，指导深度网络权值的更新优化。 梯度消失 网络太深层 采用了不合适的损失函数 梯度爆炸 网络太深 权值初始化值太大 解决方案： 预训练加微调 梯度剪切，权重正则（针对梯度爆炸） 使用不同的激活函数 Batch normalization 残差结构 使用LSTM或GRU （有点像残差网络） 梯度截断 当梯度的模大于一定阈值时，就对梯度进行截断；分为按值截断、按模截断 卷积神经网络作用及发展CNN与DNN区别：卷积、池化 卷积作用：局部感受野（提升表达能力和泛化能力），参数共享（减少运算量） 1*1卷积核作用：不影响输入输出维度，增加网络非线性表达能力，降低参数量 池化（下采样）：最大，平均；减少参数 激活函数：提升表达能力和泛化能力 Dropout:随机舍弃某些权重，降低模型复杂度，预防过拟合 LeNet(传统CNN)-&gt;AlexNet（数据增广，dropout,relu,局部响应归一化LRN）-&gt;VGG(深)-&gt;GoogLeNet(inception增加网络宽度和深度)-&gt;ResNet(shortcut，残差网络，防止梯度消失)-&gt;DenseNet(密集连接，任何两层都有直接的连接，内存占用大) 卷积神经网络计算 卷积：nm的图像，kk的滤波器，卷积后为(n-k+1)(m-k+1)，参数量kk+1 Padding：卷积得到原图像size，加入层数为p=(k-1)/2 步长stride：(n+2p-k)/s+1，s为步长 单卷积核：三通道的过滤器与图像卷积，对kk3个数去加权计算和，不是分层计算 多卷积核：j个kk3的滤波器，得到(n-k+1)(m-k+1)j层输出，参数量kk3*j+j 池化：改变输入输出，不会有参数，nm的图像，kk的滤波器,s为步长，输出(n+2p-k)/s+1 全连接层：FC1 * FC2 循环神经网络 任务模式：序列到类别（分类）、同步序列到序列（词性标注）、异步序列到序列（编码器解码器、机器翻译） 参数学习：随时间反向传播（BPTT），实时循环学习算法（RTRL、前向传播） 两种算法比较：RTRL算法和BPTT算法都是基于梯度下降的算法，分别通过前向模式和反向模式应用链式法则来计算梯度。在循环神经网络中，一般网络输出维度远低于输入维度，因此BPTT算法的计算量会更小，但是BPTT算法需要保存所有时刻的中间梯度，空间复杂度较高。RTRL算法不需要梯度回传，因此非常适合用于需要在线学习或无限序列的任务中。 长期依赖问题：如果t时刻的输出yt 依赖于t−k 时刻的输入xt−k，当间隔k 比较大时，简单神经网络很难建模这种长距离的依赖关系，称为长期依赖问题 梯度爆炸：权重衰减（通过给参数增加ℓ1 或ℓ2 范数的正则化项来限制参数的取值范围，从而使得γ ≤ 1）、梯度截断（当梯度的模大于一定阈值时，就将它截断成为一个较小的数） 梯度消失（RNN主要问题）：改变模型，ht = ht−1 + g(xt, ht−1; θ), (6.50)这样ht 和ht−1 之间为既有线性关系，也有非线性关系，但有记忆容量问题—增加额外存储，选择性遗忘 LSTM和GRU：基于门控的循环神经网络 LSTM:LSTM网络引入一个新的内部状态（internal state）ct 专门进行线性的循环信息传递，同时（非线性）输出信息给隐藏层的外部状态ht。 LSTM网络中的“门”是一种“软”门，取值在(0, 1) 之间，表示以一定的比例运行信息通过。 输入门：输入门it 控制当前时刻的候选状态˜ct 有多少信息需要保存 遗忘门：遗忘门ft 控制上一个时刻的内部状态ct−1 需要遗忘多少信息 输出门：输出门ot 控制当前时刻的内部状态ct 有多少信息需要输出给外部状态ht。 LSTM网络中，记忆单元c 可以在某个时刻捕捉到某个关键信息，并有能力将此关键信息保存一定的时间间隔。记忆单元c 中保存信息的生命周期要长于短期记忆h，但又远远短于长期记忆，因此称为长的短期记忆（long short-term memory）。 LSTM变体： 无遗忘门的LSTM Schmidhuber最早提出，ct会不断累加 peephole连接 三个门不但依赖于输入xt 和上一时刻的隐状态ht−1，也依赖于上一个时刻的记忆单元ct−1。 耦合输入门和遗忘门 LSTM网络中的输入门和遗忘门有些互补关系，同时用两个门比较冗余。 门控循环单元（GRU) GRU将输入门与和遗忘门合并成一个门：更新门。同时，GRU也不引入额外的记忆单元，直接在当前状态ht 和历史状态ht−1 之间引入线性依赖关系。 深层循环神经网络 增加循环神经网络的深度主要是增加同一时刻网络输入到输出之间的路径xt →yt，比如增加隐状态到输出ht → yt，以及输入到隐状态xt → ht 之间的路径的深度。 堆叠循环神经网络 双向循环神经网络 一个时刻的输出不但和过去时刻的信息有关，也和后续时刻的信息有关。比如给定一个句子，其中一个词的词性由它的上下文决定 注意力机制参数初始化 在感知器和logistic 回归的训练中，我们一般将参数全部初始化为0 对称权重：神经网络训练，前向计算时所有隐层神经元激活值相同，导致深层无区分性 参数初始化过小：多层传递信号慢慢消失；使sigmoid丢失非线性（0附近近似线性） 参数初始化过大：sigmoid后激活值变得饱和，导致梯度接近于0 常用初始化方法：Gassian分布初始化、均匀分布初始化（Xavier 初始化）","link":"/2020/03/30/ck8mt4udd000gqcunksg271h2/"},{"title":"二叉树常用操作的实现","text":"二叉树的最全总结，常考题型，持续更新 二叉树的递归思想很重要，还有递归的复杂度分析 1.1 二叉树的初始化12345678910111213141516171819202122#initial of BinaryTreeclass BinaryTree: def __init__(self,rootObj): self.val = rootObj self.left = None self.right = None def insertLeft(self,newNode): if self.left == None: self.left = BinaryTree(newNode) else: t = BinaryTree(newNode) t.left = self.left self.left = t def insertRight(self,newNode): if self.right == None: self.right = BinaryTree(newNode) else: t = BinaryTree(newNode) t.right = self.right self.right = t 1.2 创建一个二叉树1234567891011121314151617#create a BinaryTree [18,7,11,3,4,5,6,#,#,#,#,1,3,2,4]# 18# 7 11#3 4 5 6# 1 3 2 4root = BinaryTree(18)root.left = BinaryTree(7)root.right = BinaryTree(11)root.left.left = BinaryTree(3)root.left.right = BinaryTree(4)root.right.left = BinaryTree(5)root.right.right = BinaryTree(6)root.right.left.left = BinaryTree(1)root.right.left.right = BinaryTree(3)root.right.right.left = BinaryTree(2)root.right.right.right = BinaryTree(4) 1.3 前序遍历1234567891011121314151617181920212223#递归版本def PreOrder(self, node): if node: print(node.val) self.PreOrder(node.left) self.PreOrder(node.right)#循环版本def PreOrderLoop(self, node): if node == None: return stack =[] print(node.val) stack.append(node) node = node.left while stack!=[] or node: while node: print(node.val) stack.append(node) node = node.left node = stack[-1].right stack.pop()#ouput: 18 7 3 4 11 5 1 3 6 2 4 1.4 中序遍历123456789101112131415161718192021#递归版本def InOrder(self, node): if node: self.InOrder(node.left) print(node.val) self.InOrder(node.right)#循环版本def InOrderLoop(self, node): if node == None: return None stack = [] stack.append(node) node = node.left while stack!=[] or node: while node: stack.append(node) node = node.left print(stack[-1].val) node = stack[-1].right stack.pop()#output：3 7 4 18 1 5 3 11 2 6 4 1.5 后序遍历1234567891011121314151617181920212223242526#递归def PostOrder(self, node): if node: self.PostOrder(node.left) self.PostOrder(node.right) print(node.val)#非递归def PostOrderLoop(self, node): if node == None: return stack =[] stack.append(node) pre = None while stack!=[]: node = stack[-1] if ((node.left==None and node.right==None) or (pre and (pre == node.left or pre ==node.right))): print(node.val) pre = node stack.pop() else: if node.right: stack.append(node.right) if node.left: stack.append(node.left)#output:3 4 7 1 3 5 2 4 6 11 18 1.6 层序遍历1234567891011121314def LevelOrder(self, node): if node == None: return stack = [] stack.append(node) while stack!=[]: node = stack[0] if node.left: stack.append(node.left) if node.right: stack.append(node.right) print(node.val) stack.pop(0)output: 18 7 11 3 4 5 6 1 3 2 4 1.7 计算节点数1234567891011121314151617181920#递归版本def CountNode(self, root): if root == None: return 0 return self.CountNode(root.left) + self.CountNode(root.right) + 1#非递归版本def CountNodeNotRev(self, root): if root == None: return 0 stack = [] stack.append(root) index = 0 while index&lt;len(stack): if stack[index].left: stack.append(stack[index].left) if stack[index].right: stack.append(stack[index].right) index += 1 print(len(stack))output: 11 1.8 计算树的深度123456def getTreeDepth(self, root): if root == None: return 0 left = self.getTreeDepth(root.left) + 1 right = self.getTreeDepth(root.right) + 1 return left if left&gt;right else right 1.9 计算树的叶子树123456def countLeaves(self, root): if root == None: return 0 if root.left==None and root.right==None: return 1 return self.countLeaves(root.left)+self.countLeaves(root.right) 1.10 获取第K层节点数1234def getKLevel(self, root, K): if root == None: return 0 if K == 1: return 1 return self.getKLevel(root.left, K-1)+self.getKLevel(root.right, K-1) 1.11 判断两颗二叉树是否相同1234def StrucCmp(self, root1, root2): if root1 == None and root2 == None: return True elif root1 ==None or root2 == None: return False return self.StrucCmp(root1.left, root2.left) and self.StrucCmp(root1.right, root2.right) 1.12 二叉树的镜像1234567def Mirror(self, root): if root == None: return tmp = root.left root.left = root.right root.right = tmp self.Mirror(root.left) self.Mirror(root.right) 1.13 找最低公共祖先节点12345678def findLCA(self, root, node1, node2): if root == None: return if root == node1 or root == node2: return root left = self.findLCA(root.left, node1, node2) right = self.findLCA(root.right, node1, node2) if left and right: return root return left if left else right 1.14 获取两个节点的距离123456789101112def getDist(self, root, node1, node2): lca = self.findLCA(root, node1, node2) #找最低公共祖宗节点 level1 = self.FindLevel(lca, node1) #祖节点到两个节点的距离 level2 = self.FindLevel(lca, node2) return level1+level2def FindLevel(self, node, target): if node == None: return -1 if node == target: return 0 level = self.FindLevel(node.left, target) if level == -1: level = self.FindLevel(node.right, target) if level != -1: return level + 1 return -1 1.15 找一个节点的所有祖宗节点1234567def findAllAncestor(self, root, target): if root == None: return False if root == target: return True if self.findAllAncestor(root.left, target) or self.findAllAncestor(root.right, target): print(root.val) return True return False","link":"/2019/03/09/ck8mt4ud10005qcuntsdb5wd9/"},{"title":"【转载】Manacher's algorithm (马拉车算法)","text":"Manacher’s算法(C++代码实现) 文章作者：刘毅 (Ethson Liu) 发布日期：2018-04-03 原文链接：https://ethsonliu.com/2018/04/manacher.html 一：背景给定一个字符串，求出其最长回文子串。例如： s=”abcd”，最长回文长度为 1； s=”ababa”，最长回文长度为 5； s=”abccb”，最长回文长度为 4，即 bccb。 以上问题的传统思路大概是，遍历每一个字符，以该字符为中心向两边查找。其时间复杂度为 $O(n^2)$，效率很差。 1975 年，一个叫 Manacher 的人发明了一个算法，Manacher 算法（中文名：马拉车算法），该算法可以把时间复杂度提升到 $O(n)$。下面来看看马拉车算法是如何工作的。 二：算法过程分析由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：在字符串首尾，及各字符间各插入一个字符（前提这个字符未出现在串里）。 举个例子：s=&quot;abbahopxpo&quot;，转换为s_new=&quot;$#a#b#b#a#h#o#p#x#p#o#&quot;（这里的字符 $ 只是为了防止越界，下面代码会有说明），如此，s 里起初有一个偶回文abba和一个奇回文opxpo，被转换为#a#b#b#a#和#o#p#x#p#o#，长度都转换成了奇数。 定义一个辅助数组int p[]，其中p[i]表示以 i 为中心的最长回文的半径，例如： i 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 s_new[i] $ # a # b # b # a # h # o # p # x # p # p[i] 1 2 1 2 5 2 1 2 1 2 1 2 1 2 1 4 1 2 1 可以看出，p[i] - 1正好是原字符串中最长回文串的长度。 接下来的重点就是求解 p 数组，如下图：设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是mx = id + p[id]。 假设我们现在求p[i]，也就是以 i 为中心的最长回文半径，如果i &lt; mx，如上图，那么： 12if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); 2 * id - i为 i 关于 id 的对称点，即上图的 j 点，而p[j]表示以 j 为中心的最长回文半径，因此我们可以利用p[j]来加快查找。 三：代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt; #include &lt;cstring&gt;#include &lt;algorithm&gt; using namespace std;char s[1000];char s_new[2000];int p[2000];int Init(){ int len = strlen(s); s_new[0] = '$'; s_new[1] = '#'; int j = 2; for (int i = 0; i &lt; len; i++) { s_new[j++] = s[i]; s_new[j++] = '#'; } s_new[j] = '\\0'; // 别忘了哦 return j; // 返回 s_new 的长度}int Manacher(){ int len = Init(); // 取得新字符串长度并完成向 s_new 的转换 int max_len = -1; // 最长回文长度 int id; int mx = 0; for (int i = 1; i &lt; len; i++) { if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); // 需搞清楚上面那张图含义, mx 和 2*id-i 的含义 else p[i] = 1; while (s_new[i - p[i]] == s_new[i + p[i]]) // 不需边界判断，因为左有'$',右有'\\0' p[i]++; // 我们每走一步 i，都要和 mx 比较，我们希望 mx 尽可能的远，这样才能更有机会执行 if (i &lt; mx)这句代码，从而提高效率 if (mx &lt; i + p[i]) { id = i; mx = i + p[i]; } max_len = max(max_len, p[i] - 1); } return max_len;}int main(){ while (printf(\"请输入字符串：\\n\")) { scanf(\"%s\", s); printf(\"最长回文长度为 %d\\n\\n\", Manacher()); } return 0;} 四：算法复杂度分析文章开头已经提及，Manacher 算法为线性算法，即使最差情况下其时间复杂度亦为 $O(n)$，在进行证明之前，我们还需要更加深入地理解上述算法过程。 根据回文的性质，p[i]的值基于以下三种情况得出： （1）：j 的回文串有一部分在 id 的之外，如下图：上图中，黑线为 id 的回文，i 与 j 关于 id 对称，红线为 j 的回文。那么根据代码此时p[i] = mx - i，即紫线。那么p[i]还可以更大么？答案是不可能！见下图：假设右侧新增的紫色部分是p[i]可以增加的部分，那么根据回文的性质，a 等于 d ，也就是说 id 的回文不仅仅是黑线，而是黑线+两条紫线，矛盾，所以假设不成立，故p[i] = mx - i，不可以再增加一分。 （2）：j 回文串全部在 id 的内部，如下图：根据代码，此时p[i] = p[j]，那么p[i]还可以更大么？答案亦是不可能！见下图：假设右侧新增的红色部分是p[i]可以增加的部分，那么根据回文的性质，a 等于 b ，也就是说 j 的回文应该再加上 a 和 b ，矛盾，所以假设不成立，故p[i] = p[j]，也不可以再增加一分。 （3）：j 回文串左端正好与 id 的回文串左端重合，见下图：根据代码，此时p[i] = p[j]或p[i] = mx - i，并且p[i]还可以继续增加，所以需要 12while (s_new[i - p[i]] == s_new[i + p[i]]) p[i]++; 根据（1）（2）（3），很容易推出 Manacher 算法的最坏情况，即为字符串内全是相同字符的时候。在这里我们重点研究 Manacher() 中的 for 语句，推算发现 for 语句内平均访问每个字符 5 次，即时间复杂度为：$T_{worst}(n)=O(n)$。 同理，我们也很容易知道最佳情况下的时间复杂度，即字符串内字符各不相同的时候。推算得平均访问每个字符 4 次，即时间复杂度为：$T_{best}(n)=O(n)$。 综上，Manacher 算法的时间复杂度为 $O(n)$。","link":"/2020/04/05/ck8mt4udf000iqcunge7t287k/"},{"title":"【转载】Knuth–Morris–Pratt algorithm (KMP算法)","text":"KMP算法(C++代码实现) 文章作者：刘毅 (Ethson Liu) 发布日期：2018-04-04 原文链接：https://ethsonliu.com/2018/04/kmp.html 一：背景给定一个字符串，求出其最长回文子串。例如： s=”abcd”，最长回文长度为 1； s=”ababa”，最长回文长度为 5； s=”abccb”，最长回文长度为 4，即 bccb。 以上问题的传统思路大概是，遍历每一个字符，以该字符为中心向两边查找。其时间复杂度为 $O(n^2)$，效率很差。 1975 年，一个叫 Manacher 的人发明了一个算法，Manacher 算法（中文名：马拉车算法），该算法可以把时间复杂度提升到 $O(n)$。下面来看看马拉车算法是如何工作的。 二：算法过程分析由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：在字符串首尾，及各字符间各插入一个字符（前提这个字符未出现在串里）。 举个例子：s=&quot;abbahopxpo&quot;，转换为s_new=&quot;$#a#b#b#a#h#o#p#x#p#o#&quot;（这里的字符 $ 只是为了防止越界，下面代码会有说明），如此，s 里起初有一个偶回文abba和一个奇回文opxpo，被转换为#a#b#b#a#和#o#p#x#p#o#，长度都转换成了奇数。 定义一个辅助数组int p[]，其中p[i]表示以 i 为中心的最长回文的半径，例如： i 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 s_new[i] $ # a # b # b # a # h # o # p # x # p # p[i] 1 2 1 2 5 2 1 2 1 2 1 2 1 2 1 4 1 2 1 可以看出，p[i] - 1正好是原字符串中最长回文串的长度。 接下来的重点就是求解 p 数组，如下图：设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是mx = id + p[id]。 假设我们现在求p[i]，也就是以 i 为中心的最长回文半径，如果i &lt; mx，如上图，那么： 12if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); 2 * id - i为 i 关于 id 的对称点，即上图的 j 点，而p[j]表示以 j 为中心的最长回文半径，因此我们可以利用p[j]来加快查找。 三：代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt; #include &lt;cstring&gt;#include &lt;algorithm&gt; using namespace std;char s[1000];char s_new[2000];int p[2000];int Init(){ int len = strlen(s); s_new[0] = '$'; s_new[1] = '#'; int j = 2; for (int i = 0; i &lt; len; i++) { s_new[j++] = s[i]; s_new[j++] = '#'; } s_new[j] = '\\0'; // 别忘了哦 return j; // 返回 s_new 的长度}int Manacher(){ int len = Init(); // 取得新字符串长度并完成向 s_new 的转换 int max_len = -1; // 最长回文长度 int id; int mx = 0; for (int i = 1; i &lt; len; i++) { if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); // 需搞清楚上面那张图含义, mx 和 2*id-i 的含义 else p[i] = 1; while (s_new[i - p[i]] == s_new[i + p[i]]) // 不需边界判断，因为左有'$',右有'\\0' p[i]++; // 我们每走一步 i，都要和 mx 比较，我们希望 mx 尽可能的远，这样才能更有机会执行 if (i &lt; mx)这句代码，从而提高效率 if (mx &lt; i + p[i]) { id = i; mx = i + p[i]; } max_len = max(max_len, p[i] - 1); } return max_len;}int main(){ while (printf(\"请输入字符串：\\n\")) { scanf(\"%s\", s); printf(\"最长回文长度为 %d\\n\\n\", Manacher()); } return 0;} 四：算法复杂度分析文章开头已经提及，Manacher 算法为线性算法，即使最差情况下其时间复杂度亦为 $O(n)$，在进行证明之前，我们还需要更加深入地理解上述算法过程。 根据回文的性质，p[i]的值基于以下三种情况得出： （1）：j 的回文串有一部分在 id 的之外，如下图：上图中，黑线为 id 的回文，i 与 j 关于 id 对称，红线为 j 的回文。那么根据代码此时p[i] = mx - i，即紫线。那么p[i]还可以更大么？答案是不可能！见下图：假设右侧新增的紫色部分是p[i]可以增加的部分，那么根据回文的性质，a 等于 d ，也就是说 id 的回文不仅仅是黑线，而是黑线+两条紫线，矛盾，所以假设不成立，故p[i] = mx - i，不可以再增加一分。 （2）：j 回文串全部在 id 的内部，如下图：根据代码，此时p[i] = p[j]，那么p[i]还可以更大么？答案亦是不可能！见下图：假设右侧新增的红色部分是p[i]可以增加的部分，那么根据回文的性质，a 等于 b ，也就是说 j 的回文应该再加上 a 和 b ，矛盾，所以假设不成立，故p[i] = p[j]，也不可以再增加一分。 （3）：j 回文串左端正好与 id 的回文串左端重合，见下图：根据代码，此时p[i] = p[j]或p[i] = mx - i，并且p[i]还可以继续增加，所以需要 12while (s_new[i - p[i]] == s_new[i + p[i]]) p[i]++; 根据（1）（2）（3），很容易推出 Manacher 算法的最坏情况，即为字符串内全是相同字符的时候。在这里我们重点研究 Manacher() 中的 for 语句，推算发现 for 语句内平均访问每个字符 5 次，即时间复杂度为：$T_{worst}(n)=O(n)$。 同理，我们也很容易知道最佳情况下的时间复杂度，即字符串内字符各不相同的时候。推算得平均访问每个字符 4 次，即时间复杂度为：$T_{best}(n)=O(n)$。 综上，Manacher 算法的时间复杂度为 $O(n)$。","link":"/2020/03/19/ck8mt4ud30007qcun17hciv28/"},{"title":"中国第二届高性能云计算大赛（MAXP)——京东云数据算法赛","text":"中国第二届高性能云计算大赛（MAXP)——京东云数据算法赛","link":"/2020/03/19/ck8mt4ud8000bqcunn3zyeiwh/"},{"title":"剑指offer题解(C++)","text":"剑指offer各题目的C++解法 剑指offer 1 二维数组查找 剑指offer 2 替换空格 剑指offer 3 从尾到头打印链表 剑指offer 4 重建二叉树 剑指offer 5 用两个栈实现队列 剑指offer 6 旋转数组的最小值 剑指offer 7 斐波那契数列 剑指offer 8 跳台阶 剑指offer 9 变态跳台阶 剑指offer 10 矩形覆盖 剑指offer 11 二进制中1的个数** 剑指offer 12 求base的exponent次方 剑指offer 13 调整数组奇偶顺序 剑指offer 14 链表倒数第k个结点 剑指offer 15 反转链表 剑指offer 16 合并两个排序的链表 剑指offer 17 树的子结构 剑指offer 18 二叉树的镜像 剑指offer 19 顺时针打印矩阵 剑指offer 20 包含Min函数的栈 剑指offer 21 栈的压入、弹出序列 剑指offer 22 从上往下打印二叉树 剑指offer 23 二叉搜索树的后序遍历序列 剑指offer 24 二叉树中和为某一值的所有路径 剑指offer 25 复杂链表的复制 剑指offer 26 二叉搜索树转双端链表** 剑指offer 27 字符串的排列 剑指offer 28 数组中出现超过一半的数 剑指offer 29 最小的k个数** 剑指offer 30 连续子数组最大和 剑指offer 31 整数中1的个数 剑指offer 32 把数组排成最小的数** 剑指offer 33 丑数 剑指offer 34 第一次出现的字符 剑指offer 35 数组中的逆序对** 剑指offer 36 两个链表的第一个公共结点 剑指offer 37 数组在排序数组出现的次数 剑指offer 38 二叉树深度 剑指offer 39 判断平衡二叉树 剑指offer 40 数组中只出现一次的数字 剑指offer 41 和为S的连续正数序列 剑指offer 42 和为S的两个数 剑指offer 43 左旋转字符串 剑指offer 44 翻转单词顺序列 剑指offer 45 扑克牌顺子 剑指offer 46 孩子们的游戏（圆圈里最后剩下的数） 剑指offer 47 求1+2+…+n 剑指offer 48 不用加减乘除做加法 剑指offer 49 把字符串转换为整数 剑指offer 50 数组中重复的数字 剑指offer 51 构建乘积数组 剑指offer 52 正则表达式匹配 剑指offer 53 表示数值的字符串 剑指offer 54 字符流中第一个不重复的字符 剑指offer 55 链表中环的入口节点 剑指offer 56 删除链表中重复的节点 剑指offer 57 二叉树的下一个节点 剑指offer 58 对称的二叉树 剑指offer 59 之字形打印二叉树 剑指offer 60 把二叉树打印成多行（层序遍历） 剑指offer 61 序列化二叉树 剑指offer 62 二叉搜索树的第k个结点 剑指offer 63 数据流中的中位数 剑指offer 64 滑动窗口的最大值 剑指offer 65 矩阵中的路径 剑指offer 66 机器人的动作范围 剑指offer 67 剪绳子 剑指offer 1 二维数组查找在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。12345678910111213141516171819202122232425262728293031// 左下往右上查找，快速定位地图经纬度 O(n+m)bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) { int rows = array.size(), cols = array[0].size(); int row=rows-1,col=0; while(row&gt;=0 &amp;&amp; col&lt;cols){ if(array[row][col]==target) return true; else if(array[row][col]&gt;target) row--; else col++; } return false;}// 二分法 O(nlogm) O(n+m)bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) { if(array.size()==0) return false; int nrows = array.size(), ncols= array[0].size(); for(int i=0;i&lt;nrows;i++){ int low=0; int high=ncols-1; while(low&lt;=high){ int mid=(low+high)/2; if(target&gt;array[i][mid]) low=mid+1; else if(target&lt;array[i][mid]) high=mid-1; else return true; } } return false; } 剑指offer 2 替换空格请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。12345678910111213141516171819202122// O(n)void replaceSpace(char *str,int length) { int count=0; for(int i=0;i&lt;length;i++){ if(str[i]==&apos; &apos;) count++; } for(int i=length-1;i&gt;=0;i--){ if(str[i]!=&apos; &apos;){ str[i+2*count]=str[i]; //非空格在新数组的位置 //0 1 2 3 4 5 6 7 8 //0 # 3 # 4 //0 % 2 0 3 % 2 0 4 } else{ count--; str[i+2*count]=&apos;%&apos;; str[i+2*count+1]=&apos;2&apos;; str[i+2*count+2]=&apos;0&apos;; } }} 剑指offer 3 从尾到头打印链表输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。1234567891011121314151617181920212223242526272829303132333435363738394041424344//递归vector&lt;int&gt; printListFromTailToHead(ListNode* head) { vector&lt;int&gt; res; if(head!=NULL){ if(head-&gt;next!=NULL){ res = printListFromTailToHead(head-&gt;next); } res.push_back(head-&gt;val); } return res;}//栈vector&lt;int&gt; printListFromTailToHead(ListNode* head) { vector&lt;int&gt; res; stack&lt;int&gt; sta; while(head!=NULL){ sta.push(head-&gt;val); head=head-&gt;next; } while(!sta.empty()){ res.push_back(sta.top()); sta.pop(); } return res;}// **链表原地反转**vector&lt;int&gt; printListFromTailToHead(struct ListNode* head) { vector&lt;int&gt; vec; ListNode *buf=head; ListNode *pre=buf; if(head==NULL) return vec; while(head-&gt;next!=NULL){ buf=head-&gt;next; head-&gt;next=buf-&gt;next; buf-&gt;next=pre; pre=buf; } while(buf){ vec.push_back(buf-&gt;val); buf=buf-&gt;next; } return vec;} 剑指offer 4 重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。1234567891011121314151617TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) { TreeNode* root = helper(pre, 0, pre.size()-1, vin, 0, vin.size()-1); return root;}TreeNode* helper(vector&lt;int&gt; pre, int startpre, int endpre, vector&lt;int&gt; vin, int startvin, int endvin){ if(startpre&gt;endpre||startvin&gt;endvin) return NULL; TreeNode* root=new TreeNode(pre[startpre]); for(int i=startvin;i&lt;=endvin;i++){ if(vin[i]==pre[startpre]){ root-&gt;left = helper(pre, startpre+1, startpre+i-startvin, vin, startvin, i-1); root-&gt;right = helper(pre, startpre+i-startvin+1, endpre, vin, i+1, endvin); break; } } return root;} 剑指offer 5 用两个栈实现队列用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。1234567891011121314151617181920212223242526272829303132333435stack&lt;int&gt; stack1;stack&lt;int&gt; stack2;void push(int node) { stack1.push(node);}//栈1不空，全部压入栈2，栈2的top则可以输出；//然后把栈2再压回栈1int pop() { while(!stack1.empty()){ int a = stack1.top(); stack1.pop(); stack2.push(a); } int res = stack2.top(); stack2.pop(); while(!stack2.empty()){ stack1.push(stack2.top()); stack2.pop(); } return res;}//如果栈2不空，栈2的top即为输出，否则把栈1全部压入栈2int pop() { if(stack2.empty()){ while(!stack1.empty()){ int a = stack1.top(); stack1.pop(); stack2.push(a); } } int res = stack2.top(); stack2.pop(); return res;} 剑指offer 6 旋转数组的最小值把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。1234567891011121314151617181920212223//O(N)int minNumberInRotateArray(int[] array) { if (array.length == 0) return 0; for (int i = 0; i &lt; array.length - 1; i++) { if (array[i] &gt; array[i + 1]) return array[i + 1]; } return array[0];}// O(logn) 二分法int minNumberInRotateArray(vector&lt;int&gt; rotateArray) { if(rotateArray.size()==0) return 0; int low=0, high=rotateArray.size()-1; while(low&lt;high){ int mid=(low+high)/2; if(rotateArray[mid]&gt;rotateArray[high]) low=mid+1; else if(rotateArray[mid]==rotateArray[high]) high--; else high=mid; } return rotateArray[high];} 剑指offer 7 斐波那契数列12345678910111213141516171819202122232425262728293031323334//斐波那契数列0 1 2 3 4 ...0 1 1 2 3 ...//递归int Fibonacci(int n) { if(n==0) return 0; if(n==1) return 1; return Fibonacci(n-1)+Fibonacci(n-2);}//循环 时间复杂度O(N) 空间复杂度O(1)int Fibonacci(int n) { if(n==0) return 0; if(n==1) return 1; int pre=0, now=1; while(n&gt;1){ int tmp = pre+now; pre = now; now = tmp; n--; } return now;}//动态规划 时间复杂度O(N) 空间复杂度O(N)int Fibonacci(int n) { if(n==0) return 0; if(n==1) return 1; vector&lt;int&gt; dp(n+1,0); dp[0]=0; dp[1]=1; for(int i=2;i&lt;=n;++i){ dp[i]=dp[i-1]+dp[i-2]; } return dp[n];} 剑指offer 8 跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。1234567891011//斐波那契数列 DP O(N)int jumpFloor(int number) { if(number&lt;2) return number; int pre=1, now=2; for(int i=3;i&lt;=number;i++){ int tmp = pre+now; pre = now; now=tmp; } return now;} 剑指offer 9 变态跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。12345678910int jumpFloorII(int number) { if(number==0) return 0; int res=1; while(number--&gt;1){ res*=2; } return res;}//移位 左移一位*2，左移n-1位即 2^(n-1)int res = 1&lt;&lt;(number-1) 剑指offer 10 矩形覆盖我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，有多少种方法？12//还是斐波那契数列 f(n) = f(n-1) + f(n-2)， (n &gt; 2)。 更一般的结论，如果用1*m的方块覆盖m*n区域，递推关系式为f(n) = f(n-1) + f(n-m)，(n &gt; m)。123456789101112131415161718192021222324252627282930313233// 循环int rectCover(int number) { if(number&lt;=2) return number; int pre=1, now=2; for(int i=3;i&lt;=number;++i){ int tmp=pre+now; pre=now; now=tmp; } return now;}// 递归public class Solution { public int RectCover(int target) { if (target &lt; 1) { return 0; } else if (target == 1 || target == 2) { return target; } else { return RectCover(target-1) + RectCover(target-2); } }}// dpint rectCover(int number) { if ( number &lt; 1 ) return 0; int g = 1, f = 2; while ( --number ) { f = f + g; g = f - g; } return g;} 剑指offer 11 二进制中1的个数**输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。123456789// 如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。int NumberOf1(int n) { int count = 0; while (n != 0) { ++count; n = (n - 1) &amp; n; } return count; } 剑指offer 12 求base的exponent次方给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。1234567891011// 简单快速幂double Power(double base, int exponent) { long long p = abs((long long)exponent); double r = 1.0; while(p){ if(p &amp; 1) r *= base; base *= base; p &gt;&gt;= 1; } return exponent &lt; 0 ? 1/ r : r;} 第一种方法：使用递归，时间复杂度O(logn)当n为偶数，a^n =（a^n/2）*（a^n/2） 当n为奇数，a^n = a ^ [( n - 1) / 2] a ^ [(n-1)/2] a 举例： 2^11 = 2^1 2^2 2^8 2^1011 = 2^0001 2^0010 2^1000 第二种方法：累乘，时间复杂度为O(n) 剑指offer 13 调整数组奇偶顺序输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。1234567891011121314151617181920212223242526272829303132333435// O(2n) O(n) void reOrderArray(vector&lt;int&gt; &amp;array) { if(array.size()==0) return; vector&lt;int&gt; res(array.size(),0); int s=0,e=array.size()-1; for(int i=0;i&lt;array.size();++i){ if(array[i]%2==1){ res[s++]=array[i]; } } for(int i=array.size()-1;i&gt;=0;--i){ if(array[i]%2==0){ res[e--]=array[i]; } } array=res;}// O(n*n) O(1) 插排想法void reOrderArray1(vector&lt;int&gt; &amp;array){ if(array.size()&lt;=1) return; for(int i=0;i&lt;array.size();i++){ if(array[i]%2==1){ int tmp=array[i]; int j=i-1; while(j&gt;=0 &amp;&amp; array[j]%2==0){ array[j+1]=array[j]; j--; } array[j+1] =tmp; } }}// 开辟2个数组分别存奇数和偶数 O(n) O(2n) 剑指offer 14 链表倒数第k个结点输入一个链表，输出该链表中倒数第k个结点。123456789101112131415161718192021222324252627282930313233343536373839404142// 遍历再数 O(2n-k)ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) { if(k&lt;=0) return NULL; int cnt=0, start=0; ListNode* root=pListHead; while(pListHead!=NULL){ pListHead=pListHead-&gt;next; cnt++; } if(k&gt;cnt) return NULL; while(start!=cnt-k){ root=root-&gt;next; start++; } return root;}// 遍历再数 O(n)ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) { if(k&lt;=0 || pListHead==NULL) return NULL; ListNode *fast=pListHead; ListNode *slow=pListHead; while(k--&gt;0){ if(fast==nullptr) return nullptr; fast=fast-&gt;next; } while(fast!=NULL){ fast=fast-&gt;next; slow=slow-&gt;next; } return slow;}// 递归ListNode* FindKthToTail2(ListNode* pListHead, unsigned int k) { if(pListHead==NULL) return NULL; ListNode* node=FindKthToTail(pListHead-&gt;next,k); if(node!=NULL) return node; cnt++; if(cnt==k) return pListHead; else return NULL;} 剑指offer 15 反转链表输入一个链表，反转链表后，输出新链表的表头。12345678910111213141516171819202122232425262728public ListNode ReverseList(ListNode head) { if(head==null) return null; //head为当前节点，如果当前节点为空的话，那就什么也不做，直接返回null； ListNode pre = null; ListNode next = null; //当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点 //需要pre和next的目的是让当前节点从pre-&gt;head-&gt;next1-&gt;next2变成pre&lt;-head next1-&gt;next2 //即pre让节点可以反转所指方向，但反转之后如果不用next节点保存next1节点的话，此单链表就此断开了 //所以需要用到pre和next两个节点 //1-&gt;2-&gt;3-&gt;4-&gt;5 //1&lt;-2&lt;-3 4-&gt;5 while(head!=null){ //做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre //如此就可以做到反转链表的效果 //先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂 next = head.next; //保存完next，就可以让head从指向next变成指向pre了，代码如下 head.next = pre; //head指向pre后，就继续依次反转下一个节点 //让pre，head，next依次向后移动一个节点，继续下一次的指针反转 pre = head; head = next; } //如果head为null的时候，pre就为最后一个节点了，但是链表已经反转完毕，pre就是反转后链表的第一个节点 //直接输出pre就是我们想要得到的反转后的链表 return pre;} 剑指offer 16 合并两个排序的链表输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。12345678910111213141516171819202122232425262728293031323334353637383940//递归ListNode* Merge(ListNode* pHead1, ListNode* pHead2){ if(pHead1==NULL) return pHead2; if(pHead2==nullptr) return pHead1; if(pHead1-&gt;val&gt;pHead2-&gt;val) { pHead2-&gt;next=Merge(pHead1, pHead2-&gt;next); return pHead2; } if(pHead1-&gt;val&lt;pHead2-&gt;val) { pHead1-&gt;next=Merge(pHead1-&gt;next, pHead2); return pHead1; }}// 循环if(list1 == null) return list2;if(list2 == null) return list1;ListNode mergeHead = null;ListNode current = null;while(list1!=null &amp;&amp; list2!=null){ if(list1.val &lt;= list2.val){ if(mergeHead == null){ mergeHead = current = list1; }else{ current.next = list1; current = current.next; } list1 = list1.next; }else{ if(mergeHead == null){ mergeHead = current = list2; }else{ current.next = list2; current = current.next; } list2 = list2.next; }}if(list1 == null) current.next = list2;else current.next = list1;return mergeHead; 剑指offer 17 树的子结构输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）1234567891011121314151617bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2){ bool result=false; if(pRoot1!=NULL &amp;&amp; pRoot2!=NULL){ if(pRoot1-&gt;val==pRoot2-&gt;val) result=Tree1HaveTree2(pRoot1, pRoot2); if(!result) { result=Tree1HaveTree2(pRoot1-&gt;left, pRoot2) || Tree1HaveTree2(pRoot1-&gt;right, pRoot2); } } return result;}bool Tree1HaveTree2(TreeNode* pRoot1, TreeNode* pRoot2){ if(pRoot2==NULL) return true; if(pRoot1==NULL) return false; if(pRoot1-&gt;val!=pRoot2-&gt;val) return false; return Tree1HaveTree2(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; Tree1HaveTree2(pRoot1-&gt;right,pRoot2-&gt;right);} 剑指offer 18 二叉树的镜像12345678910void Mirror(TreeNode *pRoot) { if (pRoot==NULL) return; else { TreeNode *tmp=pRoot-&gt;left; pRoot-&gt;left = pRoot-&gt;right; pRoot-&gt;right = tmp; Mirror(pRoot-&gt;left); Mirror(pRoot-&gt;right); }} 剑指offer 19 顺时针打印矩阵输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.1234567891011121314151617181920212223242526vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) { int row = matrix.size(); int col = matrix[0].size(); vector&lt;int&gt; res; // 输入的二维数组非法，返回空的数组 if (row == 0 || col == 0) return res; // 定义四个关键变量，表示左上和右下的打印范围 int left = 0, top = 0, right = col - 1, bottom = row - 1; while (left &lt;= right &amp;&amp; top &lt;= bottom) { // left to right for (int i = left; i &lt;= right; ++i) res.push_back(matrix[top][i]); // top to bottom for (int i = top + 1; i &lt;= bottom; ++i) res.push_back(matrix[i][right]); // right to left if (top != bottom) for (int i = right - 1; i &gt;= left; --i) res.push_back(matrix[bottom][i]); // bottom to top if (left != right) for (int i = bottom - 1; i &gt; top; --i) res.push_back(matrix[i][left]); left++,top++,right--,bottom--; } return res;} 剑指offer 20 包含Min函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。123456789101112131415161718stack&lt;int&gt; stack1, stack2;void push(int value) { stack1.push(value); if(stack2.empty()) stack2.push(value); else{ if(value&lt;stack2.top()) stack2.push(value); }}void pop() { if(stack1.top()==stack2.top()) stack2.pop(); stack1.pop();}int top() { return stack1.top();}int min() { return stack2.top();} 剑指offer 21 栈的压入、弹出序列//输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）12345678910111213bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) { if(pushV.empty()||popV.empty()) return false; stack&lt;int&gt; Stack; int popIndex=0; for(int i=0;i&lt;pushV.size();++i){ Stack.push(pushV[i]); while(!Stack.empty() &amp;&amp; Stack.top()==popV[popIndex]){ Stack.pop(); popIndex++; } } return Stack.empty(); } 剑指offer 22 从上往下打印二叉树12345678910111213141516171819202122232425262728293031323334//双端队列vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) { vector&lt;int&gt; res; if(root==NULL) return NULL; deque&lt;TreeNode*&gt; d; d.push_back(root); while(!d.empty()){ root=d.front(); if(root!=NULL){ res.push_back(root-&gt;val); d.push_back(root-&gt;left); d.push_back(root-&gt;right); } d.pop_front(); } return res;}//队列vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) { vector&lt;int&gt; res; if(root==NULL) return res; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()){ res.push_back(q.front()-&gt;val); if(q.front()-&gt;left!=NULL) q.push(q.front()-&gt;left); if(q.front()-&gt;right!=NULL) q.push(q.front()-&gt;right); q.pop(); } return res;} 剑指offer 23 二叉搜索树的后序遍历序列//输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。//如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。12345678910111213141516171819202122232425bool VerifySquenceOfBST(vector&lt;int&gt; sequence) { if (sequence.empty()) { return false; } return helper(sequence, 0, sequence.size() - 1);}bool helper(vector&lt;int&gt; &amp;sequence, int first, int last) { // first和last表示树序列的开始和结束的位置 if(first &gt;= last){ return true; } int curIdx = first; int rootVal = sequence[last]; //后序遍历，根节点一定在最后，找到根节点后，就可以将树分为左右两棵子树，其中左子树中的元素都小于根节点，右子树中的元素都大于根节点 while(curIdx &lt; last &amp;&amp; sequence[curIdx] &lt; rootVal){ ++curIdx; } int midIdx = curIdx; // 到curIdx的值大于根节点时，我们认为开始进入到右子树部分，用一个midIdx记录下当前的右子树开始的位置 while (curIdx &lt; last){ if(sequence[curIdx] &lt; rootVal){ return false; } ++curIdx; } return helper(sequence, first, midIdx - 1) &amp;&amp; helper(sequence, midIdx, last - 1); // 再分别对左子树和右子树做同样的操作} 剑指offer 24 二叉树中和为某一值的所有路径//输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。//路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。//(注意: 在返回值的list中，数组长度大的数组靠前)1234567891011121314151617181920212223vector&lt;vector&lt;int&gt;&gt; res;vector&lt;int&gt; path;vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) { if(root==NULL || expectNumber&lt;=0) return res; findHelper(root, expectNumber); return res;}void findHelper(TreeNode* root, int sum){ if(root==NULL) return; path.push_back(root-&gt;val); if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL &amp;&amp; root-&gt;val==sum){ res.push_back(path); } else{ if(root-&gt;left!=NULL){ findHelper(root-&gt;left, sum-root-&gt;val); } if(root-&gt;right!=NULL){ findHelper(root-&gt;right, sum-root-&gt;val); } } path.pop_back();} 剑指offer 25 复杂链表的复制//输入一个复杂链表（每个节点中有节点值，以及两个指针，//一个指向下一个节点，另一个特殊指针指向任意一个节点），//返回结果为复制后复杂链表的head。//（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）1234567891011121314151617181920212223242526272829303132333435363738struct RandomListNode { int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) { }};class Solution {public: RandomListNode* Clone(RandomListNode* pHead){ if(pHead==NULL) return NULL; RandomListNode* currentNode=pHead; //复制每个结点，将其插入结点后面 while(currentNode!=NULL){ RandomListNode* cloneNode = new RandomListNode(currentNode-&gt;label); RandomListNode* nextNode = currentNode-&gt;next; currentNode-&gt;next=cloneNode; cloneNode-&gt;next=nextNode; currentNode=nextNode; } currentNode=pHead; //复制老结点的随机指针给新结点 while(currentNode!=NULL){ currentNode-&gt;next-&gt;random = currentNode-&gt;random==NULL?NULL:currentNode-&gt;random-&gt;next; currentNode=currentNode-&gt;next-&gt;next; } //拆分链表 currentNode=pHead; RandomListNode* pCloneHead=pHead-&gt;next; while(currentNode!=NULL){ RandomListNode* cloneNode=currentNode-&gt;next; currentNode-&gt;next=cloneNode-&gt;next; cloneNode-&gt;next=cloneNode-&gt;next==NULL?NULL:cloneNode-&gt;next-&gt;next; currentNode=currentNode-&gt;next; } return pCloneHead; }}; 剑指offer 26 二叉搜索树转双端链表**//题目描述//输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。//要求不能创建任何新的结点，只能调整树中结点指针的指向。123456789101112131415161718192021222324252627/*struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { }};*/TreeNode* Convert(TreeNode* pRootOfTree){if(pRootOfTree==NULL) return NULL; TreeNode* pre=NULL; convertHelper(pRootOfTree, pre); TreeNode* res=pRootOfTree; while(res-&gt;left){ res=res-&gt;left; } return res;}void convertHelper(TreeNode* cur, TreeNode*&amp; pre){ if(cur==NULL) return; convertHelper(cur-&gt;left, pre); cur-&gt;left=pre; if(pre) pre-&gt;right=cur; pre=cur; convertHelper(cur-&gt;right, pre);} 剑指offer 27 字符串的排列题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。输入描述:输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136/** * 1、递归算法 * * 解析：http://www.cnblogs.com/cxjchen/p/3932949.html (感谢该文作者！) * * 对于无重复值的情况 * * 固定第一个字符，递归取得首位后面的各种字符串组合； * 再把第一个字符与后面每一个字符交换，并同样递归获得首位后面的字符串组合； *递归的出口，就是只剩一个字符的时候，递归的循环过程，就是从每个子串的第二个字符开始依次与第一个字符交换，然后继续处理子串。 * * 假如有重复值呢？ * *由于全排列就是从第一个数字起，每个数分别与它后面的数字交换，我们先尝试加个这样的判断——如果一个数与后面的数字相同那么这两个数就不交换了。 * 例如abb，第一个数与后面两个数交换得bab，bba。然后abb中第二个数和第三个数相同，就不用交换了。 * 但是对bab，第二个数和第三个数不 同，则需要交换，得到bba。 * 由于这里的bba和开始第一个数与第三个数交换的结果相同了，因此这个方法不行。 * * 换种思维，对abb，第一个数a与第二个数b交换得到bab，然后考虑第一个数与第三个数交换，此时由于第三个数等于第二个数， * 所以第一个数就不再用与第三个数交换了。再考虑bab，它的第二个数与第三个数交换可以解决bba。此时全排列生成完毕！ * * * @param str * @return */vector&lt;string&gt; Permutation(string str) { vector&lt;string&gt; res; if(str.empty()) return res; permutationHelper(str, res, 0, str.size()-1); sort(res.begin(),res.end()); return res; }void permutationHelper(string str, vector&lt;string&gt; &amp;res, int start, int end){ if(start==end) { res.push_back(str); } for(int i=start;i&lt;=end;i++){ //从str的头到尾都换一次 if(is_swap(str, start, i)){ swap(str, start, i); permutationHelper(str, res, start+1, end); swap(str, start, i); } }}bool is_swap(string str, int l, int r){ bool flag=true; for(int i=l;i&lt;r;i++){ //l==r则跳过循环，比如aa可以加入res if(str[i]==str[r]){ flag=false; break; } } return flag;}void swap(string &amp;str, int l, int r){ char tmp=str[l]; str[l]=str[r]; str[r]=tmp;}void swap(char* str,int a,int b){ char tmp = str[a]; str[a] = str[b]; str[b] = tmp;}/** * 2、字典序排列算法 * * 可参考解析： http://www.cnblogs.com/pmars/archive/2013/12/04/3458289.html （感谢作者） * * 一个全排列可看做一个字符串，字符串可有前缀、后缀。 * 生成给定全排列的下一个排列.所谓一个的下一个就是这一个与下一个之间没有其他的。 * 这就要求这一个与下一个有尽可能长的共同前缀，也即变化限制在尽可能短的后缀上。 * * [例]839647521是1--9的排列。1—9的排列最前面的是123456789，最后面的987654321， * 从右向左扫描若都是增的，就到了987654321，也就没有下一个了。否则找出第一次出现下降的位置。 * * 【例】 如何得到346987521的下一个 * 1，从尾部往前找第一个P(i-1) &lt; P(i)的位置 * 3 4 6 &lt;- 9 &lt;- 8 &lt;- 7 &lt;- 5 &lt;- 2 &lt;- 1 * 最终找到6是第一个变小的数字，记录下6的位置i-1 * * 2，从i位置往后找到最后一个大于6的数 * 3 4 6 -&gt; 9 -&gt; 8 -&gt; 7 5 2 1 * 最终找到7的位置，记录位置为m * * 3，交换位置i-1和m的值 * 3 4 7 9 8 6 5 2 1 * 4，倒序i位置后的所有数据 * 3 4 7 1 2 5 6 8 9 * 则347125689为346987521的下一个排列 * * @param str * @return */ public ArrayList&lt;String&gt; Permutation2(String str){ ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); if(str==null || str.length()==0){ return list; } char[] chars = str.toCharArray(); Arrays.sort(chars); list.add(String.valueOf(chars)); int len = chars.length; while(true){ int lIndex = len-1; int rIndex; while(lIndex&gt;=1 &amp;&amp; chars[lIndex-1]&gt;=chars[lIndex]){ lIndex--; } if(lIndex == 0) break; rIndex = lIndex; while(rIndex&lt;len &amp;&amp; chars[rIndex]&gt;chars[lIndex-1]){ rIndex++; } swap(chars,lIndex-1,rIndex-1); reverse(chars,lIndex); list.add(String.valueOf(chars)); } return list;} private void reverse(char[] chars,int k){ if(chars==null || chars.length&lt;=k) return; int len = chars.length; for(int i=0;i&lt;(len-k)/2;i++){ int m = k+i; int n = len-1-i; if(m&lt;=n){ swap(chars,m,n); } }} 剑指offer 28 数组中出现超过一半的数//数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// O(n) 空间O(n) 不追求元素排序，不用map或者hashmapint MoreThanHalfNum_Solution2(vector&lt;int&gt; numbers) { int n = numbers.size(); //map 记录出现次数 unordered_map&lt;int, int&gt; m; int count; for (int i = 0; i &lt; n; i++) { count = ++m[numbers[i]]; if (count &gt; n/2) return numbers[i]; } return 0;}// O(n) O(1)int MoreThanHalfNum_Solution1(vector&lt;int&gt; numbers) { if(numbers.empty()) return 0; int n = numbers.size(), num=numbers[0],count=1; for (int i = 1; i &lt; n; i++) { if(numbers[i]==num) count++; else count--; if(count==0){ num=numbers[i]; count=1; } } count=0; for(int i=0;i&lt;n;i++){ if(numbers[i]==num) count++; } return (count&gt;n/2)?num:0;}//快排思想 O(n)?O(logn)?int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) { if(numbers.empty()) return 0; int n = numbers.size(), mid=n/2,count=1; int start=0,end=n-1; int k=partition(numbers, 0, n-1); while(k!=mid){ if(k&gt;mid){ end=k-1; k=partition(numbers, start, end); } else{ start=k+1; k=partition(numbers, start, end); } } int num=numbers[mid]; count=0; for(int i=0;i&lt;n;i++){ if(numbers[i]==num) count++; } return (count&gt;n/2)?num:0;}int partition(vector&lt;int&gt; &amp;numbers, int s, int e){ int pivot=numbers[s]; int leftmark=s+1, rightmark=e; bool done=false; while(!done){ while(leftmark&lt;=rightmark &amp;&amp; pivot&gt;=numbers[leftmark]) leftmark++; while(leftmark&lt;=rightmark &amp;&amp; pivot&lt;=numbers[rightmark]) rightmark--; if(leftmark&gt;rightmark) done=true; else{ swap(numbers, leftmark, rightmark); } } swap(numbers, s, rightmark); return rightmark;}void swap(vector&lt;int&gt; &amp;v, int s, int e){ int tmp=v[s]; v[s]=v[e]; v[e]=tmp;}//拓展：输出数组中两个数量超过1/3的数 //投票法，讲道理partition应该也行1/3,2/3的位置vector&lt;int&gt; MoreThanOneThirdNum_Solution(vector&lt;int&gt; numbers) { vector&lt;int&gt; res; if(numbers.empty()) return res; int num1=0, num2=0, cnt1=0, cnt2=0, len = numbers.size(); for(int i=0;i&lt;len;i++){ if(numbers[i]==num1) cnt1++; else if (numbers[i]==num2) cnt2++; else if (cnt1==0) num1=numbers[i], cnt1=1; else if (cnt2==0) num2=numbers[i], cnt2=1; else cnt1--, cnt2--; } cnt1=0, cnt2=0; for(int i=0;i&lt;len;i++){ if(numbers[i]==num1) cnt1++; if(numbers[i]==num2) cnt2++; } if(cnt1&gt;len/3) res.push_back(num1); if(cnt2&gt;len/3) res.push_back(num2); return res;} 剑指offer 29 最小的k个数**//输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。partition O(n)-O(n^2）?牛客超时？1234567891011121314151617181920212223242526272829303132vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) { vector&lt;int&gt; res; if(input.empty() || k&gt;input.size()) return res; int len=input.size(), pos, s=0, e=len-1; pos=par(input, 0, len-1); while (pos!=k){ if (pos&gt;k) e=pos-1,pos=par(input, s, e); else s=pos+1,pos=par(input, s, e); } for(int i=0;i&lt;k;i++){ res.push_back(input[i]); } sort(res.begin(),res.end()); return res;}int par(vector&lt;int&gt; &amp;arr, int s, int e){ int pivot=arr[s]; int l=s+1, r=e; bool done=false; while(!done){ while(l&lt;=r &amp;&amp; arr[l]&lt;=pivot) l++; while(l&lt;=r &amp;&amp; arr[r]&gt;=pivot) r--; if(l&gt;r) done=true; else swap(arr, l, r); } swap(arr, s, r); return r;}//最大堆，待写 剑指offer 30 连续子数组最大和HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)1234567891011//DP O(n) O(1)int FindGreatestSumOfSubArray(vector&lt;int&gt; array) { if(array.empty()) return 0; int len=array.size(); int res=array[0], pre=array[0]; for(int i=1;i&lt;len;i++){ pre=max(array[i], pre+array[i]); if(res&lt;pre) res=pre; } return res;} 剑指offer 31 整数中1的个数求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数?为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。123456789int NumberOf1Between1AndN_Solution(int n){ if(n&lt;0) return 0; int count=0; for(int i=1;i&lt;=n;i*=10){ int k=i*10; count+=(n/k)*i+min(max(n%k-i+1, 0), i); } return count;} 剑指offer 32 把数组排成最小的数**//输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。123456789101112131415161718192021class Solution {public: static bool cmp(int a, int b){ string A=&quot;&quot;; string B=&quot;&quot;; A += to_string(a); A += to_string(b); B += to_string(b); B += to_string(a); return A&lt;B; } string PrintMinNumber(vector&lt;int&gt; numbers) { string res=&quot;&quot;; if(numbers.empty()) return res; sort(numbers.begin(), numbers.end(), cmp); for(int i=0;i&lt;numbers.size();i++){ res+=to_string(numbers[i]); } return res; }}; 剑指offer 33 丑数//把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。1234567891011121314151617181920class Solution {public: int GetUglyNumber_Solution(int index) { if(index&lt;1) return 0; vector&lt;int&gt; ugly(index, 1); int pointer2=0, pointer3=0, pointer5=0; for(int i=1;i&lt;index;i++){ ugly[i] = findmin(ugly[pointer2]*2, ugly[pointer3]*3, ugly[pointer5]*5); if(ugly[pointer2]*2==ugly[i]) pointer2++; if(ugly[pointer3]*3==ugly[i]) pointer3++; if(ugly[pointer5]*5==ugly[i]) pointer5++; } return ugly[index-1]; }int findmin(int a, int b, int c){ int tmp = a&gt;b?b:a; int tmp2 = tmp&gt;c?c:tmp; return tmp2; }}; 剑指offer 34 第一次出现的字符//在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.1234567891011121314151617int FirstNotRepeatingChar(string str) { int res=-1; if(str.empty()) return res; int len=str.size(); unordered_map&lt;char, int&gt; mp; for(int i=0;i&lt;len;i++){ mp[str[i]]++; // cout&lt;&lt;mp[str[i]]&lt;&lt;endl; } for(int i=0;i&lt;len;i++){ cout&lt;&lt;mp[str[i]]&lt;&lt;endl; if(mp[str[i]]==1){ res=i;break; } } return res;} 剑指offer 35 数组中的逆序对**//在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007。例子：输入 1,2,3,4,5,6,7,0 输出 7123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//暴力求解 O(N*N)int InversePairs2(vector&lt;int&gt; data) { int res=0; if(data.empty()) return res; int len=data.size(); for(int i=len-1;i&gt;=0;i--){ for(int j=i-1;j&gt;=0;j--){ if(data[j]&gt;data[i]) res++; } } return res;}//归并排序 O(nlogn)int InversePairs(vector&lt;int&gt; data) { int res=0; if(data.empty()) return res; int len=data.size(); vector&lt;int&gt; cp(len, 0); for(int i=0;i&lt;len;i++){ cp[i]=data[i]; } res = mergeCount(data, cp, 0, len-1); return res;}int mergeCount(vector&lt;int&gt; &amp;arr, vector&lt;int&gt; &amp;cp, int s, int e){ if(s==e) return 0; int mid=(s+e)&gt;&gt;1; int leftCount=mergeCount(arr, cp, s, mid)%1000000007; int rightCount=mergeCount(arr, cp, mid+1, e)%1000000007; int count=0,i=mid,j=e,locCopy=e; while(i&gt;=s &amp;&amp; j&gt;mid){ if(arr[i]&gt;arr[j]){ count += j-mid; cp[locCopy--] = arr[i--]; if(count&gt;=1000000007) count%=1000000007; } else{ cp[locCopy--] = arr[j--]; } } for(;i&gt;=s;i--){ cp[locCopy--]=arr[i]; } for(;j&gt;mid;j--){ cp[locCopy--]=arr[j]; } for(int ss=s;ss&lt;=e;ss++){ arr[ss]=cp[ss]; } return (leftCount+rightCount+count)%1000000007;} 剑指offer 36 两个链表的第一个公共结点输入两个链表，找出它们的第一个公共结点。1234567891011121314151617181920212223242526272829303132// 若有公共结点，让最长的链表先走len1-len2步，再一起走，必会相交ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) { if(pHead1==NULL || pHead2==NULL) return NULL; int len1 = findLinkedListLength(pHead1); int len2 = findLinkedListLength(pHead2); if(len1&gt;len2){ pHead1=walkK(pHead1, len1-len2); } else{ pHead2 = walkK(pHead2, len2-len1); } while(pHead1!=NULL &amp;&amp; pHead2!=NULL){ if(pHead1==pHead2) return pHead1; pHead1=pHead1-&gt;next; pHead2=pHead2-&gt;next; } return NULL;}int findLinkedListLength(ListNode* pHead){ int res=0; while(pHead!=NULL){ pHead = pHead-&gt;next; res++; } return res;}ListNode* walkK(ListNode* pHead, int k){ while(k--){ pHead=pHead-&gt;next; } return pHead;} 剑指offer 37 数组在排序数组出现的次数//统计一个数字在排序数组中出现的次数。1234567891011121314151617181920212223242526272829303132// O(n) O(1)int GetNumberOfK1(vector&lt;int&gt; data ,int k) { if(data.empty()) return 0; int res=0; for(int i=0;i&lt;data.size();i++){ if(data[i]==k) res++; } return res; }// O(logn) O(1)int GetNumberOfK(vector&lt;int&gt; data ,int k) { if(data.empty()) return 0; int start=0, end=data.size()-1, res=0; while(start&lt;=end){ int mid=(start+end)&gt;&gt;1; if(data[mid]&gt;k){ end=mid-1; } else if(data[mid]&lt;k) { start=mid+1; } else { int l=mid, r=mid; res++; while(data[--l]==k) res++; while(data[++r]==k) res++; cout&lt;&lt;res&lt;&lt;endl; break; } } return res;} 剑指offer 38 二叉树深度//输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。12345678910111213141516171819202122//递归int TreeDepth(TreeNode* pRoot) { if(pRoot==NULL) return 0; return max(TreeDepth(pRoot-&gt;left), TreeDepth(pRoot-&gt;right))+1;}//非递归int TreeDepthNotLoop(TreeNode* pRoot) { int res=0; if(pRoot==NULL) return res; queue&lt;TreeNode *&gt; q; q.push(pRoot); while(!q.empty()) { int size=q.size(); res++; for(int i=0;i&lt;size;i++){ TreeNode* top=q.front(); q.pop(); if(top-&gt;left) q.push(top-&gt;left); if(top-&gt;right) q.push(top-&gt;right); } } return res; } 剑指offer 39 判断平衡二叉树//输入一棵二叉树，判断该二叉树是否是平衡二叉树。如果二叉树的每个节点的左子树和右子树的深度不大于1，它就是平衡二叉树。1234567891011bool IsBalanced_Solution(TreeNode* pRoot){ return pos_travel(pRoot)!=-1; }int pos_travel(TreeNode* pRoot){ if(pRoot==NULL) return 0; int left=pos_travel(pRoot-&gt;left); if(left==-1) return -1; int right=pos_travel(pRoot-&gt;right); if(right==-1) return -1; return abs(left-right)&gt;1?-1:1+max(left, right);} 剑指offer 40 数组中只出现一次的数字//一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。12345678910111213141516171819202122232425//input vector&lt;int&gt; arr={1,4,4,5,5,7};void FindNumsAppearOnce(vector &lt;int&gt; data, int* num1, int *num2) { if(data.empty()) return; int len=data.size(); unordered_map &lt;int, int&gt; mp; for(int i=0;i&lt;len;i++){ mp[data[i]]++; } vector&lt;int&gt; res; for(int i=0;i&lt;len;i++){ if(mp[data[i]]==1){ res.push_back(data[i]); } } *num1 = res[0]; *num2 = res[1];}public static int find1From2(int[] a){ int len = a.length, res = 0; for(int i = 0; i &lt; len; i++){ res = res ^ a[i]; } return res;} 剑指offer 41 和为S的连续正数序列//输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) { vector&lt;vector&lt;int&gt; &gt; vOut; vector&lt;int&gt; vIn; if(sum==1) { vIn.push_back(1); vOut.push_back(vIn); return vOut; } int left=1, right=2; while(left&lt;right){ int k=(left+right)*(right-left+1)/2; if(sum==k) { vector&lt;int&gt; vTmp; for(int i=left;i&lt;=right;i++){ vTmp.push_back(i); } vOut.push_back(vTmp); right++; } else if(sum&gt;k) { right++; } else { left++; } } return vOut;}//vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) { vector&lt;vector&lt;int&gt;&gt; res; if(sum&lt;=2) return res; int up=sqrt(2*sum); for(int i=up;i&gt;=2;i--){ int n = sum/i; if(i%2==1 &amp;&amp; sum%i==0){ vector&lt;int&gt; tmp; for(int j=n-(i-1)/2;j&lt;=n+(i-1)/2;j++){ tmp.push_back(j); } res.push_back(tmp); } if(i%2==0 &amp;&amp; sum%i*2==i){ vector&lt;int&gt; tmp; for(int j=n-(i-2)/2;j&lt;=n+(i-2)/2+1;j++){ tmp.push_back(j); } res.push_back(tmp); } } return res;} 剑指offer 42 和为S的两个数//输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。123456789101112131415161718192021222324252627vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) { vector&lt;int&gt; res; if(array.empty()) return res; int low=0, high=array.size()-1, Min=INT32_MAX; while(low&lt;high){ cout&lt;&lt;low&lt;&lt;&quot; &quot;&lt;&lt;high&lt;&lt;endl; int add = array[low]+array[high], product= array[low]*array[high]; if(sum==add) { if(product&lt;Min){ Min = product; while(!res.empty()){ res.clear(); } res.push_back(array[low]); res.push_back(array[high]); } low++;high--; } else if (sum&lt;add){ high--; } else{ low++; } } return res;} 剑指offer 43 左旋转字符串//汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！123456789101112131415161718192021222324252627282930313233343536string LeftRotateStringCircle(string str, int n) { if (str.empty()) return &quot;&quot;; deque&lt;char&gt; q; for (int i=0;i&lt;str.size();i++){ q.push_back(str[i]); } while(n!=0) { char tmp = q.front(); q.pop_front(); q.push_back(tmp); n--; } string res=&quot;&quot;; for (int i=0;i&lt;q.size();i++){ res = res+q[i]; } return res;}string LeftRotateString(string str, int n) { if (str.empty()) return &quot;&quot;; n = n % str.size(); reverse(str.begin(), str.end()); reverse(str.begin(), str.begin()+str.size()-n); reverse(str.begin()+str.size()-n, str.end()); return str;}//自写reverse函数void reverse1(string&amp; str, int s, int e){ while (s &lt; e) { char temp = str[s]; str[s] = str[e]; str[e] = temp; s++; e--; }} 剑指offer 44 翻转单词顺序列// “student. a am I”-&gt;“I am a student.”12345678910111213141516171819202122232425262728293031323334353637string ReverseSentence1(string str) { string res = &quot;&quot;; if(str.empty()) return res; vector &lt;string&gt; s; int index=0; string tmp=&quot;&quot;; while(index &lt; str.size()){ if (str[index]==&apos; &apos;) { s.push_back(tmp); tmp=&quot;&quot;; } else{ tmp+=str[index]; } if(index==str.size()-1) s.push_back(tmp); index++; } for (int i=s.size()-1;i&gt;=0;i--) { res += s[i]; if(i!=0) res += &apos; &apos;; }return res;}string ReverseSentence(string str) { std::reverse(str.begin(),str.end()); int front=0; int back=0; int size = str.size(); while(front&lt;size){ while(front&lt;size&amp;&amp;str[front]==&apos; &apos;)++front; //跳过空格，找第一个非空字母位置 back = front; while(back&lt;size&amp;&amp;str[back]!=&apos; &apos;)++back; //找单词最后一个字符的位置 std::reverse(str.begin()+front, str.begin()+back); //反转 front = back; } return str;} 剑指offer 45 扑克牌顺子//一组数字，判断是否顺子。0为任意数，如果牌能组成顺子就输出true，否则就输出false。1234567891011121314151617181920212223242526272829303132333435// O(n)bool IsContinuous( vector&lt;int&gt; numbers ) { if(numbers.empty()) return false; vector&lt;int&gt; arr(14, 0); arr[0]=-5; int Min=14, Max=-1; for (int i=0;i&lt;numbers.size();i++){ arr[numbers[i]]++; if(numbers[i]==0) continue; if(arr[numbers[i]]&gt;1) return false; if (numbers[i]&lt;Min) { Min = numbers[i]; } if (numbers[i]&gt;Max) { Max = numbers[i]; } } if(Max-Min&gt;4) return false; return true;}// O(nlogn)bool IsContinuous( vector&lt;int&gt; numbers ) { sort(numbers.begin(), numbers.end()); int cnt0 = 0, cntNeed = 0; for(int i = 0; i &lt; 5; i++) { if(numbers[i] == 0) { ++cnt0; } else if(i + 1 &lt; 5 ) { if(numbers[i + 1] == numbers[i]) return false; cntNeed += numbers[i + 1] - numbers[i] - 1; } } if(cntNeed &gt; cnt0) return false; return true;} 剑指offer 46 孩子们的游戏（圆圈里最后剩下的数）//约瑟夫圆环。一个数m,编号为0开始报数，m-1的出列，下一个继续从0开始，直至最后一个。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int LastRemaining_Solution(int n, int m) { if(n==0 || m&lt;=0) return -1; if (n==1) return 0; vector&lt;int&gt; v; for (int i=0;i&lt;n;i++) { v.push_back(i); } int p = 0; while(v.size()&gt;1) { n = v.size(); p = (p+m) % n - 1; if (p == -1) p = n-1; v.erase(v.begin()+p); } return v[0]; }//公式dp int LastRemaining_Solution1(unsigned int n, unsigned int m) { if(n &lt;= 0 &amp;&amp; m &lt;= 0) return -1; //蛋疼的特殊条件 int t = 0; for(int i = 2; i &lt;= n; i++) t = (t + m) % i; return t; }//模拟循环链表int LastRemaining_Solution2(int n, int m)//n为人数{ if(n&lt;1||m&lt;1) return -1; list&lt;int&gt; numbers; for(int i=0;i&lt;n;i++) numbers.push_back(i); list&lt;int&gt;::iterator current=numbers.begin(); while(numbers.size()&gt;1) { for(int i=1;i&lt;m;i++)//走m-1步到达第m个数处 { ++current; if(current==numbers.end()) current=numbers.begin(); } list&lt;int&gt;::iterator next=++current; if(next==numbers.end()) next=numbers.begin(); --current; numbers.erase(current); current=next; } return *current;//对迭代器取值，等价于对指针取值} 剑指offer 47 求1+2+…+n//求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。1234567891011int Sum_Solution(int n) { if (n&lt;=0) return 0; if (n==1) return 1; return Sum_Solution(n-1)+n; }int Sum_Solution(int n) { int ans = n;//逻辑与有个短路特点，前面为假，后面不计算。 ans &amp;&amp; (ans += Sum_Solution(n - 1)); return ans;} 剑指offer 48 不用加减乘除做加法//求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。用三步走的方式计算二进制值相加：5-101，7-111,第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101 &amp; 111) \\&lt;\\&lt; 1。第三步重复上述两步， 各位相加 0 1 0 \\^ 1 0 1 0 = 1 0 0 0，进位值为100 = (010 \\&amp; 1010)\\&lt;\\&lt; 1。继续重复上述两步：1000\\^100 = 1100，进位值为0，跳出循环，1100为最终结果。12345678int Add(int num1, int num2) { while(num2!=0){ int tmp = num1^num2; num2 = (num1&amp;num2)&lt;&lt;1; num1=tmp; } return num1;} 剑指offer 49 把字符串转换为整数将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。12345678910111213141516171819int StrToInt(string str) { if(str.empty()) return 0; int res=0, symbol=1; if(str[0]==&apos;+&apos;) { str[0]=&apos;0&apos;; } else if(str[0]==&apos;-&apos;) { symbol=-1; str[0] = &apos;0&apos;; } for(int i=0;i&lt;str.size();i++) { if(str[i]&lt;&apos;0&apos; || str[i]&gt;&apos;9&apos;) { res = 0; break; } res = res*10 + str[i]-&apos;0&apos;; } return symbol*res;} 剑指offer 50 数组中重复的数字// 在一个长度为n的数组里的所有数字都在0到n-1的范围内.数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。1234567891011121314151617181920// Parameters:// numbers: an array of integers// length: the length of array numbers// duplication: (Output) the duplicated number in the array numberbool duplicate1(int numbers[], int length, int* duplication) { bool res=false; if(length==0) return res; unordered_map&lt;int, int&gt; mp; for(int i=0;i&lt;length;i++) { if (mp.count(numbers[i])==0) { mp[numbers[i]] ++; } else { *duplication = numbers[i]; res = true; break; } } return res;} //思路二：剑指offer中解法：因为数组中数字都在0~n - 1，所以若无重复数字排好序则数字i将出现在下标i的位置。//解法：从头到尾扫描这个数组，当扫描到下标为i的数字m时，先比较这个数字是否等于i，是则扫描下一个数字，否则//将该数字与下标为m的数字进行比较，若相等，则找到一个重复的数字，否则将两个数字交换，并继续对该位置//（下标i）重复上面比较过程。12345678910111213141516171819202122bool duplicate(int numbers[], int length, int* duplication) { bool res = false; if (length == 0) return res; int i = 0; while(i&lt;length) { if (numbers[i] == i) { i++; continue; } if (numbers[numbers[i]] == numbers[i]) { res = true; *duplication = numbers[i]; break; } else { int tmp = numbers[i]; numbers[i] = numbers[tmp]; numbers[tmp] = tmp; } } return res;} 剑指offer 51 构建乘积数组给定一个数组A[0, 1, …, n - 1], 请构建一个数组B[0, 1, …, n - 1],其中B中的元素B[i] = A[0] A[1] … A[i - 1] A[i + 1] … A[n - 1]。不能使用除法。12345678910111213141516171819202122232425262728293031323334// recurrent O(n\\*n)vector&lt;int&gt; multiplyN2(const vector&lt;int&gt;&amp; A) { vector&lt;int&gt; B; if (A.empty()) return B; for (int i = 0; i &lt; A.size(); i++) { B.push_back(ABhelper(A, A.size()-1, i)); } return B;}int ABhelper(vector&lt;int&gt; A, int n, int k) { if (n == k &amp;&amp; n == 0) return 1; if (n == k &amp;&amp; n &gt; 0) return ABhelper(A, n - 1, k); if (n == 0) return A[0]; return ABhelper(A, n - 1, k) * A[n];}// 上下三角求解合并//链接：https://www.nowcoder.com/questionTerminal/94a4d381a68b47b7a8bed86f2975db46?f=discussionvector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) { vector&lt;int&gt; B; if (A.empty()) return B; int len = A.size(); // cal up triangle B.push_back(1); for (int i = 1; i &lt; len; i++) { B.push_back(B[i - 1] * A[i - 1]); } // cal down triangle int down =1; for (int i = len - 2; i &gt;= 0; i--) { down *= A[i + 1]; B[i] *= down; } return B;} 剑指offer 52 正则表达式匹配//请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配12345678910111213141516171819202122232425262728293031323334bool match(char* str, char* pattern){ if (str == NULL || pattern == NULL) return false; int strIndex = 0, patternIndex = 0; return matchHelper(str, pattern);}bool matchHelper(char* str, char* pattern) { // str到尾，pattern到尾，匹配成功 // 注意下指针和string字符串判断是否为空的区别 if (*str == &apos;\\0&apos; &amp;&amp; *pattern == &apos;\\0&apos;) return true; // pattern为空，str不空，匹配必定失败 if (*pattern == &apos;\\0&apos; &amp;&amp; *str != &apos;\\0&apos;) return false; // 如果pattern下一个字符不为&apos;*&apos; if (*(pattern + 1) != &apos;*&apos;) { // 匹配成功情况： // 1. 当前str字符==当前pattern字符 // 2. pattern为&apos;.&apos;且当前str不为空 if (*pattern == *str || (*pattern == &apos;.&apos; &amp;&amp; *str != &apos;\\0&apos;)){ return matchHelper(str+1, pattern+1); } else return false; } // 如果pattern下一个字符为&apos;*&apos; else { // 继续匹配的情况： // 1. 当‘*’匹配0个字符时，str当前字符不变，pattern当前字符后移两位，跳过这个‘*’符号； // 2. 当‘*’匹配1个或多个时，str当前字符移向下一个，pattern当前字符不变。 if (*pattern == *str || (*pattern == &apos;.&apos; &amp;&amp; *str != &apos;\\0&apos;)) { return matchHelper(str+1,pattern) || matchHelper(str, pattern+2); } else return matchHelper(str, pattern+2); }} 剑指offer 53 表示数值的字符串// 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。1234567891011121314151617181920212223242526bool isNumeric(char* string){ if (string == nullptr) return false; // 标记符号、小数点、e是否出现过 bool sign = false, decimal = false, hasE = false; for (int i = 0; i &lt; strlen(string); i++) { if (string[i] == &apos;+&apos; || string[i] == &apos;-&apos;) { // 第二次出现+-符号，必须紧接在e之后 if (sign &amp;&amp; string[i-1] != &apos;e&apos; &amp;&amp; string[i-1] != &apos;E&apos;) return false; // 第一次出现+-符号，且不是在字符串开头，也必须紧接在e之后 if (!sign &amp;&amp; i&gt;0 &amp;&amp; string[i-1] != &apos;e&apos; &amp;&amp; string[i-1] != &apos;E&apos;) return false; } else if (string[i] == &apos;e&apos; || string[i] == &apos;E&apos;) { // e后面一定要接数字 || 不能同时存在两个e if (i == strlen(string) - 1 || hasE) return false; hasE = true; } else if (string[i] == &apos;.&apos;) { // e后面不能接小数点，小数点不能出现两次 if (hasE || decimal) return false; decimal = true; } else if (string[i] &lt; &apos;0&apos; || string[i] &gt; &apos;9&apos;) return false; } return true;} 剑指offer 54 字符流中第一个不重复的字符// 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。如果当前字符流没有存在出现一次的字符，返回#字符。123456789101112131415161718string s;char hash[256] = {0};//Insert one char from stringstreamvoid Insert(char ch){ s += ch; hash[ch]++;}//return the first appearence once char in current stringstreamchar FirstAppearingOnce(){ for (int i = 0; i &lt; s.size(); i++) { if (hash[s[i]] == 1) { return s[i]; } } return &apos;#&apos;;} 剑指offer 55 链表中环的入口节点// 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。12345678910111213141516171819202122232425ListNode* EntryNodeOfLoop(ListNode* pHead){ if (pHead == nullptr) return nullptr; ListNode* fast = pHead; ListNode* slow = pHead; ListNode* meetingNode = nullptr; while (fast-&gt;next &amp;&amp; slow) { fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast == slow) { meetingNode = fast; break; } } if (meetingNode) { ListNode* p1 = meetingNode; ListNode* p2 = pHead; while (p1 != p2) { p1 = p1-&gt;next; p2 = p2-&gt;next; } return p1; } return nullptr;} 剑指offer 56 删除链表中重复的节点// 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;512345678910111213141516171819202122232425ListNode* deleteDuplication(ListNode* pHead){ if (pHead == nullptr) return nullptr; ListNode *root = pHead, *pre; while (root != nullptr) { if (root-&gt;next-&gt;val != root-&gt;val) { pre = root; root = root-&gt;next; } else { while (root-&gt;next &amp;&amp; root-&gt;next-&gt;val == root-&gt;val) { root = root-&gt;next; } if (root-&gt;next) { pre-&gt;next = root-&gt;next; root = root-&gt;next; } else { pre-&gt;next = nullptr; return pHead; } } } return pHead;} 剑指offer 57 二叉树的下一个节点// 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。1234567TreeLinkNode* GetNext(TreeLinkNode* pNode){ if (pNode == nullptr) return pNode; while (pNode-&gt;right) { pNode = pNode-&gt;left; }} 剑指offer 58 对称的二叉树// 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。1234567891011121314bool isSymmetrical(TreeNode* pRoot){ if (pRoot == nullptr) return true; return isSymmetricalHelper(pRoot-&gt;left, pRoot-&gt;right);}bool isSymmetricalHelper(TreeNode* p1, TreeNode* p2) { if (p1 &amp;&amp; p2 == nullptr) return false; else if (p2 &amp;&amp; p1 == nullptr) return false; else if (p1 == nullptr &amp;&amp; p2 == nullptr) return true; if (p1-&gt;val == p2-&gt;val) { return isSymmetricalHelper(p1-&gt;left, p2-&gt;right) &amp;&amp; isSymmetricalHelper(p2-&gt;left, p1-&gt;right); } else return false;} 剑指offer 59 之字形打印二叉树// 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。12345678910111213141516171819202122232425262728293031vector&lt;vector&lt;int&gt; &gt; PrintZ(TreeNode* pRoot) { vector&lt;vector&lt;int&gt; &gt; res; if (pRoot == nullptr) return res; vector&lt;TreeNode*&gt; d; d.push_back(pRoot); vector&lt;int&gt; init; init.push_back(pRoot-&gt;val); res.push_back(init); int layer = 1; while (!d.empty()) { layer++; vector&lt;TreeNode*&gt; tmp; for (int i = 0; i &lt; d.size(); i++) { if (d[i]-&gt;left) tmp.push_back(d[i]-&gt;left); if (d[i]-&gt;right) tmp.push_back(d[i]-&gt;right); } vector&lt;int&gt; tmpInt; for (int i = 0; i &lt; tmp.size(); i++) { tmpInt.push_back(tmp[i]-&gt;val); } if (layer % 2 == 1 &amp;&amp; !tmpInt.empty()) { res.push_back(tmpInt); } else if (layer % 2 == 0 &amp;&amp; !tmpInt.empty()) { reverse(tmpInt.begin(), tmpInt.end()); res.push_back(tmpInt); } d = tmp; } return res;} 剑指offer 60 把二叉树打印成多行（层序遍历）从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。1234567891011121314151617181920212223vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) { vector&lt;vector&lt;int&gt; &gt; vec; if(pRoot == NULL) return vec; queue&lt;TreeNode*&gt; q; q.push(pRoot); while(!q.empty()) { int lo = 0, hi = q.size(); vector&lt;int&gt; c; while(lo++ &lt; hi) { TreeNode *t = q.front(); q.pop(); c.push_back(t-&gt;val); if(t-&gt;left) q.push(t-&gt;left); if(t-&gt;right) q.push(t-&gt;right); } vec.push_back(c); } return vec;} 剑指offer 61 序列化二叉树二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。 二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。12345678910111213141516171819202122232425262728293031323334353637typedef TreeNode node;typedef TreeNode* pnode;typedef int* pint;class Solution { vector&lt;int&gt; buf; void dfs(pnode p){ if(!p) buf.push_back(0x23333); else{ buf.push_back(p -&gt; val); dfs(p -&gt; left); dfs(p -&gt; right); } } pnode dfs2(pint&amp; p){ if(*p == 0x23333){ ++p; return NULL; } pnode res = new node(*p); ++p; res -&gt; left = dfs2(p); res -&gt; right = dfs2(p); return res; }public: char* Serialize(TreeNode *p) { buf.clear(); dfs(p); int *res = new int[buf.size()]; for(unsigned int i = 0; i &lt; buf.size(); ++i) res[i] = buf[i]; return (char*)res; } TreeNode* Deserialize(char *str) { int *p = (int*)str; return dfs2(p); }}; 剑指offer 62 二叉搜索树的第k个结点给定一棵二叉搜索树，请找出其中的第k小的结点。例如,(5，3，7，2，4，6，8)中，按结点数值大小顺序第三小结点的值为4。12345678910111213141516171819202122232425262728293031323334// 递归int cnt = 0;TreeNode* KthNode(TreeNode* pRoot, int k){ if (pRoot) { TreeNode* node = KthNode(pRoot-&gt;left, k); if (node) return node; cnt++; if (cnt == k) return pRoot; node = KthNode(pRoot-&gt;right, k); if (node) return node; } return nullptr;}// 非递归 中序遍历TreeNode* KthNode(TreeNode* pRoot, int k){ if (pRoot == nullptr || k &lt; 1) return nullptr; stack&lt;TreeNode*&gt; S; int cnt = 0; TreeNode* node = pRoot; while (!S.empty() || node) { while (node) { S.push(node); node = node-&gt;left; } node = S.top(); S.pop(); cnt++; if (cnt == k) return node; node = node-&gt;right; } return nullptr;} 剑指offer 63 数据流中的中位数如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。12345678910111213141516171819202122// 法1：大顶堆+小顶堆 // 法2：AVL 平衡二叉搜索树// 法3：排序vector&lt;int&gt; dataStream;void Insert(int num){ dataStream.push_back(num); sort(dataStream.begin(), dataStream.end());}double GetMedian(){ int sz = dataStream.size(); double res; if (sz % 2 == 0) { res = (double) (dataStream[sz/2] + dataStream[sz/2-1]) / 2; } else { res = (double) dataStream[sz/2]; } return res;} 剑指offer 64 滑动窗口的最大值给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}。1234567891011121314151617181920212223242526272829303132333435363738394041// 暴力法 O(n * size)int FindMaxVal(vector&lt;int&gt; num, int st, int ed) { int MaxVal = num[st]; for (int i = st; i &lt;= ed; i++) { if (num[i] &gt; MaxVal) MaxVal = num[i]; } return MaxVal;}vector&lt;int&gt; maxInWindows1(const vector&lt;int&gt;&amp; num, unsigned int size){ vector&lt;int&gt; res; if (num.size() == 0 || size &lt; 1) return res; for (int i = 0; i &lt;= num.size()-size; i++) { int tmp = FindMaxVal(num, i, i+size-1); res.push_back(tmp); } return res;}// 双端队列 O(n)vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size){ vector&lt;int&gt; res; if (num.size() == 0 || size &lt; 1) return res; deque&lt;int&gt; d; for (int i = 0; i &lt; num.size(); ++i) { // 从后面依次弹出队列汇总比当前num值小的元素，同时保证队首元素为当前窗口最大值下标 while (d.size() &amp;&amp; num[d.back()] &lt;= num[i]) { d.pop_back(); } // 当当前窗口移出队首元素所在的位置，即队首元素坐标对应的num不在窗口中，需要弹出 if (d.size() &amp;&amp; i-d.front()+1 &gt; size) { d.pop_front(); } d.push_back(i); // 当滑动窗口首地址i大于等于size时才开始写入窗口最大值 if (i &gt;= size - 1) { res.push_back(num[d.front()]); } } return res;} 剑指offer 65 矩阵中的路径请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。1234567891011121314151617181920212223242526272829303132bool dfs(char* matrix, int i, int j, int rows, int cols, char* str, vector&lt;vector&lt;bool&gt; &gt; path) { if (*str == &apos;\\0&apos;) return true; if (matrix[i * cols + j] != str[0]) return false; bool hasPath = false; if (j &gt;= 0 &amp;&amp; i &gt;=0 &amp;&amp; i &lt; rows &amp;&amp; j &lt; cols &amp;&amp; !path[i][j] &amp;&amp; matrix[i * cols + j] == str[0]) { path[i][j] = true; hasPath = dfs(matrix, i-1, j, rows, cols, str+1, path) || dfs(matrix, i+1, j, rows, cols, str+1, path) || dfs(matrix, i, j-1, rows, cols, str+1, path) || dfs(matrix, i, j+1, rows, cols, str+1, path); if (!hasPath) path[i][j] = false; } return hasPath;}bool hasPath(char* matrix, int rows, int cols, char* str){ if (matrix == nullptr || str == nullptr) return false; vector&lt;vector&lt;bool&gt; &gt; path(rows, vector&lt;bool&gt;(cols, false)); bool res = false; for (int row = 0; row &lt; rows; row++) { for (int col = 0; col &lt; cols; col++) { if (matrix[row * cols + col] == str[0]) { res = dfs(matrix, row, col, rows, cols, str, path); } if (res) return res; } } return res;} 剑指offer 66 机器人的动作范围地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？1234567891011121314151617181920212223242526272829303132333435363738int movingCount(int threshold, int rows, int cols){ bool* flag=new bool[rows*cols]; for(int i=0;i&lt;rows*cols;i++) flag[i]=false; int count=moving(threshold,rows,cols,0,0,flag);//从（0,0）坐标开始访问; delete[] flag; return count;}//计算最大移动位置int moving(int threshold,int rows,int cols,int i,int j,bool* flag) { int count=0; if(check(threshold,rows,cols,i,j,flag)) { flag[i*cols+j]=true; //标记访问过，这个标志flag不需要回溯，因为只要被访问过即可。 //因为如果能访问，访问过会加1.不能访问，也会标记下访问过。 count=1+moving(threshold,rows,cols,i-1,j,flag) + moving(threshold,rows,cols,i,j-1,flag) +moving(threshold,rows,cols,i+1,j,flag) + moving(threshold,rows,cols,i,j+1,flag); } return count;}//检查当前位置是否可以访问bool check(int threshold,int rows,int cols,int i,int j,bool* flag) { if(i&gt;=0 &amp;&amp; i&lt;rows &amp;&amp; j&gt;=0 &amp;&amp; j&lt;cols &amp;&amp; getSum(i)+getSum(j)&lt;=threshold &amp;&amp; flag[i*cols+j]==false) return true; return false;}//计算位置的数值int getSum(int number) { int sum=0; while(number&gt;0) { sum+=number%10; number/=10; } return sum;} 剑指offer 67 剪绳子给你一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。123456789101112131415161718/* 首先判断k[0]到k[m]可能有哪些数字，实际上只可能是2或者3。 * 5&lt;2*3,6&lt;3*3,比6更大的数字我们就更不用考虑了，肯定要继续分。 * 其次看2和3的数量，2的数量肯定小于3个，为什么呢？因为2*2*2&lt;3*3，那么题目就简单了。 * 直接用n除以3，根据得到的余数判断是一个2还是两个2还是没有2就行了。 * 由于题目规定m&gt;1，所以2只能是1*1，3只能是2*1，这两个特殊情况直接返回就行了。 */long long n_max_3(long long n) { if (n == 2) return 1; if (n == 3) return 2; long long x = n % 3; long long y = n / 3; if (x == 0) { return pow(3, y); } else if (x == 1) { return 2 * 2 * (long long) pow(3, y - 1); } else { return 2 * (long long) pow(3, y); }}","link":"/2020/03/06/ck8mt4uea000oqcun4fmoz8mq/"},{"title":"clion连接postgresql","text":"Clion连接postgresqlClion是Jetbrains家的面向跨平台开发的C/C++集成开发环境. 有时候开发需要连接到数据库进行query查询. 安装postgresql教程可用菜单栏上的pgAdmin查询自己的数据库名、端口 安装Clion参考详细文档Clion使用 设置database连接 clion界面右侧-&gt;+号-&gt;Data Source-&gt;PostgreSQL 检查数据库信息，用户名和密码是否正确，点击Test Connection，成功可返回；不成功查看下一步。 若无法连接外网，点击下方的Download，无法下载，但要把网址上的.jar包下载下来，后面用到；点击左侧drivers-&gt;PostgreSQL，在Dirver files下点击+号，加载刚下载的jar包，然后左侧的Data source，点击Test Connection可以看到数据库具体信息。 有时候clion首页会重新让输入数据库用户名和密码，输入即可","link":"/2020/03/21/ck8mt4udb000dqcun0uhustdk/"},{"title":"Postgresql+postgis地图开发说明","text":"Postgresql+postgis地图开发说明实习期间需要部署路网数据库查询服务，windows和ubuntu下的安装部署大同小异，现以postgresql 10+postgis 2.5.0为例 1. 安装postgresql+postgis部署地图数据查询服务ubuntu: sudo apt install libpq-dev postgresql-server-dev-10 postgresql-server-dev-all windows:参考博客csdn blog 2. 下载openstreetmap地图osm数据 下载国家地图数据，在www.openstreetmap.org，无法具体到省份城市 下载具体省份城市地图下载可参考省市地图 更小区域地图下载，可使用www.openstreetmap.org限定经纬度直接导出 3. 创建数据库，并支持postgis和pgrouting 方式一，命令行 createdb -U postgres XXX（数据库名称，后续都用XXX代替） 进入数据库\\c XXX,输入以下语句使数据库支持空间分析和空间查询 123456CREATE EXTENSION postgis; CREATE EXTENSION pgrouting;CREATE EXTENSION postgis_topology; CREATE EXTENSION fuzzystrmatch; CREATE EXTENSION postgis_tiger_geocoder; CREATE EXTENSION address_standardizer; 方式二：在pgAdmin中打开，直接以postgis数据库为模版创建数据库，这样创建的数据库直接支持空间查询和空间分析。 4. 将osm数据导入数据库blog4.1 安装OSM数据导入工具osm2pgsql(Ubuntu操作)： sudo apt install osm2pgsql (windows操作)： osm2pgsql下载地址：http://customdebug.com/osm/osm2pgsql.zip default.style文件:https://github.com/openstreetmap/osm2pgsql/blob/master/default.style osm2pgsql下载好之后解压，解压完成之后，将下载的default.style放入到.\\osm2pgsql\\x64文件夹下 4.2 进入数据库windows: cmd输入psql -U postgres -d XXX进入数据库 ubuntu: psql -U user_name -d database_name -h localhost 4.3 为了避免后面出现要输入密码或者出现Error: Connection to database failed: fe_sendauth: no password supplied错误，将文件pg_hba.conf（文件路径：...\\PostgreSQL\\10\\data）里面的md5，下图所示的两个md5改为trust4.4 (windwos)加载postgis对象和函数定义（postgis.sql） 在数据库安装位置bin文件夹下打开dos窗口，输入命令psql -U postgres -d osm -f “此处为postgis.sql文件的路径”。 postgis.sql文件在...PostgreSQL\\10\\share\\contrib\\postgis-2.5文件夹下 4.5 (windows)加载EPSG坐标系统定义（spatial_ref_sys.sql） 在dos窗口下输入命令psql -U postgres -d osm -f 此处为postgis.sql文件的路径 postgis.sql文件在...PostgreSQL\\10\\share\\contrib\\postgis-2.4文件夹下 4.6 导入OSM数据 ubuntu osm2pgsql -d XXX –U username -P portID -C 12000 -S /home/china-latest.osm.pbf -H localhost -W windows 在下载的osm2pgsql的.\\osm2pgsql\\x64文件夹下打开dos窗口，输入命令osm2pgsql -d XXX –U username -P portID -C 12000 -S &quot;C:\\develop\\postsql-gis\\osm2pgsql\\x64\\default.style&quot; china-latest.osm.pbf 4.7 验证数据是否成功 (linux) \\d发现多了几张table和view说明导入成功 (windows) 从菜单栏的postgressql打开pgAdmin，发现XXX库中多了4张表，说明导入成功 5. 创建路网拓扑图和查询数据表5.1 创建数据表，选择指定列，并重新排序gid 选择指定列：CREATE TABLE XXX AS (SELECT osm_id,name,ref,highway,oneway,bridge,way FROM planet_osm_roads); 添加起点id：ALTER TABLE XXX ADD COLUMN source integer; 添加终点id：ALTER TABLE XXX ADD COLUMN target integer; 添加道路权重值: ALTER TABLE XXX ADD COLUMN length double precision; 创建序列： 123456CREATE SEQUENCE test_id_seqSTART WITH 1INCREMENT BY 1NO MINVALUENO MAXVALUECACHE 1; 更新自增ID： 123alter table XXX add column gid int;alter table XXX alter column gid set default nextval(&apos;test_id_seq&apos;);update XXX set gid=nextval(&apos;test_id_seq&apos;); 修改数据表中列名way为geom: alter table XXX rename way to geom 5.2 创建路网拓扑 SELECT pgr_createTopology('XXX',0.00001, 'geom', 'gid');5.3 为length赋值 update XXX set length =st_length(geom);6. 使用QGIS加载数据表和在线地图6.1 QGIS连接postgressql 连接PostGIS数据源——数据库管理器——导入数据——加载数据 输入数据库名称 端口 用户名和密码 双击数据表即可显示图层 6.2 安装在线地图插件显示地图图层 打开QGIS，在插件下搜QGIS cloud插件，选择 add background layer 即可添加google map，bing map，openstreet map 作为底图","link":"/2020/03/19/ck8mt4ude000hqcunwfdi5f7k/"},{"title":"Git","text":"Git &amp; Linux operations python程序后台运行程序后台运行，打印结果到out.log文件nohup python -u test.py &gt; out.log 2&gt;&amp;1 &amp;说明： 末尾的“&amp;”：表示后台运行程序 “nohup” ：保证程序不被挂起 “python”：是执行python代码的命令 “-u”：表示不启用缓存，实时输出打印信息到日志文件（如果不加-u，则会导致日志文件不会实时刷新代码中的print函数的信息） “Job.py”：是python的源代码文件 “log.log”：是输出的日志文件 “&gt;”：是指将打印信息指定到日志文件 “2&gt;&amp;1”：将标准错误输出转变化标准输出，可以将错误信息也输出到日志文件中（0-&gt; stdin, 1-&gt;stdout, 2-&gt;stderr） 查询下进程 ，可查看pidps -ef | grep xxx 终止脚本进程kill -9 pid to be continue…","link":"/2020/01/08/ck8mt4udc000eqcuntg0ovqjq/"},{"title":"链表的算法合集整理","text":"链表的算法合集大全(C/C++) 1. 链表结构体定义 2. 链表初始化，可以快速创建样例 3. 链表遍历打印，检验算法正确性 4. 输出单链表倒数第 K 个节点 5. 判断链表是否有环 6. 定位环的入口 7. 计算环的长度 8. 链表实现大数加法 9. 有序链表合并 10. K个有序链表合并 11. O(1)复杂度删除链表中结点 12. 从尾到头打印链表 13. 反转链表 14. 复杂链表的复制 15. 逆序构造单链表 16. 链表升序排序 17. 找出单链表的中间结点 1. 链表结构体定义1234567struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { }}; 2. 链表初始化，可以快速创建样例12345678910111213// 链表初始化，创造样例ListNode* linkedListInit(vector&lt;int&gt; v) { if (v.empty()) return NULL; ListNode* root = new ListNode(v[0]); ListNode* node = root; int i = 1; while (i&lt;v.size()) { node-&gt;next = new ListNode(v[i]); node = node-&gt;next; i++; } return root;} 3. 链表遍历打印，检验算法正确性123456789// 打印链表元素值，检验算法void PrintLinkedList(ListNode* root) { if (root == NULL) return; while (root != NULL) { cout&lt;&lt;root-&gt;val&lt;&lt;&quot; &quot;; root = root-&gt;next; } cout&lt;&lt;endl;} 4. 输出单链表倒数第 K 个节点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 输出单链表倒数第 K 个节点// 法一：两次遍历ListNode* findKthTail1(ListNode *pHead, int k) { if (pHead == NULL || k &lt;= 0) return NULL; int len = 0; ListNode* root = pHead; while (pHead != NULL) { pHead = pHead-&gt;next; len++; } if (len&lt;k) return NULL; int countdown = len-k; while (countdown--&gt;0) { root = root-&gt;next; } return root;}// 法二：递归**int cnt = 0;ListNode* findKthTail2(ListNode* pHead, int k) { if (pHead == NULL) return NULL; ListNode* node = findKthTail2(pHead-&gt;next, k); // 没找到就返回NULL，找到一直返回结点 if (node == NULL) { cnt++; if (cnt == k) return pHead; else return NULL; } else { return node; }}// 法三：快慢指针***ListNode* findKthTail3(ListNode* pHead, int k) { if (pHead == NULL || k &lt;= 0) return NULL; ListNode* slow = pHead; ListNode* fast = pHead; for(int i=0;i&lt;k;i++) { //快指针先走k步 if(fast) fast = fast-&gt;next; else return NULL; } while(fast) { fast = fast-&gt;next; slow = slow-&gt;next; } return slow;} 5. 判断链表是否有环123456789101112131415// 判断链表是否有环// 法一：穷举比较 O(n^2)// 法二：哈希缓存 O(n)// 法三：快慢指针 O(n)~O(n^2)环很大时bool isExistRing3(ListNode* pHead) { if (pHead == NULL) return false; ListNode* fast = pHead; ListNode* slow = pHead; while (fast-&gt;next &amp;&amp; slow) { fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast == slow) return true; } return false;} 6. 定位环的入口12345678910111213141516171819202122232425// 定位环的入口***hard***ListNode* getEntryNodeOfRing(ListNode* pHead) { ListNode* meetingnode = getMeetingNode(pHead); if (meetingnode == NULL) return NULL; // 没环则相遇尾结点 ListNode* p1 = meetingnode; ListNode* p2 = pHead; // p1和p2以相同的速度向前移动，当p2指向环的入口节点时 // p1已经围绕着环走了n圈又回到了入口节点。 while(p1 != p2) { p1 = p1-&gt;next; p2 = p2-&gt;next; } return p1;}ListNode* getMeetingNode(ListNode* pHead) { if (pHead == NULL) return NULL; ListNode* fast = pHead; ListNode* slow = pHead; while (fast-&gt;next &amp;&amp; slow) { fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast == slow) return slow; } return NULL;} 7. 计算环的长度12345678910111213141516// 计算环的长度// 找到slow与fast的相遇节点，令slow与fast指针从相遇节点出发，// 按照之前的前进规则，当slow与fast再次相遇时，slow走过的长度正好为环的长度。int getLengthOfRing(ListNode* pHead) { if (pHead == NULL) return 0; ListNode* meetingnode = getMeetingNode(pHead); if (meetingnode == NULL) return 0; // 防止无环 ListNode* fast = meetingnode-&gt;next-&gt;next; ListNode* slow = meetingnode-&gt;next; int length = 1; while (fast != slow) { fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; } return length;} 8. 链表实现大数加法1234567891011121314151617181920212223242526272829303132// 链表实现大数加法ListNode* numberAddAsList(ListNode* l1, ListNode* l2) { ListNode *ret = l1, *pre = l2; int up = 0; // 进位 while (l1 != NULL &amp;&amp; l2 != NULL) { l1-&gt;val = l1-&gt;val + l2-&gt;val +up; up = l1-&gt;val / 10; l1-&gt;val %= 10; pre = l1; //记录当前结点位置 l1 = l1-&gt;next; l2 = l2-&gt;next; } // 若l1到达末尾，说明l1长度小于l2 if (l1 == NULL) { pre-&gt;next = l2; // pre-&gt;next指向l2当前位置 } l1 = pre-&gt;next; // l1指针指向l2结点当前位置,即把l2拼到l1上继续计算 // 继续计算剩余结点，防止9999999+1这种情况 while (l1 != NULL) { l1-&gt;val = l1-&gt;val + up; up = l1-&gt;val / 10; l1-&gt;val %= 10; pre = l1; l1 = l1-&gt;next; } // 最高位有进位，新建一个结点保留最高位 if (up != 0) { ListNode* tmp = new ListNode(up); pre-&gt;next = tmp; } return ret;} 9. 有序链表合并12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 有序链表合并// 递归ListNode* mergeTwoOrderedListsRec(ListNode* pHead1, ListNode* pHead2){ if(pHead1 == NULL) return pHead2; if(pHead2 == NULL) return pHead1; if(pHead1-&gt;val &gt; pHead2-&gt;val) { pHead2-&gt;next = mergeTwoOrderedListsRec(pHead1, pHead2-&gt;next); return pHead2; } else { pHead1-&gt;next = mergeTwoOrderedListsRec(pHead1-&gt;next, pHead2); return pHead1; }}// 非递归ListNode* mergeTwoOrderedListsNotRec(ListNode* pHead1, ListNode* pHead2) { if (pHead1 == NULL) return pHead2; else if (pHead2 == NULL) return pHead1; else { ListNode* pTail = NULL; // 新链表最后一个结点 ListNode* newHead = NULL; // 合并后链表第一个结点 if (pHead1-&gt;val &lt; pHead2-&gt;val) { newHead = pHead1; pHead1 = pHead1-&gt;next; } else { newHead = pHead2; pHead2 = pHead2-&gt;next; } pTail = newHead; // 指向第一个结点 while (pHead1 &amp;&amp; pHead2) { if (pHead1-&gt;val &lt;= pHead2-&gt;val) { pTail-&gt;next = pHead1; pHead1 = pHead1-&gt;next; } else { pTail-&gt;next = pHead2; pHead2 = pHead2-&gt;next; } pTail = pTail-&gt;next; } if (pHead1 == NULL) pTail-&gt;next = pHead2; else if (pHead2 == NULL) pTail-&gt;next = pHead1; return newHead; }} 10. K个有序链表合并12345678910111213// K个有序链表合并// 归并排序，复杂度O(nlogk)ListNode* mergeKsortedLists(vector&lt;ListNode*&gt; lists) { int amount = lists.size(); int gap = 1; while (gap &lt; amount) { for (int i=0; i&lt; amount-gap; i+=gap*2) { lists[i] = mergeTwoOrderedListsRec(lists[i], lists[i+gap]); } gap *= 2; } return amount&gt;0?lists[0]:NULL;} 11. O(1)复杂度删除链表中结点12345678910111213141516171819202122232425void deleteNode(ListNode **pHead, ListNode* pDelNode) { if (pDelNode == NULL) return; if (pDelNode-&gt;next != NULL) { ListNode* pNext = pDelNode-&gt;next; // 下一个节点的值赋给删除节点 pDelNode-&gt;val = pNext-&gt;val; pDelNode-&gt;next = pNext-&gt;next; delete pNext; // delete是删除指针指向的内容 pNext = NULL; // 不指向NULL会成为野指针 } else if (*pHead == pDelNode) { //头结点 delete pDelNode; pDelNode = NULL; *pHead = NULL; } else { //删除尾结点 ListNode *pNode = *pHead; while (pNode-&gt;next != pDelNode) { pNode = pNode-&gt;next; } pNode-&gt;next = NULL; delete pDelNode; pDelNode = NULL; }} 12. 从尾到头打印链表1234567891011121314151617181920212223242526272829303132333435363738394041424344// 递归vector&lt;int&gt; printListFromTailToHead1(ListNode* head) { vector&lt;int&gt; res; if(head!=NULL){ if(head-&gt;next!=NULL){ res = printListFromTailToHead1(head-&gt;next); } res.push_back(head-&gt;val); } return res;}//栈vector&lt;int&gt; printListFromTailToHead2(ListNode* head) { vector&lt;int&gt; res; stack&lt;int&gt; sta; while(head!=NULL){ sta.push(head-&gt;val); head=head-&gt;next; } while(!sta.empty()){ res.push_back(sta.top()); sta.pop(); } return res;}// **链表原地反转**vector&lt;int&gt; printListFromTailToHead3(struct ListNode* head) { vector&lt;int&gt; vec; ListNode *buf=head; ListNode *pre=buf; if(head==NULL) return vec; while(head-&gt;next!=NULL){ /*这里还没看懂*/ buf=head-&gt;next; head-&gt;next=buf-&gt;next; buf-&gt;next=pre; pre=buf; } while(buf){ vec.push_back(buf-&gt;val); buf=buf-&gt;next; } return vec;} 13. 反转链表123456789101112131415161718192021222324// 迭代（链表的原地反转）ListNode* reverseList1(ListNode* head) { ListNode* pre = NULL; ListNode* cur = head; while (cur != NULL) { ListNode* next = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = next; } return pre;}// 递归ListNode* reverseList2(ListNode* head) { if (head == NULL || head-&gt;next == NULL) { return head; } ListNode* rhead = reverseList2(head-&gt;next); // head-&gt;next此刻指向head后面的链表的尾节点 // head-&gt;next-&gt;next = head把head节点放在了尾部 head-&gt;next-&gt;next = head; head-&gt;next = NULL; return rhead;} 14. 复杂链表的复制123456789101112131415161718192021222324252627282930// （每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针// 指向任意一个节点），返回结果为复制后复杂链表的head。RandomListNode* Clone(RandomListNode* pHead){ if(pHead==NULL) return NULL; RandomListNode* currentNode=pHead; //复制每个结点，将其插入结点后面 while(currentNode!=NULL){ RandomListNode* cloneNode = new RandomListNode(currentNode-&gt;label); RandomListNode* nextNode = currentNode-&gt;next; currentNode-&gt;next=cloneNode; cloneNode-&gt;next=nextNode; currentNode=nextNode; } currentNode=pHead; //复制老结点的随机指针给新结点 while(currentNode!=NULL){ currentNode-&gt;next-&gt;random = currentNode-&gt;random==NULL?NULL:currentNode-&gt;random-&gt;next; currentNode=currentNode-&gt;next-&gt;next; } //拆分链表 currentNode=pHead; RandomListNode* pCloneHead=pHead-&gt;next; while(currentNode!=NULL){ RandomListNode* cloneNode=currentNode-&gt;next; currentNode-&gt;next=cloneNode-&gt;next; cloneNode-&gt;next=cloneNode-&gt;next==NULL?NULL:cloneNode-&gt;next-&gt;next; currentNode=currentNode-&gt;next; } return pCloneHead;} 15. 逆序构造单链表输入数据：[1,2,3,4,5],构造单链表:5-&gt;4-&gt;3-&gt;2-&gt;1 1234567891011// 逆序构造单链表ListNode* desc_construct(vector&lt;int&gt; input) { if (input.empty()) return NULL; ListNode* pre = NULL; for (int i=0;i&lt;input.size();i++) { ListNode* cur = new ListNode(input[i]); cur-&gt;next = pre; pre = cur; } return pre;} 16. 链表升序排序快排是需要一个指针指向头，一个指针指向尾，然后两个指针相向运动并按一定规律交换值，最后使得支点左边小于支点，支点右边大于支点，但是对于单链表而言，指向结尾的指针很好办，但是这个指针如何往前，我们只有一个 next（这并不是一个双向链表）。 我们只需要两个指针 i 和 j，这两个指针均往 next 方向移动，移动的过程中始终保持区间 [1, i] 的 data 都小于 base（位置 0 是主元），区间 [i+1, j) 的 data 都大于等于 base，那么当 j 走到末尾的时候便完成了一次支点的寻找。若以 swap 操作即 if 判断语句成立作为基本操作，其操作数和快速排序相同，故该方法的平均时间复杂度亦为$T(n) = O(nlogn)$。 1234567891011121314151617181920212223// 链表升序排序/** * @param begin 链表的第一个结点，即header-&gt;next * @param end 链表的最后一个结点的next */void asc_sort(ListNode* begin, ListNode* end) { // 链表为空或只有一个结点 if (begin == end || begin-&gt;next == end) return; int base = begin-&gt;val; ListNode* i = begin; ListNode* j = begin-&gt;next; while (j != end) { if (j-&gt;val &lt; base) { i = i-&gt;next; swap(i-&gt;val, j-&gt;val); } j = j-&gt;next; } swap (i-&gt;val, begin-&gt;val); asc_sort(begin, i); asc_sort(i-&gt;next, end);}// usage: asc_sort(header-&gt;next, nullptr); 17. 找出单链表的中间结点123456789101112// 找出单链表的中间结点（类似倒数第k个结点）// 法一：遍历一次，再遍历到n/2,复杂度为O(n+n/2)// 法二：快慢指针ListNode* find_middle(ListNode* head) { ListNode* fast = head; ListNode* slow = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) { slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; } return slow;}","link":"/2019/08/21/ck8mt4udc000fqcun96nbmao5/"},{"title":"2019中兴捧月算法大赛——无线信道估计","text":"Github项目：https://github.com/dlc1994/2019ZTE-Algorithm-Competition 本来想参加深度学习题目的，但看到用caffe，还要现学就作罢了 傅里叶门派有三个题目，一开始想做了智能调度，但是看了半天题目也没理解，随便提交了一个上去（最后发现一共才50多份提交，悔不当初） 看到这个有点像曲线拟合，题目就是用最少的导频数，估计带噪声的其余一共250个频点的信道值 看上去有点像曲线拟合，所以我就往曲线拟合方向做了 1 导频数用62，此时导频和误差百分比大致在50% 2 导频分开实部和虚部分开进行拟合，拟合函数使用SmoothingSpline 3 拟合出来函数是带噪声的，接下来去噪 4 用小波变换，小波基为coif5,分解层数为10层 5 输出最终结果，感觉有点过拟合了 最后一天做了半天，只能提高到36名了，看到进决赛拿蓝剑的那些大神还是很羡慕的，应该多花些时间的，从原理上改进而不是简单的去噪拟合 大佬的思路： 1 多种组合构成个闭环优化，中兴专家做的，好像用20个导频左右拿了第一 2 用CNN，这个可能是从autoencoder方向想，但是数据集够用？","link":"/2019/05/24/ck8mt4udi000mqcun8zzmpx9c/"},{"title":"LeetCode Solutions","text":"Here are my solutions to the LeetCode problems, linking to my Github repository: EASY Leetcode 1 Two Sum Leetcode 9 Palindrome Number Leetcode 13 roman2integer Leetcode 14 longestcommonprefix Leetcode 20 valid parentheses Leetcode 21 merge2sortedlist Leetcode 461 Hamming Distance Leetcode 709 To Lower Case Leetcode 771 Jewels and Stones Leetcode 804 Unique Morse Code Words Circle Leetcode 832 Flipping an Image MEDIUM Leetcode 12 int2roman Leetcode 21 merge2sortedlist Leetcode 22 generateParentheses Leetcode 29 DivideTwoIntegers Leetcode 33 SearchInRotatedSortedArray Leetcode 34 FindFirstAndLastPositionInSortedArray Leetcode 36 SearchInRotatedSortedArray Leetcode 516 LongestPalindSubstringHARD Leetcode 23 mergeKsortedlists","link":"/2018/07/30/ck8mt4ud60009qcunv9n6jwoi/"},{"title":"常用排序算法（python）","text":"常用排序算法（python） 冒泡排序1234567def bubbleSort(alist): for i in range(len(alist)): for j in range(len(alist)-i-1): if alist[j]&gt;alist[j+1]: tmp = alist[j] alist[j] = alist[j+1] alist[j+1] = tmp 选择排序123456789def selectSort(alist): for i in range(len(alist)): minPos = i for j in range(i+1, len(alist)): if alist[i]&gt;alist[j]: minPos = j tmp = alist[i] alist[i] = alist[minPos] alist[minPos] = tmp 插入排序12345678def insertSort(alist): for i in range(1, len(alist)): current = alist[i] pos = i while pos&gt;0 and current&lt;alist[pos-1]: alist[pos] = alist[pos-1] pos-=1 alist[pos] = current 希尔排序1234567891011def shellSort(alist): gap = len(alist)//2 while gap&gt;0: for i in range(gap, len(alist)): j = i current = alist[i] while j-gap&gt;0 and current&lt;alist[j-gap]: alist[j] = alist[j-gap] j = j - gap alist[j] = current gap = gap // 2 归并排序1234567891011121314151617181920212223242526def mergeSort(alist): if len(alist)&gt;1: mid = len(alist) // 2 left = alist[:mid] right = alist[mid:] mergeSort(left) mergeSort(right) i,j,k = 0,0,0 while i&lt;len(left) and j&lt;len(right): if left[i]&lt;right[j]: alist[k] = left[i] i+=1 else: alist[k] = right[j] j+=1 k+=1 while i&lt;len(left): alist[k] = left[i] k+=1 i+=1 while j&lt;len(right): alist[k] = right[j] k+=1 j+=1 快速排序1234567891011121314151617181920212223242526272829def quickSort(alist): quickSortHelper(alist, 0, len(alist)-1)def quickSortHelper(alist, first, last): if first&lt;last: splitpoint = partition(alist, first, last) quickSortHelper(alist, first, splitpoint-1) quickSortHelper(alist, splitpoint + 1, last)def partition(alist, first, last): pivot = alist[first] leftmark = first + 1 rightmark = last done = False while not done: while leftmark &lt;= rightmark and alist[leftmark] &lt;= pivot: leftmark += 1 while rightmark &gt;= leftmark and alist[rightmark] &gt;= pivot: rightmark -= 1 if rightmark &lt; leftmark: done = True else: tmp = alist[leftmark] alist[leftmark] = alist[rightmark] alist[rightmark] = tmp tmp = alist[first] alist[first] = alist[rightmark] alist[rightmark] = tmp return rightmark","link":"/2019/04/19/ck8mt4udf000jqcunu39498jt/"},{"title":"Water Filling Algorithm and Matlab Simulation","text":"注水算法是根据某种准则，并根据信道状况对发送功率进行自适应分配，通常是信道状况好的时刻，多分配功率，信道差的时候，少分配功率，从而最大化传输速率。当接收端完全已知CSI（信道状态信息）而发送端未知CSI时，发送天线阵列中的功率平均分配是合理的。 实现功率的“注水”分配，发送端必须知道CSI。 直观而言，就如下图所示： 图1 注水原理示意图（白色平台越高代表信道条件越差，注入的水就越少） 注水原理可以建模为下述优化问题： \\begin{align} & \\underset{P_1,P_2,...,P_N}{\\mathop{\\max }}\\,\\text{ }{C_{sum}}=\\sum_{n=1}^{N}{\\log \\left( 1+\\frac{P_n{\\left| {h_n} \\right|}^2}{N_0} \\right)} \\\\ & \\text{subject to }\\sum_{n=1}^{N}{P_n}={P}_{sum},n=1,2,...,N \\ \\end{align}其中${C}_{sum}$表示系统总信道容量，$N$为信道数，${P}_{n}$为第$n$个信道的功率，${h}_{n}$为第$n$个信道的信道增益，${N}_{0}$为噪声功率谱密度，${P}_{sum}$为传输总功率，也就是总水量。 该优化问题为凸优化问题，可以用拉格朗日乘数法求得全局最优解。 \\mathcal{L}(\\lambda ,{P_1},{P_2},...,{P_N})=\\sum_{n=1}^{N}{\\log \\left( 1+\\frac{P_n{\\left| {h_n} \\right|}^2}{N_0} \\right)}+\\lambda (\\sum_{n=1}^{N}{P_n}-P_{sum})令$\\frac{\\partial \\mathcal{L} }{\\partial P_n}=\\frac{\\partial \\mathcal{L} }{\\partial \\lambda }=0$，解得最优功率分配方案为： P_{n}^{*}={\\left( \\frac{1}{\\lambda }-\\frac{N_0}{\\left| {h}_{n} \\right|}^{2} \\right)}^{+}其中${(\\centerdot )}^{+}$表示取值非负。 MATLAB实现 1234567891011121314151617181920212223242526272829303132333435363738394041clear all;channel_n=10; %channel numberM=[5,10,20,50]; %transmitted powerN0=0.5; h_1= random(&apos;rayleigh&apos;,1,1,channel_n); %Rayleigh fadingh_2=h_1.^2; %|h|.^2h_2_sorted=sort(h_2); %sort the channel gainh=h_2_sorted/N0; syms lamdafor m=1:length(M) fprintf(&apos;transmitted power is %d watt&apos;,M(m)); for k=1:channel_n p=zeros(1,channel_n); sum=0; for i=k:channel_n sum=sum+(1/lamda-1/h(i)); end f=sum-M(m); x=solve(f,lamda); %find lamda if k==1 if vpa(x)&gt;0 &amp;&amp; vpa(x)&lt;h(k) for i=k:channel_n p(i)=1/x-1/h(i); %allocate power capacity=capacity+log2(1+p(i)*h(i));%compute the capacity end p(i)=vpa(p(i),3) capacity=vpa(capacity,3) end else if vpa(x)&gt;h(k-1) &amp;&amp; vpa(x)&lt;h(k) capacity=0; for i=k:channel_n p(i)=1/x-1/h(i); %allocate power capacity=capacity+log2(1+p(i)*h(i)); %compute the capacity end p(i)=vpa(p(i),3) capacity=vpa(capacity,3) end end endend","link":"/2018/07/18/ck8mt4ud9000cqcunsjzoi8rm/"},{"title":"Introduction to Machine Learning","text":"做了与机器学习相关的项目好久了，但对机器学习一直没有一个系统的认识，导致在切入一些新的领域时力有不逮，总感觉理解有偏差或者理解困难，因此想系统地、详细地学习机器学习，就从周志华的西瓜书和Andrew Ng的机器学习视频开始吧。 众所周知， 机器学习是研究计算机怎样模拟或实现人类的学习行为，以获取新是研究计算机怎样模拟或实现人类的学习行为。 来自卡内基梅隆大学的Tom Mitchell提出的关于机器学习的定义较为人所接受，他定义的机器学习是，一个程序被认为能从经验E中学习，解决任务T，达到性能度量值P，当且仅当，有了经验E后，经过P评判，程序在处理T时的性能有所提升。 一般而言，我把机器学习分为监督学习、无监督学习和增强学习，而深度学习和大数据是拓展也是紧密的关联，如下图所示： 监督学习，顾名思义，就是有人指导你，告诉你这个学习正确与否。专业点来讲，就是数据集中每个样本都会带有一个正确答案，比如在西瓜分类里，“红瓤，有蒂”带有标签“甜”，“黄瓤，无蒂”带有标签“不甜”；在回归里，房价预测里每个样本都带有房价。分类和回归的区别在于预测的是一组离散的结果，而回归可以预测连续的输出。 无监督学习，从上图可以看出，我们事先不知道样本是哪一类或者是哪一个值，也就是没有任何的标签或“答案”。一个比较著名的例子就是鸡尾酒宴问题：许多人坐在一起参加鸡尾酒会，大家都在同一时间说话，声音此起彼伏，重重叠叠，要想分离出不同人说话的声音，就是一个聚类问题，也是无监督学习问题。这个例子可能比较难懂，再说一个就是在无线通信中，有时会根据用户的行为特征对用户进行分类，便于进行一些资源的调度和统一管理，而如何判断一堆用户里哪些用户是类似的，比如上班族、学生党、旅客等，这就是一个典型的聚类问题。 增强学习则是要解决这样的问题，一个能感知环境的自治agent，怎样通过学习选择能达到其目标的最优动作。当agent（机器人，下棋，在无线领域则可以是用户、基站和operator）在环境中作出某个动作时，会产生不同的奖励值或者惩罚值，agent的任务就是从这个非直接的，有延迟的回报中学习，以便后续的动作产生最大的累积效应。 在后续的文章中，我们会对各个算法有比较详细的学习过程，敬请期待啦。","link":"/2018/11/28/ck8mt4ud20006qcunbkcrlbp8/"},{"title":"常用数据结构——栈 (python)","text":"本科学过c++的数据结构了，但研究生转无线通信后就忘的差不多了，现在重新复习下栈。 栈（stack）、队列（queues）、双端队列（deques）和列表都是有序数据容器，元素添加后在容器内的位置跟其他元素添加和删除的顺序有关，像这样的容器被称作线性数据结构（linear data structure）。 栈可以想象为只有一端开口的瓶子，假设每放一个东西进去都会把前面放的完全盖住，那么这时你想取出最里面的东西显然是不可能的，所以你只能把上面的一个个拿出来才能取到你想要的，这就叫做后进先出（LIFO, last-in first-out）。 1. 栈的主要方法及实现 栈的方法主要有下面几种： Stack() creates a new stack that is empty. It needs no parameters and returns an empty stack. push(item) adds a new item to the top of the stack. It needs the item and returns nothing. pop() removes the top item from the stack. It needs no parameters and returns the item. The stack is modified. peek() returns the top item from the stack but does not remove it. It needs no parameters. The stack is not modified. isEmpty() tests to see whether the stack is empty. It needs no parameters and returns a boolean value. size() returns the number of items on the stack. It needs no parameters and returns an integer.在python中是没有栈的实现的，所以栈需要自己实现，简单点可以用个list充当下，更一般的要实现上面各种方法还是面向对象创造一个类比较好，实现代码如下所示：123456789101112131415161718class Stack: def __init__(self): self.items = [] def isEmpty(self): return self.items == [] def push(self, item): self.items.append(item) def pop(self): return self.items.pop() def peek(self): return self.items[len(self.items)-1] def size(self): return len(self.items) 2. 栈的主要应用2.1 字符串反转 那么，费尽心机创造一个栈有啥用呢？首先可以用来翻转字符串，当然python有超级多方式可以反转字符串，最简单的自然是string[::-1]。12345678def stringReverse(self, stringstring): s = Stack() output = &quot;&quot; for ss in stringstring: s.push(ss) while not s.isEmpty(): output = output + s.pop() return output 2.2 简单括号匹配 除此之外，还有简单的括号匹配问题，也可以利用栈的特性来解决：1234567891011121314151617181920def parChecker(symbolString): s = Stack() balanced = True index = 0 while index &lt; len(symbolString) and balanced: symbol = symbolString[index] if symbol == &quot;(&quot;: s.push(symbol) else: if s.isEmpty(): balanced = False else: s.pop() index = index + 1 if balanced and s.isEmpty(): return True else: return False 其实吧，也可以不用栈解决呀（不是我杠，笔试时间也是很重要的）123456789def parChecker(symbolString): left = 0 right = 0 for s in symbolString: if s == &apos;(&apos;: left+=1 else: right+=1 return left==right 2.3 多重括号匹配 拓展到更复杂一点的括号匹配问题——多重括号匹配：12345678910111213141516171819202122232425def parChecker(symbolString): s = Stack() balanced = True index = 0 while index &lt; len(symbolString) and balanced: symbol = symbolString[index] if symbol in &quot;([{&quot;: s.push(symbol) else: if s.isEmpty(): balanced = False else: top = s.pop() if not matches(top,symbol): balanced = False index = index + 1 if balanced and s.isEmpty(): return True else: return Falsedef matches(open,close): opens = &quot;([{&quot; closers = &quot;)]}&quot; return opens.index(open) == closers.index(close) 当然，我又“杠”了，主要不想想这么复杂的结构2333：12345678910111213141516def parChecker(symbolString): l1,l2,l3,r1,r2,r3=0,0,0,0,0,0 for s in symbolString: if s==&apos;{&apos;: l1+=1 elif s==&apos;}&apos;: r1+=1 elif s==&apos;(&apos;: l2+=1 elif s==&apos;)&apos;: r2+=1 elif s==&apos;[&apos;: l3+=1 else: r3+=1 return [l1,l2,l3]==[r1,r2,r3] 2.4 将十进制数转换为各种进制 想将10进制数（Decimal）转换为2进制（Binary）、8进制（Octal）或者16进制（Hexidecimal），就将这个数不断除进制数，然后将余数逆序输出，不想贴图了自己百度查下。1234567891011121314def baseConverter(decNumber,base): digits = &quot;0123456789ABCDEF&quot; remstack = Stack() while decNumber &gt; 0: rem = decNumber % base remstack.push(rem) decNumber = decNumber // base newString = &quot;&quot; while not remstack.isEmpty(): newString = newString + digits[remstack.pop()] return newString 2.5 中缀表达式、前后缀表达式 接下来就是栈的重点操作了（就是比较复杂一点）。 什么是中缀表达式呢？就是一般的表达式，比如A+B, C*D等。 顾名思义，前缀表达式就是操作符在前面，后缀就是在后面，给几个例子体会一下： Infix Expression Prefix Expression Postfix Expression A + B C + D + + A B C D A B C + D + (A + B) (C + D) + A B + C D A B + C D + A B + C D + A B C D A B C D + A + B + C + D + + + A B C D A B + C + D + 将中缀表达式转换为后缀表达式，利用栈可以写为：123456789101112131415161718192021222324252627282930def infixToPostfix(infixexpr): prec = {} prec[&quot;*&quot;] = 3 prec[&quot;/&quot;] = 3 prec[&quot;+&quot;] = 2 prec[&quot;-&quot;] = 2 prec[&quot;(&quot;] = 1 opStack = Stack() postfixList = [] tokenList = infixexpr.split() for token in tokenList: if token in &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; or token in &quot;0123456789&quot;: postfixList.append(token) elif token == &apos;(&apos;: opStack.push(token) elif token == &apos;)&apos;: topToken = opStack.pop() while topToken != &apos;(&apos;: postfixList.append(topToken) topToken = opStack.pop() else: while (not opStack.isEmpty()) and \\ (prec[opStack.peek()] &gt;= prec[token]): postfixList.append(opStack.pop()) opStack.push(token) while not opStack.isEmpty(): postfixList.append(opStack.pop()) return &quot; &quot;.join(postfixList) 假如直接给你一个后缀表达式让你计算呢，这就是需要再写一个算法了，不过比较简单，贴上来：1234567891011121314151617181920212223def postfixEval(postfixExpr): operandStack = Stack() tokenList = postfixExpr.split() for token in tokenList: if token in &quot;0123456789&quot;: operandStack.push(int(token)) else: operand2 = operandStack.pop() operand1 = operandStack.pop() result = doMath(token,operand1,operand2) operandStack.push(result) return operandStack.pop()def doMath(op, op1, op2): if op == &quot;*&quot;: return op1 * op2 elif op == &quot;/&quot;: return op1 / op2 elif op == &quot;+&quot;: return op1 + op2 else: return op1 - op2 栈就目前学完了，后续有的话还会补充。","link":"/2019/04/29/ck8mt4udg000kqcunzvo5kcjw/"},{"title":"暑期实习招聘笔试题3月(更新ing)","text":"实习笔试试题，有些没投（准备好先），拿过来先看了看 12 头条笔试题1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;numeric&gt;using namespace std;int main(){ int N; cin&gt;&gt;N; for(int n=0;n&lt;N;++n){ int L, minVal, minPos; minVal = 1000; minPos = 0; cin&gt;&gt;L; vector&lt;int&gt; v(L, 0); for(int l=0;l&lt;L;l++){ cin&gt;&gt;v[l]; if(v[l]&lt;minVal){ minVal = v[l]; minPos = l; } } vector&lt;int&gt; reward(v.size(), 0); reward[minPos] = 1; for(int k=0;k&lt;L;k++){ int pos = k+minPos; if (pos&gt;=L){ pos = pos - L; } if(pos==0){ if(v[pos]&gt;v[L-1]) reward[pos] = reward[L-1]+1; else if(v[pos]==v[L-1]) reward[pos] = reward[L-1] - 1; else reward[pos]=reward[pos]; } else{ if(v[pos]&gt;v[pos-1]) reward[pos] = reward[pos-1]+1; else if(v[pos]==v[pos-1]) reward[pos] = reward[pos-1] - 1; else reward[pos]=reward[pos]; } } cout&lt;&lt;accumulate(reward.begin(),reward.end(),0)&lt;&lt;endl; } return 0;} 3 头条笔试题1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;numeric&gt;using namespace std;vector&lt;int&gt; zhaoqian(int N){ vector&lt;int&gt; v(4,0); N = 1024 - N; int value[4] = {64, 16, 4, 1}; for(int i=0;i&lt;(sizeof(value)/sizeof(value[0]));i++){ cout&lt;&lt;i&lt;&lt;endl; int a = N/value[i]; v[i] = a; N = N%value[i]; } return v;}int main(){ int N; cin&gt;&gt;N; vector&lt;int&gt; vv; vv = zhaoqian(N); cout&lt;&lt;accumulate(vv.begin(), vv.end(), 0)&lt;&lt;endl; return 0;} 4 招行笔试题题目描述：切不等高的蛋糕，蛋糕N份，每刀切平一部分，切下来的不得超过k份，整块蛋糕切平最少需要几刀，比如如下输入5 61 2 3 4 5提示：第一刀可以切到2，切下来刚好是6份，剩下蛋糕为1 2 2 2 2第二刀全切到1，最少需要2刀12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &lt;iostream&gt;#include &lt;numeric&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;list&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;int main(){ int N,k; cin&gt;&gt;N&gt;&gt;k; vector&lt;int&gt; v(N, 0); for(int l=0;l&lt;N;l++){ cin&gt;&gt;v[l]; } sort(v.begin(),v.end()); int minVal = v.front(); int maxVal = v.back(); int dao = 0; bool hello = false; int i = 0; while(i&lt;v.size()){ if(hello) i=0; if(minVal==maxVal) break; int sum = 0; bool flag = true; int minVal1=v[i]; for(int j=v.size()-1;j&gt;i;--j){ sum = sum+(v[j]-minVal1); if(sum&gt;k){ flag = false; break; } } if(flag){ dao++; hello = true; for(int g=v.size()-1;g&gt;i;g--){ v[g] = v[g]-(v[g]-minVal1); } } maxVal=v.back(); i++; } cout&lt;&lt;dao; return 0;}","link":"/2019/03/16/ck8mt4udh000lqcunj0aj7hae/"},{"title":"Linear Regression","text":"就从最简单的线性回归模型（Linear Regression model）开始学习吧。 从这个模型的名字我们可以看出，因变量和变量之间的关系是线性的，预测值可以通过计算输入特征的权重给出： \\hat{y} = \\theta_0+\\theta_1x_1+\\theta_2x_2+...+\\theta_nx_n其中，$\\hat{y}$是预测值，$n$是特征数量，$\\theta_0$是bias，$x_i$是第$i$个特征值，$\\theta_j$是第$j$个特征的模型参数。如果获取了模型的所有参数，给定一个样本我们就可以用上面这个公式模型得到预测值。 为了表达更简洁，一般用向量表示： \\hat{y} = h_{\\mathbf{\\theta}}(\\mathbf{x}) = \\mathbf{\\theta}^T \\mathbf{x}其中$h_{\\mathbf{\\theta}}()$是hypothesis function是关于$\\mathbf{\\theta}$的假设函数，$\\mathbf{\\theta} = [\\theta_0;\\theta_1;…;\\theta_n]$，$\\mathbf{x} = [x_0, x_1, x_2, …, x_n]$并且$x_0=1$。 我们的目标当然是想要所有预测值都跟实际值相等，因此，目标函数或者称代价函数建模为： \\text{MSE}(\\mathbf{X},h_{\\mathbf{\\theta}}) = \\frac{1}{m}\\sum_{i=1}^{m}\\left(\\mathbf{\\theta}^T\\cdot\\mathbf{x}^{(i)}-y^{(i)}\\right)^2其中$\\mathbf{X}$为所有样本的集合，数量为$m$。 标准闭式解 基于均方误差最小化来进行模型求解的方法称为“最小二乘法”（least square method）。在线性回归中，最小二乘法就是试图找到一条直线，使所有样本到直线上的欧氏距离之和最小。 一般地，我们利用最小二乘法对$\\mathbf{\\theta}$进行估计。数据集$\\mathbf{X}$表示为： \\mathbf{X}=\\left( \\begin{array}{ccc} 1 & x_{11} & x_{12} & \\cdots\\ & x_{1d}\\\\ 1 & x_{21} & x_{22} & \\cdots\\ & x_{23} \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\\\\ 1 & x_{m1} & x_{m2} & \\cdots\\ & x_{md}\\\\ \\end{array} \\right) =\\left( \\begin{array}{ccc} 1 & \\mathbf{x}_1^T \\\\ 1 & \\mathbf{x}_2^T \\\\ \\vdots & \\vdots \\\\ 1 & \\mathbf{x}_m^T \\\\ \\end{array} \\right) 然后把实际值也写成向量模式$\\mathbf{y}=(y_1;y_2;…;y_m)$，因此优化问题为： \\mathbf{\\theta}^*=\\underset{\\mathbf{\\theta}}{\\text{arg}\\min}(\\mathbf{y}-\\mathbf{\\theta}^T\\mathbf{X})^T(\\mathbf{y}-\\mathbf{\\theta}^T\\mathbf{X}) 令$E_{\\mathbf{\\theta}}=(\\mathbf{y}-\\mathbf{\\theta}^T\\mathbf{X})^T(\\mathbf{y}-\\mathbf{\\theta}^T\\mathbf{X})$，对$\\mathbf{\\theta}$求导可得： \\frac{\\partial E_{\\mathbf{\\theta}}}{\\partial \\mathbf{\\theta}}=2\\mathbf{X}^T(\\mathbf{\\theta}^T\\mathbf{X}-\\mathbf{y}) 令上式等于0可解得 \\mathbf{\\theta}^*=(\\mathbf{X}^T\\mathbf{X})^{-1}\\mathbf{X}^T\\mathbf{y} 如果$\\mathbf{X}^T\\mathbf{X}$不可逆怎么办，这可能是由于矩阵中存在冗余特征，在线性代数里说明矩阵并非线性不相关，因此可以删除多余特征；也有可能是由于特征数大于等于样本数，也就是$m \\le n$，可以通过删除一些特征或者使用正则化（regularization，后续介绍）。 给出python一个实现例子如下： 12345678910111213141516171819import numpy as np X = 2 * np.random.rand(100, 1)y = 2 + 6 * X + np.random.randn(100, 1)X_b = np.c_[np.ones((100, 1)), X] # add x0 = 1 to each instancetheta_best = np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(y)print(theta_best)# [[1.74568681] [6.27246194]]X_new = np.array([[0], [2]])X_new_b = np.c_[np.ones((2, 1)), X_new] # add x0 = 1 to each instancey_predict = X_new_b.dot(theta_best)print(y_predict) #[[ 1.74568681] [14.29061069]]plt.plot(X_new, y_predict, &quot;r-&quot;)plt.plot(X, y, &quot;b.&quot;)plt.axis([0, 2, 0, 15])plt.show() 如果用sklearn实现的话，代码如下：12345678&gt;&gt;&gt; from sklearn.linear_model import LinearRegression&gt;&gt;&gt; lin_reg = LinearRegression()&gt;&gt;&gt; lin_reg.fit(X, y)&gt;&gt;&gt; lin_reg.intercept_, lin_reg.coef_(array([ 4.21509616]), array([[ 2.77011339]]))&gt;&gt;&gt; lin_reg.predict(X_new)array([[ 4.21509616],[ 9.75532293]]) 这种方式实现的计算复杂度只要在矩阵求逆上，对于一个$n \\times n$的矩阵，求逆复杂度大约是$O(n^{2.4})$到$O(n^{3})$，当特征数量很大时（比如100,000以上时），标准闭式解会变得很慢；另一方面，对于样本数量其复杂度是$O(m)$，也就是线性的；此外，模型训练完成后，预测的复杂度对于样本数量和特征数量复杂度都很快。 梯度下降法 梯度下降法是十分常用的优化算法，目的是通过迭代过程不断更新参数进而最小化代价函数，每次优化的方向都是斜率绝对值最大的方向。Note： 需要谨慎选择步长（step size）或者叫做学习率（learning rate），太小的话，需要许多次迭代才能走到最优点，而步子太大，则有可能跨过最优点，然后陷入震荡。 凸优化问题找到最优点比较容易，而非凸问题则容易陷入局部最优点或者陷入平台（plateau)。线性回归问题是个凸优化问题。 最好在使用梯度下降法前对数据进行标准化处理，不然“碗”太长需要更多的迭代次数。 问题参数越多，维度越大，参数空间越大，搜索最优解也就越难。 Batch Gradient Descent Batch是批的意思，批梯度下降就是在每次迭代过程中把所有数据都来计算代价函数的偏导，也就是梯度。代价函数对于参数$\\theta_j$的偏导为： \\frac{\\partial \\text{MSE}(\\theta)}{\\partial{\\theta}_j}=\\frac{2}{m}\\sum_{i=1}^{m}\\left(\\theta^T \\cdot \\mathbf{x}^{(i)}-y^{(i)}\\right)x_j^{(i)} 用向量来表示梯度下降为： \\nabla_{\\theta}\\text{MSE}(\\theta)=\\left( \\begin{array}{ccc} \\frac{\\partial \\text{MSE}(\\theta)}{\\partial \\theta_0}\\\\ \\frac{\\partial \\text{MSE}(\\theta)}{\\partial \\theta_1}\\\\ \\vdots\\\\ \\frac{\\partial \\text{MSE}(\\theta)}{\\partial \\theta_0} \\end{array} \\right) =\\frac{2}{m}\\mathbf{X}^T\\cdot(\\mathbf{X}\\cdot \\theta-\\mathbf{y}) 由此，我们可以得到梯度下降的步骤： \\theta^{(n+1)} = \\theta^{(n)}-\\eta \\nabla_{\\theta}\\text{MSE}(\\theta) 推导出这个公式之后就可以实现了：1234567eta = 0.1 # learning raten_iterations = 1000m = 100theta = np.random.randn(2,1) # random initializationfor iteration in range(n_iterations): gradients = 2/m * X_b.T.dot(X_b.dot(theta) - y) theta = theta - eta * gradients Stochastic Gradient Descent 在前面讲过，BGD在每次迭代中是把所有数据都用于计算的，因此当数据量很大时，算法会变得难以忍受的慢，因此需要使用其他梯度下降算法。随机梯度下降法跟批梯度下降是两个极端，SGD在每次迭代中会随机从训练集中选择一个样本，然后只用这个样本计算并更新梯度。因此，这个算法计算比BGD快很多很多；但也由于其随机特性，优化曲线不会“直接”向着最优点前进，而是来回波动，但最终会抵达最优值附近。其算法如下图所示： Python实现如下：1234567891011121314n_epochs = 50t0, t1 = 5, 50 # learning schedule hyperparametersdef learning_schedule(t):return t0 / (t + t1)theta = np.random.randn(2,1) # random initializationfor epoch in range(n_epochs): for i in range(m): random_index = np.random.randint(m) xi = X_b[random_index:random_index+1] yi = y[random_index:random_index+1] gradients = 2 * xi.T.dot(xi.dot(theta) - yi) eta = learning_schedule(epoch * m + i) theta = theta - eta * gradientsprint(theta) 如果用sklearn来实现的话，代码就简单多了：1234from sklearn.linear_model import SGDRegressorsgd_reg = SGDRegressor(n_iter=50, penalty=None, eta0=0.1)sgd_reg.fit(X, y.ravel())print(sgd_reg.intercept_, sgd_reg.coef_) NOTE: epoch是指把所有数据样本都遍历一遍，iteration表示更新一次参数，batch则是指数据样本的大小，在SGD中，iteration=batch=1，epoch=num_X/batch Mini-batch Gradient Descent Mini-batch GD介于SGD和BGD之间，也就是每次用来更新参数的样本不是一也不是所有（吴恩达说在2-400之间，他倾向于用10），它吸收了BGD和SGD的优缺点的折中，收敛更快，随机性较小，但也难抵达最优值，其算法流程如下图所示： 这里介绍的标准闭式解只适用于线性回归问题，但梯度下降法可以用来训练许多模型，在深度学习中也有广泛应用，将他们比较如下： Algorithm Large m Out-of-core Support Large n Hyperparameters Scaling Required Sklearn Normal Equation Fast No Slow 0 No LinearRegression Batch GD Slow No Fast 2 Yes n/a Stochastic GD Fast Yes Fast $\\ge$2 Yes SGDRegressor Mini-batch GD Fast Yes Fast $\\ge $2 Yes n/a Polynomial Regression 如果数据并非一条直线呢，那么还可以用线性模型吗？实际上是可以的，主要方法就是把一个特征拓展成多维的，比如$x^2, x^3,…, x^k$，然后将其作为另一个维度的特征，比如$x_1 = x, x_2 = x^2$，那么就可以用线性模型按照上面的方法进行训练了，用sklearn实现如下： 1234567891011121314151617181920import numpy as npimport matplotlib.pyplot as pltfrom sklearn.preprocessing import PolynomialFeaturesfrom sklearn.linear_model import LinearRegressionm = 100X = 6 * np.random.rand(m, 1) - 3y = 1 * X**2 + X + 2 + np.random.randn(m, 1)plt.scatter(X, y)poly_features = PolynomialFeatures(degree=2, include_bias=False)X_poly = poly_features.fit_transform(X)lin_reg = LinearRegression()lin_reg.fit(X_poly, y)print(lin_reg.intercept_, lin_reg.coef_)xx = np.array((range(-3, 4)))print(xx)yy = xx*0.98134428+xx*xx*0.94365742+1.94555083plt.plot(xx, yy, c=&apos;r&apos;)plt.show() 此外，需要注意，PolynomialFeatures(degree=d)会把一个包含n个特征的矩阵转化为包含$\\frac{(n+d)!}{d!n!}$个特征的矩阵，即如果对于两个特征a和b，令degree=3，那么特征不仅有$a^2$，$a^3$，$b^2$，$b^3$，还会有$ab$，$a^2b$和$ab^2$.","link":"/2018/11/28/ck8mt4ud7000aqcunshrdna0w/"},{"title":"How to Make a Visual Mark Up and Revision of Significant Differences between Two Latex Files by Latexdiff","text":"Recently my survey was rejected and required minor revision, while I have to submit a revised article with the “editing mode” feature turned on. Because I use Miktex+Texstudio to edit my paper in windows 10, Latexdiff is considered of course. Latexdiff is a Perl script for visual mark up and revision of significant differences between two LATEX files. Various options are available for visual mark up using standard LATEX packages such as color. Changes not di­rectly af­fect­ing vis­i­ble text, for ex­am­ple in for­mat­ting com­mands, are still marked in the LATEX source. A rudi­men­tary re­vi­sion fa­cilil­ity is pro­vided by an­other Perl script, la­texre­vise, which ac­cepts or re­jects all changes. Man­ual edit­ing of the dif­fer­ence file can be used to over­ride this de­fault be­haviour and ac­cept or re­ject se­lected changes only. Step 1:For a pure rookie, first of all, you need to install CTEX (for Chinese users) or Miktex. Step 2:Then, win+R and open cmd, input command latexdiff, if returns 12 and only 2 non-option arguments required. Write latexdiff -h to get help Congrats! You have successfully installed latexdiff and you can turn to Step 3.3. Step 3:Otherwise, don’t worry, I encountered the same situation as you. Do as follows. 3.1 Install Latexdiff PackageAfter you install a Tex, open Start Menu-&gt;Ctex or Miktex-&gt;Package Manager (Admin). Search Latexdiff in column Name: as follows Click the + button and install it. 3.2 Install PerlLatexdiff is a Perl script, so you can go to Perl download corresponding version in your computer. Technically, ActivePerl and StrawberryPerl is both ok. Same steps in Step 2, if you have problem as 12latexdiff: The Perl script could not be found. latexdiff: Data: scripts/latexdiff/perl/latexdiff.pl It’s a common problem and you can find the answer in 这里 or Here. It is worth mentioning that if you have the following problem which confused me for a long time 12latexmk: the script engine could not be found latexdiff: data: scriptengine=&quot;perl.exe&quot; Actually I have no idea how I successfully solve it. You may do the trials as what I have done. Check the System Path of Perl and Tex, especially according to x86 or x64 Reinstall Perl, if not work, change to ActivePerl or StrawberryPerl Restart your windows after you make some changes 3.3 LatexdiffPut your origin tex version (e.g., old.tex) and your modified tex version (e.g., new.tex) in a same file. cmd to this path, and input 1latexdiff old.tex new.tex &gt;diff.tex where diff.tex is the editted version, add the required files to this path and compile it. Then you can have the results If you encounter some errors in compiling, just google it because they are just some common LATEX errors. Enjoy. !!!Tips: if you suffer any problem, first go to google or baidu it. Please discover the truth by yourself.","link":"/2018/06/19/ck8mt4ud40008qcuncm0lvkih/"},{"title":"A Stupid Mistake I Made about Sorting in Python DataFrame","text":"One day when I try to sort a DataFrame by a column, an amazing mistake happens!I will reproduce this stupid thing here. Firstly, make a dataframe example: 12345 a b c0 9 4 61 2 7 52 5 -3 83 1 2 3 123frame = pd.DataFrame({&quot;a&quot;:[9,2,5,1],&quot;b&quot;:[4,7,-3,2],&quot;c&quot;:[6,5,8,3]})frame.sort_values(&apos;a&apos;,inplace=True)print(frame) What do you think the result will be? What I expect it will get is like this: 12345 a b c3 1 2 31 2 7 52 5 -3 80 9 4 6 However, what I actually get is 12345 a b c0 9 4 61 2 7 52 5 -3 83 1 2 3 I get really confused, so I try all the arg in function DataFrame.sort_values(by, axis=0, ascending=True, inplace=False, kind=’quicksort’, na_position=’last’) I find out that only if the inplace= is set to True, the result is as expected. But the usage of this function I searched in google, did not meantion this parameter. Therefore, I look for an instruction of inplace， and I find that the inplace parameter is a generic term w.r.t pandas and not specific to sort_values alone. You can see it in several functions like pd.fillna, pd.replace etc. Whenever the inplace is set to True, it modifies the existing data frame and you need not assign it to a new data frame. Ohhhh… Then I find out where the mistake really lies in. In my previous code, the DataFrame frame I sorted has not been modified only if the parameter inplace is set to True, so I modify the code as follow: 123frame = pd.DataFrame({&quot;a&quot;:[9,2,5,1],&quot;b&quot;:[4,7,-3,2],&quot;c&quot;:[6,5,8,3]})df = frame.sort_values(&apos;a&apos;,inplace=True)print(df) The problem is solved! How stupid I was!","link":"/2018/06/12/ck8mt4ucu0001qcun2k94s11u/"},{"title":"Hexo: setup a static blog","text":"​ Before we start, you have to know what is the difference between static site and dynamic site. Let’s take a look at the definition in Wiki: A static web page (sometimes called a flat page/stationary page) is a web page that is delivered to the user exactly as stored, in contrast to dynamic web pages which are generated by a web application. Consequently, a static web page displays the same information for all users, from all contexts, subject to modern capabilities of a web server to negotiate content-type or language of the document where such versions are available and the server is configured to do so. It’s pros and cons are listed as follows: Advantages of a static website Provide improved security over dynamic websites Improved performance for end users compared to dynamic websites Fewer or no dependencies on systems such as databases or other application servers Disadvantages of a static website Dynamic functionality has to be added separately ​ Dynamic site is not our topic here. I wil talk about how to deploy a hexo blog in Github repository under the environment of Window 10. 1. Github initialization​ From the very beginning, you have to create a GitHub account and new a repository, note that the repository name need to be the same with your owner name (the alarm is appeared cause I have already newed a same one). REMEMBER the repository address (two kinds of address—- SSH: git@github.com:dlc1994/dlc1994.github.io.git and HTTPS: https://github.com/dlc1994/dlc1994.github.io.git). The configuration of SSH can be seen in here, and HTTPS has no need of extra operation. Install Git tool and the rest of operations is done through this tool. 2. Install the necessary componentsAfter that, install Node.js, in case of the low speed, you can also download it in here. Now it’s time to install Hexo in your machine, click right-hand button anywhere and open Git Bash, then input 12npm install hexo-cli -gnpm install hexo-deployer-git --save Wait a minute you can check if the component is installed successfully. Input directly in Git Bash, or Win+R and input cmd, then input codes as follow: 123git --versionnode -vnpm -v If return the version number then you can go on, otherwise just google your mistake during your installation. After Hexo is installed, go to the place where you want to save your blog and open Git Bash. Input hexo init, you can find that a lot of files are created. 3. Create your first blogUse file editor like Notepad++, open file _config.yml, find the codes and edit it as you want 123456789101112131415# Sitetitle: DLC&apos;s Blog #your blog namesubtitle: Find myself in the darkest place #your blog subtitledescription: Personal Blog #description of your blogkeywords:author: language: timezone: Asia/Shanghaitheme: landscape #your blog theme, I will talk about how to change it to `Next`deploy: type: repository: git@github.com:dlc1994/dlc1994.github.io.git #your repository address branch: master In Git Bash, input hexo g and hexo s, it will return (perfectly) Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. Open your browser and input localhost:4000 in address bar, you can see that (Ok it is really ugly) Lastly, you have to deploy it to your github repository, continue to input hexo d. Luckily, there is no error and you can see it in your repository address like git@github.com:dlc1994/dlc1994.github.io.git. If not, go to google for help. Create a new blog use hexo new &quot;postname&quot; or in your blog path blogpath\\source\\_posts new a .md file and edit it use Markdown (Typora is recommended here). More commands can be found here. I will update the process of blog beautification in my next blogs. !!!Tips: if you suffer any problem, first go to google or baidu it. Please discover the truth by yourself.","link":"/2018/06/12/ck8mt4ucz0003qcun44vjh8fs/"}],"tags":[{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"DataFrame","slug":"DataFrame","link":"/tags/DataFrame/"},{"name":"Sorting","slug":"Sorting","link":"/tags/Sorting/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Binary Tree","slug":"Binary-Tree","link":"/tags/Binary-Tree/"},{"name":"C/C++","slug":"C-C","link":"/tags/C-C/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Latex","slug":"Latex","link":"/tags/Latex/"},{"name":"Algorithms","slug":"Algorithms","link":"/tags/Algorithms/"},{"name":"Linear Regression","slug":"Linear-Regression","link":"/tags/Linear-Regression/"},{"name":"Polynomial Regression","slug":"Polynomial-Regression","link":"/tags/Polynomial-Regression/"},{"name":"Gradient Decent Methods","slug":"Gradient-Decent-Methods","link":"/tags/Gradient-Decent-Methods/"},{"name":"Matlab","slug":"Matlab","link":"/tags/Matlab/"},{"name":"Clion","slug":"Clion","link":"/tags/Clion/"},{"name":"Database","slug":"Database","link":"/tags/Database/"},{"name":"Postgresql","slug":"Postgresql","link":"/tags/Postgresql/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"LinkedList","slug":"LinkedList","link":"/tags/LinkedList/"},{"name":"Map","slug":"Map","link":"/tags/Map/"},{"name":"Postgis","slug":"Postgis","link":"/tags/Postgis/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Wireless communications","slug":"Wireless-communications","link":"/tags/Wireless-communications/"}],"categories":[{"name":"Data Processing","slug":"Data-Processing","link":"/categories/Data-Processing/"},{"name":"HEXO","slug":"HEXO","link":"/categories/HEXO/"},{"name":"Algorithm and Data Structure","slug":"Algorithm-and-Data-Structure","link":"/categories/Algorithm-and-Data-Structure/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/categories/Machine-Learning/"},{"name":"Paper Work","slug":"Paper-Work","link":"/categories/Paper-Work/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"Competition","slug":"Competition","link":"/categories/Competition/"},{"name":"Wireless Communications","slug":"Wireless-Communications","link":"/categories/Wireless-Communications/"},{"name":"Development","slug":"Development","link":"/categories/Development/"},{"name":"achine Learning","slug":"achine-Learning","link":"/categories/achine-Learning/"}]}