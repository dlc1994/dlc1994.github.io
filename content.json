{"pages":[{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"戴凌成（Lingcheng Dai)","text":"个人信息 手机：(+86)XXXXXXXXX Email：dailingcheng@foxmail.com 技术博客：https://dlc1994.github.io Github: https://github.com/dlc1994 教育经历北京邮电大学 信息与通信工程学院 信息与通信工程 工学硕士 2017.09-2020.06北京邮电大学 信息与通信工程学院 通信工程 工学学士 2013.09-2017.06 竞赛经历中国第二届高性能云计算创新大赛—区块链地址分类数据算法竞赛 二等奖 2019.07 从超过4000 万条比特币交易数据中提取与地址类别相关的交易特征（交易笔数、矿工费、时间等） 根据任务+交易特性结合随机森林模型+多进程搜索进行比特币地址标记分类，预测准确率达99.99% 百度&amp; 西安交大国际大数据竞赛城市功能区域分类 59/2037 2019.06 给定城市9 类功能区域的带噪遥感图像与用户访问数据，对图像进行去噪+访问数据矩阵化 设计双分支网络（ImageNet 预训练模型+微调）进行融合并使特征向量维度相同，预测准确率达0.67 中国“易华录杯”CCF软件服务创新大赛——公交线路准点预测 三等奖 2018.09 对天津市公交车超过4亿条GPS记录进行数据处理，构建天气、日期等特征并进行one-hot编码 调用XGBoost 进行训练，预测结果再与平均值线性叠加后乘以拥堵系数，输出公交车站点间运行时间 北邮、北师、中农大校园大数据竞赛——校园人流量预测 5% 2018.03 提取校园内33个地点10个月内采集的所有手机终端位置的数据，利用数据挖掘平台WEKA，对常用时间序列分析模型比如ARIMA,ARCH等进行分析 考虑课程、节假日对人流量的影响，不断修正预测模型及模型参数，最终对11月和12月校园内33个地点每小时的人数进行预测。 工作经历华为技术有限公司 华为云Cloud BU 调度优化算法工程师 2019.07 - 2019.09 利用PostgreSQL+PostGIS 部署地图查询服务，优化基于交互投票的路网匹配算法、设计关键点提取算法； 调研并初步构建首汽共享汽车的多网点租还需求预测、网点间均衡调度与VRP 问题以解决潮汐现象； 北京佰才帮技术有限公司 协议栈开发工程师 2019.02 - 2019.03 负责5G/LTE小基站上Layer2/Layer3（MAC、PDCP、RLC和RRC等）协议栈的研究、设计工作； 负责在CentOS上编写Makefile完成C代码工程中若干个库的编译和静态库封装； 负责完成一些代码整合、移植和混淆工作。 科研项目华为HIRP项目“基于机器学习的免传模一键式站址规划” 2018.01 - 2019.01独立完成从原始数据文件中用python提取数据，利用开源库Scikit-learn中的机器学习算法比如SVM、k近邻、神经网络等，在CentOS服务器上训练得到电平预测模型，最后利用遗传算法（开源框架GAFT）和贪心算法对基站覆盖率进行在线优化，确定基站最优部署参数。工程代码达上千行。 华为HIRP项目“以用户为中心网络下的资源管理和干扰协同研究” 2017.09-2018.08独立完成在以用户为中心的多天线超密组网下，基于WMMSE设计了一种低复杂度的分布式聚簇和波束赋形算法，通过块对角化方法将原始NP-hard非凸问题分解为各簇各变量的凸优化问题，再采用拉格朗日乘数法求解，最后在Matlab上进行系统级仿真，提升了边缘用户速率。 中兴项目“超密组网下的用户移动性预测研究” 2017.08-2018.06独立完成对现有学术界移动性预测方案的调研，对当前移动性预测采用的方案进行了详细总结，包括（隐）马尔科夫过程、贝叶斯网络、数据挖掘和神经网络等，并提出移动性预测在未来5G及6G路径规划、移动性优化、辅助定位上的应用和挑战，以及深度学习可能带来的巨大性能提升。 发表作品 &lt;学生一作&gt;, “Pricing-Based Semi-Distributed Clustering and Beamforming for User-Centric MIMO Networks,” IEEE Communications Letters, vol. 23, no. 12, pp. 2398-2401, Dec. 2019.（SCI，影响因子3.457） &lt;学生一作&gt;, “Mobility Prediction: A Survey on State-of-the-Art Schemes and Future Applications,” IEEE Access, vol. 7, pp. 802-822, 2019.（SCI，影响因子3.557） &lt;第一作者&gt;, “Decentralized Clustering and Beamforming Based on Interference Pricing in User-Centric Networks,” in IEEE PIMRC, Istanbul, Turkey, 2019, pp. 1-6.（EI，B类会议） &lt;第一作者&gt;, “Propagation-model-free Coverage Evaluation via Machine Learning for Future 5G Networks,” in IEEE PIMRC, Italy, 2018, pp. 1-5.（EI，B类会议） 获奖经历 2018-2019 国家奖学金 2017-2019 一等学业奖学金 2015-2016 国家励志奖学金、校“三好学生”、优秀共青团员 2014 北京邮电大学“明日之星”英语风采大赛 配音组二等奖 技能 程序开发：C++/Python/Matlab 排版编辑：LaTex/Markdown/MS Office 操作系统：Linux/Windows 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。","link":"/about/index.html"},{"title":"LeetCode--Two Sum","text":"Description of Problem: Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice.Example:1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].&gt; Approach 1: Brute Force1234for i in range(0,len(nums)-1): for j in range(i+1,len(nums)): if nums[i]+nums[j]==target: return [i,j] running time: 5640ms Approach 2: Python List.index1234for i in range(len(nums)): if (target-nums[i]) in nums: if (nums.index(target - nums[i])) != i: return [i, nums.index(target - nums[i])] running time: 1072ms Approach 3: Python Dict123456dict = {}for i in range(len(nums)): if (target-nums[i]) in dict: return [dict[(target-nums[i])], i] else: dict[nums[i]]=i running time: 40ms Approach 4: Enumerate+Hash_Table12345hash_table={}for i, value in enumerate (nums): if target-value in hash_table: return hash_table[target-value], i hash_table[value]=i running time: 40ms","link":"/drafts/LeetCode--Two Sum.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Knuth–Morris–Pratt algorithm (C++)","text":"KMP算法(C++) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;vector&gt;using namespace::std;void getNext(string p, vector&lt;int&gt; &amp;next) { int i = 0, j = -1; // i为p的下标 next[0] = -1; int length = p.size(); while (i &lt; length-1) { if (j == -1 || p[i] == p[j]) { i++; j++; next[i] = j; } else { j = next[j]; } }}void getNextVal(string p, vector&lt;int&gt; &amp;next) { int i = 0, j = -1; // i为p的下标 next[0] = -1; int length = p.size(); while (i &lt; length-1) { if (j == -1 || p[i] == p[j]) { i++; j++; if (p[i] != p[j]) { next[i] = j; } else { next[i] = next[j]; // 相同继续往前找真前缀 } } else { j = next[j]; } }}int KMP(string s, string p) { vector&lt;int&gt; v(p.size(), -1); getNext(p, v); int i = 0, j = 0; // s, p的下标 int s_len = s.size(), p_len = p.size(); while (i&lt;s_len &amp;&amp; j&lt;p_len) { if (j==-1 || s[i]==p[j]) { i++; j++; } else { j = v[j]; // 当前字符匹配失败，跳转 } } if (j == p_len) return i-j; return -1;}int main() { cout &lt;&lt; KMP(&quot;bbc abcdab abcdabcdabde&quot;, &quot;abcdabd&quot;) &lt;&lt; endl; return 0;}","link":"/2020/03/19/ck7yp1q4c0007xsunf0sa8e6r/"},{"title":"中国第二届高性能云计算大赛（MAXP)——京东云数据算法赛","text":"中国第二届高性能云计算大赛（MAXP)——京东云数据算法赛1 2 3","link":"/2020/03/19/ck7yp1q4i000bxsunf04kluz7/"},{"title":"剑指offer题解(C++)","text":"剑指offer各题目的C++解法 剑指offer 1 二维数组查找 剑指offer 2 替换空格 剑指offer 3 从尾到头打印链表 剑指offer 4 重建二叉树 剑指offer 5 用两个栈实现队列 剑指offer 6 旋转数组的最小值 剑指offer 7 斐波那契数列 剑指offer 8 跳台阶 剑指offer 9 变态跳台阶 剑指offer 10 矩形覆盖 剑指offer 11 二进制中1的个数** 剑指offer 12 求base的exponent次方 剑指offer 13 调整数组奇偶顺序 剑指offer 14 链表倒数第k个结点 剑指offer 15 反转链表 剑指offer 16 合并两个排序的链表 剑指offer 17 树的子结构 剑指offer 18 二叉树的镜像 剑指offer 19 顺时针打印矩阵 剑指offer 20 包含Min函数的栈 剑指offer 21 栈的压入、弹出序列 剑指offer 22 从上往下打印二叉树 剑指offer 23 二叉搜索树的后序遍历序列 剑指offer 24 二叉树中和为某一值的所有路径 剑指offer 25 复杂链表的复制 剑指offer 26 二叉搜索树转双端链表** 剑指offer 27 字符串的排列 剑指offer 28 数组中出现超过一半的数 剑指offer 29 最小的k个数** 剑指offer 30 连续子数组最大和 剑指offer 31 整数中1的个数 剑指offer 32 把数组排成最小的数** 剑指offer 33 丑数 剑指offer 34 第一次出现的字符 剑指offer 35 数组中的逆序对** 剑指offer 36 两个链表的第一个公共结点 剑指offer 37 数组在排序数组出现的次数 剑指offer 38 二叉树深度 剑指offer 39 判断平衡二叉树 剑指offer 40 数组中只出现一次的数字 剑指offer 41 和为S的连续正数序列 剑指offer 42 和为S的两个数 剑指offer 43 左旋转字符串 剑指offer 44 翻转单词顺序列 剑指offer 45 扑克牌顺子 剑指offer 46 孩子们的游戏（圆圈里最后剩下的数） 剑指offer 47 求1+2+…+n 剑指offer 48 不用加减乘除做加法 剑指offer 49 把字符串转换为整数 剑指offer 50 数组中重复的数字 剑指offer 51 构建乘积数组 剑指offer 52 正则表达式匹配 剑指offer 53 表示数值的字符串 剑指offer 54 字符流中第一个不重复的字符 剑指offer 55 链表中环的入口节点 剑指offer 56 删除链表中重复的节点 剑指offer 57 二叉树的下一个节点 剑指offer 58 对称的二叉树 剑指offer 59 之字形打印二叉树 剑指offer 60 把二叉树打印成多行（层序遍历） 剑指offer 61 序列化二叉树 剑指offer 62 二叉搜索树的第k个结点 剑指offer 63 数据流中的中位数 剑指offer 64 滑动窗口的最大值 剑指offer 65 矩阵中的路径 剑指offer 66 机器人的动作范围 剑指offer 67 剪绳子 剑指offer 1 二维数组查找在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。12345678910111213141516171819202122232425262728293031// 左下往右上查找，快速定位地图经纬度 O(n+m)bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) { int rows = array.size(), cols = array[0].size(); int row=rows-1,col=0; while(row&gt;=0 &amp;&amp; col&lt;cols){ if(array[row][col]==target) return true; else if(array[row][col]&gt;target) row--; else col++; } return false;}// 二分法 O(nlogm) O(n+m)bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) { if(array.size()==0) return false; int nrows = array.size(), ncols= array[0].size(); for(int i=0;i&lt;nrows;i++){ int low=0; int high=ncols-1; while(low&lt;=high){ int mid=(low+high)/2; if(target&gt;array[i][mid]) low=mid+1; else if(target&lt;array[i][mid]) high=mid-1; else return true; } } return false; } 剑指offer 2 替换空格请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。12345678910111213141516171819202122// O(n)void replaceSpace(char *str,int length) { int count=0; for(int i=0;i&lt;length;i++){ if(str[i]==&apos; &apos;) count++; } for(int i=length-1;i&gt;=0;i--){ if(str[i]!=&apos; &apos;){ str[i+2*count]=str[i]; //非空格在新数组的位置 //0 1 2 3 4 5 6 7 8 //0 # 3 # 4 //0 % 2 0 3 % 2 0 4 } else{ count--; str[i+2*count]=&apos;%&apos;; str[i+2*count+1]=&apos;2&apos;; str[i+2*count+2]=&apos;0&apos;; } }} 剑指offer 3 从尾到头打印链表输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。1234567891011121314151617181920212223242526272829303132333435363738394041424344//递归vector&lt;int&gt; printListFromTailToHead(ListNode* head) { vector&lt;int&gt; res; if(head!=NULL){ if(head-&gt;next!=NULL){ res = printListFromTailToHead(head-&gt;next); } res.push_back(head-&gt;val); } return res;}//栈vector&lt;int&gt; printListFromTailToHead(ListNode* head) { vector&lt;int&gt; res; stack&lt;int&gt; sta; while(head!=NULL){ sta.push(head-&gt;val); head=head-&gt;next; } while(!sta.empty()){ res.push_back(sta.top()); sta.pop(); } return res;}// **链表原地反转**vector&lt;int&gt; printListFromTailToHead(struct ListNode* head) { vector&lt;int&gt; vec; ListNode *buf=head; ListNode *pre=buf; if(head==NULL) return vec; while(head-&gt;next!=NULL){ buf=head-&gt;next; head-&gt;next=buf-&gt;next; buf-&gt;next=pre; pre=buf; } while(buf){ vec.push_back(buf-&gt;val); buf=buf-&gt;next; } return vec;} 剑指offer 4 重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。1234567891011121314151617TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) { TreeNode* root = helper(pre, 0, pre.size()-1, vin, 0, vin.size()-1); return root;}TreeNode* helper(vector&lt;int&gt; pre, int startpre, int endpre, vector&lt;int&gt; vin, int startvin, int endvin){ if(startpre&gt;endpre||startvin&gt;endvin) return NULL; TreeNode* root=new TreeNode(pre[startpre]); for(int i=startvin;i&lt;=endvin;i++){ if(vin[i]==pre[startpre]){ root-&gt;left = helper(pre, startpre+1, startpre+i-startvin, vin, startvin, i-1); root-&gt;right = helper(pre, startpre+i-startvin+1, endpre, vin, i+1, endvin); break; } } return root;} 剑指offer 5 用两个栈实现队列用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。1234567891011121314151617181920212223242526272829303132333435stack&lt;int&gt; stack1;stack&lt;int&gt; stack2;void push(int node) { stack1.push(node);}//栈1不空，全部压入栈2，栈2的top则可以输出；//然后把栈2再压回栈1int pop() { while(!stack1.empty()){ int a = stack1.top(); stack1.pop(); stack2.push(a); } int res = stack2.top(); stack2.pop(); while(!stack2.empty()){ stack1.push(stack2.top()); stack2.pop(); } return res;}//如果栈2不空，栈2的top即为输出，否则把栈1全部压入栈2int pop() { if(stack2.empty()){ while(!stack1.empty()){ int a = stack1.top(); stack1.pop(); stack2.push(a); } } int res = stack2.top(); stack2.pop(); return res;} 剑指offer 6 旋转数组的最小值把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。1234567891011121314151617181920212223//O(N)int minNumberInRotateArray(int[] array) { if (array.length == 0) return 0; for (int i = 0; i &lt; array.length - 1; i++) { if (array[i] &gt; array[i + 1]) return array[i + 1]; } return array[0];}// O(logn) 二分法int minNumberInRotateArray(vector&lt;int&gt; rotateArray) { if(rotateArray.size()==0) return 0; int low=0, high=rotateArray.size()-1; while(low&lt;high){ int mid=(low+high)/2; if(rotateArray[mid]&gt;rotateArray[high]) low=mid+1; else if(rotateArray[mid]==rotateArray[high]) high--; else high=mid; } return rotateArray[high];} 剑指offer 7 斐波那契数列12345678910111213141516171819202122232425262728293031323334//斐波那契数列0 1 2 3 4 ...0 1 1 2 3 ...//递归int Fibonacci(int n) { if(n==0) return 0; if(n==1) return 1; return Fibonacci(n-1)+Fibonacci(n-2);}//循环 时间复杂度O(N) 空间复杂度O(1)int Fibonacci(int n) { if(n==0) return 0; if(n==1) return 1; int pre=0, now=1; while(n&gt;1){ int tmp = pre+now; pre = now; now = tmp; n--; } return now;}//动态规划 时间复杂度O(N) 空间复杂度O(N)int Fibonacci(int n) { if(n==0) return 0; if(n==1) return 1; vector&lt;int&gt; dp(n+1,0); dp[0]=0; dp[1]=1; for(int i=2;i&lt;=n;++i){ dp[i]=dp[i-1]+dp[i-2]; } return dp[n];} 剑指offer 8 跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。1234567891011//斐波那契数列 DP O(N)int jumpFloor(int number) { if(number&lt;2) return number; int pre=1, now=2; for(int i=3;i&lt;=number;i++){ int tmp = pre+now; pre = now; now=tmp; } return now;} 剑指offer 9 变态跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。12345678910int jumpFloorII(int number) { if(number==0) return 0; int res=1; while(number--&gt;1){ res*=2; } return res;}//移位 左移一位*2，左移n-1位即 2^(n-1)int res = 1&lt;&lt;(number-1) 剑指offer 10 矩形覆盖我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，有多少种方法？12//还是斐波那契数列 f(n) = f(n-1) + f(n-2)， (n &gt; 2)。 更一般的结论，如果用1*m的方块覆盖m*n区域，递推关系式为f(n) = f(n-1) + f(n-m)，(n &gt; m)。123456789101112131415161718192021222324252627282930313233// 循环int rectCover(int number) { if(number&lt;=2) return number; int pre=1, now=2; for(int i=3;i&lt;=number;++i){ int tmp=pre+now; pre=now; now=tmp; } return now;}// 递归public class Solution { public int RectCover(int target) { if (target &lt; 1) { return 0; } else if (target == 1 || target == 2) { return target; } else { return RectCover(target-1) + RectCover(target-2); } }}// dpint rectCover(int number) { if ( number &lt; 1 ) return 0; int g = 1, f = 2; while ( --number ) { f = f + g; g = f - g; } return g;} 剑指offer 11 二进制中1的个数**输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。123456789// 如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。int NumberOf1(int n) { int count = 0; while (n != 0) { ++count; n = (n - 1) &amp; n; } return count; } 剑指offer 12 求base的exponent次方给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。1234567891011// 简单快速幂double Power(double base, int exponent) { long long p = abs((long long)exponent); double r = 1.0; while(p){ if(p &amp; 1) r *= base; base *= base; p &gt;&gt;= 1; } return exponent &lt; 0 ? 1/ r : r;} 第一种方法：使用递归，时间复杂度O(logn)当n为偶数，a^n =（a^n/2）*（a^n/2） 当n为奇数，a^n = a ^ [( n - 1) / 2] a ^ [(n-1)/2] a 举例： 2^11 = 2^1 2^2 2^8 2^1011 = 2^0001 2^0010 2^1000 第二种方法：累乘，时间复杂度为O(n) 剑指offer 13 调整数组奇偶顺序输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。1234567891011121314151617181920212223242526272829303132333435// O(2n) O(n) void reOrderArray(vector&lt;int&gt; &amp;array) { if(array.size()==0) return; vector&lt;int&gt; res(array.size(),0); int s=0,e=array.size()-1; for(int i=0;i&lt;array.size();++i){ if(array[i]%2==1){ res[s++]=array[i]; } } for(int i=array.size()-1;i&gt;=0;--i){ if(array[i]%2==0){ res[e--]=array[i]; } } array=res;}// O(n*n) O(1) 插排想法void reOrderArray1(vector&lt;int&gt; &amp;array){ if(array.size()&lt;=1) return; for(int i=0;i&lt;array.size();i++){ if(array[i]%2==1){ int tmp=array[i]; int j=i-1; while(j&gt;=0 &amp;&amp; array[j]%2==0){ array[j+1]=array[j]; j--; } array[j+1] =tmp; } }}// 开辟2个数组分别存奇数和偶数 O(n) O(2n) 剑指offer 14 链表倒数第k个结点输入一个链表，输出该链表中倒数第k个结点。123456789101112131415161718192021222324252627282930313233343536373839404142// 遍历再数 O(2n-k)ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) { if(k&lt;=0) return NULL; int cnt=0, start=0; ListNode* root=pListHead; while(pListHead!=NULL){ pListHead=pListHead-&gt;next; cnt++; } if(k&gt;cnt) return NULL; while(start!=cnt-k){ root=root-&gt;next; start++; } return root;}// 遍历再数 O(n)ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) { if(k&lt;=0 || pListHead==NULL) return NULL; ListNode *fast=pListHead; ListNode *slow=pListHead; while(k--&gt;0){ if(fast==nullptr) return nullptr; fast=fast-&gt;next; } while(fast!=NULL){ fast=fast-&gt;next; slow=slow-&gt;next; } return slow;}// 递归ListNode* FindKthToTail2(ListNode* pListHead, unsigned int k) { if(pListHead==NULL) return NULL; ListNode* node=FindKthToTail(pListHead-&gt;next,k); if(node!=NULL) return node; cnt++; if(cnt==k) return pListHead; else return NULL;} 剑指offer 15 反转链表输入一个链表，反转链表后，输出新链表的表头。12345678910111213141516171819202122232425262728public ListNode ReverseList(ListNode head) { if(head==null) return null; //head为当前节点，如果当前节点为空的话，那就什么也不做，直接返回null； ListNode pre = null; ListNode next = null; //当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点 //需要pre和next的目的是让当前节点从pre-&gt;head-&gt;next1-&gt;next2变成pre&lt;-head next1-&gt;next2 //即pre让节点可以反转所指方向，但反转之后如果不用next节点保存next1节点的话，此单链表就此断开了 //所以需要用到pre和next两个节点 //1-&gt;2-&gt;3-&gt;4-&gt;5 //1&lt;-2&lt;-3 4-&gt;5 while(head!=null){ //做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre //如此就可以做到反转链表的效果 //先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂 next = head.next; //保存完next，就可以让head从指向next变成指向pre了，代码如下 head.next = pre; //head指向pre后，就继续依次反转下一个节点 //让pre，head，next依次向后移动一个节点，继续下一次的指针反转 pre = head; head = next; } //如果head为null的时候，pre就为最后一个节点了，但是链表已经反转完毕，pre就是反转后链表的第一个节点 //直接输出pre就是我们想要得到的反转后的链表 return pre;} 剑指offer 16 合并两个排序的链表输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。12345678910111213141516171819202122232425262728293031323334353637383940//递归ListNode* Merge(ListNode* pHead1, ListNode* pHead2){ if(pHead1==NULL) return pHead2; if(pHead2==nullptr) return pHead1; if(pHead1-&gt;val&gt;pHead2-&gt;val) { pHead2-&gt;next=Merge(pHead1, pHead2-&gt;next); return pHead2; } if(pHead1-&gt;val&lt;pHead2-&gt;val) { pHead1-&gt;next=Merge(pHead1-&gt;next, pHead2); return pHead1; }}// 循环if(list1 == null) return list2;if(list2 == null) return list1;ListNode mergeHead = null;ListNode current = null;while(list1!=null &amp;&amp; list2!=null){ if(list1.val &lt;= list2.val){ if(mergeHead == null){ mergeHead = current = list1; }else{ current.next = list1; current = current.next; } list1 = list1.next; }else{ if(mergeHead == null){ mergeHead = current = list2; }else{ current.next = list2; current = current.next; } list2 = list2.next; }}if(list1 == null) current.next = list2;else current.next = list1;return mergeHead; 剑指offer 17 树的子结构输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）1234567891011121314151617bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2){ bool result=false; if(pRoot1!=NULL &amp;&amp; pRoot2!=NULL){ if(pRoot1-&gt;val==pRoot2-&gt;val) result=Tree1HaveTree2(pRoot1, pRoot2); if(!result) { result=Tree1HaveTree2(pRoot1-&gt;left, pRoot2) || Tree1HaveTree2(pRoot1-&gt;right, pRoot2); } } return result;}bool Tree1HaveTree2(TreeNode* pRoot1, TreeNode* pRoot2){ if(pRoot2==NULL) return true; if(pRoot1==NULL) return false; if(pRoot1-&gt;val!=pRoot2-&gt;val) return false; return Tree1HaveTree2(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; Tree1HaveTree2(pRoot1-&gt;right,pRoot2-&gt;right);} 剑指offer 18 二叉树的镜像12345678910void Mirror(TreeNode *pRoot) { if (pRoot==NULL) return; else { TreeNode *tmp=pRoot-&gt;left; pRoot-&gt;left = pRoot-&gt;right; pRoot-&gt;right = tmp; Mirror(pRoot-&gt;left); Mirror(pRoot-&gt;right); }} 剑指offer 19 顺时针打印矩阵输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.1234567891011121314151617181920212223242526vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) { int row = matrix.size(); int col = matrix[0].size(); vector&lt;int&gt; res; // 输入的二维数组非法，返回空的数组 if (row == 0 || col == 0) return res; // 定义四个关键变量，表示左上和右下的打印范围 int left = 0, top = 0, right = col - 1, bottom = row - 1; while (left &lt;= right &amp;&amp; top &lt;= bottom) { // left to right for (int i = left; i &lt;= right; ++i) res.push_back(matrix[top][i]); // top to bottom for (int i = top + 1; i &lt;= bottom; ++i) res.push_back(matrix[i][right]); // right to left if (top != bottom) for (int i = right - 1; i &gt;= left; --i) res.push_back(matrix[bottom][i]); // bottom to top if (left != right) for (int i = bottom - 1; i &gt; top; --i) res.push_back(matrix[i][left]); left++,top++,right--,bottom--; } return res;} 剑指offer 20 包含Min函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。123456789101112131415161718stack&lt;int&gt; stack1, stack2;void push(int value) { stack1.push(value); if(stack2.empty()) stack2.push(value); else{ if(value&lt;stack2.top()) stack2.push(value); }}void pop() { if(stack1.top()==stack2.top()) stack2.pop(); stack1.pop();}int top() { return stack1.top();}int min() { return stack2.top();} 剑指offer 21 栈的压入、弹出序列//输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）12345678910111213bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) { if(pushV.empty()||popV.empty()) return false; stack&lt;int&gt; Stack; int popIndex=0; for(int i=0;i&lt;pushV.size();++i){ Stack.push(pushV[i]); while(!Stack.empty() &amp;&amp; Stack.top()==popV[popIndex]){ Stack.pop(); popIndex++; } } return Stack.empty(); } 剑指offer 22 从上往下打印二叉树12345678910111213141516171819202122232425262728293031323334//双端队列vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) { vector&lt;int&gt; res; if(root==NULL) return NULL; deque&lt;TreeNode*&gt; d; d.push_back(root); while(!d.empty()){ root=d.front(); if(root!=NULL){ res.push_back(root-&gt;val); d.push_back(root-&gt;left); d.push_back(root-&gt;right); } d.pop_front(); } return res;}//队列vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) { vector&lt;int&gt; res; if(root==NULL) return res; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()){ res.push_back(q.front()-&gt;val); if(q.front()-&gt;left!=NULL) q.push(q.front()-&gt;left); if(q.front()-&gt;right!=NULL) q.push(q.front()-&gt;right); q.pop(); } return res;} 剑指offer 23 二叉搜索树的后序遍历序列//输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。//如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。12345678910111213141516171819202122232425bool VerifySquenceOfBST(vector&lt;int&gt; sequence) { if (sequence.empty()) { return false; } return helper(sequence, 0, sequence.size() - 1);}bool helper(vector&lt;int&gt; &amp;sequence, int first, int last) { // first和last表示树序列的开始和结束的位置 if(first &gt;= last){ return true; } int curIdx = first; int rootVal = sequence[last]; //后序遍历，根节点一定在最后，找到根节点后，就可以将树分为左右两棵子树，其中左子树中的元素都小于根节点，右子树中的元素都大于根节点 while(curIdx &lt; last &amp;&amp; sequence[curIdx] &lt; rootVal){ ++curIdx; } int midIdx = curIdx; // 到curIdx的值大于根节点时，我们认为开始进入到右子树部分，用一个midIdx记录下当前的右子树开始的位置 while (curIdx &lt; last){ if(sequence[curIdx] &lt; rootVal){ return false; } ++curIdx; } return helper(sequence, first, midIdx - 1) &amp;&amp; helper(sequence, midIdx, last - 1); // 再分别对左子树和右子树做同样的操作} 剑指offer 24 二叉树中和为某一值的所有路径//输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。//路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。//(注意: 在返回值的list中，数组长度大的数组靠前)1234567891011121314151617181920212223vector&lt;vector&lt;int&gt;&gt; res;vector&lt;int&gt; path;vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) { if(root==NULL || expectNumber&lt;=0) return res; findHelper(root, expectNumber); return res;}void findHelper(TreeNode* root, int sum){ if(root==NULL) return; path.push_back(root-&gt;val); if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL &amp;&amp; root-&gt;val==sum){ res.push_back(path); } else{ if(root-&gt;left!=NULL){ findHelper(root-&gt;left, sum-root-&gt;val); } if(root-&gt;right!=NULL){ findHelper(root-&gt;right, sum-root-&gt;val); } } path.pop_back();} 剑指offer 25 复杂链表的复制//输入一个复杂链表（每个节点中有节点值，以及两个指针，//一个指向下一个节点，另一个特殊指针指向任意一个节点），//返回结果为复制后复杂链表的head。//（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）1234567891011121314151617181920212223242526272829303132333435363738struct RandomListNode { int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) { }};class Solution {public: RandomListNode* Clone(RandomListNode* pHead){ if(pHead==NULL) return NULL; RandomListNode* currentNode=pHead; //复制每个结点，将其插入结点后面 while(currentNode!=NULL){ RandomListNode* cloneNode = new RandomListNode(currentNode-&gt;label); RandomListNode* nextNode = currentNode-&gt;next; currentNode-&gt;next=cloneNode; cloneNode-&gt;next=nextNode; currentNode=nextNode; } currentNode=pHead; //复制老结点的随机指针给新结点 while(currentNode!=NULL){ currentNode-&gt;next-&gt;random = currentNode-&gt;random==NULL?NULL:currentNode-&gt;random-&gt;next; currentNode=currentNode-&gt;next-&gt;next; } //拆分链表 currentNode=pHead; RandomListNode* pCloneHead=pHead-&gt;next; while(currentNode!=NULL){ RandomListNode* cloneNode=currentNode-&gt;next; currentNode-&gt;next=cloneNode-&gt;next; cloneNode-&gt;next=cloneNode-&gt;next==NULL?NULL:cloneNode-&gt;next-&gt;next; currentNode=currentNode-&gt;next; } return pCloneHead; }}; 剑指offer 26 二叉搜索树转双端链表**//题目描述//输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。//要求不能创建任何新的结点，只能调整树中结点指针的指向。123456789101112131415161718192021222324252627/*struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { }};*/TreeNode* Convert(TreeNode* pRootOfTree){if(pRootOfTree==NULL) return NULL; TreeNode* pre=NULL; convertHelper(pRootOfTree, pre); TreeNode* res=pRootOfTree; while(res-&gt;left){ res=res-&gt;left; } return res;}void convertHelper(TreeNode* cur, TreeNode*&amp; pre){ if(cur==NULL) return; convertHelper(cur-&gt;left, pre); cur-&gt;left=pre; if(pre) pre-&gt;right=cur; pre=cur; convertHelper(cur-&gt;right, pre);} 剑指offer 27 字符串的排列题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。输入描述:输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136/** * 1、递归算法 * * 解析：http://www.cnblogs.com/cxjchen/p/3932949.html (感谢该文作者！) * * 对于无重复值的情况 * * 固定第一个字符，递归取得首位后面的各种字符串组合； * 再把第一个字符与后面每一个字符交换，并同样递归获得首位后面的字符串组合； *递归的出口，就是只剩一个字符的时候，递归的循环过程，就是从每个子串的第二个字符开始依次与第一个字符交换，然后继续处理子串。 * * 假如有重复值呢？ * *由于全排列就是从第一个数字起，每个数分别与它后面的数字交换，我们先尝试加个这样的判断——如果一个数与后面的数字相同那么这两个数就不交换了。 * 例如abb，第一个数与后面两个数交换得bab，bba。然后abb中第二个数和第三个数相同，就不用交换了。 * 但是对bab，第二个数和第三个数不 同，则需要交换，得到bba。 * 由于这里的bba和开始第一个数与第三个数交换的结果相同了，因此这个方法不行。 * * 换种思维，对abb，第一个数a与第二个数b交换得到bab，然后考虑第一个数与第三个数交换，此时由于第三个数等于第二个数， * 所以第一个数就不再用与第三个数交换了。再考虑bab，它的第二个数与第三个数交换可以解决bba。此时全排列生成完毕！ * * * @param str * @return */vector&lt;string&gt; Permutation(string str) { vector&lt;string&gt; res; if(str.empty()) return res; permutationHelper(str, res, 0, str.size()-1); sort(res.begin(),res.end()); return res; }void permutationHelper(string str, vector&lt;string&gt; &amp;res, int start, int end){ if(start==end) { res.push_back(str); } for(int i=start;i&lt;=end;i++){ //从str的头到尾都换一次 if(is_swap(str, start, i)){ swap(str, start, i); permutationHelper(str, res, start+1, end); swap(str, start, i); } }}bool is_swap(string str, int l, int r){ bool flag=true; for(int i=l;i&lt;r;i++){ //l==r则跳过循环，比如aa可以加入res if(str[i]==str[r]){ flag=false; break; } } return flag;}void swap(string &amp;str, int l, int r){ char tmp=str[l]; str[l]=str[r]; str[r]=tmp;}void swap(char* str,int a,int b){ char tmp = str[a]; str[a] = str[b]; str[b] = tmp;}/** * 2、字典序排列算法 * * 可参考解析： http://www.cnblogs.com/pmars/archive/2013/12/04/3458289.html （感谢作者） * * 一个全排列可看做一个字符串，字符串可有前缀、后缀。 * 生成给定全排列的下一个排列.所谓一个的下一个就是这一个与下一个之间没有其他的。 * 这就要求这一个与下一个有尽可能长的共同前缀，也即变化限制在尽可能短的后缀上。 * * [例]839647521是1--9的排列。1—9的排列最前面的是123456789，最后面的987654321， * 从右向左扫描若都是增的，就到了987654321，也就没有下一个了。否则找出第一次出现下降的位置。 * * 【例】 如何得到346987521的下一个 * 1，从尾部往前找第一个P(i-1) &lt; P(i)的位置 * 3 4 6 &lt;- 9 &lt;- 8 &lt;- 7 &lt;- 5 &lt;- 2 &lt;- 1 * 最终找到6是第一个变小的数字，记录下6的位置i-1 * * 2，从i位置往后找到最后一个大于6的数 * 3 4 6 -&gt; 9 -&gt; 8 -&gt; 7 5 2 1 * 最终找到7的位置，记录位置为m * * 3，交换位置i-1和m的值 * 3 4 7 9 8 6 5 2 1 * 4，倒序i位置后的所有数据 * 3 4 7 1 2 5 6 8 9 * 则347125689为346987521的下一个排列 * * @param str * @return */ public ArrayList&lt;String&gt; Permutation2(String str){ ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); if(str==null || str.length()==0){ return list; } char[] chars = str.toCharArray(); Arrays.sort(chars); list.add(String.valueOf(chars)); int len = chars.length; while(true){ int lIndex = len-1; int rIndex; while(lIndex&gt;=1 &amp;&amp; chars[lIndex-1]&gt;=chars[lIndex]){ lIndex--; } if(lIndex == 0) break; rIndex = lIndex; while(rIndex&lt;len &amp;&amp; chars[rIndex]&gt;chars[lIndex-1]){ rIndex++; } swap(chars,lIndex-1,rIndex-1); reverse(chars,lIndex); list.add(String.valueOf(chars)); } return list;} private void reverse(char[] chars,int k){ if(chars==null || chars.length&lt;=k) return; int len = chars.length; for(int i=0;i&lt;(len-k)/2;i++){ int m = k+i; int n = len-1-i; if(m&lt;=n){ swap(chars,m,n); } }} 剑指offer 28 数组中出现超过一半的数//数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// O(n) 空间O(n) 不追求元素排序，不用map或者hashmapint MoreThanHalfNum_Solution2(vector&lt;int&gt; numbers) { int n = numbers.size(); //map 记录出现次数 unordered_map&lt;int, int&gt; m; int count; for (int i = 0; i &lt; n; i++) { count = ++m[numbers[i]]; if (count &gt; n/2) return numbers[i]; } return 0;}// O(n) O(1)int MoreThanHalfNum_Solution1(vector&lt;int&gt; numbers) { if(numbers.empty()) return 0; int n = numbers.size(), num=numbers[0],count=1; for (int i = 1; i &lt; n; i++) { if(numbers[i]==num) count++; else count--; if(count==0){ num=numbers[i]; count=1; } } count=0; for(int i=0;i&lt;n;i++){ if(numbers[i]==num) count++; } return (count&gt;n/2)?num:0;}//快排思想 O(n)?O(logn)?int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) { if(numbers.empty()) return 0; int n = numbers.size(), mid=n/2,count=1; int start=0,end=n-1; int k=partition(numbers, 0, n-1); while(k!=mid){ if(k&gt;mid){ end=k-1; k=partition(numbers, start, end); } else{ start=k+1; k=partition(numbers, start, end); } } int num=numbers[mid]; count=0; for(int i=0;i&lt;n;i++){ if(numbers[i]==num) count++; } return (count&gt;n/2)?num:0;}int partition(vector&lt;int&gt; &amp;numbers, int s, int e){ int pivot=numbers[s]; int leftmark=s+1, rightmark=e; bool done=false; while(!done){ while(leftmark&lt;=rightmark &amp;&amp; pivot&gt;=numbers[leftmark]) leftmark++; while(leftmark&lt;=rightmark &amp;&amp; pivot&lt;=numbers[rightmark]) rightmark--; if(leftmark&gt;rightmark) done=true; else{ swap(numbers, leftmark, rightmark); } } swap(numbers, s, rightmark); return rightmark;}void swap(vector&lt;int&gt; &amp;v, int s, int e){ int tmp=v[s]; v[s]=v[e]; v[e]=tmp;}//拓展：输出数组中两个数量超过1/3的数 //投票法，讲道理partition应该也行1/3,2/3的位置vector&lt;int&gt; MoreThanOneThirdNum_Solution(vector&lt;int&gt; numbers) { vector&lt;int&gt; res; if(numbers.empty()) return res; int num1=0, num2=0, cnt1=0, cnt2=0, len = numbers.size(); for(int i=0;i&lt;len;i++){ if(numbers[i]==num1) cnt1++; else if (numbers[i]==num2) cnt2++; else if (cnt1==0) num1=numbers[i], cnt1=1; else if (cnt2==0) num2=numbers[i], cnt2=1; else cnt1--, cnt2--; } cnt1=0, cnt2=0; for(int i=0;i&lt;len;i++){ if(numbers[i]==num1) cnt1++; if(numbers[i]==num2) cnt2++; } if(cnt1&gt;len/3) res.push_back(num1); if(cnt2&gt;len/3) res.push_back(num2); return res;} 剑指offer 29 最小的k个数**//输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。partition O(n)-O(n^2）?牛客超时？1234567891011121314151617181920212223242526272829303132vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) { vector&lt;int&gt; res; if(input.empty() || k&gt;input.size()) return res; int len=input.size(), pos, s=0, e=len-1; pos=par(input, 0, len-1); while (pos!=k){ if (pos&gt;k) e=pos-1,pos=par(input, s, e); else s=pos+1,pos=par(input, s, e); } for(int i=0;i&lt;k;i++){ res.push_back(input[i]); } sort(res.begin(),res.end()); return res;}int par(vector&lt;int&gt; &amp;arr, int s, int e){ int pivot=arr[s]; int l=s+1, r=e; bool done=false; while(!done){ while(l&lt;=r &amp;&amp; arr[l]&lt;=pivot) l++; while(l&lt;=r &amp;&amp; arr[r]&gt;=pivot) r--; if(l&gt;r) done=true; else swap(arr, l, r); } swap(arr, s, r); return r;}//最大堆，待写 剑指offer 30 连续子数组最大和HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)1234567891011//DP O(n) O(1)int FindGreatestSumOfSubArray(vector&lt;int&gt; array) { if(array.empty()) return 0; int len=array.size(); int res=array[0], pre=array[0]; for(int i=1;i&lt;len;i++){ pre=max(array[i], pre+array[i]); if(res&lt;pre) res=pre; } return res;} 剑指offer 31 整数中1的个数求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数?为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。123456789int NumberOf1Between1AndN_Solution(int n){ if(n&lt;0) return 0; int count=0; for(int i=1;i&lt;=n;i*=10){ int k=i*10; count+=(n/k)*i+min(max(n%k-i+1, 0), i); } return count;} 剑指offer 32 把数组排成最小的数**//输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。123456789101112131415161718192021class Solution {public: static bool cmp(int a, int b){ string A=&quot;&quot;; string B=&quot;&quot;; A += to_string(a); A += to_string(b); B += to_string(b); B += to_string(a); return A&lt;B; } string PrintMinNumber(vector&lt;int&gt; numbers) { string res=&quot;&quot;; if(numbers.empty()) return res; sort(numbers.begin(), numbers.end(), cmp); for(int i=0;i&lt;numbers.size();i++){ res+=to_string(numbers[i]); } return res; }}; 剑指offer 33 丑数//把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。1234567891011121314151617181920class Solution {public: int GetUglyNumber_Solution(int index) { if(index&lt;1) return 0; vector&lt;int&gt; ugly(index, 1); int pointer2=0, pointer3=0, pointer5=0; for(int i=1;i&lt;index;i++){ ugly[i] = findmin(ugly[pointer2]*2, ugly[pointer3]*3, ugly[pointer5]*5); if(ugly[pointer2]*2==ugly[i]) pointer2++; if(ugly[pointer3]*3==ugly[i]) pointer3++; if(ugly[pointer5]*5==ugly[i]) pointer5++; } return ugly[index-1]; }int findmin(int a, int b, int c){ int tmp = a&gt;b?b:a; int tmp2 = tmp&gt;c?c:tmp; return tmp2; }}; 剑指offer 34 第一次出现的字符//在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.1234567891011121314151617int FirstNotRepeatingChar(string str) { int res=-1; if(str.empty()) return res; int len=str.size(); unordered_map&lt;char, int&gt; mp; for(int i=0;i&lt;len;i++){ mp[str[i]]++; // cout&lt;&lt;mp[str[i]]&lt;&lt;endl; } for(int i=0;i&lt;len;i++){ cout&lt;&lt;mp[str[i]]&lt;&lt;endl; if(mp[str[i]]==1){ res=i;break; } } return res;} 剑指offer 35 数组中的逆序对**//在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007。例子：输入 1,2,3,4,5,6,7,0 输出 7123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//暴力求解 O(N*N)int InversePairs2(vector&lt;int&gt; data) { int res=0; if(data.empty()) return res; int len=data.size(); for(int i=len-1;i&gt;=0;i--){ for(int j=i-1;j&gt;=0;j--){ if(data[j]&gt;data[i]) res++; } } return res;}//归并排序 O(nlogn)int InversePairs(vector&lt;int&gt; data) { int res=0; if(data.empty()) return res; int len=data.size(); vector&lt;int&gt; cp(len, 0); for(int i=0;i&lt;len;i++){ cp[i]=data[i]; } res = mergeCount(data, cp, 0, len-1); return res;}int mergeCount(vector&lt;int&gt; &amp;arr, vector&lt;int&gt; &amp;cp, int s, int e){ if(s==e) return 0; int mid=(s+e)&gt;&gt;1; int leftCount=mergeCount(arr, cp, s, mid)%1000000007; int rightCount=mergeCount(arr, cp, mid+1, e)%1000000007; int count=0,i=mid,j=e,locCopy=e; while(i&gt;=s &amp;&amp; j&gt;mid){ if(arr[i]&gt;arr[j]){ count += j-mid; cp[locCopy--] = arr[i--]; if(count&gt;=1000000007) count%=1000000007; } else{ cp[locCopy--] = arr[j--]; } } for(;i&gt;=s;i--){ cp[locCopy--]=arr[i]; } for(;j&gt;mid;j--){ cp[locCopy--]=arr[j]; } for(int ss=s;ss&lt;=e;ss++){ arr[ss]=cp[ss]; } return (leftCount+rightCount+count)%1000000007;} 剑指offer 36 两个链表的第一个公共结点输入两个链表，找出它们的第一个公共结点。1234567891011121314151617181920212223242526272829303132// 若有公共结点，让最长的链表先走len1-len2步，再一起走，必会相交ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) { if(pHead1==NULL || pHead2==NULL) return NULL; int len1 = findLinkedListLength(pHead1); int len2 = findLinkedListLength(pHead2); if(len1&gt;len2){ pHead1=walkK(pHead1, len1-len2); } else{ pHead2 = walkK(pHead2, len2-len1); } while(pHead1!=NULL &amp;&amp; pHead2!=NULL){ if(pHead1==pHead2) return pHead1; pHead1=pHead1-&gt;next; pHead2=pHead2-&gt;next; } return NULL;}int findLinkedListLength(ListNode* pHead){ int res=0; while(pHead!=NULL){ pHead = pHead-&gt;next; res++; } return res;}ListNode* walkK(ListNode* pHead, int k){ while(k--){ pHead=pHead-&gt;next; } return pHead;} 剑指offer 37 数组在排序数组出现的次数//统计一个数字在排序数组中出现的次数。1234567891011121314151617181920212223242526272829303132// O(n) O(1)int GetNumberOfK1(vector&lt;int&gt; data ,int k) { if(data.empty()) return 0; int res=0; for(int i=0;i&lt;data.size();i++){ if(data[i]==k) res++; } return res; }// O(logn) O(1)int GetNumberOfK(vector&lt;int&gt; data ,int k) { if(data.empty()) return 0; int start=0, end=data.size()-1, res=0; while(start&lt;=end){ int mid=(start+end)&gt;&gt;1; if(data[mid]&gt;k){ end=mid-1; } else if(data[mid]&lt;k) { start=mid+1; } else { int l=mid, r=mid; res++; while(data[--l]==k) res++; while(data[++r]==k) res++; cout&lt;&lt;res&lt;&lt;endl; break; } } return res;} 剑指offer 38 二叉树深度//输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。12345678910111213141516171819202122//递归int TreeDepth(TreeNode* pRoot) { if(pRoot==NULL) return 0; return max(TreeDepth(pRoot-&gt;left), TreeDepth(pRoot-&gt;right))+1;}//非递归int TreeDepthNotLoop(TreeNode* pRoot) { int res=0; if(pRoot==NULL) return res; queue&lt;TreeNode *&gt; q; q.push(pRoot); while(!q.empty()) { int size=q.size(); res++; for(int i=0;i&lt;size;i++){ TreeNode* top=q.front(); q.pop(); if(top-&gt;left) q.push(top-&gt;left); if(top-&gt;right) q.push(top-&gt;right); } } return res; } 剑指offer 39 判断平衡二叉树//输入一棵二叉树，判断该二叉树是否是平衡二叉树。如果二叉树的每个节点的左子树和右子树的深度不大于1，它就是平衡二叉树。1234567891011bool IsBalanced_Solution(TreeNode* pRoot){ return pos_travel(pRoot)!=-1; }int pos_travel(TreeNode* pRoot){ if(pRoot==NULL) return 0; int left=pos_travel(pRoot-&gt;left); if(left==-1) return -1; int right=pos_travel(pRoot-&gt;right); if(right==-1) return -1; return abs(left-right)&gt;1?-1:1+max(left, right);} 剑指offer 40 数组中只出现一次的数字//一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。12345678910111213141516171819202122232425//input vector&lt;int&gt; arr={1,4,4,5,5,7};void FindNumsAppearOnce(vector &lt;int&gt; data, int* num1, int *num2) { if(data.empty()) return; int len=data.size(); unordered_map &lt;int, int&gt; mp; for(int i=0;i&lt;len;i++){ mp[data[i]]++; } vector&lt;int&gt; res; for(int i=0;i&lt;len;i++){ if(mp[data[i]]==1){ res.push_back(data[i]); } } *num1 = res[0]; *num2 = res[1];}public static int find1From2(int[] a){ int len = a.length, res = 0; for(int i = 0; i &lt; len; i++){ res = res ^ a[i]; } return res;} 剑指offer 41 和为S的连续正数序列//输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) { vector&lt;vector&lt;int&gt; &gt; vOut; vector&lt;int&gt; vIn; if(sum==1) { vIn.push_back(1); vOut.push_back(vIn); return vOut; } int left=1, right=2; while(left&lt;right){ int k=(left+right)*(right-left+1)/2; if(sum==k) { vector&lt;int&gt; vTmp; for(int i=left;i&lt;=right;i++){ vTmp.push_back(i); } vOut.push_back(vTmp); right++; } else if(sum&gt;k) { right++; } else { left++; } } return vOut;}//vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) { vector&lt;vector&lt;int&gt;&gt; res; if(sum&lt;=2) return res; int up=sqrt(2*sum); for(int i=up;i&gt;=2;i--){ int n = sum/i; if(i%2==1 &amp;&amp; sum%i==0){ vector&lt;int&gt; tmp; for(int j=n-(i-1)/2;j&lt;=n+(i-1)/2;j++){ tmp.push_back(j); } res.push_back(tmp); } if(i%2==0 &amp;&amp; sum%i*2==i){ vector&lt;int&gt; tmp; for(int j=n-(i-2)/2;j&lt;=n+(i-2)/2+1;j++){ tmp.push_back(j); } res.push_back(tmp); } } return res;} 剑指offer 42 和为S的两个数//输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。123456789101112131415161718192021222324252627vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) { vector&lt;int&gt; res; if(array.empty()) return res; int low=0, high=array.size()-1, Min=INT32_MAX; while(low&lt;high){ cout&lt;&lt;low&lt;&lt;&quot; &quot;&lt;&lt;high&lt;&lt;endl; int add = array[low]+array[high], product= array[low]*array[high]; if(sum==add) { if(product&lt;Min){ Min = product; while(!res.empty()){ res.clear(); } res.push_back(array[low]); res.push_back(array[high]); } low++;high--; } else if (sum&lt;add){ high--; } else{ low++; } } return res;} 剑指offer 43 左旋转字符串//汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！123456789101112131415161718192021222324252627282930313233343536string LeftRotateStringCircle(string str, int n) { if (str.empty()) return &quot;&quot;; deque&lt;char&gt; q; for (int i=0;i&lt;str.size();i++){ q.push_back(str[i]); } while(n!=0) { char tmp = q.front(); q.pop_front(); q.push_back(tmp); n--; } string res=&quot;&quot;; for (int i=0;i&lt;q.size();i++){ res = res+q[i]; } return res;}string LeftRotateString(string str, int n) { if (str.empty()) return &quot;&quot;; n = n % str.size(); reverse(str.begin(), str.end()); reverse(str.begin(), str.begin()+str.size()-n); reverse(str.begin()+str.size()-n, str.end()); return str;}//自写reverse函数void reverse1(string&amp; str, int s, int e){ while (s &lt; e) { char temp = str[s]; str[s] = str[e]; str[e] = temp; s++; e--; }} 剑指offer 44 翻转单词顺序列// “student. a am I”-&gt;“I am a student.”12345678910111213141516171819202122232425262728293031323334353637string ReverseSentence1(string str) { string res = &quot;&quot;; if(str.empty()) return res; vector &lt;string&gt; s; int index=0; string tmp=&quot;&quot;; while(index &lt; str.size()){ if (str[index]==&apos; &apos;) { s.push_back(tmp); tmp=&quot;&quot;; } else{ tmp+=str[index]; } if(index==str.size()-1) s.push_back(tmp); index++; } for (int i=s.size()-1;i&gt;=0;i--) { res += s[i]; if(i!=0) res += &apos; &apos;; }return res;}string ReverseSentence(string str) { std::reverse(str.begin(),str.end()); int front=0; int back=0; int size = str.size(); while(front&lt;size){ while(front&lt;size&amp;&amp;str[front]==&apos; &apos;)++front; //跳过空格，找第一个非空字母位置 back = front; while(back&lt;size&amp;&amp;str[back]!=&apos; &apos;)++back; //找单词最后一个字符的位置 std::reverse(str.begin()+front, str.begin()+back); //反转 front = back; } return str;} 剑指offer 45 扑克牌顺子//一组数字，判断是否顺子。0为任意数，如果牌能组成顺子就输出true，否则就输出false。1234567891011121314151617181920212223242526272829303132333435// O(n)bool IsContinuous( vector&lt;int&gt; numbers ) { if(numbers.empty()) return false; vector&lt;int&gt; arr(14, 0); arr[0]=-5; int Min=14, Max=-1; for (int i=0;i&lt;numbers.size();i++){ arr[numbers[i]]++; if(numbers[i]==0) continue; if(arr[numbers[i]]&gt;1) return false; if (numbers[i]&lt;Min) { Min = numbers[i]; } if (numbers[i]&gt;Max) { Max = numbers[i]; } } if(Max-Min&gt;4) return false; return true;}// O(nlogn)bool IsContinuous( vector&lt;int&gt; numbers ) { sort(numbers.begin(), numbers.end()); int cnt0 = 0, cntNeed = 0; for(int i = 0; i &lt; 5; i++) { if(numbers[i] == 0) { ++cnt0; } else if(i + 1 &lt; 5 ) { if(numbers[i + 1] == numbers[i]) return false; cntNeed += numbers[i + 1] - numbers[i] - 1; } } if(cntNeed &gt; cnt0) return false; return true;} 剑指offer 46 孩子们的游戏（圆圈里最后剩下的数）//约瑟夫圆环。一个数m,编号为0开始报数，m-1的出列，下一个继续从0开始，直至最后一个。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int LastRemaining_Solution(int n, int m) { if(n==0 || m&lt;=0) return -1; if (n==1) return 0; vector&lt;int&gt; v; for (int i=0;i&lt;n;i++) { v.push_back(i); } int p = 0; while(v.size()&gt;1) { n = v.size(); p = (p+m) % n - 1; if (p == -1) p = n-1; v.erase(v.begin()+p); } return v[0]; }//公式dp int LastRemaining_Solution1(unsigned int n, unsigned int m) { if(n &lt;= 0 &amp;&amp; m &lt;= 0) return -1; //蛋疼的特殊条件 int t = 0; for(int i = 2; i &lt;= n; i++) t = (t + m) % i; return t; }//模拟循环链表int LastRemaining_Solution2(int n, int m)//n为人数{ if(n&lt;1||m&lt;1) return -1; list&lt;int&gt; numbers; for(int i=0;i&lt;n;i++) numbers.push_back(i); list&lt;int&gt;::iterator current=numbers.begin(); while(numbers.size()&gt;1) { for(int i=1;i&lt;m;i++)//走m-1步到达第m个数处 { ++current; if(current==numbers.end()) current=numbers.begin(); } list&lt;int&gt;::iterator next=++current; if(next==numbers.end()) next=numbers.begin(); --current; numbers.erase(current); current=next; } return *current;//对迭代器取值，等价于对指针取值} 剑指offer 47 求1+2+…+n//求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。1234567891011int Sum_Solution(int n) { if (n&lt;=0) return 0; if (n==1) return 1; return Sum_Solution(n-1)+n; }int Sum_Solution(int n) { int ans = n;//逻辑与有个短路特点，前面为假，后面不计算。 ans &amp;&amp; (ans += Sum_Solution(n - 1)); return ans;} 剑指offer 48 不用加减乘除做加法//求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。用三步走的方式计算二进制值相加：5-101，7-111,第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101 &amp; 111) \\&lt;\\&lt; 1。第三步重复上述两步， 各位相加 0 1 0 \\^ 1 0 1 0 = 1 0 0 0，进位值为100 = (010 \\&amp; 1010)\\&lt;\\&lt; 1。继续重复上述两步：1000\\^100 = 1100，进位值为0，跳出循环，1100为最终结果。12345678int Add(int num1, int num2) { while(num2!=0){ int tmp = num1^num2; num2 = (num1&amp;num2)&lt;&lt;1; num1=tmp; } return num1;} 剑指offer 49 把字符串转换为整数将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。12345678910111213141516171819int StrToInt(string str) { if(str.empty()) return 0; int res=0, symbol=1; if(str[0]==&apos;+&apos;) { str[0]=&apos;0&apos;; } else if(str[0]==&apos;-&apos;) { symbol=-1; str[0] = &apos;0&apos;; } for(int i=0;i&lt;str.size();i++) { if(str[i]&lt;&apos;0&apos; || str[i]&gt;&apos;9&apos;) { res = 0; break; } res = res*10 + str[i]-&apos;0&apos;; } return symbol*res;} 剑指offer 50 数组中重复的数字// 在一个长度为n的数组里的所有数字都在0到n-1的范围内.数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。1234567891011121314151617181920// Parameters:// numbers: an array of integers// length: the length of array numbers// duplication: (Output) the duplicated number in the array numberbool duplicate1(int numbers[], int length, int* duplication) { bool res=false; if(length==0) return res; unordered_map&lt;int, int&gt; mp; for(int i=0;i&lt;length;i++) { if (mp.count(numbers[i])==0) { mp[numbers[i]] ++; } else { *duplication = numbers[i]; res = true; break; } } return res;} //思路二：剑指offer中解法：因为数组中数字都在0~n - 1，所以若无重复数字排好序则数字i将出现在下标i的位置。//解法：从头到尾扫描这个数组，当扫描到下标为i的数字m时，先比较这个数字是否等于i，是则扫描下一个数字，否则//将该数字与下标为m的数字进行比较，若相等，则找到一个重复的数字，否则将两个数字交换，并继续对该位置//（下标i）重复上面比较过程。12345678910111213141516171819202122bool duplicate(int numbers[], int length, int* duplication) { bool res = false; if (length == 0) return res; int i = 0; while(i&lt;length) { if (numbers[i] == i) { i++; continue; } if (numbers[numbers[i]] == numbers[i]) { res = true; *duplication = numbers[i]; break; } else { int tmp = numbers[i]; numbers[i] = numbers[tmp]; numbers[tmp] = tmp; } } return res;} 剑指offer 51 构建乘积数组给定一个数组A[0, 1, …, n - 1], 请构建一个数组B[0, 1, …, n - 1],其中B中的元素B[i] = A[0] A[1] … A[i - 1] A[i + 1] … A[n - 1]。不能使用除法。12345678910111213141516171819202122232425262728293031323334// recurrent O(n\\*n)vector&lt;int&gt; multiplyN2(const vector&lt;int&gt;&amp; A) { vector&lt;int&gt; B; if (A.empty()) return B; for (int i = 0; i &lt; A.size(); i++) { B.push_back(ABhelper(A, A.size()-1, i)); } return B;}int ABhelper(vector&lt;int&gt; A, int n, int k) { if (n == k &amp;&amp; n == 0) return 1; if (n == k &amp;&amp; n &gt; 0) return ABhelper(A, n - 1, k); if (n == 0) return A[0]; return ABhelper(A, n - 1, k) * A[n];}// 上下三角求解合并//链接：https://www.nowcoder.com/questionTerminal/94a4d381a68b47b7a8bed86f2975db46?f=discussionvector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) { vector&lt;int&gt; B; if (A.empty()) return B; int len = A.size(); // cal up triangle B.push_back(1); for (int i = 1; i &lt; len; i++) { B.push_back(B[i - 1] * A[i - 1]); } // cal down triangle int down =1; for (int i = len - 2; i &gt;= 0; i--) { down *= A[i + 1]; B[i] *= down; } return B;} 剑指offer 52 正则表达式匹配//请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配12345678910111213141516171819202122232425262728293031323334bool match(char* str, char* pattern){ if (str == NULL || pattern == NULL) return false; int strIndex = 0, patternIndex = 0; return matchHelper(str, pattern);}bool matchHelper(char* str, char* pattern) { // str到尾，pattern到尾，匹配成功 // 注意下指针和string字符串判断是否为空的区别 if (*str == &apos;\\0&apos; &amp;&amp; *pattern == &apos;\\0&apos;) return true; // pattern为空，str不空，匹配必定失败 if (*pattern == &apos;\\0&apos; &amp;&amp; *str != &apos;\\0&apos;) return false; // 如果pattern下一个字符不为&apos;*&apos; if (*(pattern + 1) != &apos;*&apos;) { // 匹配成功情况： // 1. 当前str字符==当前pattern字符 // 2. pattern为&apos;.&apos;且当前str不为空 if (*pattern == *str || (*pattern == &apos;.&apos; &amp;&amp; *str != &apos;\\0&apos;)){ return matchHelper(str+1, pattern+1); } else return false; } // 如果pattern下一个字符为&apos;*&apos; else { // 继续匹配的情况： // 1. 当‘*’匹配0个字符时，str当前字符不变，pattern当前字符后移两位，跳过这个‘*’符号； // 2. 当‘*’匹配1个或多个时，str当前字符移向下一个，pattern当前字符不变。 if (*pattern == *str || (*pattern == &apos;.&apos; &amp;&amp; *str != &apos;\\0&apos;)) { return matchHelper(str+1,pattern) || matchHelper(str, pattern+2); } else return matchHelper(str, pattern+2); }} 剑指offer 53 表示数值的字符串// 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。1234567891011121314151617181920212223242526bool isNumeric(char* string){ if (string == nullptr) return false; // 标记符号、小数点、e是否出现过 bool sign = false, decimal = false, hasE = false; for (int i = 0; i &lt; strlen(string); i++) { if (string[i] == &apos;+&apos; || string[i] == &apos;-&apos;) { // 第二次出现+-符号，必须紧接在e之后 if (sign &amp;&amp; string[i-1] != &apos;e&apos; &amp;&amp; string[i-1] != &apos;E&apos;) return false; // 第一次出现+-符号，且不是在字符串开头，也必须紧接在e之后 if (!sign &amp;&amp; i&gt;0 &amp;&amp; string[i-1] != &apos;e&apos; &amp;&amp; string[i-1] != &apos;E&apos;) return false; } else if (string[i] == &apos;e&apos; || string[i] == &apos;E&apos;) { // e后面一定要接数字 || 不能同时存在两个e if (i == strlen(string) - 1 || hasE) return false; hasE = true; } else if (string[i] == &apos;.&apos;) { // e后面不能接小数点，小数点不能出现两次 if (hasE || decimal) return false; decimal = true; } else if (string[i] &lt; &apos;0&apos; || string[i] &gt; &apos;9&apos;) return false; } return true;} 剑指offer 54 字符流中第一个不重复的字符// 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。如果当前字符流没有存在出现一次的字符，返回#字符。123456789101112131415161718string s;char hash[256] = {0};//Insert one char from stringstreamvoid Insert(char ch){ s += ch; hash[ch]++;}//return the first appearence once char in current stringstreamchar FirstAppearingOnce(){ for (int i = 0; i &lt; s.size(); i++) { if (hash[s[i]] == 1) { return s[i]; } } return &apos;#&apos;;} 剑指offer 55 链表中环的入口节点// 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。12345678910111213141516171819202122232425ListNode* EntryNodeOfLoop(ListNode* pHead){ if (pHead == nullptr) return nullptr; ListNode* fast = pHead; ListNode* slow = pHead; ListNode* meetingNode = nullptr; while (fast-&gt;next &amp;&amp; slow) { fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast == slow) { meetingNode = fast; break; } } if (meetingNode) { ListNode* p1 = meetingNode; ListNode* p2 = pHead; while (p1 != p2) { p1 = p1-&gt;next; p2 = p2-&gt;next; } return p1; } return nullptr;} 剑指offer 56 删除链表中重复的节点// 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;512345678910111213141516171819202122232425ListNode* deleteDuplication(ListNode* pHead){ if (pHead == nullptr) return nullptr; ListNode *root = pHead, *pre; while (root != nullptr) { if (root-&gt;next-&gt;val != root-&gt;val) { pre = root; root = root-&gt;next; } else { while (root-&gt;next &amp;&amp; root-&gt;next-&gt;val == root-&gt;val) { root = root-&gt;next; } if (root-&gt;next) { pre-&gt;next = root-&gt;next; root = root-&gt;next; } else { pre-&gt;next = nullptr; return pHead; } } } return pHead;} 剑指offer 57 二叉树的下一个节点// 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。1234567TreeLinkNode* GetNext(TreeLinkNode* pNode){ if (pNode == nullptr) return pNode; while (pNode-&gt;right) { pNode = pNode-&gt;left; }} 剑指offer 58 对称的二叉树// 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。1234567891011121314bool isSymmetrical(TreeNode* pRoot){ if (pRoot == nullptr) return true; return isSymmetricalHelper(pRoot-&gt;left, pRoot-&gt;right);}bool isSymmetricalHelper(TreeNode* p1, TreeNode* p2) { if (p1 &amp;&amp; p2 == nullptr) return false; else if (p2 &amp;&amp; p1 == nullptr) return false; else if (p1 == nullptr &amp;&amp; p2 == nullptr) return true; if (p1-&gt;val == p2-&gt;val) { return isSymmetricalHelper(p1-&gt;left, p2-&gt;right) &amp;&amp; isSymmetricalHelper(p2-&gt;left, p1-&gt;right); } else return false;} 剑指offer 59 之字形打印二叉树// 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。12345678910111213141516171819202122232425262728293031vector&lt;vector&lt;int&gt; &gt; PrintZ(TreeNode* pRoot) { vector&lt;vector&lt;int&gt; &gt; res; if (pRoot == nullptr) return res; vector&lt;TreeNode*&gt; d; d.push_back(pRoot); vector&lt;int&gt; init; init.push_back(pRoot-&gt;val); res.push_back(init); int layer = 1; while (!d.empty()) { layer++; vector&lt;TreeNode*&gt; tmp; for (int i = 0; i &lt; d.size(); i++) { if (d[i]-&gt;left) tmp.push_back(d[i]-&gt;left); if (d[i]-&gt;right) tmp.push_back(d[i]-&gt;right); } vector&lt;int&gt; tmpInt; for (int i = 0; i &lt; tmp.size(); i++) { tmpInt.push_back(tmp[i]-&gt;val); } if (layer % 2 == 1 &amp;&amp; !tmpInt.empty()) { res.push_back(tmpInt); } else if (layer % 2 == 0 &amp;&amp; !tmpInt.empty()) { reverse(tmpInt.begin(), tmpInt.end()); res.push_back(tmpInt); } d = tmp; } return res;} 剑指offer 60 把二叉树打印成多行（层序遍历）从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。1234567891011121314151617181920212223vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) { vector&lt;vector&lt;int&gt; &gt; vec; if(pRoot == NULL) return vec; queue&lt;TreeNode*&gt; q; q.push(pRoot); while(!q.empty()) { int lo = 0, hi = q.size(); vector&lt;int&gt; c; while(lo++ &lt; hi) { TreeNode *t = q.front(); q.pop(); c.push_back(t-&gt;val); if(t-&gt;left) q.push(t-&gt;left); if(t-&gt;right) q.push(t-&gt;right); } vec.push_back(c); } return vec;} 剑指offer 61 序列化二叉树二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。 二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。12345678910111213141516171819202122232425262728293031323334353637typedef TreeNode node;typedef TreeNode* pnode;typedef int* pint;class Solution { vector&lt;int&gt; buf; void dfs(pnode p){ if(!p) buf.push_back(0x23333); else{ buf.push_back(p -&gt; val); dfs(p -&gt; left); dfs(p -&gt; right); } } pnode dfs2(pint&amp; p){ if(*p == 0x23333){ ++p; return NULL; } pnode res = new node(*p); ++p; res -&gt; left = dfs2(p); res -&gt; right = dfs2(p); return res; }public: char* Serialize(TreeNode *p) { buf.clear(); dfs(p); int *res = new int[buf.size()]; for(unsigned int i = 0; i &lt; buf.size(); ++i) res[i] = buf[i]; return (char*)res; } TreeNode* Deserialize(char *str) { int *p = (int*)str; return dfs2(p); }}; 剑指offer 62 二叉搜索树的第k个结点给定一棵二叉搜索树，请找出其中的第k小的结点。例如,(5，3，7，2，4，6，8)中，按结点数值大小顺序第三小结点的值为4。12345678910111213141516171819202122232425262728293031323334// 递归int cnt = 0;TreeNode* KthNode(TreeNode* pRoot, int k){ if (pRoot) { TreeNode* node = KthNode(pRoot-&gt;left, k); if (node) return node; cnt++; if (cnt == k) return pRoot; node = KthNode(pRoot-&gt;right, k); if (node) return node; } return nullptr;}// 非递归 中序遍历TreeNode* KthNode(TreeNode* pRoot, int k){ if (pRoot == nullptr || k &lt; 1) return nullptr; stack&lt;TreeNode*&gt; S; int cnt = 0; TreeNode* node = pRoot; while (!S.empty() || node) { while (node) { S.push(node); node = node-&gt;left; } node = S.top(); S.pop(); cnt++; if (cnt == k) return node; node = node-&gt;right; } return nullptr;} 剑指offer 63 数据流中的中位数如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。12345678910111213141516171819202122// 法1：大顶堆+小顶堆 // 法2：AVL 平衡二叉搜索树// 法3：排序vector&lt;int&gt; dataStream;void Insert(int num){ dataStream.push_back(num); sort(dataStream.begin(), dataStream.end());}double GetMedian(){ int sz = dataStream.size(); double res; if (sz % 2 == 0) { res = (double) (dataStream[sz/2] + dataStream[sz/2-1]) / 2; } else { res = (double) dataStream[sz/2]; } return res;} 剑指offer 64 滑动窗口的最大值给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}。1234567891011121314151617181920212223242526272829303132333435363738394041// 暴力法 O(n * size)int FindMaxVal(vector&lt;int&gt; num, int st, int ed) { int MaxVal = num[st]; for (int i = st; i &lt;= ed; i++) { if (num[i] &gt; MaxVal) MaxVal = num[i]; } return MaxVal;}vector&lt;int&gt; maxInWindows1(const vector&lt;int&gt;&amp; num, unsigned int size){ vector&lt;int&gt; res; if (num.size() == 0 || size &lt; 1) return res; for (int i = 0; i &lt;= num.size()-size; i++) { int tmp = FindMaxVal(num, i, i+size-1); res.push_back(tmp); } return res;}// 双端队列 O(n)vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size){ vector&lt;int&gt; res; if (num.size() == 0 || size &lt; 1) return res; deque&lt;int&gt; d; for (int i = 0; i &lt; num.size(); ++i) { // 从后面依次弹出队列汇总比当前num值小的元素，同时保证队首元素为当前窗口最大值下标 while (d.size() &amp;&amp; num[d.back()] &lt;= num[i]) { d.pop_back(); } // 当当前窗口移出队首元素所在的位置，即队首元素坐标对应的num不在窗口中，需要弹出 if (d.size() &amp;&amp; i-d.front()+1 &gt; size) { d.pop_front(); } d.push_back(i); // 当滑动窗口首地址i大于等于size时才开始写入窗口最大值 if (i &gt;= size - 1) { res.push_back(num[d.front()]); } } return res;} 剑指offer 65 矩阵中的路径请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。1234567891011121314151617181920212223242526272829303132bool dfs(char* matrix, int i, int j, int rows, int cols, char* str, vector&lt;vector&lt;bool&gt; &gt; path) { if (*str == &apos;\\0&apos;) return true; if (matrix[i * cols + j] != str[0]) return false; bool hasPath = false; if (j &gt;= 0 &amp;&amp; i &gt;=0 &amp;&amp; i &lt; rows &amp;&amp; j &lt; cols &amp;&amp; !path[i][j] &amp;&amp; matrix[i * cols + j] == str[0]) { path[i][j] = true; hasPath = dfs(matrix, i-1, j, rows, cols, str+1, path) || dfs(matrix, i+1, j, rows, cols, str+1, path) || dfs(matrix, i, j-1, rows, cols, str+1, path) || dfs(matrix, i, j+1, rows, cols, str+1, path); if (!hasPath) path[i][j] = false; } return hasPath;}bool hasPath(char* matrix, int rows, int cols, char* str){ if (matrix == nullptr || str == nullptr) return false; vector&lt;vector&lt;bool&gt; &gt; path(rows, vector&lt;bool&gt;(cols, false)); bool res = false; for (int row = 0; row &lt; rows; row++) { for (int col = 0; col &lt; cols; col++) { if (matrix[row * cols + col] == str[0]) { res = dfs(matrix, row, col, rows, cols, str, path); } if (res) return res; } } return res;} 剑指offer 66 机器人的动作范围地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？1234567891011121314151617181920212223242526272829303132333435363738int movingCount(int threshold, int rows, int cols){ bool* flag=new bool[rows*cols]; for(int i=0;i&lt;rows*cols;i++) flag[i]=false; int count=moving(threshold,rows,cols,0,0,flag);//从（0,0）坐标开始访问; delete[] flag; return count;}//计算最大移动位置int moving(int threshold,int rows,int cols,int i,int j,bool* flag) { int count=0; if(check(threshold,rows,cols,i,j,flag)) { flag[i*cols+j]=true; //标记访问过，这个标志flag不需要回溯，因为只要被访问过即可。 //因为如果能访问，访问过会加1.不能访问，也会标记下访问过。 count=1+moving(threshold,rows,cols,i-1,j,flag) + moving(threshold,rows,cols,i,j-1,flag) +moving(threshold,rows,cols,i+1,j,flag) + moving(threshold,rows,cols,i,j+1,flag); } return count;}//检查当前位置是否可以访问bool check(int threshold,int rows,int cols,int i,int j,bool* flag) { if(i&gt;=0 &amp;&amp; i&lt;rows &amp;&amp; j&gt;=0 &amp;&amp; j&lt;cols &amp;&amp; getSum(i)+getSum(j)&lt;=threshold &amp;&amp; flag[i*cols+j]==false) return true; return false;}//计算位置的数值int getSum(int number) { int sum=0; while(number&gt;0) { sum+=number%10; number/=10; } return sum;} 剑指offer 67 剪绳子给你一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。123456789101112131415161718/* 首先判断k[0]到k[m]可能有哪些数字，实际上只可能是2或者3。 * 5&lt;2*3,6&lt;3*3,比6更大的数字我们就更不用考虑了，肯定要继续分。 * 其次看2和3的数量，2的数量肯定小于3个，为什么呢？因为2*2*2&lt;3*3，那么题目就简单了。 * 直接用n除以3，根据得到的余数判断是一个2还是两个2还是没有2就行了。 * 由于题目规定m&gt;1，所以2只能是1*1，3只能是2*1，这两个特殊情况直接返回就行了。 */long long n_max_3(long long n) { if (n == 2) return 1; if (n == 3) return 2; long long x = n % 3; long long y = n / 3; if (x == 0) { return pow(3, y); } else if (x == 1) { return 2 * 2 * (long long) pow(3, y - 1); } else { return 2 * (long long) pow(3, y); }}","link":"/2020/03/06/ck7yp1q53000lxsun9jzxrwwv/"},{"title":"Postgresql+postgis地图开发说明","text":"Postgresql+postgis地图开发说明实习期间需要部署路网数据库查询服务，windows和ubuntu下的安装部署大同小异，现以postgresql 10+postgis 2.5.0为例 1. 安装postgresql+postgis部署地图数据查询服务ubuntu: sudo apt install libpq-dev postgresql-server-dev-10 postgresql-server-dev-all windows:参考博客csdn blog 2. 下载openstreetmap地图osm数据 下载国家地图数据，在www.openstreetmap.org，无法具体到省份城市 下载具体省份城市地图下载可参考省市地图 更小区域地图下载，可使用www.openstreetmap.org限定经纬度直接导出 3. 创建数据库，并支持postgis和pgrouting 方式一，命令行 createdb -U postgres XXX（数据库名称，后续都用XXX代替） 进入数据库\\c XXX,输入以下语句使数据库支持空间分析和空间查询 123456CREATE EXTENSION postgis; CREATE EXTENSION pgrouting;CREATE EXTENSION postgis_topology; CREATE EXTENSION fuzzystrmatch; CREATE EXTENSION postgis_tiger_geocoder; CREATE EXTENSION address_standardizer; 方式二：在pgAdmin中打开，直接以postgis数据库为模版创建数据库，这样创建的数据库直接支持空间查询和空间分析。 4. 将osm数据导入数据库blog4.1 安装OSM数据导入工具osm2pgsql(Ubuntu操作)： sudo apt install osm2pgsql (windows操作)： osm2pgsql下载地址：http://customdebug.com/osm/osm2pgsql.zip default.style文件:https://github.com/openstreetmap/osm2pgsql/blob/master/default.style osm2pgsql下载好之后解压，解压完成之后，将下载的default.style放入到.\\osm2pgsql\\x64文件夹下 4.2 进入数据库windows: cmd输入psql -U postgres -d XXX进入数据库 ubuntu: psql -U user_name -d database_name -h localhost 4.3 为了避免后面出现要输入密码或者出现Error: Connection to database failed: fe_sendauth: no password supplied错误，将文件pg_hba.conf（文件路径：...\\PostgreSQL\\10\\data）里面的md5，下图所示的两个md5改为trust4.4 (windwos)加载postgis对象和函数定义（postgis.sql） 在数据库安装位置bin文件夹下打开dos窗口，输入命令psql -U postgres -d osm -f “此处为postgis.sql文件的路径”。 postgis.sql文件在...PostgreSQL\\10\\share\\contrib\\postgis-2.5文件夹下 4.5 (windows)加载EPSG坐标系统定义（spatial_ref_sys.sql） 在dos窗口下输入命令psql -U postgres -d osm -f 此处为postgis.sql文件的路径 postgis.sql文件在...PostgreSQL\\10\\share\\contrib\\postgis-2.4文件夹下 4.6 导入OSM数据 ubuntu osm2pgsql -d XXX –U username -P portID -C 12000 -S /home/china-latest.osm.pbf -H localhost -W windows 在下载的osm2pgsql的.\\osm2pgsql\\x64文件夹下打开dos窗口，输入命令osm2pgsql -d XXX –U username -P portID -C 12000 -S &quot;C:\\develop\\postsql-gis\\osm2pgsql\\x64\\default.style&quot; china-latest.osm.pbf 4.7 验证数据是否成功 (linux) \\d发现多了几张table和view说明导入成功 (windows) 从菜单栏的postgressql打开pgAdmin，发现XXX库中多了4张表，说明导入成功 5. 创建路网拓扑图和查询数据表5.1 创建数据表，选择指定列，并重新排序gid 选择指定列：CREATE TABLE XXX AS (SELECT osm_id,name,ref,highway,oneway,bridge,way FROM planet_osm_roads); 添加起点id：ALTER TABLE XXX ADD COLUMN source integer; 添加终点id：ALTER TABLE XXX ADD COLUMN target integer; 添加道路权重值: ALTER TABLE XXX ADD COLUMN length double precision; 创建序列： 123456CREATE SEQUENCE test_id_seqSTART WITH 1INCREMENT BY 1NO MINVALUENO MAXVALUECACHE 1; 更新自增ID： 123alter table XXX add column gid int;alter table XXX alter column gid set default nextval(&apos;test_id_seq&apos;);update XXX set gid=nextval(&apos;test_id_seq&apos;); 修改数据表中列名way为geom: alter table XXX rename way to geom 5.2 创建路网拓扑 SELECT pgr_createTopology('XXX',0.00001, 'geom', 'gid');5.3 为length赋值 update XXX set length =st_length(geom);6. 使用QGIS加载数据表和在线地图6.1 QGIS连接postgressql 连接PostGIS数据源——数据库管理器——导入数据——加载数据 输入数据库名称 端口 用户名和密码 双击数据表即可显示图层 6.2 安装在线地图插件显示地图图层 打开QGIS，在插件下搜QGIS cloud插件，选择 add background layer 即可添加google map，bing map，openstreet map 作为底图","link":"/2020/03/19/ck7yp1q4o000fxsunfuz38bn3/"},{"title":"Git","text":"Git &amp; Linux operations python程序后台运行程序后台运行，打印结果到out.log文件nohup python -u test.py &gt; out.log 2&gt;&amp;1 &amp;说明： 末尾的“&amp;”：表示后台运行程序 “nohup” ：保证程序不被挂起 “python”：是执行python代码的命令 “-u”：表示不启用缓存，实时输出打印信息到日志文件（如果不加-u，则会导致日志文件不会实时刷新代码中的print函数的信息） “Job.py”：是python的源代码文件 “log.log”：是输出的日志文件 “&gt;”：是指将打印信息指定到日志文件 “2&gt;&amp;1”：将标准错误输出转变化标准输出，可以将错误信息也输出到日志文件中（0-&gt; stdin, 1-&gt;stdout, 2-&gt;stderr） 查询下进程 ，可查看pidps -ef | grep xxx 终止脚本进程kill -9 pid to be continue…","link":"/2020/01/08/ck7yp1q4m000dxsun661r7ltf/"},{"title":"链表的算法合集整理","text":"链表的算法合集大全(C/C++) 1. 链表结构体定义 2. 链表初始化，可以快速创建样例 3. 链表遍历打印，检验算法正确性 4. 输出单链表倒数第 K 个节点 5. 判断链表是否有环 6. 定位环的入口 7. 计算环的长度 8. 链表实现大数加法 9. 有序链表合并 10. K个有序链表合并 11. O(1)复杂度删除链表中结点 12. 从尾到头打印链表 13. 反转链表 14. 复杂链表的复制 15. 逆序构造单链表 16. 链表升序排序 17. 找出单链表的中间结点 1. 链表结构体定义1234567struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { }}; 2. 链表初始化，可以快速创建样例12345678910111213// 链表初始化，创造样例ListNode* linkedListInit(vector&lt;int&gt; v) { if (v.empty()) return NULL; ListNode* root = new ListNode(v[0]); ListNode* node = root; int i = 1; while (i&lt;v.size()) { node-&gt;next = new ListNode(v[i]); node = node-&gt;next; i++; } return root;} 3. 链表遍历打印，检验算法正确性123456789// 打印链表元素值，检验算法void PrintLinkedList(ListNode* root) { if (root == NULL) return; while (root != NULL) { cout&lt;&lt;root-&gt;val&lt;&lt;&quot; &quot;; root = root-&gt;next; } cout&lt;&lt;endl;} 4. 输出单链表倒数第 K 个节点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 输出单链表倒数第 K 个节点// 法一：两次遍历ListNode* findKthTail1(ListNode *pHead, int k) { if (pHead == NULL || k &lt;= 0) return NULL; int len = 0; ListNode* root = pHead; while (pHead != NULL) { pHead = pHead-&gt;next; len++; } if (len&lt;k) return NULL; int countdown = len-k; while (countdown--&gt;0) { root = root-&gt;next; } return root;}// 法二：递归**int cnt = 0;ListNode* findKthTail2(ListNode* pHead, int k) { if (pHead == NULL) return NULL; ListNode* node = findKthTail2(pHead-&gt;next, k); // 没找到就返回NULL，找到一直返回结点 if (node == NULL) { cnt++; if (cnt == k) return pHead; else return NULL; } else { return node; }}// 法三：快慢指针***ListNode* findKthTail3(ListNode* pHead, int k) { if (pHead == NULL || k &lt;= 0) return NULL; ListNode* slow = pHead; ListNode* fast = pHead; for(int i=0;i&lt;k;i++) { //快指针先走k步 if(fast) fast = fast-&gt;next; else return NULL; } while(fast) { fast = fast-&gt;next; slow = slow-&gt;next; } return slow;} 5. 判断链表是否有环123456789101112131415// 判断链表是否有环// 法一：穷举比较 O(n^2)// 法二：哈希缓存 O(n)// 法三：快慢指针 O(n)~O(n^2)环很大时bool isExistRing3(ListNode* pHead) { if (pHead == NULL) return false; ListNode* fast = pHead; ListNode* slow = pHead; while (fast-&gt;next &amp;&amp; slow) { fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast == slow) return true; } return false;} 6. 定位环的入口12345678910111213141516171819202122232425// 定位环的入口***hard***ListNode* getEntryNodeOfRing(ListNode* pHead) { ListNode* meetingnode = getMeetingNode(pHead); if (meetingnode == NULL) return NULL; // 没环则相遇尾结点 ListNode* p1 = meetingnode; ListNode* p2 = pHead; // p1和p2以相同的速度向前移动，当p2指向环的入口节点时 // p1已经围绕着环走了n圈又回到了入口节点。 while(p1 != p2) { p1 = p1-&gt;next; p2 = p2-&gt;next; } return p1;}ListNode* getMeetingNode(ListNode* pHead) { if (pHead == NULL) return NULL; ListNode* fast = pHead; ListNode* slow = pHead; while (fast-&gt;next &amp;&amp; slow) { fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast == slow) return slow; } return NULL;} 7. 计算环的长度12345678910111213141516// 计算环的长度// 找到slow与fast的相遇节点，令slow与fast指针从相遇节点出发，// 按照之前的前进规则，当slow与fast再次相遇时，slow走过的长度正好为环的长度。int getLengthOfRing(ListNode* pHead) { if (pHead == NULL) return 0; ListNode* meetingnode = getMeetingNode(pHead); if (meetingnode == NULL) return 0; // 防止无环 ListNode* fast = meetingnode-&gt;next-&gt;next; ListNode* slow = meetingnode-&gt;next; int length = 1; while (fast != slow) { fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; } return length;} 8. 链表实现大数加法1234567891011121314151617181920212223242526272829303132// 链表实现大数加法ListNode* numberAddAsList(ListNode* l1, ListNode* l2) { ListNode *ret = l1, *pre = l2; int up = 0; // 进位 while (l1 != NULL &amp;&amp; l2 != NULL) { l1-&gt;val = l1-&gt;val + l2-&gt;val +up; up = l1-&gt;val / 10; l1-&gt;val %= 10; pre = l1; //记录当前结点位置 l1 = l1-&gt;next; l2 = l2-&gt;next; } // 若l1到达末尾，说明l1长度小于l2 if (l1 == NULL) { pre-&gt;next = l2; // pre-&gt;next指向l2当前位置 } l1 = pre-&gt;next; // l1指针指向l2结点当前位置,即把l2拼到l1上继续计算 // 继续计算剩余结点，防止9999999+1这种情况 while (l1 != NULL) { l1-&gt;val = l1-&gt;val + up; up = l1-&gt;val / 10; l1-&gt;val %= 10; pre = l1; l1 = l1-&gt;next; } // 最高位有进位，新建一个结点保留最高位 if (up != 0) { ListNode* tmp = new ListNode(up); pre-&gt;next = tmp; } return ret;} 9. 有序链表合并12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 有序链表合并// 递归ListNode* mergeTwoOrderedListsRec(ListNode* pHead1, ListNode* pHead2){ if(pHead1 == NULL) return pHead2; if(pHead2 == NULL) return pHead1; if(pHead1-&gt;val &gt; pHead2-&gt;val) { pHead2-&gt;next = mergeTwoOrderedListsRec(pHead1, pHead2-&gt;next); return pHead2; } else { pHead1-&gt;next = mergeTwoOrderedListsRec(pHead1-&gt;next, pHead2); return pHead1; }}// 非递归ListNode* mergeTwoOrderedListsNotRec(ListNode* pHead1, ListNode* pHead2) { if (pHead1 == NULL) return pHead2; else if (pHead2 == NULL) return pHead1; else { ListNode* pTail = NULL; // 新链表最后一个结点 ListNode* newHead = NULL; // 合并后链表第一个结点 if (pHead1-&gt;val &lt; pHead2-&gt;val) { newHead = pHead1; pHead1 = pHead1-&gt;next; } else { newHead = pHead2; pHead2 = pHead2-&gt;next; } pTail = newHead; // 指向第一个结点 while (pHead1 &amp;&amp; pHead2) { if (pHead1-&gt;val &lt;= pHead2-&gt;val) { pTail-&gt;next = pHead1; pHead1 = pHead1-&gt;next; } else { pTail-&gt;next = pHead2; pHead2 = pHead2-&gt;next; } pTail = pTail-&gt;next; } if (pHead1 == NULL) pTail-&gt;next = pHead2; else if (pHead2 == NULL) pTail-&gt;next = pHead1; return newHead; }} 10. K个有序链表合并12345678910111213// K个有序链表合并// 归并排序，复杂度O(nlogk)ListNode* mergeKsortedLists(vector&lt;ListNode*&gt; lists) { int amount = lists.size(); int gap = 1; while (gap &lt; amount) { for (int i=0; i&lt; amount-gap; i+=gap*2) { lists[i] = mergeTwoOrderedListsRec(lists[i], lists[i+gap]); } gap *= 2; } return amount&gt;0?lists[0]:NULL;} 11. O(1)复杂度删除链表中结点12345678910111213141516171819202122232425void deleteNode(ListNode **pHead, ListNode* pDelNode) { if (pDelNode == NULL) return; if (pDelNode-&gt;next != NULL) { ListNode* pNext = pDelNode-&gt;next; // 下一个节点的值赋给删除节点 pDelNode-&gt;val = pNext-&gt;val; pDelNode-&gt;next = pNext-&gt;next; delete pNext; // delete是删除指针指向的内容 pNext = NULL; // 不指向NULL会成为野指针 } else if (*pHead == pDelNode) { //头结点 delete pDelNode; pDelNode = NULL; *pHead = NULL; } else { //删除尾结点 ListNode *pNode = *pHead; while (pNode-&gt;next != pDelNode) { pNode = pNode-&gt;next; } pNode-&gt;next = NULL; delete pDelNode; pDelNode = NULL; }} 12. 从尾到头打印链表1234567891011121314151617181920212223242526272829303132333435363738394041424344// 递归vector&lt;int&gt; printListFromTailToHead1(ListNode* head) { vector&lt;int&gt; res; if(head!=NULL){ if(head-&gt;next!=NULL){ res = printListFromTailToHead1(head-&gt;next); } res.push_back(head-&gt;val); } return res;}//栈vector&lt;int&gt; printListFromTailToHead2(ListNode* head) { vector&lt;int&gt; res; stack&lt;int&gt; sta; while(head!=NULL){ sta.push(head-&gt;val); head=head-&gt;next; } while(!sta.empty()){ res.push_back(sta.top()); sta.pop(); } return res;}// **链表原地反转**vector&lt;int&gt; printListFromTailToHead3(struct ListNode* head) { vector&lt;int&gt; vec; ListNode *buf=head; ListNode *pre=buf; if(head==NULL) return vec; while(head-&gt;next!=NULL){ /*这里还没看懂*/ buf=head-&gt;next; head-&gt;next=buf-&gt;next; buf-&gt;next=pre; pre=buf; } while(buf){ vec.push_back(buf-&gt;val); buf=buf-&gt;next; } return vec;} 13. 反转链表123456789101112131415161718192021222324// 迭代（链表的原地反转）ListNode* reverseList1(ListNode* head) { ListNode* pre = NULL; ListNode* cur = head; while (cur != NULL) { ListNode* next = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = next; } return pre;}// 递归ListNode* reverseList2(ListNode* head) { if (head == NULL || head-&gt;next == NULL) { return head; } ListNode* rhead = reverseList2(head-&gt;next); // head-&gt;next此刻指向head后面的链表的尾节点 // head-&gt;next-&gt;next = head把head节点放在了尾部 head-&gt;next-&gt;next = head; head-&gt;next = NULL; return rhead;} 14. 复杂链表的复制123456789101112131415161718192021222324252627282930// （每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针// 指向任意一个节点），返回结果为复制后复杂链表的head。RandomListNode* Clone(RandomListNode* pHead){ if(pHead==NULL) return NULL; RandomListNode* currentNode=pHead; //复制每个结点，将其插入结点后面 while(currentNode!=NULL){ RandomListNode* cloneNode = new RandomListNode(currentNode-&gt;label); RandomListNode* nextNode = currentNode-&gt;next; currentNode-&gt;next=cloneNode; cloneNode-&gt;next=nextNode; currentNode=nextNode; } currentNode=pHead; //复制老结点的随机指针给新结点 while(currentNode!=NULL){ currentNode-&gt;next-&gt;random = currentNode-&gt;random==NULL?NULL:currentNode-&gt;random-&gt;next; currentNode=currentNode-&gt;next-&gt;next; } //拆分链表 currentNode=pHead; RandomListNode* pCloneHead=pHead-&gt;next; while(currentNode!=NULL){ RandomListNode* cloneNode=currentNode-&gt;next; currentNode-&gt;next=cloneNode-&gt;next; cloneNode-&gt;next=cloneNode-&gt;next==NULL?NULL:cloneNode-&gt;next-&gt;next; currentNode=currentNode-&gt;next; } return pCloneHead;} 15. 逆序构造单链表输入数据：[1,2,3,4,5],构造单链表:5-&gt;4-&gt;3-&gt;2-&gt;1 1234567891011// 逆序构造单链表ListNode* desc_construct(vector&lt;int&gt; input) { if (input.empty()) return NULL; ListNode* pre = NULL; for (int i=0;i&lt;input.size();i++) { ListNode* cur = new ListNode(input[i]); cur-&gt;next = pre; pre = cur; } return pre;} 16. 链表升序排序快排是需要一个指针指向头，一个指针指向尾，然后两个指针相向运动并按一定规律交换值，最后使得支点左边小于支点，支点右边大于支点，但是对于单链表而言，指向结尾的指针很好办，但是这个指针如何往前，我们只有一个 next（这并不是一个双向链表）。 我们只需要两个指针 i 和 j，这两个指针均往 next 方向移动，移动的过程中始终保持区间 [1, i] 的 data 都小于 base（位置 0 是主元），区间 [i+1, j) 的 data 都大于等于 base，那么当 j 走到末尾的时候便完成了一次支点的寻找。若以 swap 操作即 if 判断语句成立作为基本操作，其操作数和快速排序相同，故该方法的平均时间复杂度亦为$T(n) = O(nlogn)$。 1234567891011121314151617181920212223// 链表升序排序/** * @param begin 链表的第一个结点，即header-&gt;next * @param end 链表的最后一个结点的next */void asc_sort(ListNode* begin, ListNode* end) { // 链表为空或只有一个结点 if (begin == end || begin-&gt;next == end) return; int base = begin-&gt;val; ListNode* i = begin; ListNode* j = begin-&gt;next; while (j != end) { if (j-&gt;val &lt; base) { i = i-&gt;next; swap(i-&gt;val, j-&gt;val); } j = j-&gt;next; } swap (i-&gt;val, begin-&gt;val); asc_sort(begin, i); asc_sort(i-&gt;next, end);}// usage: asc_sort(header-&gt;next, nullptr); 17. 找出单链表的中间结点123456789101112// 找出单链表的中间结点（类似倒数第k个结点）// 法一：遍历一次，再遍历到n/2,复杂度为O(n+n/2)// 法二：快慢指针ListNode* find_middle(ListNode* head) { ListNode* fast = head; ListNode* slow = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) { slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; } return slow;}","link":"/2019/08/21/ck7yp1q4n000exsun0u7zirp2/"},{"title":"2019中兴捧月算法大赛——无线信道估计","text":"Github项目：https://github.com/dlc1994/2019ZTE-Algorithm-Competition 本来想参加深度学习题目的，但看到用caffe，还要现学就作罢了 傅里叶门派有三个题目，一开始想做了智能调度，但是看了半天题目也没理解，随便提交了一个上去（最后发现一共才50多份提交，悔不当初） 看到这个有点像曲线拟合，题目就是用最少的导频数，估计带噪声的其余一共250个频点的信道值 看上去有点像曲线拟合，所以我就往曲线拟合方向做了 1 导频数用62，此时导频和误差百分比大致在50% 2 导频分开实部和虚部分开进行拟合，拟合函数使用SmoothingSpline 3 拟合出来函数是带噪声的，接下来去噪 4 用小波变换，小波基为coif5,分解层数为10层 5 输出最终结果，感觉有点过拟合了 最后一天做了半天，只能提高到36名了，看到进决赛拿蓝剑的那些大神还是很羡慕的，应该多花些时间的，从原理上改进而不是简单的去噪拟合 大佬的思路： 1 多种组合构成个闭环优化，中兴专家做的，好像用20个导频左右拿了第一 2 用CNN，这个可能是从autoencoder方向想，但是数据集够用？","link":"/2019/05/24/ck7yp1q4r000jxsundf34bvkf/"},{"title":"LeetCode Solutions","text":"Here are my solutions to the LeetCode problems, linking to my Github repository: EASY Leetcode 1 Two Sum Leetcode 9 Palindrome Number Leetcode 13 roman2integer Leetcode 14 longestcommonprefix Leetcode 20 valid parentheses Leetcode 21 merge2sortedlist Leetcode 461 Hamming Distance Leetcode 709 To Lower Case Leetcode 771 Jewels and Stones Leetcode 804 Unique Morse Code Words Circle Leetcode 832 Flipping an Image MEDIUM Leetcode 12 int2roman Leetcode 21 merge2sortedlist Leetcode 22 generateParentheses Leetcode 29 DivideTwoIntegers Leetcode 33 SearchInRotatedSortedArray Leetcode 34 FindFirstAndLastPositionInSortedArray Leetcode 36 SearchInRotatedSortedArray Leetcode 516 LongestPalindSubstringHARD Leetcode 23 mergeKsortedlists","link":"/2018/07/30/ck7yp1q4f0009xsunyo7xwjco/"},{"title":"常用排序算法（python）","text":"常用排序算法（python） 冒泡排序1234567def bubbleSort(alist): for i in range(len(alist)): for j in range(len(alist)-i-1): if alist[j]&gt;alist[j+1]: tmp = alist[j] alist[j] = alist[j+1] alist[j+1] = tmp 选择排序123456789def selectSort(alist): for i in range(len(alist)): minPos = i for j in range(i+1, len(alist)): if alist[i]&gt;alist[j]: minPos = j tmp = alist[i] alist[i] = alist[minPos] alist[minPos] = tmp 插入排序12345678def insertSort(alist): for i in range(1, len(alist)): current = alist[i] pos = i while pos&gt;0 and current&lt;alist[pos-1]: alist[pos] = alist[pos-1] pos-=1 alist[pos] = current 希尔排序1234567891011def shellSort(alist): gap = len(alist)//2 while gap&gt;0: for i in range(gap, len(alist)): j = i current = alist[i] while j-gap&gt;0 and current&lt;alist[j-gap]: alist[j] = alist[j-gap] j = j - gap alist[j] = current gap = gap // 2 归并排序1234567891011121314151617181920212223242526def mergeSort(alist): if len(alist)&gt;1: mid = len(alist) // 2 left = alist[:mid] right = alist[mid:] mergeSort(left) mergeSort(right) i,j,k = 0,0,0 while i&lt;len(left) and j&lt;len(right): if left[i]&lt;right[j]: alist[k] = left[i] i+=1 else: alist[k] = right[j] j+=1 k+=1 while i&lt;len(left): alist[k] = left[i] k+=1 i+=1 while j&lt;len(right): alist[k] = right[j] k+=1 j+=1 快速排序1234567891011121314151617181920212223242526272829def quickSort(alist): quickSortHelper(alist, 0, len(alist)-1)def quickSortHelper(alist, first, last): if first&lt;last: splitpoint = partition(alist, first, last) quickSortHelper(alist, first, splitpoint-1) quickSortHelper(alist, splitpoint + 1, last)def partition(alist, first, last): pivot = alist[first] leftmark = first + 1 rightmark = last done = False while not done: while leftmark &lt;= rightmark and alist[leftmark] &lt;= pivot: leftmark += 1 while rightmark &gt;= leftmark and alist[rightmark] &gt;= pivot: rightmark -= 1 if rightmark &lt; leftmark: done = True else: tmp = alist[leftmark] alist[leftmark] = alist[rightmark] alist[rightmark] = tmp tmp = alist[first] alist[first] = alist[rightmark] alist[rightmark] = tmp return rightmark","link":"/2019/04/19/ck7yp1q4o000gxsun1ml1kiw2/"},{"title":"Water Filling Algorithm and Matlab Simulation","text":"注水算法是根据某种准则，并根据信道状况对发送功率进行自适应分配，通常是信道状况好的时刻，多分配功率，信道差的时候，少分配功率，从而最大化传输速率。当接收端完全已知CSI（信道状态信息）而发送端未知CSI时，发送天线阵列中的功率平均分配是合理的。 实现功率的“注水”分配，发送端必须知道CSI。 直观而言，就如下图所示： 图1 注水原理示意图（白色平台越高代表信道条件越差，注入的水就越少） 注水原理可以建模为下述优化问题： \\begin{align} & \\underset{P_1,P_2,...,P_N}{\\mathop{\\max }}\\,\\text{ }{C_{sum}}=\\sum_{n=1}^{N}{\\log \\left( 1+\\frac{P_n{\\left| {h_n} \\right|}^2}{N_0} \\right)} \\\\ & \\text{subject to }\\sum_{n=1}^{N}{P_n}={P}_{sum},n=1,2,...,N \\ \\end{align}其中${C}_{sum}$表示系统总信道容量，$N$为信道数，${P}_{n}$为第$n$个信道的功率，${h}_{n}$为第$n$个信道的信道增益，${N}_{0}$为噪声功率谱密度，${P}_{sum}$为传输总功率，也就是总水量。 该优化问题为凸优化问题，可以用拉格朗日乘数法求得全局最优解。 \\mathcal{L}(\\lambda ,{P_1},{P_2},...,{P_N})=\\sum_{n=1}^{N}{\\log \\left( 1+\\frac{P_n{\\left| {h_n} \\right|}^2}{N_0} \\right)}+\\lambda (\\sum_{n=1}^{N}{P_n}-P_{sum})令$\\frac{\\partial \\mathcal{L} }{\\partial P_n}=\\frac{\\partial \\mathcal{L} }{\\partial \\lambda }=0$，解得最优功率分配方案为： P_{n}^{*}={\\left( \\frac{1}{\\lambda }-\\frac{N_0}{\\left| {h}_{n} \\right|}^{2} \\right)}^{+}其中${(\\centerdot )}^{+}$表示取值非负。 MATLAB实现 1234567891011121314151617181920212223242526272829303132333435363738394041clear all;channel_n=10; %channel numberM=[5,10,20,50]; %transmitted powerN0=0.5; h_1= random(&apos;rayleigh&apos;,1,1,channel_n); %Rayleigh fadingh_2=h_1.^2; %|h|.^2h_2_sorted=sort(h_2); %sort the channel gainh=h_2_sorted/N0; syms lamdafor m=1:length(M) fprintf(&apos;transmitted power is %d watt&apos;,M(m)); for k=1:channel_n p=zeros(1,channel_n); sum=0; for i=k:channel_n sum=sum+(1/lamda-1/h(i)); end f=sum-M(m); x=solve(f,lamda); %find lamda if k==1 if vpa(x)&gt;0 &amp;&amp; vpa(x)&lt;h(k) for i=k:channel_n p(i)=1/x-1/h(i); %allocate power capacity=capacity+log2(1+p(i)*h(i));%compute the capacity end p(i)=vpa(p(i),3) capacity=vpa(capacity,3) end else if vpa(x)&gt;h(k-1) &amp;&amp; vpa(x)&lt;h(k) capacity=0; for i=k:channel_n p(i)=1/x-1/h(i); %allocate power capacity=capacity+log2(1+p(i)*h(i)); %compute the capacity end p(i)=vpa(p(i),3) capacity=vpa(capacity,3) end end endend","link":"/2018/07/18/ck7yp1q4k000cxsunuzbxv2hr/"},{"title":"二叉树常用操作的实现","text":"二叉树的最全总结，常考题型，持续更新二叉树的递归思想很重要，还有递归的复杂度分析 1.1 二叉树的初始化12345678910111213141516171819202122#initial of BinaryTreeclass BinaryTree: def __init__(self,rootObj): self.val = rootObj self.left = None self.right = None def insertLeft(self,newNode): if self.left == None: self.left = BinaryTree(newNode) else: t = BinaryTree(newNode) t.left = self.left self.left = t def insertRight(self,newNode): if self.right == None: self.right = BinaryTree(newNode) else: t = BinaryTree(newNode) t.right = self.right self.right = t 1.2 创建一个二叉树1234567891011121314151617#create a BinaryTree [18,7,11,3,4,5,6,#,#,#,#,1,3,2,4]# 18# 7 11#3 4 5 6# 1 3 2 4root = BinaryTree(18)root.left = BinaryTree(7)root.right = BinaryTree(11)root.left.left = BinaryTree(3)root.left.right = BinaryTree(4)root.right.left = BinaryTree(5)root.right.right = BinaryTree(6)root.right.left.left = BinaryTree(1)root.right.left.right = BinaryTree(3)root.right.right.left = BinaryTree(2)root.right.right.right = BinaryTree(4) 1.3 前序遍历1234567891011121314151617181920212223#递归版本def PreOrder(self, node): if node: print(node.val) self.PreOrder(node.left) self.PreOrder(node.right)#循环版本def PreOrderLoop(self, node): if node == None: return stack =[] print(node.val) stack.append(node) node = node.left while stack!=[] or node: while node: print(node.val) stack.append(node) node = node.left node = stack[-1].right stack.pop()#ouput: 18 7 3 4 11 5 1 3 6 2 4 1.4 中序遍历123456789101112131415161718192021#递归版本def InOrder(self, node): if node: self.InOrder(node.left) print(node.val) self.InOrder(node.right)#循环版本def InOrderLoop(self, node): if node == None: return None stack = [] stack.append(node) node = node.left while stack!=[] or node: while node: stack.append(node) node = node.left print(stack[-1].val) node = stack[-1].right stack.pop()#output：3 7 4 18 1 5 3 11 2 6 4 1.5 后序遍历1234567891011121314151617181920212223242526#递归def PostOrder(self, node): if node: self.PostOrder(node.left) self.PostOrder(node.right) print(node.val)#非递归def PostOrderLoop(self, node): if node == None: return stack =[] stack.append(node) pre = None while stack!=[]: node = stack[-1] if ((node.left==None and node.right==None) or (pre and (pre == node.left or pre ==node.right))): print(node.val) pre = node stack.pop() else: if node.right: stack.append(node.right) if node.left: stack.append(node.left)#output:3 4 7 1 3 5 2 4 6 11 18 1.6 层序遍历1234567891011121314def LevelOrder(self, node): if node == None: return stack = [] stack.append(node) while stack!=[]: node = stack[0] if node.left: stack.append(node.left) if node.right: stack.append(node.right) print(node.val) stack.pop(0)output: 18 7 11 3 4 5 6 1 3 2 4 1.7 计算节点数1234567891011121314151617181920#递归版本def CountNode(self, root): if root == None: return 0 return self.CountNode(root.left) + self.CountNode(root.right) + 1#非递归版本def CountNodeNotRev(self, root): if root == None: return 0 stack = [] stack.append(root) index = 0 while index&lt;len(stack): if stack[index].left: stack.append(stack[index].left) if stack[index].right: stack.append(stack[index].right) index += 1 print(len(stack))output: 11 1.8 计算树的深度123456def getTreeDepth(self, root): if root == None: return 0 left = self.getTreeDepth(root.left) + 1 right = self.getTreeDepth(root.right) + 1 return left if left&gt;right else right 1.9 计算树的叶子树123456def countLeaves(self, root): if root == None: return 0 if root.left==None and root.right==None: return 1 return self.countLeaves(root.left)+self.countLeaves(root.right) 1.10 获取第K层节点数1234def getKLevel(self, root, K): if root == None: return 0 if K == 1: return 1 return self.getKLevel(root.left, K-1)+self.getKLevel(root.right, K-1) 1.11 判断两颗二叉树是否相同1234def StrucCmp(self, root1, root2): if root1 == None and root2 == None: return True elif root1 ==None or root2 == None: return False return self.StrucCmp(root1.left, root2.left) and self.StrucCmp(root1.right, root2.right) 1.12 二叉树的镜像1234567def Mirror(self, root): if root == None: return tmp = root.left root.left = root.right root.right = tmp self.Mirror(root.left) self.Mirror(root.right) 1.13 找最低公共祖先节点12345678def findLCA(self, root, node1, node2): if root == None: return if root == node1 or root == node2: return root left = self.findLCA(root.left, node1, node2) right = self.findLCA(root.right, node1, node2) if left and right: return root return left if left else right 1.14 获取两个节点的距离123456789101112def getDist(self, root, node1, node2): lca = self.findLCA(root, node1, node2) #找最低公共祖宗节点 level1 = self.FindLevel(lca, node1) #祖节点到两个节点的距离 level2 = self.FindLevel(lca, node2) return level1+level2def FindLevel(self, node, target): if node == None: return -1 if node == target: return 0 level = self.FindLevel(node.left, target) if level == -1: level = self.FindLevel(node.right, target) if level != -1: return level + 1 return -1 1.20 找一个节点的所有祖宗节点1234567def findAllAncestor(self, root, target): if root == None: return False if root == target: return True if self.findAllAncestor(root.left, target) or self.findAllAncestor(root.right, target): print(root.val) return True return False","link":"/2019/03/09/ck7yp1q470003xsun3ijve01q/"},{"title":"Introduction to Machine Learning","text":"做了与机器学习相关的项目好久了，但对机器学习一直没有一个系统的认识，导致在切入一些新的领域时力有不逮，总感觉理解有偏差或者理解困难，因此想系统地、详细地学习机器学习，就从周志华的西瓜书和Andrew Ng的机器学习视频开始吧。 众所周知， 机器学习是研究计算机怎样模拟或实现人类的学习行为，以获取新是研究计算机怎样模拟或实现人类的学习行为。 来自卡内基梅隆大学的Tom Mitchell提出的关于机器学习的定义较为人所接受，他定义的机器学习是，一个程序被认为能从经验E中学习，解决任务T，达到性能度量值P，当且仅当，有了经验E后，经过P评判，程序在处理T时的性能有所提升。 一般而言，我把机器学习分为监督学习、无监督学习和增强学习，而深度学习和大数据是拓展也是紧密的关联，如下图所示： 监督学习，顾名思义，就是有人指导你，告诉你这个学习正确与否。专业点来讲，就是数据集中每个样本都会带有一个正确答案，比如在西瓜分类里，“红瓤，有蒂”带有标签“甜”，“黄瓤，无蒂”带有标签“不甜”；在回归里，房价预测里每个样本都带有房价。分类和回归的区别在于预测的是一组离散的结果，而回归可以预测连续的输出。 无监督学习，从上图可以看出，我们事先不知道样本是哪一类或者是哪一个值，也就是没有任何的标签或“答案”。一个比较著名的例子就是鸡尾酒宴问题：许多人坐在一起参加鸡尾酒会，大家都在同一时间说话，声音此起彼伏，重重叠叠，要想分离出不同人说话的声音，就是一个聚类问题，也是无监督学习问题。这个例子可能比较难懂，再说一个就是在无线通信中，有时会根据用户的行为特征对用户进行分类，便于进行一些资源的调度和统一管理，而如何判断一堆用户里哪些用户是类似的，比如上班族、学生党、旅客等，这就是一个典型的聚类问题。 增强学习则是要解决这样的问题，一个能感知环境的自治agent，怎样通过学习选择能达到其目标的最优动作。当agent（机器人，下棋，在无线领域则可以是用户、基站和operator）在环境中作出某个动作时，会产生不同的奖励值或者惩罚值，agent的任务就是从这个非直接的，有延迟的回报中学习，以便后续的动作产生最大的累积效应。 在后续的文章中，我们会对各个算法有比较详细的学习过程，敬请期待啦。","link":"/2018/11/28/ck7yp1q4b0006xsun6ioyg377/"},{"title":"常用数据结构——栈 (python)","text":"本科学过c++的数据结构了，但研究生转无线通信后就忘的差不多了，现在重新复习下栈。 栈（stack）、队列（queues）、双端队列（deques）和列表都是有序数据容器，元素添加后在容器内的位置跟其他元素添加和删除的顺序有关，像这样的容器被称作线性数据结构（linear data structure）。 栈可以想象为只有一端开口的瓶子，假设每放一个东西进去都会把前面放的完全盖住，那么这时你想取出最里面的东西显然是不可能的，所以你只能把上面的一个个拿出来才能取到你想要的，这就叫做后进先出（LIFO, last-in first-out）。 1. 栈的主要方法及实现 栈的方法主要有下面几种： Stack() creates a new stack that is empty. It needs no parameters and returns an empty stack. push(item) adds a new item to the top of the stack. It needs the item and returns nothing. pop() removes the top item from the stack. It needs no parameters and returns the item. The stack is modified. peek() returns the top item from the stack but does not remove it. It needs no parameters. The stack is not modified. isEmpty() tests to see whether the stack is empty. It needs no parameters and returns a boolean value. size() returns the number of items on the stack. It needs no parameters and returns an integer.在python中是没有栈的实现的，所以栈需要自己实现，简单点可以用个list充当下，更一般的要实现上面各种方法还是面向对象创造一个类比较好，实现代码如下所示：123456789101112131415161718class Stack: def __init__(self): self.items = [] def isEmpty(self): return self.items == [] def push(self, item): self.items.append(item) def pop(self): return self.items.pop() def peek(self): return self.items[len(self.items)-1] def size(self): return len(self.items) 2. 栈的主要应用2.1 字符串反转 那么，费尽心机创造一个栈有啥用呢？首先可以用来翻转字符串，当然python有超级多方式可以反转字符串，最简单的自然是string[::-1]。12345678def stringReverse(self, stringstring): s = Stack() output = &quot;&quot; for ss in stringstring: s.push(ss) while not s.isEmpty(): output = output + s.pop() return output 2.2 简单括号匹配 除此之外，还有简单的括号匹配问题，也可以利用栈的特性来解决：1234567891011121314151617181920def parChecker(symbolString): s = Stack() balanced = True index = 0 while index &lt; len(symbolString) and balanced: symbol = symbolString[index] if symbol == &quot;(&quot;: s.push(symbol) else: if s.isEmpty(): balanced = False else: s.pop() index = index + 1 if balanced and s.isEmpty(): return True else: return False 其实吧，也可以不用栈解决呀（不是我杠，笔试时间也是很重要的）123456789def parChecker(symbolString): left = 0 right = 0 for s in symbolString: if s == &apos;(&apos;: left+=1 else: right+=1 return left==right 2.3 多重括号匹配 拓展到更复杂一点的括号匹配问题——多重括号匹配：12345678910111213141516171819202122232425def parChecker(symbolString): s = Stack() balanced = True index = 0 while index &lt; len(symbolString) and balanced: symbol = symbolString[index] if symbol in &quot;([{&quot;: s.push(symbol) else: if s.isEmpty(): balanced = False else: top = s.pop() if not matches(top,symbol): balanced = False index = index + 1 if balanced and s.isEmpty(): return True else: return Falsedef matches(open,close): opens = &quot;([{&quot; closers = &quot;)]}&quot; return opens.index(open) == closers.index(close) 当然，我又“杠”了，主要不想想这么复杂的结构2333：12345678910111213141516def parChecker(symbolString): l1,l2,l3,r1,r2,r3=0,0,0,0,0,0 for s in symbolString: if s==&apos;{&apos;: l1+=1 elif s==&apos;}&apos;: r1+=1 elif s==&apos;(&apos;: l2+=1 elif s==&apos;)&apos;: r2+=1 elif s==&apos;[&apos;: l3+=1 else: r3+=1 return [l1,l2,l3]==[r1,r2,r3] 2.4 将十进制数转换为各种进制 想将10进制数（Decimal）转换为2进制（Binary）、8进制（Octal）或者16进制（Hexidecimal），就将这个数不断除进制数，然后将余数逆序输出，不想贴图了自己百度查下。1234567891011121314def baseConverter(decNumber,base): digits = &quot;0123456789ABCDEF&quot; remstack = Stack() while decNumber &gt; 0: rem = decNumber % base remstack.push(rem) decNumber = decNumber // base newString = &quot;&quot; while not remstack.isEmpty(): newString = newString + digits[remstack.pop()] return newString 2.5 中缀表达式、前后缀表达式 接下来就是栈的重点操作了（就是比较复杂一点）。 什么是中缀表达式呢？就是一般的表达式，比如A+B, C*D等。 顾名思义，前缀表达式就是操作符在前面，后缀就是在后面，给几个例子体会一下： Infix Expression Prefix Expression Postfix Expression A + B C + D + + A B C D A B C + D + (A + B) (C + D) + A B + C D A B + C D + A B + C D + A B C D A B C D + A + B + C + D + + + A B C D A B + C + D + 将中缀表达式转换为后缀表达式，利用栈可以写为：123456789101112131415161718192021222324252627282930def infixToPostfix(infixexpr): prec = {} prec[&quot;*&quot;] = 3 prec[&quot;/&quot;] = 3 prec[&quot;+&quot;] = 2 prec[&quot;-&quot;] = 2 prec[&quot;(&quot;] = 1 opStack = Stack() postfixList = [] tokenList = infixexpr.split() for token in tokenList: if token in &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; or token in &quot;0123456789&quot;: postfixList.append(token) elif token == &apos;(&apos;: opStack.push(token) elif token == &apos;)&apos;: topToken = opStack.pop() while topToken != &apos;(&apos;: postfixList.append(topToken) topToken = opStack.pop() else: while (not opStack.isEmpty()) and \\ (prec[opStack.peek()] &gt;= prec[token]): postfixList.append(opStack.pop()) opStack.push(token) while not opStack.isEmpty(): postfixList.append(opStack.pop()) return &quot; &quot;.join(postfixList) 假如直接给你一个后缀表达式让你计算呢，这就是需要再写一个算法了，不过比较简单，贴上来：1234567891011121314151617181920212223def postfixEval(postfixExpr): operandStack = Stack() tokenList = postfixExpr.split() for token in tokenList: if token in &quot;0123456789&quot;: operandStack.push(int(token)) else: operand2 = operandStack.pop() operand1 = operandStack.pop() result = doMath(token,operand1,operand2) operandStack.push(result) return operandStack.pop()def doMath(op, op1, op2): if op == &quot;*&quot;: return op1 * op2 elif op == &quot;/&quot;: return op1 / op2 elif op == &quot;+&quot;: return op1 + op2 else: return op1 - op2 栈就目前学完了，后续有的话还会补充。","link":"/2019/04/29/ck7yp1q4p000hxsune3firr6y/"},{"title":"暑期实习招聘笔试题3月(更新ing)","text":"实习笔试试题，有些没投（准备好先），拿过来先看了看 12 头条笔试题1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;numeric&gt;using namespace std;int main(){ int N; cin&gt;&gt;N; for(int n=0;n&lt;N;++n){ int L, minVal, minPos; minVal = 1000; minPos = 0; cin&gt;&gt;L; vector&lt;int&gt; v(L, 0); for(int l=0;l&lt;L;l++){ cin&gt;&gt;v[l]; if(v[l]&lt;minVal){ minVal = v[l]; minPos = l; } } vector&lt;int&gt; reward(v.size(), 0); reward[minPos] = 1; for(int k=0;k&lt;L;k++){ int pos = k+minPos; if (pos&gt;=L){ pos = pos - L; } if(pos==0){ if(v[pos]&gt;v[L-1]) reward[pos] = reward[L-1]+1; else if(v[pos]==v[L-1]) reward[pos] = reward[L-1] - 1; else reward[pos]=reward[pos]; } else{ if(v[pos]&gt;v[pos-1]) reward[pos] = reward[pos-1]+1; else if(v[pos]==v[pos-1]) reward[pos] = reward[pos-1] - 1; else reward[pos]=reward[pos]; } } cout&lt;&lt;accumulate(reward.begin(),reward.end(),0)&lt;&lt;endl; } return 0;} 3 头条笔试题1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;numeric&gt;using namespace std;vector&lt;int&gt; zhaoqian(int N){ vector&lt;int&gt; v(4,0); N = 1024 - N; int value[4] = {64, 16, 4, 1}; for(int i=0;i&lt;(sizeof(value)/sizeof(value[0]));i++){ cout&lt;&lt;i&lt;&lt;endl; int a = N/value[i]; v[i] = a; N = N%value[i]; } return v;}int main(){ int N; cin&gt;&gt;N; vector&lt;int&gt; vv; vv = zhaoqian(N); cout&lt;&lt;accumulate(vv.begin(), vv.end(), 0)&lt;&lt;endl; return 0;} 4 招行笔试题题目描述：切不等高的蛋糕，蛋糕N份，每刀切平一部分，切下来的不得超过k份，整块蛋糕切平最少需要几刀，比如如下输入5 61 2 3 4 5提示：第一刀可以切到2，切下来刚好是6份，剩下蛋糕为1 2 2 2 2第二刀全切到1，最少需要2刀12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &lt;iostream&gt;#include &lt;numeric&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;list&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;int main(){ int N,k; cin&gt;&gt;N&gt;&gt;k; vector&lt;int&gt; v(N, 0); for(int l=0;l&lt;N;l++){ cin&gt;&gt;v[l]; } sort(v.begin(),v.end()); int minVal = v.front(); int maxVal = v.back(); int dao = 0; bool hello = false; int i = 0; while(i&lt;v.size()){ if(hello) i=0; if(minVal==maxVal) break; int sum = 0; bool flag = true; int minVal1=v[i]; for(int j=v.size()-1;j&gt;i;--j){ sum = sum+(v[j]-minVal1); if(sum&gt;k){ flag = false; break; } } if(flag){ dao++; hello = true; for(int g=v.size()-1;g&gt;i;g--){ v[g] = v[g]-(v[g]-minVal1); } } maxVal=v.back(); i++; } cout&lt;&lt;dao; return 0;}","link":"/2019/03/16/ck7yp1q4q000ixsunqacn8bv1/"},{"title":"Linear Regression","text":"就从最简单的线性回归模型（Linear Regression model）开始学习吧。 从这个模型的名字我们可以看出，因变量和变量之间的关系是线性的，预测值可以通过计算输入特征的权重给出： \\hat{y} = \\theta_0+\\theta_1x_1+\\theta_2x_2+...+\\theta_nx_n其中，$\\hat{y}$是预测值，$n$是特征数量，$\\theta_0$是bias，$x_i$是第$i$个特征值，$\\theta_j$是第$j$个特征的模型参数。如果获取了模型的所有参数，给定一个样本我们就可以用上面这个公式模型得到预测值。 为了表达更简洁，一般用向量表示： \\hat{y} = h_{\\mathbf{\\theta}}(\\mathbf{x}) = \\mathbf{\\theta}^T \\mathbf{x}其中$h_{\\mathbf{\\theta}}()$是hypothesis function是关于$\\mathbf{\\theta}$的假设函数，$\\mathbf{\\theta} = [\\theta_0;\\theta_1;…;\\theta_n]$，$\\mathbf{x} = [x_0, x_1, x_2, …, x_n]$并且$x_0=1$。 我们的目标当然是想要所有预测值都跟实际值相等，因此，目标函数或者称代价函数建模为： \\text{MSE}(\\mathbf{X},h_{\\mathbf{\\theta}}) = \\frac{1}{m}\\sum_{i=1}^{m}\\left(\\mathbf{\\theta}^T\\cdot\\mathbf{x}^{(i)}-y^{(i)}\\right)^2其中$\\mathbf{X}$为所有样本的集合，数量为$m$。 标准闭式解 基于均方误差最小化来进行模型求解的方法称为“最小二乘法”（least square method）。在线性回归中，最小二乘法就是试图找到一条直线，使所有样本到直线上的欧氏距离之和最小。 一般地，我们利用最小二乘法对$\\mathbf{\\theta}$进行估计。数据集$\\mathbf{X}$表示为： \\mathbf{X}=\\left( \\begin{array}{ccc} 1 & x_{11} & x_{12} & \\cdots\\ & x_{1d}\\\\ 1 & x_{21} & x_{22} & \\cdots\\ & x_{23} \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\\\\ 1 & x_{m1} & x_{m2} & \\cdots\\ & x_{md}\\\\ \\end{array} \\right) =\\left( \\begin{array}{ccc} 1 & \\mathbf{x}_1^T \\\\ 1 & \\mathbf{x}_2^T \\\\ \\vdots & \\vdots \\\\ 1 & \\mathbf{x}_m^T \\\\ \\end{array} \\right) 然后把实际值也写成向量模式$\\mathbf{y}=(y_1;y_2;…;y_m)$，因此优化问题为： \\mathbf{\\theta}^*=\\underset{\\mathbf{\\theta}}{\\text{arg}\\min}(\\mathbf{y}-\\mathbf{\\theta}^T\\mathbf{X})^T(\\mathbf{y}-\\mathbf{\\theta}^T\\mathbf{X}) 令$E_{\\mathbf{\\theta}}=(\\mathbf{y}-\\mathbf{\\theta}^T\\mathbf{X})^T(\\mathbf{y}-\\mathbf{\\theta}^T\\mathbf{X})$，对$\\mathbf{\\theta}$求导可得： \\frac{\\partial E_{\\mathbf{\\theta}}}{\\partial \\mathbf{\\theta}}=2\\mathbf{X}^T(\\mathbf{\\theta}^T\\mathbf{X}-\\mathbf{y}) 令上式等于0可解得 \\mathbf{\\theta}^*=(\\mathbf{X}^T\\mathbf{X})^{-1}\\mathbf{X}^T\\mathbf{y} 如果$\\mathbf{X}^T\\mathbf{X}$不可逆怎么办，这可能是由于矩阵中存在冗余特征，在线性代数里说明矩阵并非线性不相关，因此可以删除多余特征；也有可能是由于特征数大于等于样本数，也就是$m \\le n$，可以通过删除一些特征或者使用正则化（regularization，后续介绍）。 给出python一个实现例子如下： 12345678910111213141516171819import numpy as np X = 2 * np.random.rand(100, 1)y = 2 + 6 * X + np.random.randn(100, 1)X_b = np.c_[np.ones((100, 1)), X] # add x0 = 1 to each instancetheta_best = np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(y)print(theta_best)# [[1.74568681] [6.27246194]]X_new = np.array([[0], [2]])X_new_b = np.c_[np.ones((2, 1)), X_new] # add x0 = 1 to each instancey_predict = X_new_b.dot(theta_best)print(y_predict) #[[ 1.74568681] [14.29061069]]plt.plot(X_new, y_predict, &quot;r-&quot;)plt.plot(X, y, &quot;b.&quot;)plt.axis([0, 2, 0, 15])plt.show() 如果用sklearn实现的话，代码如下：12345678&gt;&gt;&gt; from sklearn.linear_model import LinearRegression&gt;&gt;&gt; lin_reg = LinearRegression()&gt;&gt;&gt; lin_reg.fit(X, y)&gt;&gt;&gt; lin_reg.intercept_, lin_reg.coef_(array([ 4.21509616]), array([[ 2.77011339]]))&gt;&gt;&gt; lin_reg.predict(X_new)array([[ 4.21509616],[ 9.75532293]]) 这种方式实现的计算复杂度只要在矩阵求逆上，对于一个$n \\times n$的矩阵，求逆复杂度大约是$O(n^{2.4})$到$O(n^{3})$，当特征数量很大时（比如100,000以上时），标准闭式解会变得很慢；另一方面，对于样本数量其复杂度是$O(m)$，也就是线性的；此外，模型训练完成后，预测的复杂度对于样本数量和特征数量复杂度都很快。 梯度下降法 梯度下降法是十分常用的优化算法，目的是通过迭代过程不断更新参数进而最小化代价函数，每次优化的方向都是斜率绝对值最大的方向。Note： 需要谨慎选择步长（step size）或者叫做学习率（learning rate），太小的话，需要许多次迭代才能走到最优点，而步子太大，则有可能跨过最优点，然后陷入震荡。 凸优化问题找到最优点比较容易，而非凸问题则容易陷入局部最优点或者陷入平台（plateau)。线性回归问题是个凸优化问题。 最好在使用梯度下降法前对数据进行标准化处理，不然“碗”太长需要更多的迭代次数。 问题参数越多，维度越大，参数空间越大，搜索最优解也就越难。 Batch Gradient Descent Batch是批的意思，批梯度下降就是在每次迭代过程中把所有数据都来计算代价函数的偏导，也就是梯度。代价函数对于参数$\\theta_j$的偏导为： \\frac{\\partial \\text{MSE}(\\theta)}{\\partial{\\theta}_j}=\\frac{2}{m}\\sum_{i=1}^{m}\\left(\\theta^T \\cdot \\mathbf{x}^{(i)}-y^{(i)}\\right)x_j^{(i)} 用向量来表示梯度下降为： \\nabla_{\\theta}\\text{MSE}(\\theta)=\\left( \\begin{array}{ccc} \\frac{\\partial \\text{MSE}(\\theta)}{\\partial \\theta_0}\\\\ \\frac{\\partial \\text{MSE}(\\theta)}{\\partial \\theta_1}\\\\ \\vdots\\\\ \\frac{\\partial \\text{MSE}(\\theta)}{\\partial \\theta_0} \\end{array} \\right) =\\frac{2}{m}\\mathbf{X}^T\\cdot(\\mathbf{X}\\cdot \\theta-\\mathbf{y}) 由此，我们可以得到梯度下降的步骤： \\theta^{(n+1)} = \\theta^{(n)}-\\eta \\nabla_{\\theta}\\text{MSE}(\\theta) 推导出这个公式之后就可以实现了：1234567eta = 0.1 # learning raten_iterations = 1000m = 100theta = np.random.randn(2,1) # random initializationfor iteration in range(n_iterations): gradients = 2/m * X_b.T.dot(X_b.dot(theta) - y) theta = theta - eta * gradients Stochastic Gradient Descent 在前面讲过，BGD在每次迭代中是把所有数据都用于计算的，因此当数据量很大时，算法会变得难以忍受的慢，因此需要使用其他梯度下降算法。随机梯度下降法跟批梯度下降是两个极端，SGD在每次迭代中会随机从训练集中选择一个样本，然后只用这个样本计算并更新梯度。因此，这个算法计算比BGD快很多很多；但也由于其随机特性，优化曲线不会“直接”向着最优点前进，而是来回波动，但最终会抵达最优值附近。其算法如下图所示： Python实现如下：1234567891011121314n_epochs = 50t0, t1 = 5, 50 # learning schedule hyperparametersdef learning_schedule(t):return t0 / (t + t1)theta = np.random.randn(2,1) # random initializationfor epoch in range(n_epochs): for i in range(m): random_index = np.random.randint(m) xi = X_b[random_index:random_index+1] yi = y[random_index:random_index+1] gradients = 2 * xi.T.dot(xi.dot(theta) - yi) eta = learning_schedule(epoch * m + i) theta = theta - eta * gradientsprint(theta) 如果用sklearn来实现的话，代码就简单多了：1234from sklearn.linear_model import SGDRegressorsgd_reg = SGDRegressor(n_iter=50, penalty=None, eta0=0.1)sgd_reg.fit(X, y.ravel())print(sgd_reg.intercept_, sgd_reg.coef_) NOTE: epoch是指把所有数据样本都遍历一遍，iteration表示更新一次参数，batch则是指数据样本的大小，在SGD中，iteration=batch=1，epoch=num_X/batch Mini-batch Gradient Descent Mini-batch GD介于SGD和BGD之间，也就是每次用来更新参数的样本不是一也不是所有（吴恩达说在2-400之间，他倾向于用10），它吸收了BGD和SGD的优缺点的折中，收敛更快，随机性较小，但也难抵达最优值，其算法流程如下图所示： 这里介绍的标准闭式解只适用于线性回归问题，但梯度下降法可以用来训练许多模型，在深度学习中也有广泛应用，将他们比较如下： Algorithm Large m Out-of-core Support Large n Hyperparameters Scaling Required Sklearn Normal Equation Fast No Slow 0 No LinearRegression Batch GD Slow No Fast 2 Yes n/a Stochastic GD Fast Yes Fast $\\ge$2 Yes SGDRegressor Mini-batch GD Fast Yes Fast $\\ge $2 Yes n/a Polynomial Regression 如果数据并非一条直线呢，那么还可以用线性模型吗？实际上是可以的，主要方法就是把一个特征拓展成多维的，比如$x^2, x^3,…, x^k$，然后将其作为另一个维度的特征，比如$x_1 = x, x_2 = x^2$，那么就可以用线性模型按照上面的方法进行训练了，用sklearn实现如下： 1234567891011121314151617181920import numpy as npimport matplotlib.pyplot as pltfrom sklearn.preprocessing import PolynomialFeaturesfrom sklearn.linear_model import LinearRegressionm = 100X = 6 * np.random.rand(m, 1) - 3y = 1 * X**2 + X + 2 + np.random.randn(m, 1)plt.scatter(X, y)poly_features = PolynomialFeatures(degree=2, include_bias=False)X_poly = poly_features.fit_transform(X)lin_reg = LinearRegression()lin_reg.fit(X_poly, y)print(lin_reg.intercept_, lin_reg.coef_)xx = np.array((range(-3, 4)))print(xx)yy = xx*0.98134428+xx*xx*0.94365742+1.94555083plt.plot(xx, yy, c=&apos;r&apos;)plt.show() 此外，需要注意，PolynomialFeatures(degree=d)会把一个包含n个特征的矩阵转化为包含$\\frac{(n+d)!}{d!n!}$个特征的矩阵，即如果对于两个特征a和b，令degree=3，那么特征不仅有$a^2$，$a^3$，$b^2$，$b^3$，还会有$ab$，$a^2b$和$ab^2$.","link":"/2018/11/28/ck7yp1q4g000axsunfh6ga0qk/"},{"title":"How to Make a Visual Mark Up and Revision of Significant Differences between Two Latex Files by Latexdiff","text":"Recently my survey was rejected and required minor revision, while I have to submit a revised article with the “editing mode” feature turned on. Because I use Miktex+Texstudio to edit my paper in windows 10, Latexdiff is considered of course. Latexdiff is a Perl script for visual mark up and revision of significant differences between two LATEX files. Various options are available for visual mark up using standard LATEX packages such as color. Changes not di­rectly af­fect­ing vis­i­ble text, for ex­am­ple in for­mat­ting com­mands, are still marked in the LATEX source. A rudi­men­tary re­vi­sion fa­cilil­ity is pro­vided by an­other Perl script, la­texre­vise, which ac­cepts or re­jects all changes. Man­ual edit­ing of the dif­fer­ence file can be used to over­ride this de­fault be­haviour and ac­cept or re­ject se­lected changes only. Step 1:For a pure rookie, first of all, you need to install CTEX (for Chinese users) or Miktex. Step 2:Then, win+R and open cmd, input command latexdiff, if returns 12 and only 2 non-option arguments required. Write latexdiff -h to get help Congrats! You have successfully installed latexdiff and you can turn to Step 3.3. Step 3:Otherwise, don’t worry, I encountered the same situation as you. Do as follows. 3.1 Install Latexdiff PackageAfter you install a Tex, open Start Menu-&gt;Ctex or Miktex-&gt;Package Manager (Admin). Search Latexdiff in column Name: as follows Click the + button and install it. 3.2 Install PerlLatexdiff is a Perl script, so you can go to Perl download corresponding version in your computer. Technically, ActivePerl and StrawberryPerl is both ok. Same steps in Step 2, if you have problem as 12latexdiff: The Perl script could not be found. latexdiff: Data: scripts/latexdiff/perl/latexdiff.pl It’s a common problem and you can find the answer in 这里 or Here. It is worth mentioning that if you have the following problem which confused me for a long time 12latexmk: the script engine could not be found latexdiff: data: scriptengine=&quot;perl.exe&quot; Actually I have no idea how I successfully solve it. You may do the trials as what I have done. Check the System Path of Perl and Tex, especially according to x86 or x64 Reinstall Perl, if not work, change to ActivePerl or StrawberryPerl Restart your windows after you make some changes 3.3 LatexdiffPut your origin tex version (e.g., old.tex) and your modified tex version (e.g., new.tex) in a same file. cmd to this path, and input 1latexdiff old.tex new.tex &gt;diff.tex where diff.tex is the editted version, add the required files to this path and compile it. Then you can have the results If you encounter some errors in compiling, just google it because they are just some common LATEX errors. Enjoy. !!!Tips: if you suffer any problem, first go to google or baidu it. Please discover the truth by yourself.","link":"/2018/06/19/ck7yp1q4d0008xsunakrobd4n/"},{"title":"A Stupid Mistake I Made about Sorting in Python DataFrame","text":"One day when I try to sort a DataFrame by a column, an amazing mistake happens!I will reproduce this stupid thing here. Firstly, make a dataframe example: 12345 a b c0 9 4 61 2 7 52 5 -3 83 1 2 3 123frame = pd.DataFrame({&quot;a&quot;:[9,2,5,1],&quot;b&quot;:[4,7,-3,2],&quot;c&quot;:[6,5,8,3]})frame.sort_values(&apos;a&apos;,inplace=True)print(frame) What do you think the result will be? What I expect it will get is like this: 12345 a b c3 1 2 31 2 7 52 5 -3 80 9 4 6 However, what I actually get is 12345 a b c0 9 4 61 2 7 52 5 -3 83 1 2 3 I get really confused, so I try all the arg in function DataFrame.sort_values(by, axis=0, ascending=True, inplace=False, kind=’quicksort’, na_position=’last’) I find out that only if the inplace= is set to True, the result is as expected. But the usage of this function I searched in google, did not meantion this parameter. Therefore, I look for an instruction of inplace， and I find that the inplace parameter is a generic term w.r.t pandas and not specific to sort_values alone. You can see it in several functions like pd.fillna, pd.replace etc. Whenever the inplace is set to True, it modifies the existing data frame and you need not assign it to a new data frame. Ohhhh… Then I find out where the mistake really lies in. In my previous code, the DataFrame frame I sorted has not been modified only if the parameter inplace is set to True, so I modify the code as follow: 123frame = pd.DataFrame({&quot;a&quot;:[9,2,5,1],&quot;b&quot;:[4,7,-3,2],&quot;c&quot;:[6,5,8,3]})df = frame.sort_values(&apos;a&apos;,inplace=True)print(df) The problem is solved! How stupid I was!","link":"/2018/06/12/ck7yp1q420001xsunfmw20ikh/"},{"title":"Hexo: setup a static blog","text":"​ Before we start, you have to know what is the difference between static site and dynamic site. Let’s take a look at the definition in Wiki: A static web page (sometimes called a flat page/stationary page) is a web page that is delivered to the user exactly as stored, in contrast to dynamic web pages which are generated by a web application. Consequently, a static web page displays the same information for all users, from all contexts, subject to modern capabilities of a web server to negotiate content-type or language of the document where such versions are available and the server is configured to do so. It’s pros and cons are listed as follows: Advantages of a static website Provide improved security over dynamic websites Improved performance for end users compared to dynamic websites Fewer or no dependencies on systems such as databases or other application servers Disadvantages of a static website Dynamic functionality has to be added separately ​ Dynamic site is not our topic here. I wil talk about how to deploy a hexo blog in Github repository under the environment of Window 10. 1. Github initialization​ From the very beginning, you have to create a GitHub account and new a repository, note that the repository name need to be the same with your owner name (the alarm is appeared cause I have already newed a same one). REMEMBER the repository address (two kinds of address—- SSH: git@github.com:dlc1994/dlc1994.github.io.git and HTTPS: https://github.com/dlc1994/dlc1994.github.io.git). The configuration of SSH can be seen in here, and HTTPS has no need of extra operation. Install Git tool and the rest of operations is done through this tool. 2. Install the necessary componentsAfter that, install Node.js, in case of the low speed, you can also download it in here. Now it’s time to install Hexo in your machine, click right-hand button anywhere and open Git Bash, then input 12npm install hexo-cli -gnpm install hexo-deployer-git --save Wait a minute you can check if the component is installed successfully. Input directly in Git Bash, or Win+R and input cmd, then input codes as follow: 123git --versionnode -vnpm -v If return the version number then you can go on, otherwise just google your mistake during your installation. After Hexo is installed, go to the place where you want to save your blog and open Git Bash. Input hexo init, you can find that a lot of files are created. 3. Create your first blogUse file editor like Notepad++, open file _config.yml, find the codes and edit it as you want 123456789101112131415# Sitetitle: DLC&apos;s Blog #your blog namesubtitle: Find myself in the darkest place #your blog subtitledescription: Personal Blog #description of your blogkeywords:author: language: timezone: Asia/Shanghaitheme: landscape #your blog theme, I will talk about how to change it to `Next`deploy: type: repository: git@github.com:dlc1994/dlc1994.github.io.git #your repository address branch: master In Git Bash, input hexo g and hexo s, it will return (perfectly) Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. Open your browser and input localhost:4000 in address bar, you can see that (Ok it is really ugly) Lastly, you have to deploy it to your github repository, continue to input hexo d. Luckily, there is no error and you can see it in your repository address like git@github.com:dlc1994/dlc1994.github.io.git. If not, go to google for help. Create a new blog use hexo new &quot;postname&quot; or in your blog path blogpath\\source\\_posts new a .md file and edit it use Markdown (Typora is recommended here). More commands can be found here. I will update the process of blog beautification in my next blogs. !!!Tips: if you suffer any problem, first go to google or baidu it. Please discover the truth by yourself.","link":"/2018/06/12/ck7yp1q4a0005xsuntwcmr0g8/"}],"tags":[{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"DataFrame","slug":"DataFrame","link":"/tags/DataFrame/"},{"name":"Sorting","slug":"Sorting","link":"/tags/Sorting/"},{"name":"Binary Tree","slug":"Binary-Tree","link":"/tags/Binary-Tree/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"C/C++","slug":"C-C","link":"/tags/C-C/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Latex","slug":"Latex","link":"/tags/Latex/"},{"name":"Algorithms","slug":"Algorithms","link":"/tags/Algorithms/"},{"name":"Linear Regression","slug":"Linear-Regression","link":"/tags/Linear-Regression/"},{"name":"Polynomial Regression","slug":"Polynomial-Regression","link":"/tags/Polynomial-Regression/"},{"name":"Gradient Decent Methods","slug":"Gradient-Decent-Methods","link":"/tags/Gradient-Decent-Methods/"},{"name":"Matlab","slug":"Matlab","link":"/tags/Matlab/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"LinkedList","slug":"LinkedList","link":"/tags/LinkedList/"},{"name":"Map","slug":"Map","link":"/tags/Map/"},{"name":"Database","slug":"Database","link":"/tags/Database/"},{"name":"Postgresql","slug":"Postgresql","link":"/tags/Postgresql/"},{"name":"Postgis","slug":"Postgis","link":"/tags/Postgis/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Wireless communications","slug":"Wireless-communications","link":"/tags/Wireless-communications/"}],"categories":[{"name":"Data Processing","slug":"Data-Processing","link":"/categories/Data-Processing/"},{"name":"Algorithm and Data Structure","slug":"Algorithm-and-Data-Structure","link":"/categories/Algorithm-and-Data-Structure/"},{"name":"HEXO","slug":"HEXO","link":"/categories/HEXO/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/categories/Machine-Learning/"},{"name":"Paper Work","slug":"Paper-Work","link":"/categories/Paper-Work/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"Competition","slug":"Competition","link":"/categories/Competition/"},{"name":"Wireless Communications","slug":"Wireless-Communications","link":"/categories/Wireless-Communications/"},{"name":"Development","slug":"Development","link":"/categories/Development/"}]}