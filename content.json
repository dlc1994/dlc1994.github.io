{"pages":[{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"戴凌成（Lingcheng Dai)","text":"个人信息 手机：(+86)XXXXXXXXX Email：dailingcheng@foxmail.com 技术博客：https://dlc1994.github.io Github: https://github.com/dlc1994 教育经历北京邮电大学 信息与通信工程学院 信息与通信工程 工学硕士 2017.09-2020.06北京邮电大学 信息与通信工程学院 通信工程 工学学士 2013.09-2017.06 工作经历华为技术有限公司 华为云Cloud BU 调度优化算法工程师 2020.07 - For now[实习]华为技术有限公司 华为云Cloud BU 调度优化算法工程师 2019.07 - 2019.09 利用PostgreSQL+PostGIS 部署地图查询服务，优化基于交互投票的路网匹配算法、设计关键点提取算法； 调研并初步构建首汽共享汽车的多网点租还需求预测、网点间均衡调度与VRP 问题以解决潮汐现象； [实习]北京佰才帮技术有限公司 协议栈开发工程师 2019.02 - 2019.03 负责5G/LTE小基站上Layer2/Layer3（MAC、PDCP、RLC和RRC等）协议栈的研究、设计工作； 负责在CentOS上编写Makefile完成C代码工程中若干个库的编译和静态库封装； 负责完成一些代码整合、移植和混淆工作。 竞赛经历中国第二届高性能云计算创新大赛—区块链地址分类数据算法竞赛 二等奖 2019.07 从超过4000 万条比特币交易数据中提取与地址类别相关的交易特征（交易笔数、矿工费、时间等） 根据任务+交易特性结合随机森林模型+多进程搜索进行比特币地址标记分类，预测准确率达99.99% 百度&amp; 西安交大国际大数据竞赛城市功能区域分类 59/2037 2019.06 给定城市若干类功能区域的带噪遥感图像与用户访问数据，对图像进行去噪+访问数据矩阵化 设计双分支网络（ImageNet 预训练模型+微调）进行融合并使特征向量维度相同，预测准确率达0.67 中国“易华录杯”CCF软件服务创新大赛——公交线路准点预测 三等奖 2018.09 对天津市公交车超过4亿条GPS记录进行数据处理，构建天气、日期等特征并进行one-hot编码 调用XGBoost 进行训练，预测结果再与平均值线性叠加后乘以拥堵系数，输出公交车站点间运行时间 北邮、北师、中农大校园大数据竞赛——校园人流量预测 5% 2018.03 提取校园内33个地点10个月内采集的所有手机终端位置的数据，利用数据挖掘平台WEKA，对常用时间序列分析模型比如ARIMA,ARCH等进行分析 考虑课程、节假日对人流量的影响，不断修正预测模型及模型参数，最终对11月和12月校园内33个地点每小时的人数进行预测。 科研项目华为HIRP项目“基于机器学习的免传模一键式站址规划” 2018.01 - 2019.01独立完成从原始数据文件中用python提取数据，利用开源库Scikit-learn中的机器学习算法比如SVM、k近邻、神经网络等，在CentOS服务器上训练得到电平预测模型，最后利用遗传算法（开源框架GAFT）和贪心算法对基站覆盖率进行在线优化，确定基站最优部署参数。工程代码达上千行。 华为HIRP项目“以用户为中心网络下的资源管理和干扰协同研究” 2017.09-2018.08独立完成在以用户为中心的多天线超密组网下，基于WMMSE设计了一种低复杂度的分布式聚簇和波束赋形算法，通过块对角化方法将原始NP-hard非凸问题分解为各簇各变量的凸优化问题，再采用拉格朗日乘数法求解，最后在Matlab上进行系统级仿真，提升了边缘用户速率。 中兴项目“超密组网下的用户移动性预测研究” 2017.08-2018.06独立完成对现有学术界移动性预测方案的调研，对当前移动性预测采用的方案进行了详细总结，包括（隐）马尔科夫过程、贝叶斯网络、数据挖掘和神经网络等，并提出移动性预测在未来5G及6G路径规划、移动性优化、辅助定位上的应用和挑战，以及深度学习可能带来的巨大性能提升。 发表作品 &lt;学生一作&gt;, “Multi-Branch Deep Residual Learning for Clustering and Beamforming in User-Centric Network,” IEEE Communications Letters, early access, Jul. 2020.（SCI，影响因子3.457） &lt;学生一作&gt;, “Pricing-Based Semi-Distributed Clustering and Beamforming for User-Centric MIMO Networks,” IEEE Communications Letters, vol. 23, no. 12, pp. 2398-2401, Dec. 2019.（SCI，影响因子3.457） &lt;第一作者&gt;, “Propagation-Model-Free Base Station Deployment for Mobile Networks: Integrating Machine Learning and Heuristic Methods,” IEEE Access, vol. 8, pp. 83375-83386, 2020.（SCI，影响因子3.557） &lt;学生一作&gt;, “Mobility Prediction: A Survey on State-of-the-Art Schemes and Future Applications,” IEEE Access, vol. 7, pp. 802-822, 2019.（SCI，影响因子3.557） &lt;第一作者&gt;, “Decentralized Clustering and Beamforming Based on Interference Pricing in User-Centric Networks,” in IEEE PIMRC, Istanbul, Turkey, 2019, pp. 1-6.（EI，B类会议） &lt;第一作者&gt;, “Propagation-model-free Coverage Evaluation via Machine Learning for Future 5G Networks,” in IEEE PIMRC, Italy, 2018, pp. 1-5.（EI，B类会议） 获奖经历 2019-2020 北京邮电大学优秀毕业生 2017-2019 国家奖学金、一等学业奖学金 2015-2016 国家励志奖学金、校“三好学生”、优秀共青团员 技能 专业知识：人工智能、智能优化、移动通信 程序开发：C++/Python/Matlab 排版编辑：LaTex/Markdown/MS Office 操作系统：Linux/Windows 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。","link":"/about/index.html"},{"title":"LeetCode--Two Sum","text":"Description of Problem: Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice.Example:1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].&gt; Approach 1: Brute Force1234for i in range(0,len(nums)-1): for j in range(i+1,len(nums)): if nums[i]+nums[j]==target: return [i,j] running time: 5640ms Approach 2: Python List.index1234for i in range(len(nums)): if (target-nums[i]) in nums: if (nums.index(target - nums[i])) != i: return [i, nums.index(target - nums[i])] running time: 1072ms Approach 3: Python Dict123456dict = {}for i in range(len(nums)): if (target-nums[i]) in dict: return [dict[(target-nums[i])], i] else: dict[nums[i]]=i running time: 40ms Approach 4: Enumerate+Hash_Table12345hash_table={}for i, value in enumerate (nums): if target-value in hash_table: return hash_table[target-value], i hash_table[value]=i running time: 40ms","link":"/drafts/LeetCode--Two Sum.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"机器学习笔记","text":"机器学习笔记精编版，秋招时的学习笔记 传统机器学习Logistic Regression和percetron的异同 二者都是线性分类器 损失函数不同，LR是极大似然（交叉熵，对数似然函数，logistic损失（误差平方和损失）目标函数非凸），感知机使用的是均方损失函数（即最小化错误点到分离平面的距离） 逻辑斯蒂比感知机的优点在于对于激活函数的改进。LR为sigmoid函数，连续可导，概率解释能力，分类更好感知机为阶跃函数，分段函数，分类粗糙，线性分类器参数学习，错误驱动的在线学习算法损失函数L(w;x,y)=max(0, -ywx),如果训练集线性可分，算法必定收敛不足：1.泛化能力不能保证；2.样本顺序敏感；3.不线性可分不收敛改进：参数平均：投票感知机、平均感知机拓展到多分类：构建输入输出联合空间特征函数，将样本(x,y)映射到特征向量空间C分类问题，特征函数φ(x,y)=vec(yx),y为类别的one-hot向量表示 LR的最大损失函数推导最大似然概率p(x|θ) 是条件概率的表示方法，θ 是前置条件，理解为在 θ 的前提下，事件 x 发生的概率，相对应的似然为L(θ|x)可以理解为已知结果为 x ，参数为 θ对应的概率，即：L(θ|x)=P(x|θ)需要说明的是两者在数值上相等，但是意义并不相同，L 是关于 θ 的函数，而 P 则是关于 x 的函数机器学习领域，我们更关注的是似然函数的最大值，我们需要根据已知事件来找出产生这种结果最有可能的条件，目的当然是根据这个最有可能的条件去推测未知事件的概率对数函数不改变原函数的单调性和极值位置，而且根据对数函数的性质可以将乘积转换为加减式，这可以大大简化求导的过程： SVM 线性可分支持向量机（硬间隔） 线性支持向量机（软间隔）线性可分支持向量机的解W唯一但b不唯一线性支持向量机学习等价于最小化二阶范数正则化的合页函数合页损失函数（正确分类且函数间隔大于1，损失为0，max(z,0)） 非线性支持向量机通过非线性变换转化为高维特征空间中的线性分类问题，即核函数 序列最小化优化（SMO）算法支持向量机的学习快速算法，固定αi之外的所有参数，然后求αi上的极值；不断重复直至收敛。 和LR的异同（https://www.cnblogs.com/zhizhan/p/5038747.html） 不考虑核函数，LR和SVM都是线性分类算法，分类决策面是线性的 本质是损失函数不同，LR是对数似然函数（基于概率），SVM是合页损失函数（基于几何间隔） SVM只考虑边界点，LR考虑全局，所以LR一般不用核函数 SVM依赖数据距离测度，需要先做normalization，LR不受影响 SVM损失函数自带正则（结构风险最小化），LR需要添加 One-Hot Encoding （dummy variables) 一组编码[0 0 1 0]，一个为1其他为0，处理离散分类特征 许多算法基于向量空间计算，取值拓展到欧氏空间，扩充特征 特征空间大时，可结合PCA 树模型不太需要one-hot编码，对DT来说是增加树的深度 生成模型 监督生成模型朴素贝叶斯、隐马尔科夫、条件随机场 非监督生成模型受限玻尔兹曼机、GAN、自回归、变分自编码器、深度信念网络 模型融合：Stacking 和 Blending Stacking stacking是一种分层模型集成框架。以两层为例，第一层由多个基学习器组成，其输入为原始训练集，第二层的模型则是以第一层基学习器的输出作为特征加入训练集进行再训练，从而得到完整的stacking模型。 样例：假设我们有Training data（有label）和Testing data（无label），我们需要建立起模型对Testing data的label进行预测，我们利用两个基模型KNN和SVM进行stacking，首先我们需要训练好两个基模型 一、KNN（Base model 1） 5-fold Cross-Validation + Grid Search确定K的大小 二、SVM（Base model 2） 5-fold Cross-Validation + Grid Search确定参数 type 和 cost 三、Stacking（Meta Ensembling）将training data划分成5个testing folds为training data和testing中的每一个样本添加空属性M1、M2（model 1、2的输出），记为train_meta 和 test_meta对于每一个test fold:3.1)将其他4个folds作为一个traing fold，将此training fold作为model 1的输入，对test fold进行预测，将结果存放进train_meta的M1中，类似model 2 的结果存在M2中3.2)将整个training data作为base model的输入，对testing data进行预测，model 1、2的结果分别存在test_meta的M1、M2中将train_meta作为一个新模型S（也就是stacking model）的输入，对test_meta进行预测 stacking方法从一开始就得确定一个Kfold，这个Kfold将伴随对基模型的调参、生成元特征以及对元模型的调参，贯穿整个stacking流程 Blending Blending与Stacking大致相同，只是Blending的主要区别在于训练集不是通过K-Fold的CV策略来获得预测值从而生成第二阶段模型的特征，而是建立一个Holdout集，例如10%的训练数据，第二阶段的stacker模型就基于第一阶段模型对这10%训练数据的预测值进行拟合。说白了，就是把Stacking流程中的K-Fold CV 改成 HoldOut CV。 Adaboost,XGBoost,Bagging,LightBoost Boost算法 初始样本权重，每次训练得到模型赋予错分样本更大的权重，N次迭代后对N个模型进行加权叠加或投票，得到预测结果；串行过程，不好并行化，计算复杂度高，不适合高维稀疏特征 XGBoost GBDT以CART作为基分类器，XGBoost支持线性分类器（L1，L2的逻辑回归或线性回归） GBDT优化使用一阶导数，XGBoost对代价函数进行二阶泰勒展开，支持自定义代价函数 XGBoost加入正则项，包括树的叶子节点个数、叶子节点上score值（正则化是从bias-variance考虑，可以降低模型variance，降低模型复杂度，防止过拟合，传统GBDT没有?） 列采样（每个模型随机选取一些列），借鉴随机森林，目的是降低过拟合 Shrinkage（缩减），相当于学习速率（xgboost中的eta）。xgboost在进行完一次迭代后，会将叶子节点的权重乘上该系数，主要是为了削弱每棵树的影响，让后面有更大的学习空间 并行化。不是像bagging，仍然是boost方式，并行是在特征排序上， xgboost在训练之前，预先对数据进行排序，然后保存成block结构，后面的迭代中重复的使用这个结构，大大的减少了计算量。在进行节点分裂时，计算每个特征的信息增益，各个特征的增益计算就可以开多线程计算。 分裂节点公式： lightGBM 训练速度更快，效率更高。 降低内存使用率。 更好的准确性。 支持并行和GPU学习。 能够处理大规模数据。 与XGBoost GBDT区别：xgboost采用预排序算法进行特征分割，比较简单；LightGBM用的是histogram（直方图），将连续特征（属性）值存储到离散的bin中，加快训练速度和减少内存使用量稀疏特征优化xgboost是level-wise，多线程同时分类同一层叶子，但不加区分，开销大；lightGBM是leaf-wise的，每次找分类增益最大进行分裂，限制最大深度，防止过拟合并行优化（feature parallel, data parallel, voting parallel） GBDT GBDT用的回归树 GBDT 是以决策树为基学习器、采用 Boosting 策略的一种集成学习模型 与提升树的区别：残差的计算不同，提升树使用的是真正的残差，梯度提升树用当前模型的负梯度来拟合残差。 核心是每棵树学习的是之前所有树结论和的残差，所有树累加起来做最终结论 本质上，Shrinkage为每棵树设置了一个weight，累加时要乘以这个weight，但和Gradient并没有关系。 随机森林 Bagging的典型应用；随机采样（行、列），防止过拟合；剪枝、限制树深度优点 在当前的很多数据集上，相对其他算法有着很大的优势，表现良好 它能够处理很高维度（feature很多）的数据，并且不用做特征选择 PS：特征子集是随机选择的 在训练完后，它能够给出哪些feature比较重要 PS：http://blog.csdn.net/keepreder/article/details/47277517 在创建随机森林的时候，对generlization error使用的是无偏估计，模型泛化能力强 训练速度快，容易做成并行化方法 PS：训练时树与树之间是相互独立的 在训练过程中，能够检测到feature间的互相影响 实现比较简单 对于不平衡的数据集来说，它可以平衡误差。 如果有很大一部分的特征遗失，仍可以维持准确度。缺点：1、随机森林已经被证明在某些噪音较大的分类或回归问题上会过拟合2、对于有不同取值的属性的数据，取值划分较多的属性会对随机森林产生更大的影响，所以随机森林在这种数据上产出的属性权值是不可信的。 决策树 决策树学习算法：特征选择、决策树的生成、剪枝（条件概率分布） ID3算法：信息增益；C4.5：信息增益比 CART分类：基尼系数；CART回归：平方损失函数，用平方误差最小的准则（最小二乘法）求解每个单元上的最优输出值（每个叶子节点上的预测值为所有样本的平均值）。 决策树的生成通常使用 信息增益最大、信息增益比最大或基尼指数最小作为特征选择的准则。 过拟合和欠拟合 正则化 L1（L=∑|w|）和L2(L=||w||^2)；L1的稀疏性，指的就是在加了L1正则项后，模型的解w，有很多分量都是0。引入L2正则时，代价函数在0处的导数仍是d0，无变化。而引入L1正则后，代价函数在0处的导数有一个突变。从d0+λ到d0−λ，若d0+λ和d0−λ异号，则在0处会是一个极小值点。代价函数求导。因此，优化时，很可能优化到该极小值点上，即w=0处。 提前停止 当测试集误差不再下降时停止可以避免过拟合 dropout 偏差-方差分解 在模型能力和复杂度之间取得一个较好的平衡 偏差高，模型拟合能力不够：增加数据特征、提高模型复杂度、减少正则化系数 方差高，模型过拟合（训练集错误低，验证集错误高）：降低模型复杂度，加大正则化系数，引入先验、集成模型 参数估计 经验风险最小化 真实标签与预测标签的差异；最小二乘估计（最小均方误差）；XX^T必须满秩，即rank(XX^T)=d+1，X中每行特征之间线性不相关；样本数小于特征数也不可逆，存在多组解；当XX^T不可逆时，可用PCA消除相关性 结构风险最小化 正则化；岭回归（w=(XX^T+λI）^(-1)Xy，使其秩不为0，可看出结构风险最小化准则的LSE； 最大似然估计 MLE是指找到一组参数w使得似然函数p(y|X,w, σ) 最大，等价于对数似然函数log p(y|X,w, σ) 最大。 最大后验估计 贝叶斯估计；MAP是指最优参数为后验分布p(w|X, y, ν, σ) 中概率密度最高的参数w。当ν → ∞时，先验分布p(w|ν) 退化为均匀分布，称为无信息先验（non-informative prior），最大后验估计退化为最大似然估计。 损失函数交叉熵（cross entropy) https://blog.csdn.net/mieleizhi0522/article/details/80200126 特征工程 特征选择和特征抽取的优点是可以用较少的特征来表示原始特征中的大部分相关信息，去掉噪声信息，并进而提高计算效率和减小维度灾难 特征选择 选取原始特征集合的一个有效子集，使得基于这个特征子集训练出来的模型准确率最高；子集搜索—前向搜索，反向搜索、L1正则化 特征抽取 构造一个新的特征空间，并将原始特征投影在新的空间中。线性判断分析（LDA，监督）、PCA（无监督） 评价标准分类问题，常见的评价标准有正确率、准确率、召回率和F值，AUC,ROC,PR曲线 混淆矩阵 ROC(Receiver operating characteristic) AUC(Area under the curve)https://tracholar.github.io/machine-learning/2018/01/26/auc.html准确率、召回率、F1值等依赖于判决阈值的评估指标，AUC没有 AUC可以看做随机从正负样本中选取一对正负样本，其中正样本的得分大于负样本的概率！ 超参优化 超参优化 网络结构，包括神经元之间的连接关系、层数、每层的神经元数量、激活函数的类型等； 优化参数，包括优化方法、学习率、小批量的样本数量等； 正则化系数。 超参设置方法：人工搜索、网格搜索和随机搜索。网格搜索和随机搜索都没有利用不同超参数组合之间的相关性，即如果模型的超参数组合比较类似，其模型性能也是比较接近的。因此这两种搜索方式一般都比较低效。 自适应的超参数优化方法：贝叶斯优化和动态资源分配 贝叶斯优化的一个缺点是高斯过程建模需要计算协方差矩阵的逆，时间复杂度是O(n3)，因此不能很好地处理高维情况。深层神经网络的超参数一般比较多，为了使用贝叶斯优化来搜索神经网络的超参数，需要一些更高效的高斯过程建模 动态资源分配通过一组超参数的学习曲线来预估这组超参数配置是否有希望得到比较好的结果。逐次减半，将超参数优化看作是一种非随机的最优臂问题 神经架构搜索 网络正则化传统的机器学习中，提高泛化能力的方法主要是限制模型复杂度，比如采用ℓ1 和ℓ2 正则化等方式。在训练深层神经网络时，特别是在过度参数（Over-Parameterized）（过度参数是指模型参数的数量远远大于训练数据的数量）时，ℓ1 和ℓ2 正则化的效果往往不如浅层机器学习模型中显著。因此训练深度学习模型时，往往还会使用其它的正则化方法，比如数据增强、提前停止、丢弃法、集成法等。 权重衰减 提前停止 丢弃法（dropout) 随机丢弃一部分神经元（对应连接边） 集成学习的解释（每做一次丢弃，相当于从原始的网络中采样得到一个子网络）、贝叶斯学习的解释 循环神经网络上的dropout 当在循环神经网络上应用丢弃法，不能直接对每个时刻的隐状态进行随机丢弃，这样会损害循环网络在时间维度上记忆能力。一种简单的方法是对非时间维度的连接（即非循环连接）进行随机丢失 数据增强 通过数据增强（Data Augmentation）来增加数据量，提高模型鲁棒性，避免过拟合 旋转（Rotation）：将图像按顺时针或逆时针方向随机旋转一定角度； 翻转（Flip）：将图像沿水平或垂直方法随机翻转一定角度； 缩放（Zoom In/Out）：将图像放大或缩小一定比例； 平移（Shift）：将图像沿水平或垂直方法平移一定步长； 加噪声（Noise）：加入随机噪声。 标签平滑 注意力机制一个和注意力有关的例子是鸡尾酒会效应。当一个人在吵闹的鸡尾酒会上和朋友聊天时，尽管周围噪音干扰很多，他还是可以听到朋友的谈话内容，而忽略其他人的声音（聚焦式注意力）。同时，如果未注意到的背景声中有重要的词（比如他的名字），他会马上注意到（显著性注意力）。 可以将最大汇聚（max pooling）、门控（gating）机制来近似地看作是自下而上的基于显著性的注意力机制 注意力机制的计算可以分为两步：一是在所有输入信息上计算注意力分布，二是根据注意力分布来计算输入信息的加权平均 深度学习深层神经网络是一个高度非线性的模型，其风险函数是一个非凸函数，因此风险最小化是一个非凸优化问题，会存在很多局部最优点。 低维空间的非凸优化问题主要是存在一些局部最优点。 在高维空间中，非凸优化的难点并不在于如何逃离局部最优点，而是如何逃离鞍点。鞍点的梯度是0，但是在一些维度上是最高点，在另一些维度上是最低点 深层神经网络的参数非常多，并且有一定的冗余性，这导致每单个参数对最终损失的影响都比较小，这导致了损失函数在局部最优点附近是一个平坦的区域，称为平坦最小值 梯度下降法及其变种优缺点【An overview of gradient descent optimization algorithms】 发展历程——SGD -&gt; SGDM -&gt; NAG -&gt;AdaGrad -&gt; AdaDelta -&gt; Adam -&gt; Nadam BGD的时间复杂度是O(mn)其中m是一次迭代计算的样本数（所有样本），n是样本特征数。 SGB的时间复杂度是O(n)好吧？ SGD一次迭代计算的样本数为1，n为样本特征数 BatchGD 全数据集用于训练，有大量冗余计算；很慢且消耗内存；可以保证到达局部最优（非凸）或全局最优（凸） StochasticGD 一次用一个样本，取消冗余计算；更快、可在线；以高variance更新导致目标函数严重震荡，可能跳出局部最优点找到更好的，也可能不收敛（慢慢减少学习率） Mini-batchGD 一次用一部分，结合两者优势；减少参数更新variance，稳定收敛；利用矩阵优势，计算梯度效率更高？挑战：学习率的选择策略——预定义、动态调整；不同特征的学习率（低频特征步长更大）；鞍点 Momentum 加速相关方向抑制震荡；更新公式与前一次更新值有关；下降像放球一样，在同一个方向上会越来越快，在不同梯度方向会减少更新；更快收敛和更少震荡 NesterovAcceleratedGreadient 动量法盲目跟随斜坡；NAG上升前先减速，对梯度下降方向有粗略预测；用到了二阶信息，上一个下降点的二阶导（黄色部分） Adagrad 调整学习率（低频更新大，高频更新小，词嵌入）；适合处理稀疏数据；鲁棒性提升；参数更新率不同per-parameter update;Gt,ii为对角矩阵，对角元素为过去梯度的平方和，可向量化；不需要人为调整学习率；缺陷在于平方梯度在分母，随着训练学习率会变很小，后面不再更新 123# Adagrad updatecache += dx*82x += - learning_rate * dx / (np.sqrt(cache) + 1e-7) Adagrad updatecache += dx82x += - learning_rate dx / (np.sqrt(cache) + 1e-7) Adadelta Adagrad的拓展，旨在减少它单调递减的学习率；不收集过去所有梯度，而是收集过去固定值w大小的梯度量； RMSprop 也是Adagrad的改进，是Adadelta的第一步推导；一种泄露机制 123# RMSPorpcache = decay_rate * cache + (1 - decay_reate) * dx**2x += - learning_rate * dx / (np.sqrt(cache) + 1e-7) Adaptive Moment Estimation (Adam) Adagrad和RMSprop的结合： m与v分别是梯度的一阶矩（带权平均）和二阶矩（带权有偏方差），初始为0向量。Adam的作者发现它们(接近于0向量)，特别是在衰减因子(衰减率)β1,β2接近于1时。为了改进这个问题，对m与v进行偏差修正(bias-corrected)，偏差修正取决于时间步长t Adam (bias-corrected) 12345m = beta1 * m + (1-beta1) * dxv = beta2 * v + (1-beta2) * (dx**2)m /= 1-beta1**tv /= 1-beta2**tx += - learning_rate * m / (np.sqrt(v)) + le-7) Nadam Adam和NAG的结合（既调整学习率和粗略预测未来方向） 优化器的选择 稀疏数据用自适应学习率方法（ada系列）；RMSprop,Adadelta和Adam比较相似；SGD用的很多？SGD优化时间长，依赖于初始化和退火调度，可能陷于鞍点 用什么优化根本不重要，因为paper的contribution不在优化问题上面。 控制变量法，如果baseline是用SGD的，自然也用SGD去对比，不然怎么知道是model的差异还是optimization的差异？ 选择Adam还是SGD是工程问题不是科学问题。Adam比SGD好，是通过cross validation得出的不是通过数学推导得出的。 SGD和Adam没有本质区别，顶多是自行车和变速山地车的区别，多了一些trick罢了。 SGD在一些场景下效果比其他的好。 一些tricks 随机化 防止样本顺序带来的影响或偏差，更好的学习 Batch normalization（批归一化）在深度神经网络训练过程中使得每一层神经网络的输入保持相同分布，为解决“Internal Covariate Shift”问题——因为深层神经网络在做非线性变换前的激活输入值（就是那个x=WU+B，U是输入）随着网络深度加深或者在训练过程中，其分布逐渐发生偏移或者变动，之所以训练收敛慢，一般是整体分布逐渐往非线性函数的取值区间的上下限两端靠近（对于Sigmoid函数来说，意味着激活输入值WU+B是大的负值或正值），所以这导致反向传播时低层神经网络的梯度消失对于每个隐层神经元，把逐渐向非线性函数映射后向取值区间极限饱和区靠拢的输入分布强制拉回到均值为0方差为1的比较标准的正态分布，使得非线性变换函数的输入值落入对输入比较敏感的区域，以此避免梯度消失问题。位于X=WU+B激活值获得之后，非线性函数变换 Scale and shift: 对净输入z(l) 的标准归一化会使得其取值集中的0 附近，如果使用sigmoid型激活函数时，这个取值区间刚好是接近线性变换的区间，减弱了神经网络的非线性性质。因此，为了使得归一化不对网络的表示能力造成负面影响，通过一个附加的缩放和平移变换改变取值区间。 mini-batch期望和方差：目前主要的训练方法是基于小批量的随机梯度下降方法，z(l) 的期望和方差通常用当前小批量样本集的均值和方差近似估计。 局限性：批量归一化是对一个中间层的单个神经元进行归一化操作，因此要求小批量样本的数量不能太小，否则难以计算单个神经元的统计信息。此外，如果一个神经元的净输入的分布在神经网络中是动态变化的，比如循环神经网络，那么就无法应用批量归一化操作。 层归一化LN：层归一化是对一个中间层的所有神经元进行归一化。对于K 个样本的一个小批量集合Z(l) = [z(1,l); · · · ; z(K,l)]，层归一化是对矩阵Z(l) 对每一列进行归一化，而批量归一化是对每一行进行归一化 权重归一化：对神经网络的连接权重进行归一化，通过再参数化（Reparameterization）方法，将连接权重分解为长度和方向两种参数 局部响应归一化：基于卷积的图像处理中。局部响应归一化和层归一化都是对同层的神经元进行归一化。不同的是局部响应归一化应用在激活函数之后，只是对邻近的神经元进行局部归一化，并且不减去均值。 提前停止 梯度噪声 使网络对于糟糕初始化更鲁棒，对训练复杂很深的网络有用 激活函数 Sigmoid S曲线；值域0-1；求导；两端饱和函数；非零中心化的输出会使得其后一层的神经元的输入发生偏置偏移（Bias Shift），并进一步使得梯度下降的收敛速度变慢。 Logistic函数 σ(x)=(1+exp(-x))^-1 Tanh函数 放大平移的Logistic函数；值域为（-1,1）；tanh(x)=2σ(2x)-1 Logistic 函数和Tanh 函数都是Sigmoid 型函数，具有饱和性，但是计算开销较大。因为这两个函数都是在中间（0 附近）近似线性，两端饱和 ReLU修正线性单元 原始ReLU ReLU(x)=max(0,x)；优点：1.神经元运算简单，计算上更高效；2.单侧抑制、宽兴奋边界；3.Sigmoid会导致非稀疏网络，ReLU稀疏性好；4.ReLU左饱和，右导数为1，缓解梯度消失，加速梯度收敛；缺点：1.输出非0中心化，给后层网络引入偏置偏移，影响梯度下降效率；2.死亡ReLU问题 LeakyReLU LeakyReLU(x)=max(0,x)+γmin(0,x) PReLU PReLU=max(0, x) + γ_i min(0, x),可学习参数 ELU ELU=max(0, x) + min(0, γ(exp(x) − 1)) Softplus函数 Softplus(x) = log(1 + exp(x)).单侧抑制、宽兴奋边界，没有稀疏激活性 Swish函数 自门控激活函数 swish(x) = xσ(βx) Maxout单元 maxout单元的输入是上一层神经元的全部原始输入，是一个向量x = [x1; x2; · · · , xd]； 梯度消失和梯度爆炸原因：深度神经网络和反向传播，根据损失函数计算的误差通过梯度反向传播的方式，指导深度网络权值的更新优化。 梯度消失 网络太深层 采用了不合适的损失函数 梯度爆炸 网络太深 权值初始化值太大 解决方案： 预训练加微调 梯度剪切，权重正则（针对梯度爆炸） 使用不同的激活函数 Batch normalization 残差结构 使用LSTM或GRU （有点像残差网络） 梯度截断 当梯度的模大于一定阈值时，就对梯度进行截断；分为按值截断、按模截断 卷积神经网络作用及发展CNN与DNN区别：卷积、池化 卷积作用：局部感受野（提升表达能力和泛化能力），参数共享（减少运算量） 1*1卷积核作用：不影响输入输出维度，增加网络非线性表达能力，降低参数量 池化（下采样）：最大，平均；减少参数 激活函数：提升表达能力和泛化能力 Dropout:随机舍弃某些权重，降低模型复杂度，预防过拟合 LeNet(传统CNN)-&gt;AlexNet（数据增广，dropout,relu,局部响应归一化LRN）-&gt;VGG(深)-&gt;GoogLeNet(inception增加网络宽度和深度)-&gt;ResNet(shortcut，残差网络，防止梯度消失)-&gt;DenseNet(密集连接，任何两层都有直接的连接，内存占用大) 卷积神经网络计算 卷积：nm的图像，kk的滤波器，卷积后为(n-k+1)(m-k+1)，参数量kk+1 Padding：卷积得到原图像size，加入层数为p=(k-1)/2 步长stride：(n+2p-k)/s+1，s为步长 单卷积核：三通道的过滤器与图像卷积，对kk3个数去加权计算和，不是分层计算 多卷积核：j个kk3的滤波器，得到(n-k+1)(m-k+1)j层输出，参数量kk3*j+j 池化：改变输入输出，不会有参数，nm的图像，kk的滤波器,s为步长，输出(n+2p-k)/s+1 全连接层：FC1 * FC2 循环神经网络 任务模式：序列到类别（分类）、同步序列到序列（词性标注）、异步序列到序列（编码器解码器、机器翻译） 参数学习：随时间反向传播（BPTT），实时循环学习算法（RTRL、前向传播） 两种算法比较：RTRL算法和BPTT算法都是基于梯度下降的算法，分别通过前向模式和反向模式应用链式法则来计算梯度。在循环神经网络中，一般网络输出维度远低于输入维度，因此BPTT算法的计算量会更小，但是BPTT算法需要保存所有时刻的中间梯度，空间复杂度较高。RTRL算法不需要梯度回传，因此非常适合用于需要在线学习或无限序列的任务中。 长期依赖问题：如果t时刻的输出yt 依赖于t−k 时刻的输入xt−k，当间隔k 比较大时，简单神经网络很难建模这种长距离的依赖关系，称为长期依赖问题 梯度爆炸：权重衰减（通过给参数增加ℓ1 或ℓ2 范数的正则化项来限制参数的取值范围，从而使得γ ≤ 1）、梯度截断（当梯度的模大于一定阈值时，就将它截断成为一个较小的数） 梯度消失（RNN主要问题）：改变模型，ht = ht−1 + g(xt, ht−1; θ), (6.50)这样ht 和ht−1 之间为既有线性关系，也有非线性关系，但有记忆容量问题—增加额外存储，选择性遗忘 LSTM和GRU：基于门控的循环神经网络 LSTM:LSTM网络引入一个新的内部状态（internal state）ct 专门进行线性的循环信息传递，同时（非线性）输出信息给隐藏层的外部状态ht。 LSTM网络中的“门”是一种“软”门，取值在(0, 1) 之间，表示以一定的比例运行信息通过。 输入门：输入门it 控制当前时刻的候选状态˜ct 有多少信息需要保存 遗忘门：遗忘门ft 控制上一个时刻的内部状态ct−1 需要遗忘多少信息 输出门：输出门ot 控制当前时刻的内部状态ct 有多少信息需要输出给外部状态ht。 LSTM网络中，记忆单元c 可以在某个时刻捕捉到某个关键信息，并有能力将此关键信息保存一定的时间间隔。记忆单元c 中保存信息的生命周期要长于短期记忆h，但又远远短于长期记忆，因此称为长的短期记忆（long short-term memory）。 LSTM变体： 无遗忘门的LSTM Schmidhuber最早提出，ct会不断累加 peephole连接 三个门不但依赖于输入xt 和上一时刻的隐状态ht−1，也依赖于上一个时刻的记忆单元ct−1。 耦合输入门和遗忘门 LSTM网络中的输入门和遗忘门有些互补关系，同时用两个门比较冗余。 门控循环单元（GRU) GRU将输入门与和遗忘门合并成一个门：更新门。同时，GRU也不引入额外的记忆单元，直接在当前状态ht 和历史状态ht−1 之间引入线性依赖关系。 深层循环神经网络 增加循环神经网络的深度主要是增加同一时刻网络输入到输出之间的路径xt →yt，比如增加隐状态到输出ht → yt，以及输入到隐状态xt → ht 之间的路径的深度。 堆叠循环神经网络 双向循环神经网络 一个时刻的输出不但和过去时刻的信息有关，也和后续时刻的信息有关。比如给定一个句子，其中一个词的词性由它的上下文决定 注意力机制参数初始化 在感知器和logistic 回归的训练中，我们一般将参数全部初始化为0 对称权重：神经网络训练，前向计算时所有隐层神经元激活值相同，导致深层无区分性 参数初始化过小：多层传递信号慢慢消失；使sigmoid丢失非线性（0附近近似线性） 参数初始化过大：sigmoid后激活值变得饱和，导致梯度接近于0 常用初始化方法：Gassian分布初始化、均匀分布初始化（Xavier 初始化）","link":"/2020/03/30/ckwasv953000wv45ctzsa6t8s/"},{"title":"LeetCode Weekly Contest 268","text":"这次的题感觉还是挺简单的，做出来3道题，但是第一道题浪费太多时间了，排名1242 / 4397，进步很大，继续努力 2078. 两栋颜色不同且距离最远的房子 [EASY]街上有 n 栋房子整齐地排成一列，每栋房子都粉刷上了漂亮的颜色。给你一个下标从 0 开始且长度为 n 的整数数组 colors ，其中 colors[i] 表示第 i 栋房子的颜色。 返回 两栋 颜色 不同 房子之间的 最大 距离。 第 i 栋房子和第 j 栋房子之间的距离是 abs(i - j) ，其中 abs(x) 是 x 的绝对值。 示例 1： 输入：colors = [1,1,1,6,1,1,1]输出：3解释：上图中，颜色 1 标识成蓝色，颜色 6 标识成红色。两栋颜色不同且距离最远的房子是房子 0 和房子 3 。房子 0 的颜色是颜色 1 ，房子 3 的颜色是颜色 6 。两栋房子之间的距离是 abs(0 - 3) = 3 。注意，房子 3 和房子 6 也可以产生最佳答案。 示例 2： 输入：colors = [1,8,3,8,3]输出：4解释：上图中，颜色 1 标识成蓝色，颜色 8 标识成黄色，颜色 3 标识成绿色。两栋颜色不同且距离最远的房子是房子 0 和房子 4 。房子 0 的颜色是颜色 1 ，房子 4 的颜色是颜色 3 。两栋房子之间的距离是 abs(0 - 4) = 4 。 示例 3：输入：colors = [0,1]输出：1解释：两栋颜色不同且距离最远的房子是房子 0 和房子 1 。房子 0 的颜色是颜色 0 ，房子 1 的颜色是颜色 1 。两栋房子之间的距离是 abs(0 - 1) = 1 。 提示：n == colors.length2 &lt;= n &lt;= 1000 &lt;= colors[i] &lt;= 100生成的测试数据满足 至少 存在 2 栋颜色不同的房子 1234567891011121314151617181920212223242526272829303132/* 审题：一开始考虑复杂了，还想着用最常不重复子串，写完发现不太对，原来很简单的左右判断一下最大不相等距离就行了*/class Solution {public: int maxDistance(vector&lt;int&gt;&amp; colors) { int left = 0; int right = colors.size() - 1; int maxDistance1 = 1; int maxDistance2 = 1; while (left &lt; right) { if (colors[left] == colors[right]) { ++left; } else { maxDistance1 = right - left; break; } } left = 0; right = colors.size() - 1; while (left &lt; right) { if (colors[left] == colors[right]) { --right; } else { maxDistance2 = right - left; break; } } return max(maxDistance1, maxDistance2); }}; 2079. 给植物浇水 [MEDIUM]你打算用一个水罐给花园里的 n 株植物浇水。植物排成一行，从左到右进行标记，编号从 0 到 n - 1 。其中，第 i 株植物的位置是 x = i 。x = -1 处有一条河，你可以在那里重新灌满你的水罐。 每一株植物都需要浇特定量的水。你将会按下面描述的方式完成浇水： 按从左到右的顺序给植物浇水。在给当前植物浇完水之后，如果你没有足够的水 完全 浇灌下一株植物，那么你就需要返回河边重新装满水罐。你 不能 提前重新灌满水罐。最初，你在河边（也就是，x = -1），在 x 轴上每移动 一个单位 都需要 一步 。 给你一个下标从 0 开始的整数数组 plants ，数组由 n 个整数组成。其中，plants[i] 为第 i 株植物需要的水量。另有一个整数 capacity 表示水罐的容量，返回浇灌所有植物需要的 步数 。 示例 1：输入：plants = [2,2,3,3], capacity = 5输出：14解释：从河边开始，此时水罐是装满的： 走到植物 0 (1 步) ，浇水。水罐中还有 3 单位的水。 走到植物 1 (1 步) ，浇水。水罐中还有 1 单位的水。 由于不能完全浇灌植物 2 ，回到河边取水 (2 步)。 走到植物 2 (3 步) ，浇水。水罐中还有 2 单位的水。 由于不能完全浇灌植物 3 ，回到河边取水 (3 步)。 走到植物 3 (4 步) ，浇水。需要的步数是 = 1 + 1 + 2 + 3 + 3 + 4 = 14 。 示例 2：输入：plants = [1,1,1,4,2,3], capacity = 4输出：30解释：从河边开始，此时水罐是装满的： 走到植物 0，1，2 (3 步) ，浇水。回到河边取水 (3 步)。 走到植物 3 (4 步) ，浇水。回到河边取水 (4 步)。 走到植物 4 (5 步) ，浇水。回到河边取水 (5 步)。 走到植物 5 (6 步) ，浇水。需要的步数是 = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30 。 示例 3：输入：plants = [7,7,7,7,7,7,7], capacity = 8输出：49解释：每次浇水都需要重新灌满水罐。需要的步数是 = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49 。 提示：n == plants.length1 &lt;= n &lt;= 10001 &lt;= plants[i] &lt;= 106max(plants[i]) &lt;= capacity &lt;= 10912345678910111213141516171819202122/*审题：比较简单，模拟一下过程，一次遍历就可以*/class Solution {public: int wateringPlants(vector&lt;int&gt;&amp; plants, int capacity) { int step = 0; int current = capacity; int currentPos = -1; for (int i = 0; i &lt; plants.size(); ++i) { if (current &gt;= plants[i]) { current -= plants[i]; step += (i - currentPos); } else { step += 2 * i + 1; current = capacity - plants[i]; } currentPos = i; } return step; }}; 2080. 区间内查询数字的频率 [MEDIUM]请你设计一个数据结构，它能求出给定子数组内一个给定值的 频率 。 子数组中一个值的 频率 指的是这个子数组中这个值的出现次数。 请你实现 RangeFreqQuery 类： RangeFreqQuery(int[] arr) 用下标从 0 开始的整数数组 arr 构造一个类的实例。int query(int left, int right, int value) 返回子数组 arr[left…right] 中 value 的 频率 。一个 子数组 指的是数组中一段连续的元素。arr[left…right] 指的是 nums 中包含下标 left 和 right 在内 的中间一段连续元素。 示例 1：输入：[“RangeFreqQuery”, “query”, “query”][[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]输出：[null, 1, 2] 解释：RangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]);rangeFreqQuery.query(1, 2, 4); // 返回 1 。4 在子数组 [33, 4] 中出现 1 次。rangeFreqQuery.query(0, 11, 33); // 返回 2 。33 在整个子数组中出现 2 次。 提示：1 &lt;= arr.length &lt;= 1051 &lt;= arr[i], value &lt;= 1040 &lt;= left &lt;= right &lt; arr.length调用 query 不超过 105 次。 1234567891011121314151617181920212223242526审题：暴力写了一下果然超时，后面想通了可以初始化存下相同元素的index，然后用二分法找区间内的元素个数，后面还是超时，然后删除一个中间赋值就通过了？这个编译用的O0吗，还是跟并发数有关，搞不懂class RangeFreqQuery {public: RangeFreqQuery(vector&lt;int&gt;&amp; arr) { array_.resize(1e4 + 1); for (int i = 0; i &lt; arr.size(); ++i) { array_[arr[i]].emplace_back(i); } } int query(int left, int right, int value) { auto lb = std::lower_bound(array_[value].begin(), array_[value].end(), left); auto up = std::upper_bound(array_[value].begin(), array_[value].end(), right); return (up - array_[value].begin()) - (lb - array_[value].begin()); } private: vector&lt;vector&lt;int&gt;&gt; array_;};/** * Your RangeFreqQuery object will be instantiated and called as such: * RangeFreqQuery* obj = new RangeFreqQuery(arr); * int param_1 = obj-&gt;query(left,right,value); */ 2081. k 镜像数字的和 [HARD]一个 k 镜像数字 指的是一个在十进制和 k 进制下从前往后读和从后往前读都一样的 没有前导 0 的 正 整数。 比方说，9 是一个 2 镜像数字。9 在十进制下为 9 ，二进制下为 1001 ，两者从前往后读和从后往前读都一样。相反地，4 不是一个 2 镜像数字。4 在二进制下为 100 ，从前往后和从后往前读不相同。给你进制 k 和一个数字 n ，请你返回 k 镜像数字中 最小 的 n 个数 之和 。 示例 1：输入：k = 2, n = 5输出：25解释：最小的 5 个 2 镜像数字和它们的二进制表示如下： 十进制 二进制 1 1 3 11 5 101 7 111 9 1001它们的和为 1 + 3 + 5 + 7 + 9 = 25 。 示例 2：输入：k = 3, n = 7输出：499解释：7 个最小的 3 镜像数字和它们的三进制表示如下： 十进制 三进制 1 1 2 2 4 11 8 22 121 11111 151 12121 212 21212它们的和为 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499 。 示例 3：输入：k = 7, n = 17输出：20379000解释：17 个最小的 7 镜像数字分别为：1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596 提示：2 &lt;= k &lt;= 91 &lt;= n &lt;= 30 123审题：这题只剩十几分钟了，按照我的速度肯定是写不完的，但是有思路，就是每个数计算一下进制位，然后判断一下，当然肯定超时，但是n只有30，也可以把镜像数存起来[官方解答](https://leetcode-cn.com/problems/sum-of-k-mirror-numbers/solution/k-jing-xiang-shu-zi-de-he-by-leetcode-so-nyos/)","link":"/2021/11/21/ckwasv951000sv45cz7ctk66w/"},{"title":"LeetCode Weekly Contest 265","text":"这次的题感觉还是挺简单的，前两道题半小时做完了，第三道题用DFS栈溢出（不懂剪枝没做够？），最后一道题只剩半小时不够时间了，还是只做出来两道题，排名2206 / 4181 5914. 值相等的最小索引 [EASY]给你一个下标从 0 开始的整数数组 nums ，返回 nums 中满足 i mod 10 == nums[i] 的最小下标 i ；如果不存在这样的下标，返回 -1 。 x mod y 表示 x 除以 y 的 余数 。 示例 1： 输入：nums = [0,1,2]输出：0解释：i=0: 0 mod 10 = 0 == nums[0].i=1: 1 mod 10 = 1 == nums[1].i=2: 2 mod 10 = 2 == nums[2].所有下标都满足 i mod 10 == nums[i] ，所以返回最小下标 0 示例 2：输入：nums = [4,3,2,1]输出：2解释：i=0: 0 mod 10 = 0 != nums[0].i=1: 1 mod 10 = 1 != nums[1].i=2: 2 mod 10 = 2 == nums[2].i=3: 3 mod 10 = 3 != nums[3].2 唯一一个满足 i mod 10 == nums[i] 的下标 示例 3：输入：nums = [1,2,3,4,5,6,7,8,9,0]输出：-1解释：不存在满足 i mod 10 == nums[i] 的下标示例 4： 输入：nums = [2,1,3,5,2]输出：1解释：1 是唯一一个满足 i mod 10 == nums[i] 的下标 提示：1 &lt;= nums.length &lt;= 1000 &lt;= nums[i] &lt;= 9 123456789101112131415/* 审题：没啥好说的，过于简单还让我多审了两次题*/class Solution {public: int smallestEqual(vector&lt;int&gt;&amp; nums) { for (int i = 0; i &lt; nums.size(); i++) { if (i % 10 == nums[i]) { return i; } } return -1; }}; 5915. 找出临界点之间的最小和最大距离 [MEDIUM]链表中的 临界点 定义为一个 局部极大值点 或 局部极小值点 。 如果当前节点的值 严格大于 前一个节点和后一个节点，那么这个节点就是一个 局部极大值点 。 如果当前节点的值 严格小于 前一个节点和后一个节点，那么这个节点就是一个 局部极小值点 。 注意：节点只有在同时存在前一个节点和后一个节点的情况下，才能成为一个 局部极大值点 / 极小值点 。 给你一个链表 head ，返回一个长度为 2 的数组 [minDistance, maxDistance] ，其中 minDistance 是任意两个不同临界点之间的最小距离，maxDistance 是任意两个不同临界点之间的最大距离。如果临界点少于两个，则返回 [-1，-1] 。 示例 1：输入：head = [3,1]输出：[-1,-1]解释：链表 [3,1] 中不存在临界点。 示例 2：输入：head = [5,3,1,2,5,1,2]输出：[1,3]解释：存在三个临界点： [5,3,1,2,5,1,2]：第三个节点是一个局部极小值点，因为 1 比 3 和 2 小。 [5,3,1,2,5,1,2]：第五个节点是一个局部极大值点，因为 5 比 2 和 1 大。 [5,3,1,2,5,1,2]：第六个节点是一个局部极小值点，因为 1 比 5 和 2 小。第五个节点和第六个节点之间距离最小。minDistance = 6 - 5 = 1 。第三个节点和第六个节点之间距离最大。maxDistance = 6 - 3 = 3 。 示例 3：输入：head = [1,3,2,2,3,2,2,2,7]输出：[3,3]解释：存在两个临界点： [1,3,2,2,3,2,2,2,7]：第二个节点是一个局部极大值点，因为 3 比 1 和 2 大。 [1,3,2,2,3,2,2,2,7]：第五个节点是一个局部极大值点，因为 3 比 2 和 2 大。最小和最大距离都存在于第二个节点和第五个节点之间。因此，minDistance 和 maxDistance 是 5 - 2 = 3 。注意，最后一个节点不算一个局部极大值点，因为它之后就没有节点了。 示例 4：输入：head = [2,3,3,2]输出：[-1,-1]解释：链表 [2,3,3,2] 中不存在临界点。 提示：链表中节点的数量在范围 [2, 105] 内1 &lt;= Node.val &lt;= 1051234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/*审题：这题先把极值点找出来，标记下坐标（这个过程保证坐标有序），然后最远的肯定是第一个和最后一个，遍历下坐标点，找出距离最近的，输出即可*//** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: vector&lt;int&gt; nodesBetweenCriticalPoints(ListNode* head) { vector&lt;int&gt; result(2, 0); vector&lt;int&gt; pointIndex; auto node = head; int preNodeVal = -1; int index = 0; while (node-&gt;next) { // cout &lt;&lt; index &lt;&lt; &quot;, &quot; &lt;&lt; node-&gt;val &lt;&lt; endl; if (node == head) { } else if (node-&gt;val &gt; node-&gt;next-&gt;val &amp;&amp; node-&gt;val &gt; preNodeVal) { // 极大值 pointIndex.push_back(index); } else if (node-&gt;val &lt; node-&gt;next-&gt;val &amp;&amp; node-&gt;val &lt; preNodeVal) { // 极小值 pointIndex.push_back(index); } preNodeVal = node-&gt;val; node = node-&gt;next; ++index; } // for (auto&amp; point : pointIndex) { // cout &lt;&lt; pointIndex.size() &lt;&lt; &quot; : &quot; &lt;&lt; point &lt;&lt; &quot;, &quot;; // } // cout &lt;&lt; endl; if (pointIndex.size() &lt; 2) { result[0] = -1; result[1] = -1; return result; } int minDistance = 100000; int maxDistance = pointIndex.back() - pointIndex[0]; if (pointIndex.size() == 2) { result[0] = maxDistance; result[1] = maxDistance; return result; } for (auto i = 1; i &lt; pointIndex.size(); i++) { if (pointIndex[i] - pointIndex[i - 1] &lt; minDistance) { minDistance = pointIndex[i] - pointIndex[i - 1]; } } result[0] = minDistance; result[1] = maxDistance; return result; }}; 5916. 转化数字的最小运算数 [MEDIUM]给你一个下标从 0 开始的整数数组 nums ，该数组由 互不相同 的数字组成。另给你两个整数 start 和 goal 。 整数 x 的值最开始设为 start ，你打算执行一些运算使 x 转化为 goal 。你可以对数字 x 重复执行下述运算： 如果 0 &lt;= x &lt;= 1000 ，那么，对于数组中的任一下标 i（0 &lt;= i &lt; nums.length），可以将 x 设为下述任一值： x + nums[i]x - nums[i]x ^ nums[i]（按位异或 XOR）注意，你可以按任意顺序使用每个 nums[i] 任意次。使 x 越过 0 &lt;= x &lt;= 1000 范围的运算同样可以生效，但该该运算执行后将不能执行其他运算。 返回将 x = start 转化为 goal 的最小操作数；如果无法完成转化，则返回 -1 。 示例 1：输入：nums = [1,3], start = 6, goal = 4输出：2解释：可以按 6 → 7 → 4 的转化路径进行，只需执行下述 2 次运算： 6 ^ 1 = 7 7 ^ 3 = 4 示例 2：输入：nums = [2,4,12], start = 2, goal = 12输出：2解释：可以按 2 → 14 → 12 的转化路径进行，只需执行下述 2 次运算： 2 + 12 = 14 14 - 2 = 12 示例 3：输入：nums = [3,5,7], start = 0, goal = -4输出：2解释：可以按 0 → 3 → -4 的转化路径进行，只需执行下述 2 次运算： 0 + 3 = 3 3 - 7 = -4注意，最后一步运算使 x 超过范围 0 &lt;= x &lt;= 1000 ，但该运算仍然可以生效。 示例 4：输入：nums = [2,8,16], start = 0, goal = 1输出：-1解释：无法将 0 转化为 1 示例 5：输入：nums = [1], start = 0, goal = 3输出：3解释：可以按 0 → 1 → 2 → 3 的转化路径进行，只需执行下述 3 次运算： 0 + 1 = 1 1 + 1 = 2 2 + 1 = 3 提示：1 &lt;= nums.length &lt;= 1000-109 &lt;= nums[i], goal &lt;= 1090 &lt;= start &lt;= 1000start != goalnums 中的所有整数互不相同 123456789101112131415161718192021222324252627282930313233审题：看着就像DFS可以做出来的题，加了操作数大于已知最小退出、出现过数字退出这两个剪枝策略都没用，看讨论要用BFS// stack-overflowclass Solution {public: long long minOpt_ = INT_MAX; void dfs(const vector&lt;int&gt;&amp; nums, int x, int goal, int operation, vector&lt;int&gt;&amp; asMap) { if (x == goal) { if (operation &lt; minOpt_) { minOpt_ = operation; } return; } if (x &lt; 0 || x &gt; 1000 || operation &gt;= minOpt_ || asMap[x]) { return; } asMap[x]++; for (size_t i = 0; i &lt; nums.size(); ++i) { // add dfs(nums, x + nums[i], goal, operation + 1, asMap); // minus dfs(nums, x - nums[i], goal, operation + 1, asMap); // xor dfs(nums, x ^ nums[i], goal, operation + 1, asMap); } } int minimumOperations(vector&lt;int&gt;&amp; nums, int start, int goal) { vector&lt;int&gt; asMap(1000, 0); dfs(nums, start, goal, 0, asMap); return minOpt_ == INT_MAX ? -1 : minOpt_; }}; 5917. 同源字符串检测 [HARD]原字符串由小写字母组成，可以按下述步骤编码： 任意将其 分割 为由若干 非空 子字符串组成的一个 序列 。任意选择序列中的一些元素（也可能不选择），然后将这些元素替换为元素各自的长度（作为一个数字型的字符串）。重新 顺次连接 序列，得到编码后的字符串。例如，编码 “abcdefghijklmnop” 的一种方法可以描述为： 将原字符串分割得到一个序列：[“ab”, “cdefghijklmn”, “o”, “p”] 。选出其中第二个和第三个元素并分别替换为它们自身的长度。序列变为 [“ab”, “12”, “1”, “p”] 。重新顺次连接序列中的元素，得到编码后的字符串：”ab121p” 。给你两个编码后的字符串 s1 和 s2 ，由小写英文字母和数字 1-9 组成。如果存在能够同时编码得到 s1 和 s2 原字符串，返回 true ；否则，返回 false。 注意：生成的测试用例满足 s1 和 s2 中连续数字数不超过 3 。 示例 1：输入：s1 = “internationalization”, s2 = “i18n”输出：true解释：”internationalization” 可以作为原字符串 “internationalization”-&gt; 分割： [“internationalization”]-&gt; 不替换任何元素-&gt; 连接： “internationalization”，得到 s1 “internationalization”-&gt; 分割： [“i”, “nternationalizatio”, “n”]-&gt; 替换： [“i”, “18”, “n”]-&gt; 连接： “i18n”，得到 s2 示例 2：输入：s1 = “l123e”, s2 = “44”输出：true解释：”leetcode” 可以作为原字符串 “leetcode”-&gt; 分割： [“l”, “e”, “et”, “cod”, “e”]-&gt; 替换： [“l”, “1”, “2”, “3”, “e”]-&gt; 连接： “l123e”，得到 s1 “leetcode”-&gt; 分割： [“leet”, “code”]-&gt; 替换： [“4”, “4”]-&gt; 连接： “44”，得到 s2 示例 3：输入：s1 = “a5b”, s2 = “c5b”输出：false解释：不存在这样的原字符串 编码为 s1 的字符串必须以字母 ‘a’ 开头 编码为 s2 的字符串必须以字母 ‘c’ 开头 示例 4：输入：s1 = “112s”, s2 = “g841”输出：true解释：”gaaaaaaaaaaaas” 可以作为原字符串 “gaaaaaaaaaaaas”-&gt; 分割： [“g”, “aaaaaaaaaaaa”, “s”]-&gt; 替换： [“1”, “12”, “s”]-&gt; 连接： “112s”，得到 s1 “gaaaaaaaaaaaas”-&gt; 分割： [“g”, “aaaaaaaa”, “aaaa”, “s”]-&gt; 替换： [“g”, “8”, “4”, “1”]-&gt; 连接 “g841”，得到 s2 示例 5：输入：s1 = “ab”, s2 = “a2”输出：false解释：不存在这样的原字符串 编码为 s1 的字符串由两个字母组成 编码为 s2 的字符串由三个字母组成 提示： 1 &lt;= s1.length, s2.length &lt;= 40s1 和 s2 仅由数字 1-9 和小写英文字母组成s1 和 s2 中连续数字数不超过 3 1审题：第三题卡太久了，这题只留了半小时不到，知道做不完还是写一下，我的想法就是先把字符串分割，然后排列组合成多种，再遍历这两个s1和s2的所有组合，只写完了字符串分割(c++真难搞)。虽然后面的排列组合和比较估计也很难写，看答案应该是用动态规划，待续。。。","link":"/2021/10/31/ckwasv950000rv45cacvcpnsg/"},{"title":"二叉树常用操作的实现","text":"二叉树的最全总结，常考题型，持续更新 二叉树的递归思想很重要，还有递归的复杂度分析 1.1 二叉树的初始化12345678910111213141516171819202122#initial of BinaryTreeclass BinaryTree: def __init__(self,rootObj): self.val = rootObj self.left = None self.right = None def insertLeft(self,newNode): if self.left == None: self.left = BinaryTree(newNode) else: t = BinaryTree(newNode) t.left = self.left self.left = t def insertRight(self,newNode): if self.right == None: self.right = BinaryTree(newNode) else: t = BinaryTree(newNode) t.right = self.right self.right = t 1.2 创建一个二叉树1234567891011121314151617#create a BinaryTree [18,7,11,3,4,5,6,#,#,#,#,1,3,2,4]# 18# 7 11#3 4 5 6# 1 3 2 4root = BinaryTree(18)root.left = BinaryTree(7)root.right = BinaryTree(11)root.left.left = BinaryTree(3)root.left.right = BinaryTree(4)root.right.left = BinaryTree(5)root.right.right = BinaryTree(6)root.right.left.left = BinaryTree(1)root.right.left.right = BinaryTree(3)root.right.right.left = BinaryTree(2)root.right.right.right = BinaryTree(4) 1.3 前序遍历1234567891011121314151617181920212223#递归版本def PreOrder(self, node): if node: print(node.val) self.PreOrder(node.left) self.PreOrder(node.right)#循环版本def PreOrderLoop(self, node): if node == None: return stack =[] print(node.val) stack.append(node) node = node.left while stack!=[] or node: while node: print(node.val) stack.append(node) node = node.left node = stack[-1].right stack.pop()#ouput: 18 7 3 4 11 5 1 3 6 2 4 1.4 中序遍历123456789101112131415161718192021#递归版本def InOrder(self, node): if node: self.InOrder(node.left) print(node.val) self.InOrder(node.right)#循环版本def InOrderLoop(self, node): if node == None: return None stack = [] stack.append(node) node = node.left while stack!=[] or node: while node: stack.append(node) node = node.left print(stack[-1].val) node = stack[-1].right stack.pop()#output：3 7 4 18 1 5 3 11 2 6 4 1.5 后序遍历1234567891011121314151617181920212223242526#递归def PostOrder(self, node): if node: self.PostOrder(node.left) self.PostOrder(node.right) print(node.val)#非递归def PostOrderLoop(self, node): if node == None: return stack =[] stack.append(node) pre = None while stack!=[]: node = stack[-1] if ((node.left==None and node.right==None) or (pre and (pre == node.left or pre ==node.right))): print(node.val) pre = node stack.pop() else: if node.right: stack.append(node.right) if node.left: stack.append(node.left)#output:3 4 7 1 3 5 2 4 6 11 18 1.6 层序遍历1234567891011121314def LevelOrder(self, node): if node == None: return stack = [] stack.append(node) while stack!=[]: node = stack[0] if node.left: stack.append(node.left) if node.right: stack.append(node.right) print(node.val) stack.pop(0)output: 18 7 11 3 4 5 6 1 3 2 4 1.7 计算节点数1234567891011121314151617181920#递归版本def CountNode(self, root): if root == None: return 0 return self.CountNode(root.left) + self.CountNode(root.right) + 1#非递归版本def CountNodeNotRev(self, root): if root == None: return 0 stack = [] stack.append(root) index = 0 while index&lt;len(stack): if stack[index].left: stack.append(stack[index].left) if stack[index].right: stack.append(stack[index].right) index += 1 print(len(stack))output: 11 1.8 计算树的深度123456def getTreeDepth(self, root): if root == None: return 0 left = self.getTreeDepth(root.left) + 1 right = self.getTreeDepth(root.right) + 1 return left if left&gt;right else right 1.9 计算树的叶子树123456def countLeaves(self, root): if root == None: return 0 if root.left==None and root.right==None: return 1 return self.countLeaves(root.left)+self.countLeaves(root.right) 1.10 获取第K层节点数1234def getKLevel(self, root, K): if root == None: return 0 if K == 1: return 1 return self.getKLevel(root.left, K-1)+self.getKLevel(root.right, K-1) 1.11 判断两颗二叉树是否相同1234def StrucCmp(self, root1, root2): if root1 == None and root2 == None: return True elif root1 ==None or root2 == None: return False return self.StrucCmp(root1.left, root2.left) and self.StrucCmp(root1.right, root2.right) 1.12 二叉树的镜像1234567def Mirror(self, root): if root == None: return tmp = root.left root.left = root.right root.right = tmp self.Mirror(root.left) self.Mirror(root.right) 1.13 找最低公共祖先节点12345678def findLCA(self, root, node1, node2): if root == None: return if root == node1 or root == node2: return root left = self.findLCA(root.left, node1, node2) right = self.findLCA(root.right, node1, node2) if left and right: return root return left if left else right 1.14 获取两个节点的距离123456789101112def getDist(self, root, node1, node2): lca = self.findLCA(root, node1, node2) #找最低公共祖宗节点 level1 = self.FindLevel(lca, node1) #祖节点到两个节点的距离 level2 = self.FindLevel(lca, node2) return level1+level2def FindLevel(self, node, target): if node == None: return -1 if node == target: return 0 level = self.FindLevel(node.left, target) if level == -1: level = self.FindLevel(node.right, target) if level != -1: return level + 1 return -1 1.15 找一个节点的所有祖宗节点1234567def findAllAncestor(self, root, target): if root == None: return False if root == target: return True if self.findAllAncestor(root.left, target) or self.findAllAncestor(root.right, target): print(root.val) return True return False","link":"/2019/03/09/ckwasv94m0005v45c9h7ner3h/"},{"title":"如何编写高效、优雅、可信代码系列（4）——今天教你学会用函数指针","text":"故事的起源来自于，没错，又是来自于业务。 事实是这样的，我在重构一段代码的时候，发现有两个函数的代码近乎80%都是相同的，区别在于根据不同的条件局部调用不同的两个函数，很难搞，因为一是抽个abstract class太麻烦，二是函数里是循环，在循环里判断又影响性能，不管吧，也影响代码重复率。这个时候我想到了函数指针！ 1. 函数指针的定义和作用我们先来看看wiki的定义 【from wiki】 A function pointer, also called a subroutine pointer or procedure pointer, is a pointer that points to a function. As opposed to referencing a data value, a function pointer points to executable code within memory. Dereferencing the function pointer yields the referenced function, which can be invoked and passed arguments just as in a normal function call. Such an invocation is also known as an “indirect” call, because the function is being invoked indirectly through a variable instead of directly through a fixed identifier or address. Function pointers can be used to simplify code by providing a simple way to select a function to execute based on run-time values. 重点已经在上面标出来了，函数指针的作用之一是简化代码。 那么c++标准委员会仅仅是为了让我们写clean code吗？ Obviously not! Another use for function pointers is setting up “listener” or “callback” functions that are invoked when a particular event happens. 什么是回调函数呢？比如你为图形用户界面 (GUI) 编写代码时。大多数情况下，用户将与允许鼠标指针移动并重绘界面的循环进行交互。但是，有时用户会单击按钮或在字段中输入文本。这些操作是“事件”，可能需要您的程序需要处理的响应。你的代码怎么知道发生了什么？使用回调函数！用户的点击应该会导致界面调用您编写的用于处理事件的函数。 2. 函数指针的用法说了这么多，你是不是已经跃跃欲试，恨不得马上重构自己的代码以降低重复率了，hold on! hold on!先看完用法再去操作，磨刀不误砍柴工。 2.1 函数指针的声明先来看看函数指针的声明： 1void *(*foo)(int *); 表达式的最里面的元素是 *foo，它应该指向一个返回 void * 并采用 int *作为参数的函数。因此，foo是指向这样一个函数的指针。 还可以用typedef简化函数指针的定义 123456789101112#include &lt;iostream&gt;int test(int a){ return a;}int main(int argc, const char * argv[]){ typedef int (*foo)(int a); foo f = test; cout &lt;&lt; foo(2) &lt;&lt; endl; return 0;} 2.2 函数指针的初始化为了初始化一个函数指针，需要给它一个程序内的函数地址，比如下面的函数： 123456789101112131415161718#include &lt;stdio.h&gt;void MyFun(int x){ printf( &quot;我是%d颗大西瓜。\\n&quot;, x );}int main(){ // way 1 void (*foo)(int); foo = &amp;MyFun; // way 2 void (*foo)(int) = &amp;MyFun; // way 3 auto foo = &amp;MyFun; return 0;} 上面三种方式都是可以的。如果是指向类函数呢？ 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std; class A{ public: A(int aa = 0):a(aa){} ~A(){} void SetA(int aa = 1) { a = aa; } virtual void Print() { cout &lt;&lt; &quot;A: &quot; &lt;&lt; a &lt;&lt; endl; } private: int a;};int main(void){ A a; void (A::*ptr)(int) = &amp;A::setA; A* pa = &amp;a; //对于非虚函数，返回其在内存的真实地址 printf(&quot;A::Set(): %p\\n&quot;, &amp;A::SetA); //对于虚函数， 返回其在虚函数表的偏移位置 printf(&quot;A::Print(): %p\\n&quot;, &amp;A::print); a.Print(); a.SetA(10); //对于指向类成员函数的函数指针，引用时必须传入一个类对象的this指针，所以必须由类实体调用(如果是在类内调用就用*this) (pa-&gt;*ptr)(1000);} 2.3 让我们来看看成果下面是用不同的order进行的选择排序代码，请看成片 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;utility&gt; // for std::swap#include &lt;iostream&gt; // Note our user-defined comparison is the third parametervoid selectionSort(int *array, int size, bool (*comparisonFcn)(int, int)){ // Step through each element of the array for (int startIndex {0}; startIndex &lt; (size - 1); ++startIndex) { // bestIndex is the index of the smallest/largest element we&apos;ve encountered so far. int bestIndex {startIndex}; // Look for smallest/largest element remaining in the array (starting at startIndex+1) for (int currentIndex{ startIndex + 1 }; currentIndex &lt; size; ++currentIndex) { // If the current element is smaller/larger than our previously found smallest if (comparisonFcn(array[bestIndex], array[currentIndex])) { // COMPARISON DONE HERE // This is the new smallest/largest number for this iteration bestIndex = currentIndex; } } // Swap our start element with our smallest/largest element std::swap(array[startIndex], array[bestIndex]); }} // Here is a comparison function that sorts in ascending orderbool ascending(int x, int y){ return x &gt; y; // swap if the first element is greater than the second} // Here is a comparison function that sorts in descending orderbool descending(int x, int y){ return x &lt; y; // swap if the second element is greater than the first} // This function prints out the values in the arrayvoid printArray(int *array, int size){ for (int index{ 0 }; index &lt; size; ++index) { std::cout &lt;&lt; array[index] &lt;&lt; &apos; &apos;; } std::cout &lt;&lt; &apos;\\n&apos;;} int main(){ int array[9] { 3, 7, 9, 5, 6, 1, 8, 2, 4 }; // Sort the array in descending order using the descending() function selectionSort(array, 9, descending); printArray(array, 9); // Sort the array in ascending order using the ascending() function selectionSort(array, 9, ascending); printArray(array, 9); return 0;} 3. 后记是不是看起来还挺优雅的，函数指针的好处可以总结如下 GOOD1: 函数指针提供了一种传递有关如何做某事的指令的方法 GOOD2: 可以编写灵活的函数和库，允许程序员通过将函数指针作为参数传递来选择行为（当然这种灵活性也可以通过使用具有虚函数的类来实现） GOOD3: 可以简化代码 但是every coin has two sides，函数指针也不是百利而无一害，我也总结了一些，大家可以继续补充 BAD1: 性能开销。 让我们回到它的定义，正如一个指针变量保存的是变量的地址一样，只不过函数指针保存的是函数的地址，并且是运行时才能确定的变量。理论来说，直接函数调用开销更小，因为函数指针调用需要先访问数据区，再访问函数，增加指令开销，同时，数据取值与函数指令加载必须串行执行，影响CPU流水性能；普通的函数调用可以做内联优化。不过幸好编译器可以将函数指针的调用开销优化到跟普通的函数调用相同（优化选项O1及以上，具体可参考https://zhuanlan.zhihu.com/p/84887035） BAD2: 代码可读性。 区别于传统的函数调用，我们在进入到使用函数指针作为参数的函数中时，有时会很抓狂，比如上面的selectionSort()，我在阅读到comparisonFcn()的时候无法确认这个函数的行为，需要往外跳一层才能知道什么情况下这个函数是升序还是降序；更令人抓狂的是，更为复杂的函数中（假如作者不写任何注释），你会破口大骂谁写的函数指针，而且点跳转还无法跳转到相应的函数实现中（没错，我有时候是会骂自己的T.T）。","link":"/2021/07/19/ckwasv94y000mv45cox7nbzrp/"},{"title":"如何编写高效、优雅、可信代码系列（3）——类成员初始化的三种方式","text":"首先，先得了解一下C++支持哪几种类成员初始化的方式，你常用的又是哪一种。 初始化方式一：初始化列表 123456class A{public: int a; // 初始化列表 A(int a_):a(a_){}}; 初始化方式二：构造函数初始化 123456class A{public: int a; // 初始化列表 A(int a_, bool b) { a = a_; }}; 初始化方式三：声明时初始化（也称就地初始化，c++11后支持） 123456class A{public: int a = 1; // 声明时初始化 A() {}}; 在C++98中，支持了在类声明中使用等号“=”加初始值的方式，来初始化类中静态成员常量。这种声明方式我们也称之为“就地”声明。就地声明在代码编写时非常便利，不过C++98对类中就地声明的要求却非常高。如果静态成员不满足常量性，则不可以就地声明，而且即使常量的静态成员也只能是整型或者枚举型才能就地初始化。而非静态成员变量的初始化则必须在构造函数中进行。比如，如下代码在c++98中编译123456789101112131415class Init{public: Init(): a(0) [] Init(int d): a(d) {}private: int a; const static int b = 0; int c = 1; // member, cannot pass build static int d = 0; // member, cannot pass build static const double e = 1.3; // not int or enum type, cannot pass build stati const char* const f = &quot;e&quot;; // not int or enum type, cannot pass build} 这非常不方便，所以在C++11中，标准允许非静态成员变量的初始化有多种形式。具体而言，除了初始化列表外，在C++11中，标准还允许使用等号= 或者 花括号{} 进行就地的非静态成员变量初始化。1234struct init { int a = 1; double b {1.2};}; 大家知道，有几种情况下推荐优先使用列表初始化 const成员变量只能用成员初始化列表来完成初始化，而不能在构造函数内赋值 初始化的数据成员是对象 需要初始化引用成员数据 具体的原因这里不细述，大家可以去看一下《C++ Primer》。 构造函数初始化的本质是赋值操作（”=”），这个方法存在两个问题，一个是比起初始化列表和就地初始化，此方式的效率偏低；第二个是可能存在错误隐患。 先说第一个，赋值过程中会产生临时对象，临时对象的构造析构会造成效率损耗，初始化列表的方式就避免了产生临时对象缩带来的问题。 第二个是，如果你没有重写或者禁止赋值构造函数，c++会悄悄的加上默认的赋值构造函数，这个时候也有可能带来问题。 从C++11之后，这三种初始化的方法都可以使用，并不会存在冲突，但是，他们之间是有优先级顺序的，这个优先级来源于他们在初始化的时间顺序，后面初始化的会把前面的覆盖掉，成员变量的初始化顺序是 声明时初始化-&gt;初始化列表-&gt;构造函数初始化 因此假如三种初始化方式同时存在的话，那么最后保留的成员变量值肯定是构造函数中初始化的值。1234567891011121314151617#include &lt;iostream&gt;using namespace std;class A {public: int a = 1; A(int a_) :a(2) { a = 3; }};int main(){ A a; cout &lt;&lt; &quot;a.a=&quot; &lt;&lt; a.a &lt;&lt; endl; return 0;}// a.a=3 既然初始化方式这么多，那么什么时候适用哪种呢？ 1. 声明时初始化的使用场景 一个优点是直观，你在声明的时候顺便给一个初始值，bravo，别人在看你代码的时候，点一下调到声明也能看到你赋予的初始值，不用再去看构造函数那里给的什么值 第二个优点更有用了，比如你要定义多个构造函数，每个构造函数都用列表初始化的方法初始化，多麻烦呀，请看下面的例子，妈妈看了再也不用担心我想用其他初始化方法了1234567891011class Group {public: Group() {} Group(int a): data(a) {} Group(Mem m): mem(m) {} Group(int a, Mem m, string n): data(a), mem(m), name(n) {}private: int data = 1; Mem mem{0}; string name{&quot;Group&quot;};}; 2. 列表初始化的使用场景前面说过了三个场景，这里赘述一下 const成员变量只能用成员初始化列表来完成初始化，而不能在构造函数内赋值 初始化的数据成员是对象 需要初始化引用成员数据 但是，需要注意列表初始化的顺序，不过IDE会提示你的 3. 构造函数初始化的使用场景 第一个就是拷贝和赋值构造函数里（不然怎么叫赋值构造函数呢） 第二个就是比较无聊的情况了，比如你想把几个成员函数都初始化成一个值，请看下面例子12345678class Group {public: Group() {data1 = data2 = data3 = 0;}private: int data1; int data2; int data3;}; 一言以蔽之，优先就地初始化和列表初始化。","link":"/2021/06/28/ckwasv94x000kv45covz87hql/"},{"title":"如何编写高效、优雅、可信代码系列（2）——你真的会用new吗","text":"C++内存管理1. c++内存分配c++中的程序加载到内存后按照代码区、数据区、堆区、栈区进行布局，其中数据区又可以分为自由存储区、全局/静态存储区和常量存储区，各区所长如下： 栈区函数执行的时候，局部变量的存储单元都在栈上创建，函数执行结束后存储单元会自动释放。栈内存分配运算内置于处理器指令集中，效率高，但分配内存容量有限。 堆区堆就是new出来的内存块，编译器不管释放，由应用程序控制，new对应delete。如果没释放掉，程序结束后，操作系统会自动回收。 自由存储区C中malloc分配的内存块。用free结束生命周期。 全局/静态存储区全局变量和静态变量被分配到同一块内存中，定义的时候就会初始化。 常量存储区比较特殊的存储区，存放常量，不允许修改。 堆和栈的区别 管理方式栈由编译器自动管理，堆由程序员控制 空间大小32位系统下，堆内存可以达到4GB，栈有一定的空间大小 碎片管理对于堆，频繁的new/delete肯定造成内存空间的不连续，产生大量内存碎片降低程序效率；栈由于遵循先进后出的规则，不会产生空隙 生长方向堆是向上生长的，即向着内存地址增加的方向增长；而栈是向着内存地址减小的方向增长的 分配方式堆是动态分配的，栈有动态分配和静态分配之分：静态分配由编译器完成，动态分配由alloca函数完成，即使是动态分配，依然是编译器自动释放 分配效率计算机底层提供了栈的支持，分配了专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这决定了栈的效率会比较高。堆则是由C/C++函数库提供的，机制比较复杂，比如为了分配某个大小的内存需要在堆内存中搜索可用足够大小的空间，效率比栈要低的多 2. new/delete和new []/delete [] 回收new分配的单个对象内存空间时用delete，回收用new[]分配的一组对象时用delete[] 对于内置类型(int/double/float/char/…)，由于new[]申请内存时，编译器还会悄悄在内存中保存整数，表示指针数组的个数，所以delete/delete[]都可以正确释放所申请的内存空间 建议在调用new时使用的[]，那么调用delete也使用[] 3. new的三种形态 new operator 常用的new，语言函数内建，不能重载。调用过程中实际完成的有三件事： 为类型对象分配内存； 调用构造函数初始化内存对象； 返回对象指针如果是在堆上建立对象，直接使用new operator。 operator new 普通操作符，可以重载。如果仅仅是分配内存，那么应该调用operator new，但不负责初始化。系统默认提供的分配器在时间和空间两方面都存在一些问题：分配器速度较慢，分配小型对象时空间浪费严重，重载new/delete有三方面好处： 改善效率 检测代码中的内存错误 获得内存使用的统计数据 C++标准规定，重载的operator new必须是类成员函数或全局函数，全局的operator new重载不应该改变原有签名，而是直接无缝替换原有版本。全局重载很有侵略性，别人使用你的库无法使用默认的new，而具体类的重载只会影响本class和其派生类，但是类的operator new函数重载必须声明为static，因为operator new是在类的具体对象被构建出来之前调用的。 为了获得2和3的优势，重载的operator new需要如下函数声明void* operator new(size_t, const char* file, int line); placement new 定义在库&lt;&gt;中。如果想在一块已经获得内存里建立对象，那么应该调用placement new。通常情况不建议使用，但在某些对时间要求非常高的应用中可以考虑，因为选择合适的构造函数完成对象初始化是一个时间相对较长的过程。","link":"/2021/06/28/ckwasv94y000nv45c24f77k85/"},{"title":"如何编写高效、优雅、可信代码系列（1）——C++多线程强制终止","text":"故事的起因来源于我在优化他人c++源码的时候，想通过多线程的方式提升程序的运算效率，主要存在以下需求和难点： 多个线程并行跑模型，看哪个模型跑的快，跑出来后结束其他线程，线程间独立运行无通信过程 源码模型很复杂，函数调用较多，不好改动，因此不太适合通过信号或标志进行通信终止 网上搜索了一下线程结束的几种方式： 线程函数的return返回（建议）。这种退出线程的方式是最安全的，在线程函数return返回后, 会清理函数内申请的类对象, 即调用这些对象的析构函数.。然后会自动调用 _endthreadex()函数来清理 _beginthreadex()函数申请的资源(主要是创建的tiddata对象)。 同一个进程或另一个进程中的线程调用TerminateThread函数（应避免使用该方法）。TerminateThread能够撤消任何线程，其中hThread参数用于标识被终止运行的线程的句柄。当线程终止运行时，它的退出代码成为你作为dwExitCode参数传递的值。同时，线程的内核对象的使用计数也被递减。注意TerminateThread函数是异步运行的函数，也就是说，它告诉系统你想要线程终止运行，但是，当函数返回时，不能保证线程被撤消。如果需要确切地知道该线程已经终止运行，必须调用WaitForSingleObject或者类似的函数，传递线程的句柄。 通过调用ExitThread函数，线程将自行撤消（最好不使用该方法）。该函数将终止线程的运行，并导致操作系统清除该线程使用的所有操作系统资源。但是，C++资源（如C++类对象）将不被析构。 ExitProcess和TerminateProcess函数也可以用来终止线程的运行（应避免使用该方法）。 选项2和3可能会导致内存泄漏，实际上，没有任何语言或操作系统可以为你提供异步突然终止线程的便利，且不会警告你不要使用它们。所有这些执行环境都强烈建议开发人员，甚至要求在协作或同步线程终止的基础上构建多线程应用程序。 现有的线程结束函数，包括linux系统的pthread.h中的pthread_exit()和pthread_cancel()，windows系统的win32.h中的ExitThread()和TerminateThread()，也就是说，C++没有提供kill掉某个线程的能力，只能被动地等待某个线程的自然结束，析构函数~thread()也不能停止线程，析构函数只能在线程静止时终止线程joinable，对于连接/分离的线程，析构函数根本无法终止线程。 要终止与OS /编译器相关的函数的线程，我们需要知道如何从C++获取本机线程数据类型std::thread。幸运的是，在调用或之前std::thread提供了一个API native_handle()以获取线程的本机句柄类型。并且可以将此本地句柄传递给本地OS线程终止函数，例如join() detach() pthread_cancel()。 以下代码用于显示std::thread::native_handle()，std::thread::get_id()并pthread_self()返回相同的代码pthread_t来处理Linux / GCC的C++线程123456789101112131415161718192021222324252627282930#include &lt;mutex&gt;#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;cstring&gt;#include &lt;pthread.h&gt; std::mutex iomutex;void f(int num){ std::this_thread::sleep_for(std::chrono::seconds(1)); std::lock_guard&lt;std::mutex&gt; lk(iomutex); std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; num &lt;&lt; &quot; pthread_t &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl;} int main(){ std::thread t1(f, 1), t2(f, 2); //t1.join(); t2.join(); ----------------pos 1 //t1.detach(); t2.detach(); -------------pos 2 std::cout &lt;&lt; &quot;Thread 1 thread id &quot; &lt;&lt; t1.get_id() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Thread 2 thread id &quot; &lt;&lt; t2.get_id() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Thread 1 native handle &quot; &lt;&lt; t1.native_handle() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Thread 2 native handle &quot; &lt;&lt; t2.native_handle() &lt;&lt; std::endl; t1.join(); t2.join(); //t1.detach(); t2.detach();} 运行后可以得到结果12345678$ g++ -Wall -std=c++11 cpp_thread_pthread.cc -o cpp_thread_pthread -pthread -lpthread$ ./cpp_thread_pthread Thread 1 thread id 140109390030592Thread 2 thread id 140109381637888Thread 1 native handle 140109390030592Thread 2 native handle 140109381637888Thread 1 pthread_t 140109390030592Thread 2 pthread_t 140109381637888 uncommentpos 1或者pos 2后，即调用join()或之后detach()，C++线程会丢失本机句柄类型的信息1234567$ ./cpp_thread_pthreadThread 1 pthread_t 139811504355072Thread 2 pthread_t 139811495962368Thread 1 thread id thread::id of a non-executing threadThread 2 thread id thread::id of a non-executing threadThread 1 native handle 0Thread 2 native handle 0 因此，要有效地调用本机线程终止函数（例如pthread_cancel），需要在调用std::thread::join()时或之前保存本机句柄std::thread::detach()。这样，始终可以使用有效的本机句柄终止线程。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Foo {public: void sleep_for(const std::string &amp;tname, int num) { prctl(PR_SET_NAME,tname.c_str(),0,0,0); sleep(num); } void start_thread(const std::string &amp;tname) { std::thread thrd = std::thread(&amp;Foo::sleep_for, this, tname, 3600); tm_[tname] = thrd.native_handle(); thrd.detach(); std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; tname &lt;&lt; &quot; created:&quot; &lt;&lt; std::endl; } void stop_thread(const std::string &amp;tname) { ThreadMap::const_iterator it = tm_.find(tname); if (it != tm_.end()) { pthread_cancel(it-&gt;second); tm_.erase(tname); std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; tname &lt;&lt; &quot; killed:&quot; &lt;&lt; std::endl; } }private: typedef std::unordered_map&lt;std::string, pthread_t&gt; ThreadMap; ThreadMap tm_;};int main(){ Foo foo; std::string keyword(&quot;test_thread&quot;); std::string tname1 = keyword + &quot;1&quot;; std::string tname2 = keyword + &quot;2&quot;; // create and kill thread 1 foo.start_thread(tname1); foo.stop_thread(tname1); // create and kill thread 2 foo.start_thread(tname2); foo.stop_thread(tname2); return 0;} 结果是12345678$ g++ -Wall -std=c++11 kill_cpp_thread.cc -o kill_cpp_thread -pthread -lpthread$ ./kill_cpp_thread Thread test_thread1 created:30332 30333 pts/5 00:00:00 test_thread1Thread test_thread1 killed:Thread test_thread2 created:30332 30340 pts/5 00:00:00 test_thread2Thread test_thread2 killed: 当然，条件允许的话最好还是使用返回或信号的方式终止线程，这样也符合安全可信的要求。 【转载声明】转载请附上原贴，阿里嘎多。","link":"/2021/06/28/ckwasv953000xv45clyov74p7/"},{"title":"智能优化算法（9）：其他类型的优化算法","text":"3.3 其他类型的优化算法3.3.1 和声搜索算法和声搜索（Harmony search, HS）算法从和声记忆库按照考虑概率选择一个音调，再按照音调调整概率确定是否对选择的音调进行调整，若需调整利用步长微调，在现有和声记忆库外产生一个音调，称为随机化。用最好的新和声替换最差的和声，不断重复。算法流程图： 应用案例：管道优化设计、土坡稳定性分析、电力系统经济导读和模糊控制器设计 3.3.2 大洪水算法大洪水算法（Great Deluge Algorithm, GDA）类似于模拟退火算法，属于单点搜索，区别在于新解的接受方式，模拟退火通过Metropolis准则判断是否接受新解，而GDA通过新解函数值和水平面值的比较进行判断。 算法流程图： 应用案例:电力调度问题、复杂系统可靠度问题、排课表问题和二次分配问题（集成电路布线、打字机键盘设计、作业调度、物流运输） 3.3.3 正弦余弦算法正弦余弦算法（Sine Cosine Algorithm, SCA）2016年才提出，是一种基于数学规律的元启发方法，基于正弦函数和余弦函数值的变化实现优化搜索，不同于现有任何一种优化算法。 应用案例：电力系统安全性问题、经济负荷分配问题、结构损伤测试问题和太阳能光伏电池充电问题 3.3.4 竞争决策算法竞争决策算法（Competitive Decision Algorithm, CDA）是中国学者2006年在分析大自然生物界特别是人类各种竞争机制和决策原理基础上，利用竞争造就优化和决策左右结果的特性得出的一种寻优算法，主要用于求解NP-hard问题。 应用案例：设施选址、最小比率生成树、多目标最小生成树、最小顶点覆盖、TSP、瓶颈TSP、车辆路径和背包问题等 3.3.3 文化算法文化算法（Cultureal Algorithm, CA）模拟人类社会的文化进化过程，在现有智能优化算法基础上，提取隐含在进化过程中的各种信息，以知识的形式加以存储，指导算法的优化过程。 应用案例：数据挖掘、欺骗检测、服务器集群自适应负载均衡、电路板布局设计","link":"/2020/07/17/ckwasv954000yv45ct0kgxq8w/"},{"title":"智能优化算法（8）：差分进化算法","text":"3.2 差分进化算法差分进化（Differential Evolution, DE）算法是在求解Chebyshev多项式拟合问题时提出的，算法主要通过基于差分形式的变异操作和基于概率选择的交叉操作进行优化搜索。DE算法最初的设计方法源于遗传退火算法，主要操作包括变异、交叉和选择，但具体实现方法与遗传算法有本质区别。 3.2.1 算法原理算法首先对搜索群体进行初始化。假设$NP$表示群体规模，$D$表示变量维数，$G$表示迭代次数，令$X_{i,G}$表示第$G$代的寻优个体$i$，并可以表示为： X_{i,G} = [X_{i,G}^1, X_{i,G}^2,...,X_{i,G}^D] \\tag{1}对每个搜索个体的解采用随机初始化方法，例如个体$i$的第$j$个解的分量可以通过如下方法产生： X_{i,0}^j = X_{\\min}^j + r(X_{\\max}^j-X_{\\min}^j) \\tag{2}其中$X_{\\max}^j$和$X_{\\min}^j$分别表示第$j$个分量的上下界；$r$表示在[0,1]间服从均匀分布的随机数。完成初始化后，进入循环 1. 变异操作 在DE算法中，经典的变异操作是在目标向量的基础上，利用两个向量的差分进行解的更新，比如： V_{i,G} = X_{r_1, G}+F(X_{r_2, G}-X_{r_3, G}) \\tag{3}其中$r_1,r_2,r_3$是从当前搜索群体中随机选择的三个个体编号，要求$r_1\\ne r_2 \\ne r_3$；$X_{i,G}$称为目标向量；$V_{i,G}$表示个体$X_{i,G}$变异后的解向量，称为个体i的合成向量；$X_{r_1,G}$表示被选择的进行变异的向量，$X_{r_2,G}$和$X_{r_3,G}$是被选择进行差分操作的两个向量；系数$F$称为缩放因子，用于控制差分向量对变异公式的影响。 2. 交叉操作 在DE算法中，交叉操作是利用合成向量$V_{i,G}$和目标向量$X_{i,G}$的分量进行重新组合产生试验向量$U_{i,G}$，以提高解的多样性。目前，二项式交叉和指数交叉是DE算法主要的交叉方法，二项式交叉对应定义如下： U_{i,G}^j=\\left\\{ \\begin{aligned} &V_{i,G}^j, if\\; rand \\le \\; Cr \\;or \\; j=j_{rand} \\\\ &X_{i,G}^j, otherwise \\end{aligned} \\right. \\tag{4}其中，rand表示[0,1]之间服从均匀分布的随机数；Cr表示交叉概率，且取值与[0,1]；$j_{rand}$表示在区间[1,D]上随机产生的整数。 指数交叉实现方法如下： U_{i,G}^j=\\left\\{ \\begin{aligned} &V_{i,G}^j, j=_D,_D,...,_D \\\\ &X_{i,G}^j, otherwise \\end{aligned} \\right. \\tag{5}其中,$n$和$L$是在[1,D]上随机产生的整数；$&lt;&gt;_D$表示对D进行取模运算。 3. 选择操作选择操作是基于贪婪策略，比较试验向量$U_{i,G}$和目标向量$X_{i,G}$的优劣，挑选更优的值作为下一代的目标向量。 DE算法的流程如下图所示： 上述算法是差分优化算法的基本形式，目前还有其他版本的算法，可以用DE$/x/y/z$表示，其中$x$表示被变异的向量选择方法；$y$表示变异种采用的差分向量的个数；$z$表示交叉操作的方法，上bin表示二项式交叉，exp表示指数交叉，因此前面的DE算法可以表示为DE$/rand/1/bin$，此外，其他DE算法的形式有： DE$/rand/2/bin$ DE$/best/1/bin$ DE$/best/2/bin$ DE$/target-to-best/1/bin$ DE$/rand/1/exp$ 3.2.2 应用案例瓶颈TSP问题（不追求总巡回路线最短，希望在巡回路线中单次行程尽可能短）、Chebyshev多项式拟合问题","link":"/2020/07/17/ckwasv94n0007v45cvdk3b3wa/"},{"title":"智能优化算法（7）：禁忌搜索算法","text":"3.1 禁忌搜索算法禁忌搜索（Tabu Search, TS）算法是局部搜索算法的拓展，采用禁忌表来记录已经到达过的局部最优点，使得在以后一段时期内的搜索中，不再重复搜索这些解，以此跳出局部极值点。 3.1.1 算法原理区别于模拟退火算法通过温度调整算法从搜索空间的一个点移动到另一个点的概率来避免局部极值，在禁忌搜索算法中，是通过禁忌表驱动算法探索搜索空间的位置区域来避免早熟收敛。 局部最优解：给定一个最优化问题实例$(F, f)$的一个邻域$N$，一个可行解$x\\in F$，若$\\forall g \\in N(x)$ 有 $f(x)\\le f(g)$，称$x$为关于$N$的局部最优解。 邻域：对于组合优化问题$(D,F,f)$，其中$D$为所有解构成的状态空间，$F$为$D$上的可行域，$f$为目标函数，则一个邻域函数可定义为一种映射，即： N:x\\in D -> N(x) \\in 2^D其中，$2^D$表示所有子集的集合,$N(x)$为$x$的邻域。 局部搜索算法本质上说是基于贪婪策略的搜索算法，容易实现，但是算法往往会陷入局部极值，无法保证获得全局最优解，为避免早熟收敛，禁忌搜索算法通过禁忌策略扩大寻优范围，提高算法全局优化能力。 3.1.2 算法模型禁忌搜索算法第一次在优化过程中使用了记忆功能，使用禁忌表来避免重复搜索，扩大搜索区域。 1. 禁忌表 禁忌表由禁忌对象和禁忌长度组成，禁忌对象是产生解变化的因素，而禁忌长度是禁忌对象被禁次数。 禁忌对象分为解的简单变化、解向量分量变化、目标值变化 解的简单变化。从解空间中的$x$到$y$ 解向量分量的变化。解向量有$n$维，其中一维或者某几维发生变化 目标值变化。具有相同目标值的解认为是同一状态， 2. 禁忌长度 禁忌长度就是被禁对象不允许被选择的迭代次数。 设置禁忌长度$t$的方法主要有两种： $t$为常数。 $t$随迭代次数调整 研究表明，禁忌长度较大时，算法可以在更多的位置区域进行优化搜索，全局探索性能较好；禁忌长度较小时，算法可以进行精细搜索，局部开发能力较强。动态调整的禁忌长度比固定不变的禁忌长度能够让算法具有更好的性能。 3. 特设准则 优化过程中，可能会出现邻域解全是被禁对象，或者解禁某个对象后最优值发生改进。因此，可以将某个被禁对象解禁。 设置常用方法主要有以下几种： 基于评价值准则：如果邻域解的评价值优于历史当前最优值 基于最小错误原则：如果邻域解全是被禁对象，而且不满足评价值准则，那么可以从所有邻域解中选一个最优的 基于影响力准则：有些对象的变化对目标值影响较大 TS的流程图：","link":"/2020/07/17/ckwasv94w000iv45ct2ljfnrl/"},{"title":"智能优化算法（6）：其他基于物理学原理的优化算法","text":"2.2 其他基于物理学原理的优化算法2.2.1 引力搜索算法受万有引力定律启发，学着提出了一种新型的群体智能优化算法——引力搜索算法（Gravitational Search Algorithm, GSA）。 万有引力定律：自然界中任何两个物体都是相互吸引的，引力的大小跟这两个物体的质量的乘积成正比，跟它们的距离的二次方成反比，数学表达式为： F=G\\frac{m_1 m_2}{r^2}其中，$F$表示两个物体间的引力，$G$表示万有引力常数，$m_1$和$m_2$分别表示物体1和物体2的质量，$r$表示两个物体间的距离。 引力搜索算法在求解优化问题时，搜索个体的位置和问题的解相对应，个体质量用于评价个体的优劣，位置越好，质量越大。由于引力作用，个体之间相互吸引并且朝着质量较大的个体方向移动，个体运动遵循牛顿第二定律，随着运动不断进行，最终这个群体都会聚集在质量最大个体的周围，从而找到质量最大的个体，而质量最大的个体占据最优位置，因此算法可以获得问题的最优解。 算法流程如下图所示： 应用案例：投资者偏好条件下概率准则投资组合问题 智能优化算法一般不要求目标函数连续性和可微性，甚至有时连有没有解析表达式都不要求，并且对计算中数据的不确定性也有很强的适应能力。 2.2.2 混沌优化算法基于混沌现象（貌似无规律的复杂运动形态）的独特性质——遍历性、随机性以及规律性，我国学者李兵提出混沌优化算法，通过载波方法将混沌状态和决策变量相对应，然后将混沌运动的遍历范围映射到决策变量的的取值范围，最后利用混沌变量进行优化搜索。 混沌优化算法的几种特征： 初值敏感性 遍历性 规律性 随机性 算法基本步骤： 算法初始化。 第一次载波。 用混沌变量进行迭代搜索。 经过若干次搜索后优化目标函数值没有发生改变，进行第二次搜索。 运用二次载波后的混沌变量进行迭代搜搜。 满足终止条件，终止搜索；否则返回步骤5。 应用案例：求解天体力学Kepler方程 2.2.3 随机分形搜索算法随机分形搜索算法（Stochastic Fractal Search Algorithm, SFS）采用高斯随机游走模型，基于个体当前位置进行扩散，并根据适应度函数对个体位置做进一步更新。 分形：自相似性，部分与整体具有相似性，图案之中递归的套着图案。 随机分形搜索算法将微粒类比为寻优个体，扩散过程类比为优化过程，寻优个体的位置和待优化问题的解相对应，且个体位置的优劣将通过目标函数值的大小进行评价。 主要步骤： 设置算法参数，进行种群初始化 计算个体适应度函数值，找到当前最佳点BP 执行扩散过程，对于每一个扩散的个体，根据选择的高斯游走模型生成新个体的新位置 进行群体第一次更新 进行群体第二次更新 判断终止条件，不满足则执行步骤2 应用案例：CEC2010测试函数库 2.2.4 光学优化算法光学优化算法（Optics Inspired Optimization, OIO）2015年才提出，假设初始解为一系列初始光源点，经球面镜函数反射，得到相应的像点，这一系列像点，作为下一次搜索的光源点，不断反射搜索，即可找到最优解。 应用案例：城市排水工程——暴雨强度公式参数优化 2.2.5 量子优化算法量子计算（Quantum computing, QC），遇事不决，量子力学。 量子优化算法可以和很多优化算法结合，比如量子神经计算、量子遗传算法、量子退火算法等，与其他优化算法相比建模方式有所区别，编码方式也不同 应用案例：VRP问题","link":"/2020/07/17/ckwasv9550010v45colhh94m2/"},{"title":"智能优化算法（5）：模拟退火算法","text":"2.1 模拟退火算法模拟退火（Simlated Annealing, SA）算法是一种全局搜索算法，是局部搜索算法的拓展。区别于其他算法，模拟退火算法不要求每次产生的新解质量都有提高。 2.1.1 算法原理SA源于物理退火过程的模拟，在热力学和物理学中，将固体加温至融化状态，待其徐徐冷却之后使其凝固成规整晶体的过程称为物理退火，可以分为升温过程、降温过程和等温过程三个部分： 升温过程：加热过程中，温度不断升高，固体粒子热运动增强，能量也在增加；到熔点后固定融化为液态。粒子自由运动增加，从有序的结晶态转变为无序的液态，有助于消除固体内的非均匀态，使得随后的降温过程以某一平衡态为起点。 降温过程：在冷却时，温度慢慢降低，分子的热运动减弱，逐渐趋向有序。当温度到达结晶温度时，液体凝固，系统熵减小。在冷却时如果温度急剧降低物体只会冷凝为非均匀的亚稳态，系统能量也不会达到最小值。 等温过程：在物理退火中，系统在每一个温度下面达到平衡态的过程可以用封闭系统的等温过程来描述，即热力学系统在恒定温度下发生的各种物理或者化学过程。该过程可以保证每个温度下系统都能达到平衡态，最终达到固体的基态。 2.1.2 算法模型在SA求解优化问题时，解和目标函数类似于退火过程中物体的状态和能量函数，而最优解就是物体达到能量最低的状态。物理退火过程和模拟退火算法的对应关系| 物理退火过程 | 模拟退火算法 || —— | —— || 系统状态 | 解 || 系统能量 | 目标函数 || 系统最低能量状态（基态）| 全局最优解|| 加温过程 | 设置初始高温 || 降温过程 | 温度下降|| 等温过程 | 基于Metropolis准则搜索 | 算法流程： 设置初始高温和终止温度，选择任意初始解$x$ 内循环，在当前温度下随机产生一个邻域解$y\\in N(x)$($N(x)$表示$x$的邻域)，根据Metropolis准则，判断是否选择新解$y$。如此反复进行直到达到满足内循环停止条件。 外循环，若满足外循环终止条件算法停止 为达到每个温度下的平衡态，内循环次数要足够多，但在实际应用中无法达到理论上的平衡态，通常将内循环的次数设为常数值，在外循环中，通过调整温度来控制算法的搜索过程。 2.1.3 Metropolis准则假设在温度$T$下，由当前状态$i$产生新的状态$j$，两种状态对应的能量分布为$E_i$和$E_j$，如果$E_i&gt;E_j$，那么就接受新状态$j$。如果$E_i&lt;E_j$，那么要根据系统处于新状态$j$的概率判断该状态是否为重要状态。上述概率用$r$表示，且 r=\\exp(-(E_j-E_i)/K_BT)其中，$K_B$为Boltzman常数。 在[0,1]之间产生随机数$\\xi$，如果$r&gt;\\xi$，那么新状态$j$为重要桩体，接受该状态，否则仍然保留状态$i$。 2.1.4 应用案例平面选址问题，欧氏距离选址，绝对值选址","link":"/2020/07/17/ckwasv94v000hv45cp94dhpkq/"},{"title":"智能优化算法（4）：人工蜂群优化算法与其他基于生物学原理的优化算法","text":"人工蜂群算法（Artificial Bee Colony Algorithm, ABC），是模拟工蜂的觅食行为提出的，由三个基本部分组成，包括蜜源、雇佣蜂和未雇佣蜂；定义两种行为，包括招募蜜蜂到蜜源和放弃蜜源。 蜜源：由含蜜量的多少、距离蜂巢的远近以及采集花蜜的难易程度决定。在人工蜂群算法中对应适应度值，蜜源的质量直接决定了目标函数的优劣。 雇佣蜂：（Employed Bees），也称为引领蜂，主要任务是勘探蜜源，数量与发现的蜜源数量相同，任务是将每一个蜜源信息传递到蜂巢的其他蜜蜂。 非雇佣蜂：分为跟随蜂（Onlooker Bees）和侦察蜂（Scout Bees）。初始时刻，跟随蜂的数量和雇佣蜂相同，在蜂巢中等待雇佣蜂传递回信息后按照一定的策略选择蜜源，并进行开采；侦查蜂在蜂巢附近探索新的蜜源，如果探索到的蜜源优于已选择蜜源则对其进行替换。 1.4.1 算法模型对各引领蜂的位置进行初始化，随机产生$2N$个位置，并取较为优异的$N$个位置作为蜜源位置，引领蜂根据采蜜经验，在领域范围内利用下式产生一个新位置，评估新位置的蜜源质量，即当前位置的适应度值。若蜜源质量高于原蜜源质量，则新位置替换原位置。 v_{ij}=x_{ij}+\\phi (x_{ij}-x_{kj}) \\tag{1}其中$v_{ij}$是新位置，$x_{ij}$是原位置，$x_{kj}$是随机选取的邻居蜜源位置；$\\phi$是在$[-1,1]$上服从均匀分布的随机数；$k=1,2,…,BN$(BN为种群规模)；$j={1,2,…,n}$（$n$为维数）。 引领蜂通过跳摇摆舞将蜜源信息分享给跟随蜂，跟随蜂利用下式通过轮盘赌机制来选择一个蜜源，在利用式(1)在此蜜源附近随机产生新蜜源新位置，比较新位置和原位置的蜜源质量，若新位置的蜜源质量更好，则保存新位置。 p_i = fit_i/\\sum_{n=1}^BN fit_nfit_i=\\left\\{ \\begin{aligned} \\frac{1}{1+f_i}, f_i\\ge 0 \\\\ 1+|f_i|,fi","link":"/2020/07/17/ckwasv94k0003v45c48hs3kks/"},{"title":"智能优化算法（3）：微粒群优化算法","text":"1.3 微粒群优化算法微粒群优化（Particle Swarm Optimization, PSO）算法，或称为粒子群优化算法，是一种基于鸟群觅食行为规律提出的群体智能优化算法。算法概念简明，易于实现。 在群体觅食过程中，群体中的每一个个体都会受益于所有成员在这个过程中发现和积累的经验。而基于信息交流和共享的个体检的协作正式微粒群优化算法进行优化搜索的基础。 微粒群算法模拟鸟类觅食模型，将优化问题的搜搜空间类比作鸟类的飞行空间，所需要找到的最优解相当于食物，算法将每只鸟抽象为没有质量的微粒，每个微粒有位置和速度两个特征向量，位置代表候选解，解的优劣通过适应度函数大小进行评价；微粒速度决定飞行方向和速率。 优化过程中，微粒和位置和其他算法一样需要随机初始化，通过迭代进行更新，每次迭代需要通过两个极值进行更新，第一个是每个微粒当前所找到的最好的解，称为个体极值；第二个极值是整个群体找到的最好的解，称为全局极值。每个微粒根据自身经验和群体经验进行更新。 1.3.1 算法模型设待求解的优化问题维度为$N$，微粒群体规模为$M$，在微粒群优化算法中，$x_i = (x_{i1}, x_{i2}, x_{i3}, …, x_{iN})$表示第$i$个微粒的位置；$v_i=(v_{i1},v_{i2},…,v_{iN})$表示第$i$个微粒的速度；$p_i=(p_{i1},p_{i2},…,p_{iN})$表示第$i$个微粒所搜寻到的最好的位置；$g_i=(g_{1},g_{2},…,g_{N})$表示整个群体所搜寻到的最好的位置。 Eberhart和Kennedy最初提出的基本微粒群优化算法采用如下迭代方程进行速度和位置的更新： v_{id}(t+1) = v_{id}(t)+c_1r_1(p_{id}(t)-x_{id}(t))+c_2r_2(g_{d}(t)-x_{d}(t))x_{id}(t+1) = x_{id}(t)+v_{id}(t+1)其中，$i=1,2,…,M;d=1,2,…,N;c_1$和$c_2$是学习因子;$t$表示迭代次数；$r_1$和$r_2$是在$[0,1]$上服从均匀分布的随机数。 在速度更新方程中，第一项表示微粒根据自身的速度进行惯性运动；第二项表示微粒根据自身经验进行调整，称为认知部分；第三项表示微粒根据其他微粒的经验进行调整，称为社会部分。需要指出的是，为了防止微粒的速度过大或者过小，需要限定速度的范围： v_{id}(t+1) > v_{\\max} \\rightarrow v_{id}(t+1) = v_{\\max}v_{id}(t+1) < -v_{\\max} \\rightarrow v_{id}(t+1) = -v_{\\max}在求解边界约束问题上，如果更新后位置越界，常见的修正方法是将其限定在边界上。在公式1中，$g$是整个群体的最好位置。上述算法称为微粒群优化算法的全局版本；此外，也可以将微粒领域内的最好位置设为$g$，则称为局部版本；全局版本算法优化速度快，但是容易陷入局部最优；而局部版本算法优化速度慢，但容易找到更优解。 算法基本流程： 1.3.2 算法分析学习因子学习因子$c_1_$和$c_2$是微粒根据自身经验和社会经验对其运动进行更新的权重。如果令$c_1$为0，那么微粒缺乏自身经验，这是算法的优化速度可能比较快，但容易陷入局部极值；如果令$c_2$为0，那么优化信息无法在群体内传播，微粒搜索到最优解的概率非常低；如果同时为0，那么算法优化性能会急剧下降。 领域拓扑结构微粒群间的信息交流是算法的重要组成部分，通过为止共享，每个微粒能够向比自身位置更好的方向运动，而领域拓扑就决定了信息交流的方向。拓扑类型有： 环型（每个微粒受近邻影响，只向最好近邻位置运动） 星型（全局领域拓扑，完全图，计算复杂度较高） 齿型（发散的，中心向最好微粒逼近，再把经验传递给其他微粒，其他微粒两两不相连） 研究发现，环型拓扑收敛速度慢，容易找到全局最优解；星型拓扑收敛速度快，容易陷入局部极值；齿型拓扑优化效果差。这三种属于静态拓扑，还有动态拓扑——优化最小距离、逐步增长、重新组合。 在基本微粒群优化算法的基础上，有人提出了带惯性权重和收缩因子的两种算法版本： 惯性权重 v_{id}(t+1) = wv_{id}(t)+c_1r_1(p_{id}(t)-x_{id}(t))+c_2r_2(g_{d}(t)-x_{d}(t))其中$w$是惯性权重，用于对速度的控制；较大的惯性权重保证算法具有较强的全局探索能力，较小的惯性权重能保证算法具有较强的局部开发能力。目前，使惯性权重随迭代次数线性递减是最基本的策略，带惯性权重的优化算法是目前主流的算法版本。 收缩因子 v_{id}(t+1) = \\chi (v_{id}(t)+c_1r_1(p_{id}(t)-x_{id}(t))+c_2r_2(g_{d}(t)-x_{d}(t)))其中收缩因子$\\chi$是$c_1$和$c_2$的函数，函数表达式为： \\chi = \\frac{2}{|2-\\mu -\\sqrt{\\mu^2-4\\mu}|}其中$\\mu = c_1+c_2&gt;4$ 1.3.3 应用案例多目标优化","link":"/2020/07/17/ckwasv94u000gv45c62m2l3j5/"},{"title":"智能优化算法（2）：蚁群算法","text":"1.2 蚁群优化算法蚁群优化（Ant Colony Optimization, ACO）算法是源自大自然生物界的仿真类算法，其思想吸收了蚁群觅食过程中的行为特性。蚁群算法在TSP问题、二次分配问题、图着色问题、车辆调度问题、通信网络中的负载均衡问题等表现出良好的优化性能。 大自然中的蚂蚁没有视觉，依赖于同类散发在环境中的信息素决定自己何去何从，孤立的蚂蚁沿着同伴的信息素轨迹移动，同时释放自己的信息素，从而增强了该路线上的信息素数量，随着越来越多的蚂蚁通过该路线，一条较佳的路线就形成了（这条路径不一定最短，但对于NP-hard问题而言足够了）。 1.2.1 算法模型以旅行商问题（Traveling Salesman Problem, TSP）为例，在图论中称为最小Hamilton问题。 记$G = (V,E)$为赋权图，$V=(1,2,3,…,N)$为顶点集，$E$为边集，各顶点间的距离$d_{ij}$已知$(d_{ij}&gt;0,d_{ii}=\\infty,i,j\\in V)$，设 x_{ij} = 1, 若(i,j)在最优回路上；否则为0则经典的TSP问题可以表示如下： \\min Z = \\sum_{i=1}^{n}\\sum_{j=1}^{n}d_{ij}x_{ij}服从如下几个约束： 约束1：$\\sum_{j=1}^{n}x_{ij}=1, i\\in V$ 约束2：$\\sum_{i=1}^{n}x_{ij}=1, j\\in V$ 约束3：$\\sum_{i\\in S}\\sum_{j\\in S}x_{ij} \\le |S|-1, \\forall S \\subset V$ 约束4：$x_{ij}\\in \\{0, 1\\}$ 其中$|S|$为集合中所含图的顶点数；约束1和2对于每个点来说只有一条边进一条边出，也就是任意两个点间只有一条最优路线；约束3保证了没有任何子回路的产生。 当$d_{ij} = d_{ji}$时，问题被称为对称型TSP；当对于所有$1\\le i, j,k \\le n$时，有不等式$d_{ij}+d_{jk}\\ge d_{ik}$成立，问题被称为是满足三角形不等式的，记为$\\Delta$TSP。三角形不等式在很多情况下是满足的，即使不满足也可以转换为闭包形式求等价TSP最优解。 蚁群优化算法基本模型： 蚂蚁群体总是寻找最小费用可行解 蚂蚁具有记忆性，存储当前路径的信息，构造可行解、评价解的质量、路径反向追踪 当前状态的蚂蚁可以移动到可行领域任意一点 每个蚂蚁赋予一个初始状态和若干个终止条件 蚂蚁从初始状态到可行领域状态，以递推方式构造解，当有一个蚂蚁满足至少一个终止条件时构造过程结束 蚂蚁按某种概率决策规则移动至领域结点 移动后信息素轨迹被更新，过程称为“单步在线信息素更新” 一旦构造出一个解，蚂蚁沿原路方向追踪，更新信息素轨迹，称为“在线延迟信息素更新” 1.2.2 算法分析算法复杂度是$O(nc\\cdot n^2\\cdot m)$，m为蚂蚁个数，nc为迭代次数或者搜索次数，n为顶点数。算法运行效果受到$\\alpha, \\beta$等参数影响，其中$\\beta$的影响在于体现信息素轨迹的持久性，数值过小意味着信息消失过快；数值过大容易落入局部最优点，因此其数值通常取0.7左右。 在基本的蚁群优化算法上，可以与其他启发式算法相结合，最典型的就是嵌入局部搜索算法，在各个蚂蚁形成自己的路线后，用局部调整方法（2-opt, 3-opt）加以改进，此外，与遗传算法、模拟退火和禁忌搜索等结合也有一定的成效。 混合蚁群优化算法主要步骤： Begin 蚂蚁初始化； LOOP： $\\quad$蚂蚁路径构造； $\\quad$对某个蚂蚁实施局部搜索算法 $\\quad$蚂蚁轨迹更新 $\\quad$若迭代次数未到，转LOOP； 输出当前最好解 End","link":"/2020/07/03/ckwasv94x000lv45cl41yjetc/"},{"title":"智能优化算法（1）：遗传算法","text":"1.1 遗传算法遗传算法（Genetic algorithm, GA），模拟生物在自然环境中遗传和进化的自适应（对遗传参数的自适应调整）全局优化（随机变异不断寻找全局最优解）算法，基本思想是“优胜劣汰”，是应用最广泛和效果最显著的智能优化算法。 1.1.1 编码方法算法模型通过对个体（individual，也即solution）进行二进制编码（01编码）、自然数编码、实数编码和树型编码。在对个体进行适应度计算时需要进行解码，实现问题的解空间与算法搜索空间的相互转换。 1.1.2 适应度函数每个个体都有一个适应度函数（Fitness），对这个个体的优劣进行定量评价，适应度函数是算法执行“适者生存、优胜劣汰”的依据。适应度函数需要根据目标函数进行设置，令$g(x)$表示目标函数，令$G(x)$表示适应度函数，从目标函数$g(x)$映射到适应度函数$G(x)$的过程称为标定。 对于最大值优化问题，可直接将$g(x)$设定为适应度函数$G(x)$，即$G(x)=g(x)$；对于最小值优化问题，$G(x)=-\\min g(x)$；在遗传算法规定中，适应度函数为正值，但上述二式无法保证，因此需要加上最小值或者最大值以及分段函数。 1.1.3 选择操作选择（Selection）是从当前群体中选择适应度函数值大的个体，这些优良个体有可能作为父代繁殖下一代，个体适应度函数越大，被选择作为父代的概率越大（有可能！） 选择算法有很多，最基本的是轮盘赌算法： P_i = \\frac{F_i}{\\sum_{i=1}^{N}F_i}其中，$P_i$表示个体被选择的概率；$F_i$表示个体的适应度函数值；$N$表示种群规模。 根据选择概率$P_i$将圆盘形赌轮分为$N$份，第$i$个扇形的中心角为$2\\pi P_i$。随机产生0到1之间服从均匀分布的数$r$，落在第$i$个扇形的累计概率为$Q_i = \\sum_{j=1}^i P_j$，则选择个体$i$，重复$N$次，就可以选择$N$个个体。 1.1.4 交叉操作两个个体通过交叉（Crossover）互换染色体部分基因而重组产生新的个体，也就是产生新解。交叉前需要进行随机配对。 一般情况下，对二进制编码的个体采用点交叉的方法，也就是在两个配对字符串随机选择一个或者多个交叉点，互换部分子串从而产生新的字符串 两个个体是否进行交叉操作由交叉概率决定，较大的交叉概率可以使遗传算法产生更多新解，保持群体多样性，并能防止算法过早成熟，但是交叉概率过大会使算法过多搜索不必要的解区域，消耗过多的计算时间，一般取值在0.9左右。 1.1.5 变异操作生物进化中，某些染色体可能会发生基因突变（Mutation），从而产生新的染色体，这也是产生新解的另外一种重要方式。交叉操作相当于进行全局探索，变异操作相当于进行局部开发，这也是智能优化算法必备的两种搜索能力。 个体能否变异取决于变异概率，过低会使得部分有用基因无法进入染色体，不能提高解的质量；过大会使子代丧失父代优良基因，导致算法失去从过去搜索经验的学习能力，一般情况下，变异概率取值为0.005左右。 值得注意的是，Rudolph通过马尔科夫链相关理论证明仅采用选择、交叉和变异三个操作的遗传算法不能收敛到全局最优解，而采用精英保留策略的遗传算法是全局收敛的。 算法的整体流程如下图所示： 1.1.6 算法分析一个好的智能算法，关键在于全局探索和局部开发能力的平衡。全局探索的目的是对解空间进行更全面的探索，局部开发主要目的是对已知区域进行更精细的搜索，希望获得质量更好的新解。 遗传算法可以通过设置选择压力实现全局探索和局部开发的平衡。在算法运行初始阶段，设置较小的选择压力可以使算法具有较好的全局探索能力，进行广域搜索；算法运行后期，设置较大的选择压力可以使算法进行比较精细的局部搜索。 选择压力的设置可以从适应度函数标定和选择策略。 适应度函数标定，在算法早期，应当缩小个体适应度差距，减少淘汰率；算法运行最后阶段，扩大个体适应度差距，保证算法能在高适应度个体对应解区域进行集中搜索，加快算法收敛速度。常用方法有： 线性尺度变换 $H = aF+b$ $\\sigma$截断法 $H = F+(\\hat F - c\\sigma)$ 幂律尺度变换 $H = F^\\alpha$ 选择策略，低选择压力可选择多种类型的个体，加强对未知解区域的搜索，避免算法陷入局部极值，但算法优化速度会变得缓慢；高选择压力可选择优良个体，加快优化速度但群体多样性会下降，减少搜索到全局最优值的概率。除了轮盘赌算法外，选择策略还有： 分级选择法 锦标赛选择法 Boltzmann选择法","link":"/2020/07/03/ckwasv94o0008v45cfrzmzpac/"},{"title":"【转载】Manacher's algorithm (马拉车算法)","text":"Manacher’s算法(C++代码实现) 文章作者：刘毅 (Ethson Liu) 发布日期：2018-04-03 原文链接：https://ethsonliu.com/2018/04/manacher.html 一：背景给定一个字符串，求出其最长回文子串。例如： s=”abcd”，最长回文长度为 1； s=”ababa”，最长回文长度为 5； s=”abccb”，最长回文长度为 4，即 bccb。 以上问题的传统思路大概是，遍历每一个字符，以该字符为中心向两边查找。其时间复杂度为 $O(n^2)$，效率很差。 1975 年，一个叫 Manacher 的人发明了一个算法，Manacher 算法（中文名：马拉车算法），该算法可以把时间复杂度提升到 $O(n)$。下面来看看马拉车算法是如何工作的。 二：算法过程分析由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：在字符串首尾，及各字符间各插入一个字符（前提这个字符未出现在串里）。 举个例子：s=&quot;abbahopxpo&quot;，转换为s_new=&quot;$#a#b#b#a#h#o#p#x#p#o#&quot;（这里的字符 $ 只是为了防止越界，下面代码会有说明），如此，s 里起初有一个偶回文abba和一个奇回文opxpo，被转换为#a#b#b#a#和#o#p#x#p#o#，长度都转换成了奇数。 定义一个辅助数组int p[]，其中p[i]表示以 i 为中心的最长回文的半径，例如： i 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 s_new[i] $ # a # b # b # a # h # o # p # x # p # p[i] 1 2 1 2 5 2 1 2 1 2 1 2 1 2 1 4 1 2 1 可以看出，p[i] - 1正好是原字符串中最长回文串的长度。 接下来的重点就是求解 p 数组，如下图：设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是mx = id + p[id]。 假设我们现在求p[i]，也就是以 i 为中心的最长回文半径，如果i &lt; mx，如上图，那么： 12if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); 2 * id - i为 i 关于 id 的对称点，即上图的 j 点，而p[j]表示以 j 为中心的最长回文半径，因此我们可以利用p[j]来加快查找。 三：代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt; #include &lt;cstring&gt;#include &lt;algorithm&gt; using namespace std;char s[1000];char s_new[2000];int p[2000];int Init(){ int len = strlen(s); s_new[0] = '$'; s_new[1] = '#'; int j = 2; for (int i = 0; i &lt; len; i++) { s_new[j++] = s[i]; s_new[j++] = '#'; } s_new[j] = '\\0'; // 别忘了哦 return j; // 返回 s_new 的长度}int Manacher(){ int len = Init(); // 取得新字符串长度并完成向 s_new 的转换 int max_len = -1; // 最长回文长度 int id; int mx = 0; for (int i = 1; i &lt; len; i++) { if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); // 需搞清楚上面那张图含义, mx 和 2*id-i 的含义 else p[i] = 1; while (s_new[i - p[i]] == s_new[i + p[i]]) // 不需边界判断，因为左有'$',右有'\\0' p[i]++; // 我们每走一步 i，都要和 mx 比较，我们希望 mx 尽可能的远，这样才能更有机会执行 if (i &lt; mx)这句代码，从而提高效率 if (mx &lt; i + p[i]) { id = i; mx = i + p[i]; } max_len = max(max_len, p[i] - 1); } return max_len;}int main(){ while (printf(\"请输入字符串：\\n\")) { scanf(\"%s\", s); printf(\"最长回文长度为 %d\\n\\n\", Manacher()); } return 0;} 四：算法复杂度分析文章开头已经提及，Manacher 算法为线性算法，即使最差情况下其时间复杂度亦为 $O(n)$，在进行证明之前，我们还需要更加深入地理解上述算法过程。 根据回文的性质，p[i]的值基于以下三种情况得出： （1）：j 的回文串有一部分在 id 的之外，如下图：上图中，黑线为 id 的回文，i 与 j 关于 id 对称，红线为 j 的回文。那么根据代码此时p[i] = mx - i，即紫线。那么p[i]还可以更大么？答案是不可能！见下图：假设右侧新增的紫色部分是p[i]可以增加的部分，那么根据回文的性质，a 等于 d ，也就是说 id 的回文不仅仅是黑线，而是黑线+两条紫线，矛盾，所以假设不成立，故p[i] = mx - i，不可以再增加一分。 （2）：j 回文串全部在 id 的内部，如下图：根据代码，此时p[i] = p[j]，那么p[i]还可以更大么？答案亦是不可能！见下图：假设右侧新增的红色部分是p[i]可以增加的部分，那么根据回文的性质，a 等于 b ，也就是说 j 的回文应该再加上 a 和 b ，矛盾，所以假设不成立，故p[i] = p[j]，也不可以再增加一分。 （3）：j 回文串左端正好与 id 的回文串左端重合，见下图：根据代码，此时p[i] = p[j]或p[i] = mx - i，并且p[i]还可以继续增加，所以需要 12while (s_new[i - p[i]] == s_new[i + p[i]]) p[i]++; 根据（1）（2）（3），很容易推出 Manacher 算法的最坏情况，即为字符串内全是相同字符的时候。在这里我们重点研究 Manacher() 中的 for 语句，推算发现 for 语句内平均访问每个字符 5 次，即时间复杂度为：$T_{worst}(n)=O(n)$。 同理，我们也很容易知道最佳情况下的时间复杂度，即字符串内字符各不相同的时候。推算得平均访问每个字符 4 次，即时间复杂度为：$T_{best}(n)=O(n)$。 综上，Manacher 算法的时间复杂度为 $O(n)$。","link":"/2020/04/05/ckwasv952000vv45cr75wwp2j/"},{"title":"【转载】Knuth–Morris–Pratt algorithm (KMP算法)","text":"KMP算法(C++代码实现) 文章作者：刘毅 (Ethson Liu) 发布日期：2018-04-04 原文链接：https://ethsonliu.com/2018/04/kmp.html 一：背景给定一个字符串，求出其最长回文子串。例如： s=”abcd”，最长回文长度为 1； s=”ababa”，最长回文长度为 5； s=”abccb”，最长回文长度为 4，即 bccb。 以上问题的传统思路大概是，遍历每一个字符，以该字符为中心向两边查找。其时间复杂度为 $O(n^2)$，效率很差。 1975 年，一个叫 Manacher 的人发明了一个算法，Manacher 算法（中文名：马拉车算法），该算法可以把时间复杂度提升到 $O(n)$。下面来看看马拉车算法是如何工作的。 二：算法过程分析由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：在字符串首尾，及各字符间各插入一个字符（前提这个字符未出现在串里）。 举个例子：s=&quot;abbahopxpo&quot;，转换为s_new=&quot;$#a#b#b#a#h#o#p#x#p#o#&quot;（这里的字符 $ 只是为了防止越界，下面代码会有说明），如此，s 里起初有一个偶回文abba和一个奇回文opxpo，被转换为#a#b#b#a#和#o#p#x#p#o#，长度都转换成了奇数。 定义一个辅助数组int p[]，其中p[i]表示以 i 为中心的最长回文的半径，例如： i 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 s_new[i] $ # a # b # b # a # h # o # p # x # p # p[i] 1 2 1 2 5 2 1 2 1 2 1 2 1 2 1 4 1 2 1 可以看出，p[i] - 1正好是原字符串中最长回文串的长度。 接下来的重点就是求解 p 数组，如下图：设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是mx = id + p[id]。 假设我们现在求p[i]，也就是以 i 为中心的最长回文半径，如果i &lt; mx，如上图，那么： 12if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); 2 * id - i为 i 关于 id 的对称点，即上图的 j 点，而p[j]表示以 j 为中心的最长回文半径，因此我们可以利用p[j]来加快查找。 三：代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt; #include &lt;cstring&gt;#include &lt;algorithm&gt; using namespace std;char s[1000];char s_new[2000];int p[2000];int Init(){ int len = strlen(s); s_new[0] = '$'; s_new[1] = '#'; int j = 2; for (int i = 0; i &lt; len; i++) { s_new[j++] = s[i]; s_new[j++] = '#'; } s_new[j] = '\\0'; // 别忘了哦 return j; // 返回 s_new 的长度}int Manacher(){ int len = Init(); // 取得新字符串长度并完成向 s_new 的转换 int max_len = -1; // 最长回文长度 int id; int mx = 0; for (int i = 1; i &lt; len; i++) { if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); // 需搞清楚上面那张图含义, mx 和 2*id-i 的含义 else p[i] = 1; while (s_new[i - p[i]] == s_new[i + p[i]]) // 不需边界判断，因为左有'$',右有'\\0' p[i]++; // 我们每走一步 i，都要和 mx 比较，我们希望 mx 尽可能的远，这样才能更有机会执行 if (i &lt; mx)这句代码，从而提高效率 if (mx &lt; i + p[i]) { id = i; mx = i + p[i]; } max_len = max(max_len, p[i] - 1); } return max_len;}int main(){ while (printf(\"请输入字符串：\\n\")) { scanf(\"%s\", s); printf(\"最长回文长度为 %d\\n\\n\", Manacher()); } return 0;} 四：算法复杂度分析文章开头已经提及，Manacher 算法为线性算法，即使最差情况下其时间复杂度亦为 $O(n)$，在进行证明之前，我们还需要更加深入地理解上述算法过程。 根据回文的性质，p[i]的值基于以下三种情况得出： （1）：j 的回文串有一部分在 id 的之外，如下图：上图中，黑线为 id 的回文，i 与 j 关于 id 对称，红线为 j 的回文。那么根据代码此时p[i] = mx - i，即紫线。那么p[i]还可以更大么？答案是不可能！见下图：假设右侧新增的紫色部分是p[i]可以增加的部分，那么根据回文的性质，a 等于 d ，也就是说 id 的回文不仅仅是黑线，而是黑线+两条紫线，矛盾，所以假设不成立，故p[i] = mx - i，不可以再增加一分。 （2）：j 回文串全部在 id 的内部，如下图：根据代码，此时p[i] = p[j]，那么p[i]还可以更大么？答案亦是不可能！见下图：假设右侧新增的红色部分是p[i]可以增加的部分，那么根据回文的性质，a 等于 b ，也就是说 j 的回文应该再加上 a 和 b ，矛盾，所以假设不成立，故p[i] = p[j]，也不可以再增加一分。 （3）：j 回文串左端正好与 id 的回文串左端重合，见下图：根据代码，此时p[i] = p[j]或p[i] = mx - i，并且p[i]还可以继续增加，所以需要 12while (s_new[i - p[i]] == s_new[i + p[i]]) p[i]++; 根据（1）（2）（3），很容易推出 Manacher 算法的最坏情况，即为字符串内全是相同字符的时候。在这里我们重点研究 Manacher() 中的 for 语句，推算发现 for 语句内平均访问每个字符 5 次，即时间复杂度为：$T_{worst}(n)=O(n)$。 同理，我们也很容易知道最佳情况下的时间复杂度，即字符串内字符各不相同的时候。推算得平均访问每个字符 4 次，即时间复杂度为：$T_{best}(n)=O(n)$。 综上，Manacher 算法的时间复杂度为 $O(n)$。","link":"/2020/03/19/ckwasv94r000bv45cq4j7b81n/"},{"title":"中国第二届高性能云计算大赛（MAXP)——京东云数据算法赛","text":"中国第二届高性能云计算大赛（MAXP)——京东云数据算法赛","link":"/2020/03/19/ckwasv94u000fv45c9klarhnh/"},{"title":"剑指offer题解(C++)","text":"剑指offer各题目的C++解法 剑指offer 1 二维数组查找 剑指offer 2 替换空格 剑指offer 3 从尾到头打印链表 剑指offer 4 重建二叉树 剑指offer 5 用两个栈实现队列 剑指offer 6 旋转数组的最小值 剑指offer 7 斐波那契数列 剑指offer 8 跳台阶 剑指offer 9 变态跳台阶 剑指offer 10 矩形覆盖 剑指offer 11 二进制中1的个数** 剑指offer 12 求base的exponent次方 剑指offer 13 调整数组奇偶顺序 剑指offer 14 链表倒数第k个结点 剑指offer 15 反转链表 剑指offer 16 合并两个排序的链表 剑指offer 17 树的子结构 剑指offer 18 二叉树的镜像 剑指offer 19 顺时针打印矩阵 剑指offer 20 包含Min函数的栈 剑指offer 21 栈的压入、弹出序列 剑指offer 22 从上往下打印二叉树 剑指offer 23 二叉搜索树的后序遍历序列 剑指offer 24 二叉树中和为某一值的所有路径 剑指offer 25 复杂链表的复制 剑指offer 26 二叉搜索树转双端链表** 剑指offer 27 字符串的排列 剑指offer 28 数组中出现超过一半的数 剑指offer 29 最小的k个数** 剑指offer 30 连续子数组最大和 剑指offer 31 整数中1的个数 剑指offer 32 把数组排成最小的数** 剑指offer 33 丑数 剑指offer 34 第一次出现的字符 剑指offer 35 数组中的逆序对** 剑指offer 36 两个链表的第一个公共结点 剑指offer 37 数组在排序数组出现的次数 剑指offer 38 二叉树深度 剑指offer 39 判断平衡二叉树 剑指offer 40 数组中只出现一次的数字 剑指offer 41 和为S的连续正数序列 剑指offer 42 和为S的两个数 剑指offer 43 左旋转字符串 剑指offer 44 翻转单词顺序列 剑指offer 45 扑克牌顺子 剑指offer 46 孩子们的游戏（圆圈里最后剩下的数） 剑指offer 47 求1+2+…+n 剑指offer 48 不用加减乘除做加法 剑指offer 49 把字符串转换为整数 剑指offer 50 数组中重复的数字 剑指offer 51 构建乘积数组 剑指offer 52 正则表达式匹配 剑指offer 53 表示数值的字符串 剑指offer 54 字符流中第一个不重复的字符 剑指offer 55 链表中环的入口节点 剑指offer 56 删除链表中重复的节点 剑指offer 57 二叉树的下一个节点 剑指offer 58 对称的二叉树 剑指offer 59 之字形打印二叉树 剑指offer 60 把二叉树打印成多行（层序遍历） 剑指offer 61 序列化二叉树 剑指offer 62 二叉搜索树的第k个结点 剑指offer 63 数据流中的中位数 剑指offer 64 滑动窗口的最大值 剑指offer 65 矩阵中的路径 剑指offer 66 机器人的动作范围 剑指offer 67 剪绳子 剑指offer 1 二维数组查找在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。12345678910111213141516171819202122232425262728293031// 左下往右上查找，快速定位地图经纬度 O(n+m)bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) { int rows = array.size(), cols = array[0].size(); int row=rows-1,col=0; while(row&gt;=0 &amp;&amp; col&lt;cols){ if(array[row][col]==target) return true; else if(array[row][col]&gt;target) row--; else col++; } return false;}// 二分法 O(nlogm) O(n+m)bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) { if(array.size()==0) return false; int nrows = array.size(), ncols= array[0].size(); for(int i=0;i&lt;nrows;i++){ int low=0; int high=ncols-1; while(low&lt;=high){ int mid=(low+high)/2; if(target&gt;array[i][mid]) low=mid+1; else if(target&lt;array[i][mid]) high=mid-1; else return true; } } return false; } 剑指offer 2 替换空格请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。12345678910111213141516171819202122// O(n)void replaceSpace(char *str,int length) { int count=0; for(int i=0;i&lt;length;i++){ if(str[i]==&apos; &apos;) count++; } for(int i=length-1;i&gt;=0;i--){ if(str[i]!=&apos; &apos;){ str[i+2*count]=str[i]; //非空格在新数组的位置 //0 1 2 3 4 5 6 7 8 //0 # 3 # 4 //0 % 2 0 3 % 2 0 4 } else{ count--; str[i+2*count]=&apos;%&apos;; str[i+2*count+1]=&apos;2&apos;; str[i+2*count+2]=&apos;0&apos;; } }} 剑指offer 3 从尾到头打印链表输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。1234567891011121314151617181920212223242526272829303132333435363738394041424344//递归vector&lt;int&gt; printListFromTailToHead(ListNode* head) { vector&lt;int&gt; res; if(head!=NULL){ if(head-&gt;next!=NULL){ res = printListFromTailToHead(head-&gt;next); } res.push_back(head-&gt;val); } return res;}//栈vector&lt;int&gt; printListFromTailToHead(ListNode* head) { vector&lt;int&gt; res; stack&lt;int&gt; sta; while(head!=NULL){ sta.push(head-&gt;val); head=head-&gt;next; } while(!sta.empty()){ res.push_back(sta.top()); sta.pop(); } return res;}// **链表原地反转**vector&lt;int&gt; printListFromTailToHead(struct ListNode* head) { vector&lt;int&gt; vec; ListNode *buf=head; ListNode *pre=buf; if(head==NULL) return vec; while(head-&gt;next!=NULL){ buf=head-&gt;next; head-&gt;next=buf-&gt;next; buf-&gt;next=pre; pre=buf; } while(buf){ vec.push_back(buf-&gt;val); buf=buf-&gt;next; } return vec;} 剑指offer 4 重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。1234567891011121314151617TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) { TreeNode* root = helper(pre, 0, pre.size()-1, vin, 0, vin.size()-1); return root;}TreeNode* helper(vector&lt;int&gt; pre, int startpre, int endpre, vector&lt;int&gt; vin, int startvin, int endvin){ if(startpre&gt;endpre||startvin&gt;endvin) return NULL; TreeNode* root=new TreeNode(pre[startpre]); for(int i=startvin;i&lt;=endvin;i++){ if(vin[i]==pre[startpre]){ root-&gt;left = helper(pre, startpre+1, startpre+i-startvin, vin, startvin, i-1); root-&gt;right = helper(pre, startpre+i-startvin+1, endpre, vin, i+1, endvin); break; } } return root;} 剑指offer 5 用两个栈实现队列用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。1234567891011121314151617181920212223242526272829303132333435stack&lt;int&gt; stack1;stack&lt;int&gt; stack2;void push(int node) { stack1.push(node);}//栈1不空，全部压入栈2，栈2的top则可以输出；//然后把栈2再压回栈1int pop() { while(!stack1.empty()){ int a = stack1.top(); stack1.pop(); stack2.push(a); } int res = stack2.top(); stack2.pop(); while(!stack2.empty()){ stack1.push(stack2.top()); stack2.pop(); } return res;}//如果栈2不空，栈2的top即为输出，否则把栈1全部压入栈2int pop() { if(stack2.empty()){ while(!stack1.empty()){ int a = stack1.top(); stack1.pop(); stack2.push(a); } } int res = stack2.top(); stack2.pop(); return res;} 剑指offer 6 旋转数组的最小值把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。1234567891011121314151617181920212223//O(N)int minNumberInRotateArray(int[] array) { if (array.length == 0) return 0; for (int i = 0; i &lt; array.length - 1; i++) { if (array[i] &gt; array[i + 1]) return array[i + 1]; } return array[0];}// O(logn) 二分法int minNumberInRotateArray(vector&lt;int&gt; rotateArray) { if(rotateArray.size()==0) return 0; int low=0, high=rotateArray.size()-1; while(low&lt;high){ int mid=(low+high)/2; if(rotateArray[mid]&gt;rotateArray[high]) low=mid+1; else if(rotateArray[mid]==rotateArray[high]) high--; else high=mid; } return rotateArray[high];} 剑指offer 7 斐波那契数列12345678910111213141516171819202122232425262728293031323334//斐波那契数列0 1 2 3 4 ...0 1 1 2 3 ...//递归int Fibonacci(int n) { if(n==0) return 0; if(n==1) return 1; return Fibonacci(n-1)+Fibonacci(n-2);}//循环 时间复杂度O(N) 空间复杂度O(1)int Fibonacci(int n) { if(n==0) return 0; if(n==1) return 1; int pre=0, now=1; while(n&gt;1){ int tmp = pre+now; pre = now; now = tmp; n--; } return now;}//动态规划 时间复杂度O(N) 空间复杂度O(N)int Fibonacci(int n) { if(n==0) return 0; if(n==1) return 1; vector&lt;int&gt; dp(n+1,0); dp[0]=0; dp[1]=1; for(int i=2;i&lt;=n;++i){ dp[i]=dp[i-1]+dp[i-2]; } return dp[n];} 剑指offer 8 跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。1234567891011//斐波那契数列 DP O(N)int jumpFloor(int number) { if(number&lt;2) return number; int pre=1, now=2; for(int i=3;i&lt;=number;i++){ int tmp = pre+now; pre = now; now=tmp; } return now;} 剑指offer 9 变态跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。12345678910int jumpFloorII(int number) { if(number==0) return 0; int res=1; while(number--&gt;1){ res*=2; } return res;}//移位 左移一位*2，左移n-1位即 2^(n-1)int res = 1&lt;&lt;(number-1) 剑指offer 10 矩形覆盖我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，有多少种方法？12//还是斐波那契数列 f(n) = f(n-1) + f(n-2)， (n &gt; 2)。 更一般的结论，如果用1*m的方块覆盖m*n区域，递推关系式为f(n) = f(n-1) + f(n-m)，(n &gt; m)。123456789101112131415161718192021222324252627282930313233// 循环int rectCover(int number) { if(number&lt;=2) return number; int pre=1, now=2; for(int i=3;i&lt;=number;++i){ int tmp=pre+now; pre=now; now=tmp; } return now;}// 递归public class Solution { public int RectCover(int target) { if (target &lt; 1) { return 0; } else if (target == 1 || target == 2) { return target; } else { return RectCover(target-1) + RectCover(target-2); } }}// dpint rectCover(int number) { if ( number &lt; 1 ) return 0; int g = 1, f = 2; while ( --number ) { f = f + g; g = f - g; } return g;} 剑指offer 11 二进制中1的个数**输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。123456789// 如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。int NumberOf1(int n) { int count = 0; while (n != 0) { ++count; n = (n - 1) &amp; n; } return count; } 剑指offer 12 求base的exponent次方给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。1234567891011// 简单快速幂double Power(double base, int exponent) { long long p = abs((long long)exponent); double r = 1.0; while(p){ if(p &amp; 1) r *= base; base *= base; p &gt;&gt;= 1; } return exponent &lt; 0 ? 1/ r : r;} 第一种方法：使用递归，时间复杂度O(logn)当n为偶数，a^n =（a^n/2）*（a^n/2） 当n为奇数，a^n = a ^ [( n - 1) / 2] a ^ [(n-1)/2] a 举例： 2^11 = 2^1 2^2 2^8 2^1011 = 2^0001 2^0010 2^1000 第二种方法：累乘，时间复杂度为O(n) 剑指offer 13 调整数组奇偶顺序输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。1234567891011121314151617181920212223242526272829303132333435// O(2n) O(n) void reOrderArray(vector&lt;int&gt; &amp;array) { if(array.size()==0) return; vector&lt;int&gt; res(array.size(),0); int s=0,e=array.size()-1; for(int i=0;i&lt;array.size();++i){ if(array[i]%2==1){ res[s++]=array[i]; } } for(int i=array.size()-1;i&gt;=0;--i){ if(array[i]%2==0){ res[e--]=array[i]; } } array=res;}// O(n*n) O(1) 插排想法void reOrderArray1(vector&lt;int&gt; &amp;array){ if(array.size()&lt;=1) return; for(int i=0;i&lt;array.size();i++){ if(array[i]%2==1){ int tmp=array[i]; int j=i-1; while(j&gt;=0 &amp;&amp; array[j]%2==0){ array[j+1]=array[j]; j--; } array[j+1] =tmp; } }}// 开辟2个数组分别存奇数和偶数 O(n) O(2n) 剑指offer 14 链表倒数第k个结点输入一个链表，输出该链表中倒数第k个结点。123456789101112131415161718192021222324252627282930313233343536373839404142// 遍历再数 O(2n-k)ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) { if(k&lt;=0) return NULL; int cnt=0, start=0; ListNode* root=pListHead; while(pListHead!=NULL){ pListHead=pListHead-&gt;next; cnt++; } if(k&gt;cnt) return NULL; while(start!=cnt-k){ root=root-&gt;next; start++; } return root;}// 遍历再数 O(n)ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) { if(k&lt;=0 || pListHead==NULL) return NULL; ListNode *fast=pListHead; ListNode *slow=pListHead; while(k--&gt;0){ if(fast==nullptr) return nullptr; fast=fast-&gt;next; } while(fast!=NULL){ fast=fast-&gt;next; slow=slow-&gt;next; } return slow;}// 递归ListNode* FindKthToTail2(ListNode* pListHead, unsigned int k) { if(pListHead==NULL) return NULL; ListNode* node=FindKthToTail(pListHead-&gt;next,k); if(node!=NULL) return node; cnt++; if(cnt==k) return pListHead; else return NULL;} 剑指offer 15 反转链表输入一个链表，反转链表后，输出新链表的表头。12345678910111213141516171819202122232425262728public ListNode ReverseList(ListNode head) { if(head==null) return null; //head为当前节点，如果当前节点为空的话，那就什么也不做，直接返回null； ListNode pre = null; ListNode next = null; //当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点 //需要pre和next的目的是让当前节点从pre-&gt;head-&gt;next1-&gt;next2变成pre&lt;-head next1-&gt;next2 //即pre让节点可以反转所指方向，但反转之后如果不用next节点保存next1节点的话，此单链表就此断开了 //所以需要用到pre和next两个节点 //1-&gt;2-&gt;3-&gt;4-&gt;5 //1&lt;-2&lt;-3 4-&gt;5 while(head!=null){ //做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre //如此就可以做到反转链表的效果 //先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂 next = head.next; //保存完next，就可以让head从指向next变成指向pre了，代码如下 head.next = pre; //head指向pre后，就继续依次反转下一个节点 //让pre，head，next依次向后移动一个节点，继续下一次的指针反转 pre = head; head = next; } //如果head为null的时候，pre就为最后一个节点了，但是链表已经反转完毕，pre就是反转后链表的第一个节点 //直接输出pre就是我们想要得到的反转后的链表 return pre;} 剑指offer 16 合并两个排序的链表输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。12345678910111213141516171819202122232425262728293031323334353637383940//递归ListNode* Merge(ListNode* pHead1, ListNode* pHead2){ if(pHead1==NULL) return pHead2; if(pHead2==nullptr) return pHead1; if(pHead1-&gt;val&gt;pHead2-&gt;val) { pHead2-&gt;next=Merge(pHead1, pHead2-&gt;next); return pHead2; } if(pHead1-&gt;val&lt;pHead2-&gt;val) { pHead1-&gt;next=Merge(pHead1-&gt;next, pHead2); return pHead1; }}// 循环if(list1 == null) return list2;if(list2 == null) return list1;ListNode mergeHead = null;ListNode current = null;while(list1!=null &amp;&amp; list2!=null){ if(list1.val &lt;= list2.val){ if(mergeHead == null){ mergeHead = current = list1; }else{ current.next = list1; current = current.next; } list1 = list1.next; }else{ if(mergeHead == null){ mergeHead = current = list2; }else{ current.next = list2; current = current.next; } list2 = list2.next; }}if(list1 == null) current.next = list2;else current.next = list1;return mergeHead; 剑指offer 17 树的子结构输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）1234567891011121314151617bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2){ bool result=false; if(pRoot1!=NULL &amp;&amp; pRoot2!=NULL){ if(pRoot1-&gt;val==pRoot2-&gt;val) result=Tree1HaveTree2(pRoot1, pRoot2); if(!result) { result=Tree1HaveTree2(pRoot1-&gt;left, pRoot2) || Tree1HaveTree2(pRoot1-&gt;right, pRoot2); } } return result;}bool Tree1HaveTree2(TreeNode* pRoot1, TreeNode* pRoot2){ if(pRoot2==NULL) return true; if(pRoot1==NULL) return false; if(pRoot1-&gt;val!=pRoot2-&gt;val) return false; return Tree1HaveTree2(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; Tree1HaveTree2(pRoot1-&gt;right,pRoot2-&gt;right);} 剑指offer 18 二叉树的镜像12345678910void Mirror(TreeNode *pRoot) { if (pRoot==NULL) return; else { TreeNode *tmp=pRoot-&gt;left; pRoot-&gt;left = pRoot-&gt;right; pRoot-&gt;right = tmp; Mirror(pRoot-&gt;left); Mirror(pRoot-&gt;right); }} 剑指offer 19 顺时针打印矩阵输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.1234567891011121314151617181920212223242526vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) { int row = matrix.size(); int col = matrix[0].size(); vector&lt;int&gt; res; // 输入的二维数组非法，返回空的数组 if (row == 0 || col == 0) return res; // 定义四个关键变量，表示左上和右下的打印范围 int left = 0, top = 0, right = col - 1, bottom = row - 1; while (left &lt;= right &amp;&amp; top &lt;= bottom) { // left to right for (int i = left; i &lt;= right; ++i) res.push_back(matrix[top][i]); // top to bottom for (int i = top + 1; i &lt;= bottom; ++i) res.push_back(matrix[i][right]); // right to left if (top != bottom) for (int i = right - 1; i &gt;= left; --i) res.push_back(matrix[bottom][i]); // bottom to top if (left != right) for (int i = bottom - 1; i &gt; top; --i) res.push_back(matrix[i][left]); left++,top++,right--,bottom--; } return res;} 剑指offer 20 包含Min函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。123456789101112131415161718stack&lt;int&gt; stack1, stack2;void push(int value) { stack1.push(value); if(stack2.empty()) stack2.push(value); else{ if(value&lt;stack2.top()) stack2.push(value); }}void pop() { if(stack1.top()==stack2.top()) stack2.pop(); stack1.pop();}int top() { return stack1.top();}int min() { return stack2.top();} 剑指offer 21 栈的压入、弹出序列//输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）12345678910111213bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) { if(pushV.empty()||popV.empty()) return false; stack&lt;int&gt; Stack; int popIndex=0; for(int i=0;i&lt;pushV.size();++i){ Stack.push(pushV[i]); while(!Stack.empty() &amp;&amp; Stack.top()==popV[popIndex]){ Stack.pop(); popIndex++; } } return Stack.empty(); } 剑指offer 22 从上往下打印二叉树12345678910111213141516171819202122232425262728293031323334//双端队列vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) { vector&lt;int&gt; res; if(root==NULL) return NULL; deque&lt;TreeNode*&gt; d; d.push_back(root); while(!d.empty()){ root=d.front(); if(root!=NULL){ res.push_back(root-&gt;val); d.push_back(root-&gt;left); d.push_back(root-&gt;right); } d.pop_front(); } return res;}//队列vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) { vector&lt;int&gt; res; if(root==NULL) return res; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()){ res.push_back(q.front()-&gt;val); if(q.front()-&gt;left!=NULL) q.push(q.front()-&gt;left); if(q.front()-&gt;right!=NULL) q.push(q.front()-&gt;right); q.pop(); } return res;} 剑指offer 23 二叉搜索树的后序遍历序列//输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。//如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。12345678910111213141516171819202122232425bool VerifySquenceOfBST(vector&lt;int&gt; sequence) { if (sequence.empty()) { return false; } return helper(sequence, 0, sequence.size() - 1);}bool helper(vector&lt;int&gt; &amp;sequence, int first, int last) { // first和last表示树序列的开始和结束的位置 if(first &gt;= last){ return true; } int curIdx = first; int rootVal = sequence[last]; //后序遍历，根节点一定在最后，找到根节点后，就可以将树分为左右两棵子树，其中左子树中的元素都小于根节点，右子树中的元素都大于根节点 while(curIdx &lt; last &amp;&amp; sequence[curIdx] &lt; rootVal){ ++curIdx; } int midIdx = curIdx; // 到curIdx的值大于根节点时，我们认为开始进入到右子树部分，用一个midIdx记录下当前的右子树开始的位置 while (curIdx &lt; last){ if(sequence[curIdx] &lt; rootVal){ return false; } ++curIdx; } return helper(sequence, first, midIdx - 1) &amp;&amp; helper(sequence, midIdx, last - 1); // 再分别对左子树和右子树做同样的操作} 剑指offer 24 二叉树中和为某一值的所有路径//输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。//路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。//(注意: 在返回值的list中，数组长度大的数组靠前)1234567891011121314151617181920212223vector&lt;vector&lt;int&gt;&gt; res;vector&lt;int&gt; path;vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) { if(root==NULL || expectNumber&lt;=0) return res; findHelper(root, expectNumber); return res;}void findHelper(TreeNode* root, int sum){ if(root==NULL) return; path.push_back(root-&gt;val); if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL &amp;&amp; root-&gt;val==sum){ res.push_back(path); } else{ if(root-&gt;left!=NULL){ findHelper(root-&gt;left, sum-root-&gt;val); } if(root-&gt;right!=NULL){ findHelper(root-&gt;right, sum-root-&gt;val); } } path.pop_back();} 剑指offer 25 复杂链表的复制//输入一个复杂链表（每个节点中有节点值，以及两个指针，//一个指向下一个节点，另一个特殊指针指向任意一个节点），//返回结果为复制后复杂链表的head。//（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）1234567891011121314151617181920212223242526272829303132333435363738struct RandomListNode { int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) { }};class Solution {public: RandomListNode* Clone(RandomListNode* pHead){ if(pHead==NULL) return NULL; RandomListNode* currentNode=pHead; //复制每个结点，将其插入结点后面 while(currentNode!=NULL){ RandomListNode* cloneNode = new RandomListNode(currentNode-&gt;label); RandomListNode* nextNode = currentNode-&gt;next; currentNode-&gt;next=cloneNode; cloneNode-&gt;next=nextNode; currentNode=nextNode; } currentNode=pHead; //复制老结点的随机指针给新结点 while(currentNode!=NULL){ currentNode-&gt;next-&gt;random = currentNode-&gt;random==NULL?NULL:currentNode-&gt;random-&gt;next; currentNode=currentNode-&gt;next-&gt;next; } //拆分链表 currentNode=pHead; RandomListNode* pCloneHead=pHead-&gt;next; while(currentNode!=NULL){ RandomListNode* cloneNode=currentNode-&gt;next; currentNode-&gt;next=cloneNode-&gt;next; cloneNode-&gt;next=cloneNode-&gt;next==NULL?NULL:cloneNode-&gt;next-&gt;next; currentNode=currentNode-&gt;next; } return pCloneHead; }}; 剑指offer 26 二叉搜索树转双端链表**//题目描述//输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。//要求不能创建任何新的结点，只能调整树中结点指针的指向。123456789101112131415161718192021222324252627/*struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { }};*/TreeNode* Convert(TreeNode* pRootOfTree){if(pRootOfTree==NULL) return NULL; TreeNode* pre=NULL; convertHelper(pRootOfTree, pre); TreeNode* res=pRootOfTree; while(res-&gt;left){ res=res-&gt;left; } return res;}void convertHelper(TreeNode* cur, TreeNode*&amp; pre){ if(cur==NULL) return; convertHelper(cur-&gt;left, pre); cur-&gt;left=pre; if(pre) pre-&gt;right=cur; pre=cur; convertHelper(cur-&gt;right, pre);} 剑指offer 27 字符串的排列题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。输入描述:输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136/** * 1、递归算法 * * 解析：http://www.cnblogs.com/cxjchen/p/3932949.html (感谢该文作者！) * * 对于无重复值的情况 * * 固定第一个字符，递归取得首位后面的各种字符串组合； * 再把第一个字符与后面每一个字符交换，并同样递归获得首位后面的字符串组合； *递归的出口，就是只剩一个字符的时候，递归的循环过程，就是从每个子串的第二个字符开始依次与第一个字符交换，然后继续处理子串。 * * 假如有重复值呢？ * *由于全排列就是从第一个数字起，每个数分别与它后面的数字交换，我们先尝试加个这样的判断——如果一个数与后面的数字相同那么这两个数就不交换了。 * 例如abb，第一个数与后面两个数交换得bab，bba。然后abb中第二个数和第三个数相同，就不用交换了。 * 但是对bab，第二个数和第三个数不 同，则需要交换，得到bba。 * 由于这里的bba和开始第一个数与第三个数交换的结果相同了，因此这个方法不行。 * * 换种思维，对abb，第一个数a与第二个数b交换得到bab，然后考虑第一个数与第三个数交换，此时由于第三个数等于第二个数， * 所以第一个数就不再用与第三个数交换了。再考虑bab，它的第二个数与第三个数交换可以解决bba。此时全排列生成完毕！ * * * @param str * @return */vector&lt;string&gt; Permutation(string str) { vector&lt;string&gt; res; if(str.empty()) return res; permutationHelper(str, res, 0, str.size()-1); sort(res.begin(),res.end()); return res; }void permutationHelper(string str, vector&lt;string&gt; &amp;res, int start, int end){ if(start==end) { res.push_back(str); } for(int i=start;i&lt;=end;i++){ //从str的头到尾都换一次 if(is_swap(str, start, i)){ swap(str, start, i); permutationHelper(str, res, start+1, end); swap(str, start, i); } }}bool is_swap(string str, int l, int r){ bool flag=true; for(int i=l;i&lt;r;i++){ //l==r则跳过循环，比如aa可以加入res if(str[i]==str[r]){ flag=false; break; } } return flag;}void swap(string &amp;str, int l, int r){ char tmp=str[l]; str[l]=str[r]; str[r]=tmp;}void swap(char* str,int a,int b){ char tmp = str[a]; str[a] = str[b]; str[b] = tmp;}/** * 2、字典序排列算法 * * 可参考解析： http://www.cnblogs.com/pmars/archive/2013/12/04/3458289.html （感谢作者） * * 一个全排列可看做一个字符串，字符串可有前缀、后缀。 * 生成给定全排列的下一个排列.所谓一个的下一个就是这一个与下一个之间没有其他的。 * 这就要求这一个与下一个有尽可能长的共同前缀，也即变化限制在尽可能短的后缀上。 * * [例]839647521是1--9的排列。1—9的排列最前面的是123456789，最后面的987654321， * 从右向左扫描若都是增的，就到了987654321，也就没有下一个了。否则找出第一次出现下降的位置。 * * 【例】 如何得到346987521的下一个 * 1，从尾部往前找第一个P(i-1) &lt; P(i)的位置 * 3 4 6 &lt;- 9 &lt;- 8 &lt;- 7 &lt;- 5 &lt;- 2 &lt;- 1 * 最终找到6是第一个变小的数字，记录下6的位置i-1 * * 2，从i位置往后找到最后一个大于6的数 * 3 4 6 -&gt; 9 -&gt; 8 -&gt; 7 5 2 1 * 最终找到7的位置，记录位置为m * * 3，交换位置i-1和m的值 * 3 4 7 9 8 6 5 2 1 * 4，倒序i位置后的所有数据 * 3 4 7 1 2 5 6 8 9 * 则347125689为346987521的下一个排列 * * @param str * @return */ public ArrayList&lt;String&gt; Permutation2(String str){ ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); if(str==null || str.length()==0){ return list; } char[] chars = str.toCharArray(); Arrays.sort(chars); list.add(String.valueOf(chars)); int len = chars.length; while(true){ int lIndex = len-1; int rIndex; while(lIndex&gt;=1 &amp;&amp; chars[lIndex-1]&gt;=chars[lIndex]){ lIndex--; } if(lIndex == 0) break; rIndex = lIndex; while(rIndex&lt;len &amp;&amp; chars[rIndex]&gt;chars[lIndex-1]){ rIndex++; } swap(chars,lIndex-1,rIndex-1); reverse(chars,lIndex); list.add(String.valueOf(chars)); } return list;} private void reverse(char[] chars,int k){ if(chars==null || chars.length&lt;=k) return; int len = chars.length; for(int i=0;i&lt;(len-k)/2;i++){ int m = k+i; int n = len-1-i; if(m&lt;=n){ swap(chars,m,n); } }} 剑指offer 28 数组中出现超过一半的数//数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// O(n) 空间O(n) 不追求元素排序，不用map或者hashmapint MoreThanHalfNum_Solution2(vector&lt;int&gt; numbers) { int n = numbers.size(); //map 记录出现次数 unordered_map&lt;int, int&gt; m; int count; for (int i = 0; i &lt; n; i++) { count = ++m[numbers[i]]; if (count &gt; n/2) return numbers[i]; } return 0;}// O(n) O(1)int MoreThanHalfNum_Solution1(vector&lt;int&gt; numbers) { if(numbers.empty()) return 0; int n = numbers.size(), num=numbers[0],count=1; for (int i = 1; i &lt; n; i++) { if(numbers[i]==num) count++; else count--; if(count==0){ num=numbers[i]; count=1; } } count=0; for(int i=0;i&lt;n;i++){ if(numbers[i]==num) count++; } return (count&gt;n/2)?num:0;}//快排思想 O(n)?O(logn)?int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) { if(numbers.empty()) return 0; int n = numbers.size(), mid=n/2,count=1; int start=0,end=n-1; int k=partition(numbers, 0, n-1); while(k!=mid){ if(k&gt;mid){ end=k-1; k=partition(numbers, start, end); } else{ start=k+1; k=partition(numbers, start, end); } } int num=numbers[mid]; count=0; for(int i=0;i&lt;n;i++){ if(numbers[i]==num) count++; } return (count&gt;n/2)?num:0;}int partition(vector&lt;int&gt; &amp;numbers, int s, int e){ int pivot=numbers[s]; int leftmark=s+1, rightmark=e; bool done=false; while(!done){ while(leftmark&lt;=rightmark &amp;&amp; pivot&gt;=numbers[leftmark]) leftmark++; while(leftmark&lt;=rightmark &amp;&amp; pivot&lt;=numbers[rightmark]) rightmark--; if(leftmark&gt;rightmark) done=true; else{ swap(numbers, leftmark, rightmark); } } swap(numbers, s, rightmark); return rightmark;}void swap(vector&lt;int&gt; &amp;v, int s, int e){ int tmp=v[s]; v[s]=v[e]; v[e]=tmp;}//拓展：输出数组中两个数量超过1/3的数 //投票法，讲道理partition应该也行1/3,2/3的位置vector&lt;int&gt; MoreThanOneThirdNum_Solution(vector&lt;int&gt; numbers) { vector&lt;int&gt; res; if(numbers.empty()) return res; int num1=0, num2=0, cnt1=0, cnt2=0, len = numbers.size(); for(int i=0;i&lt;len;i++){ if(numbers[i]==num1) cnt1++; else if (numbers[i]==num2) cnt2++; else if (cnt1==0) num1=numbers[i], cnt1=1; else if (cnt2==0) num2=numbers[i], cnt2=1; else cnt1--, cnt2--; } cnt1=0, cnt2=0; for(int i=0;i&lt;len;i++){ if(numbers[i]==num1) cnt1++; if(numbers[i]==num2) cnt2++; } if(cnt1&gt;len/3) res.push_back(num1); if(cnt2&gt;len/3) res.push_back(num2); return res;} 剑指offer 29 最小的k个数**//输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。partition O(n)-O(n^2）?牛客超时？1234567891011121314151617181920212223242526272829303132vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) { vector&lt;int&gt; res; if(input.empty() || k&gt;input.size()) return res; int len=input.size(), pos, s=0, e=len-1; pos=par(input, 0, len-1); while (pos!=k){ if (pos&gt;k) e=pos-1,pos=par(input, s, e); else s=pos+1,pos=par(input, s, e); } for(int i=0;i&lt;k;i++){ res.push_back(input[i]); } sort(res.begin(),res.end()); return res;}int par(vector&lt;int&gt; &amp;arr, int s, int e){ int pivot=arr[s]; int l=s+1, r=e; bool done=false; while(!done){ while(l&lt;=r &amp;&amp; arr[l]&lt;=pivot) l++; while(l&lt;=r &amp;&amp; arr[r]&gt;=pivot) r--; if(l&gt;r) done=true; else swap(arr, l, r); } swap(arr, s, r); return r;}//最大堆，待写 剑指offer 30 连续子数组最大和HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)1234567891011//DP O(n) O(1)int FindGreatestSumOfSubArray(vector&lt;int&gt; array) { if(array.empty()) return 0; int len=array.size(); int res=array[0], pre=array[0]; for(int i=1;i&lt;len;i++){ pre=max(array[i], pre+array[i]); if(res&lt;pre) res=pre; } return res;} 剑指offer 31 整数中1的个数求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数?为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。123456789int NumberOf1Between1AndN_Solution(int n){ if(n&lt;0) return 0; int count=0; for(int i=1;i&lt;=n;i*=10){ int k=i*10; count+=(n/k)*i+min(max(n%k-i+1, 0), i); } return count;} 剑指offer 32 把数组排成最小的数**//输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。123456789101112131415161718192021class Solution {public: static bool cmp(int a, int b){ string A=&quot;&quot;; string B=&quot;&quot;; A += to_string(a); A += to_string(b); B += to_string(b); B += to_string(a); return A&lt;B; } string PrintMinNumber(vector&lt;int&gt; numbers) { string res=&quot;&quot;; if(numbers.empty()) return res; sort(numbers.begin(), numbers.end(), cmp); for(int i=0;i&lt;numbers.size();i++){ res+=to_string(numbers[i]); } return res; }}; 剑指offer 33 丑数//把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。1234567891011121314151617181920class Solution {public: int GetUglyNumber_Solution(int index) { if(index&lt;1) return 0; vector&lt;int&gt; ugly(index, 1); int pointer2=0, pointer3=0, pointer5=0; for(int i=1;i&lt;index;i++){ ugly[i] = findmin(ugly[pointer2]*2, ugly[pointer3]*3, ugly[pointer5]*5); if(ugly[pointer2]*2==ugly[i]) pointer2++; if(ugly[pointer3]*3==ugly[i]) pointer3++; if(ugly[pointer5]*5==ugly[i]) pointer5++; } return ugly[index-1]; }int findmin(int a, int b, int c){ int tmp = a&gt;b?b:a; int tmp2 = tmp&gt;c?c:tmp; return tmp2; }}; 剑指offer 34 第一次出现的字符//在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.1234567891011121314151617int FirstNotRepeatingChar(string str) { int res=-1; if(str.empty()) return res; int len=str.size(); unordered_map&lt;char, int&gt; mp; for(int i=0;i&lt;len;i++){ mp[str[i]]++; // cout&lt;&lt;mp[str[i]]&lt;&lt;endl; } for(int i=0;i&lt;len;i++){ cout&lt;&lt;mp[str[i]]&lt;&lt;endl; if(mp[str[i]]==1){ res=i;break; } } return res;} 剑指offer 35 数组中的逆序对**//在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007。例子：输入 1,2,3,4,5,6,7,0 输出 7123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//暴力求解 O(N*N)int InversePairs2(vector&lt;int&gt; data) { int res=0; if(data.empty()) return res; int len=data.size(); for(int i=len-1;i&gt;=0;i--){ for(int j=i-1;j&gt;=0;j--){ if(data[j]&gt;data[i]) res++; } } return res;}//归并排序 O(nlogn)int InversePairs(vector&lt;int&gt; data) { int res=0; if(data.empty()) return res; int len=data.size(); vector&lt;int&gt; cp(len, 0); for(int i=0;i&lt;len;i++){ cp[i]=data[i]; } res = mergeCount(data, cp, 0, len-1); return res;}int mergeCount(vector&lt;int&gt; &amp;arr, vector&lt;int&gt; &amp;cp, int s, int e){ if(s==e) return 0; int mid=(s+e)&gt;&gt;1; int leftCount=mergeCount(arr, cp, s, mid)%1000000007; int rightCount=mergeCount(arr, cp, mid+1, e)%1000000007; int count=0,i=mid,j=e,locCopy=e; while(i&gt;=s &amp;&amp; j&gt;mid){ if(arr[i]&gt;arr[j]){ count += j-mid; cp[locCopy--] = arr[i--]; if(count&gt;=1000000007) count%=1000000007; } else{ cp[locCopy--] = arr[j--]; } } for(;i&gt;=s;i--){ cp[locCopy--]=arr[i]; } for(;j&gt;mid;j--){ cp[locCopy--]=arr[j]; } for(int ss=s;ss&lt;=e;ss++){ arr[ss]=cp[ss]; } return (leftCount+rightCount+count)%1000000007;} 剑指offer 36 两个链表的第一个公共结点输入两个链表，找出它们的第一个公共结点。1234567891011121314151617181920212223242526272829303132// 若有公共结点，让最长的链表先走len1-len2步，再一起走，必会相交ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) { if(pHead1==NULL || pHead2==NULL) return NULL; int len1 = findLinkedListLength(pHead1); int len2 = findLinkedListLength(pHead2); if(len1&gt;len2){ pHead1=walkK(pHead1, len1-len2); } else{ pHead2 = walkK(pHead2, len2-len1); } while(pHead1!=NULL &amp;&amp; pHead2!=NULL){ if(pHead1==pHead2) return pHead1; pHead1=pHead1-&gt;next; pHead2=pHead2-&gt;next; } return NULL;}int findLinkedListLength(ListNode* pHead){ int res=0; while(pHead!=NULL){ pHead = pHead-&gt;next; res++; } return res;}ListNode* walkK(ListNode* pHead, int k){ while(k--){ pHead=pHead-&gt;next; } return pHead;} 剑指offer 37 数组在排序数组出现的次数//统计一个数字在排序数组中出现的次数。1234567891011121314151617181920212223242526272829303132// O(n) O(1)int GetNumberOfK1(vector&lt;int&gt; data ,int k) { if(data.empty()) return 0; int res=0; for(int i=0;i&lt;data.size();i++){ if(data[i]==k) res++; } return res; }// O(logn) O(1)int GetNumberOfK(vector&lt;int&gt; data ,int k) { if(data.empty()) return 0; int start=0, end=data.size()-1, res=0; while(start&lt;=end){ int mid=(start+end)&gt;&gt;1; if(data[mid]&gt;k){ end=mid-1; } else if(data[mid]&lt;k) { start=mid+1; } else { int l=mid, r=mid; res++; while(data[--l]==k) res++; while(data[++r]==k) res++; cout&lt;&lt;res&lt;&lt;endl; break; } } return res;} 剑指offer 38 二叉树深度//输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。12345678910111213141516171819202122//递归int TreeDepth(TreeNode* pRoot) { if(pRoot==NULL) return 0; return max(TreeDepth(pRoot-&gt;left), TreeDepth(pRoot-&gt;right))+1;}//非递归int TreeDepthNotLoop(TreeNode* pRoot) { int res=0; if(pRoot==NULL) return res; queue&lt;TreeNode *&gt; q; q.push(pRoot); while(!q.empty()) { int size=q.size(); res++; for(int i=0;i&lt;size;i++){ TreeNode* top=q.front(); q.pop(); if(top-&gt;left) q.push(top-&gt;left); if(top-&gt;right) q.push(top-&gt;right); } } return res; } 剑指offer 39 判断平衡二叉树//输入一棵二叉树，判断该二叉树是否是平衡二叉树。如果二叉树的每个节点的左子树和右子树的深度不大于1，它就是平衡二叉树。1234567891011bool IsBalanced_Solution(TreeNode* pRoot){ return pos_travel(pRoot)!=-1; }int pos_travel(TreeNode* pRoot){ if(pRoot==NULL) return 0; int left=pos_travel(pRoot-&gt;left); if(left==-1) return -1; int right=pos_travel(pRoot-&gt;right); if(right==-1) return -1; return abs(left-right)&gt;1?-1:1+max(left, right);} 剑指offer 40 数组中只出现一次的数字//一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。12345678910111213141516171819202122232425//input vector&lt;int&gt; arr={1,4,4,5,5,7};void FindNumsAppearOnce(vector &lt;int&gt; data, int* num1, int *num2) { if(data.empty()) return; int len=data.size(); unordered_map &lt;int, int&gt; mp; for(int i=0;i&lt;len;i++){ mp[data[i]]++; } vector&lt;int&gt; res; for(int i=0;i&lt;len;i++){ if(mp[data[i]]==1){ res.push_back(data[i]); } } *num1 = res[0]; *num2 = res[1];}public static int find1From2(int[] a){ int len = a.length, res = 0; for(int i = 0; i &lt; len; i++){ res = res ^ a[i]; } return res;} 剑指offer 41 和为S的连续正数序列//输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) { vector&lt;vector&lt;int&gt; &gt; vOut; vector&lt;int&gt; vIn; if(sum==1) { vIn.push_back(1); vOut.push_back(vIn); return vOut; } int left=1, right=2; while(left&lt;right){ int k=(left+right)*(right-left+1)/2; if(sum==k) { vector&lt;int&gt; vTmp; for(int i=left;i&lt;=right;i++){ vTmp.push_back(i); } vOut.push_back(vTmp); right++; } else if(sum&gt;k) { right++; } else { left++; } } return vOut;}//vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) { vector&lt;vector&lt;int&gt;&gt; res; if(sum&lt;=2) return res; int up=sqrt(2*sum); for(int i=up;i&gt;=2;i--){ int n = sum/i; if(i%2==1 &amp;&amp; sum%i==0){ vector&lt;int&gt; tmp; for(int j=n-(i-1)/2;j&lt;=n+(i-1)/2;j++){ tmp.push_back(j); } res.push_back(tmp); } if(i%2==0 &amp;&amp; sum%i*2==i){ vector&lt;int&gt; tmp; for(int j=n-(i-2)/2;j&lt;=n+(i-2)/2+1;j++){ tmp.push_back(j); } res.push_back(tmp); } } return res;} 剑指offer 42 和为S的两个数//输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。123456789101112131415161718192021222324252627vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) { vector&lt;int&gt; res; if(array.empty()) return res; int low=0, high=array.size()-1, Min=INT32_MAX; while(low&lt;high){ cout&lt;&lt;low&lt;&lt;&quot; &quot;&lt;&lt;high&lt;&lt;endl; int add = array[low]+array[high], product= array[low]*array[high]; if(sum==add) { if(product&lt;Min){ Min = product; while(!res.empty()){ res.clear(); } res.push_back(array[low]); res.push_back(array[high]); } low++;high--; } else if (sum&lt;add){ high--; } else{ low++; } } return res;} 剑指offer 43 左旋转字符串//汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！123456789101112131415161718192021222324252627282930313233343536string LeftRotateStringCircle(string str, int n) { if (str.empty()) return &quot;&quot;; deque&lt;char&gt; q; for (int i=0;i&lt;str.size();i++){ q.push_back(str[i]); } while(n!=0) { char tmp = q.front(); q.pop_front(); q.push_back(tmp); n--; } string res=&quot;&quot;; for (int i=0;i&lt;q.size();i++){ res = res+q[i]; } return res;}string LeftRotateString(string str, int n) { if (str.empty()) return &quot;&quot;; n = n % str.size(); reverse(str.begin(), str.end()); reverse(str.begin(), str.begin()+str.size()-n); reverse(str.begin()+str.size()-n, str.end()); return str;}//自写reverse函数void reverse1(string&amp; str, int s, int e){ while (s &lt; e) { char temp = str[s]; str[s] = str[e]; str[e] = temp; s++; e--; }} 剑指offer 44 翻转单词顺序列// “student. a am I”-&gt;“I am a student.”12345678910111213141516171819202122232425262728293031323334353637string ReverseSentence1(string str) { string res = &quot;&quot;; if(str.empty()) return res; vector &lt;string&gt; s; int index=0; string tmp=&quot;&quot;; while(index &lt; str.size()){ if (str[index]==&apos; &apos;) { s.push_back(tmp); tmp=&quot;&quot;; } else{ tmp+=str[index]; } if(index==str.size()-1) s.push_back(tmp); index++; } for (int i=s.size()-1;i&gt;=0;i--) { res += s[i]; if(i!=0) res += &apos; &apos;; }return res;}string ReverseSentence(string str) { std::reverse(str.begin(),str.end()); int front=0; int back=0; int size = str.size(); while(front&lt;size){ while(front&lt;size&amp;&amp;str[front]==&apos; &apos;)++front; //跳过空格，找第一个非空字母位置 back = front; while(back&lt;size&amp;&amp;str[back]!=&apos; &apos;)++back; //找单词最后一个字符的位置 std::reverse(str.begin()+front, str.begin()+back); //反转 front = back; } return str;} 剑指offer 45 扑克牌顺子//一组数字，判断是否顺子。0为任意数，如果牌能组成顺子就输出true，否则就输出false。1234567891011121314151617181920212223242526272829303132333435// O(n)bool IsContinuous( vector&lt;int&gt; numbers ) { if(numbers.empty()) return false; vector&lt;int&gt; arr(14, 0); arr[0]=-5; int Min=14, Max=-1; for (int i=0;i&lt;numbers.size();i++){ arr[numbers[i]]++; if(numbers[i]==0) continue; if(arr[numbers[i]]&gt;1) return false; if (numbers[i]&lt;Min) { Min = numbers[i]; } if (numbers[i]&gt;Max) { Max = numbers[i]; } } if(Max-Min&gt;4) return false; return true;}// O(nlogn)bool IsContinuous( vector&lt;int&gt; numbers ) { sort(numbers.begin(), numbers.end()); int cnt0 = 0, cntNeed = 0; for(int i = 0; i &lt; 5; i++) { if(numbers[i] == 0) { ++cnt0; } else if(i + 1 &lt; 5 ) { if(numbers[i + 1] == numbers[i]) return false; cntNeed += numbers[i + 1] - numbers[i] - 1; } } if(cntNeed &gt; cnt0) return false; return true;} 剑指offer 46 孩子们的游戏（圆圈里最后剩下的数）//约瑟夫圆环。一个数m,编号为0开始报数，m-1的出列，下一个继续从0开始，直至最后一个。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int LastRemaining_Solution(int n, int m) { if(n==0 || m&lt;=0) return -1; if (n==1) return 0; vector&lt;int&gt; v; for (int i=0;i&lt;n;i++) { v.push_back(i); } int p = 0; while(v.size()&gt;1) { n = v.size(); p = (p+m) % n - 1; if (p == -1) p = n-1; v.erase(v.begin()+p); } return v[0]; }//公式dp int LastRemaining_Solution1(unsigned int n, unsigned int m) { if(n &lt;= 0 &amp;&amp; m &lt;= 0) return -1; //蛋疼的特殊条件 int t = 0; for(int i = 2; i &lt;= n; i++) t = (t + m) % i; return t; }//模拟循环链表int LastRemaining_Solution2(int n, int m)//n为人数{ if(n&lt;1||m&lt;1) return -1; list&lt;int&gt; numbers; for(int i=0;i&lt;n;i++) numbers.push_back(i); list&lt;int&gt;::iterator current=numbers.begin(); while(numbers.size()&gt;1) { for(int i=1;i&lt;m;i++)//走m-1步到达第m个数处 { ++current; if(current==numbers.end()) current=numbers.begin(); } list&lt;int&gt;::iterator next=++current; if(next==numbers.end()) next=numbers.begin(); --current; numbers.erase(current); current=next; } return *current;//对迭代器取值，等价于对指针取值} 剑指offer 47 求1+2+…+n//求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。1234567891011int Sum_Solution(int n) { if (n&lt;=0) return 0; if (n==1) return 1; return Sum_Solution(n-1)+n; }int Sum_Solution(int n) { int ans = n;//逻辑与有个短路特点，前面为假，后面不计算。 ans &amp;&amp; (ans += Sum_Solution(n - 1)); return ans;} 剑指offer 48 不用加减乘除做加法//求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。用三步走的方式计算二进制值相加：5-101，7-111,第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101 &amp; 111) \\&lt;\\&lt; 1。第三步重复上述两步， 各位相加 0 1 0 \\^ 1 0 1 0 = 1 0 0 0，进位值为100 = (010 \\&amp; 1010)\\&lt;\\&lt; 1。继续重复上述两步：1000\\^100 = 1100，进位值为0，跳出循环，1100为最终结果。12345678int Add(int num1, int num2) { while(num2!=0){ int tmp = num1^num2; num2 = (num1&amp;num2)&lt;&lt;1; num1=tmp; } return num1;} 剑指offer 49 把字符串转换为整数将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。12345678910111213141516171819int StrToInt(string str) { if(str.empty()) return 0; int res=0, symbol=1; if(str[0]==&apos;+&apos;) { str[0]=&apos;0&apos;; } else if(str[0]==&apos;-&apos;) { symbol=-1; str[0] = &apos;0&apos;; } for(int i=0;i&lt;str.size();i++) { if(str[i]&lt;&apos;0&apos; || str[i]&gt;&apos;9&apos;) { res = 0; break; } res = res*10 + str[i]-&apos;0&apos;; } return symbol*res;} 剑指offer 50 数组中重复的数字// 在一个长度为n的数组里的所有数字都在0到n-1的范围内.数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。1234567891011121314151617181920// Parameters:// numbers: an array of integers// length: the length of array numbers// duplication: (Output) the duplicated number in the array numberbool duplicate1(int numbers[], int length, int* duplication) { bool res=false; if(length==0) return res; unordered_map&lt;int, int&gt; mp; for(int i=0;i&lt;length;i++) { if (mp.count(numbers[i])==0) { mp[numbers[i]] ++; } else { *duplication = numbers[i]; res = true; break; } } return res;} //思路二：剑指offer中解法：因为数组中数字都在0~n - 1，所以若无重复数字排好序则数字i将出现在下标i的位置。//解法：从头到尾扫描这个数组，当扫描到下标为i的数字m时，先比较这个数字是否等于i，是则扫描下一个数字，否则//将该数字与下标为m的数字进行比较，若相等，则找到一个重复的数字，否则将两个数字交换，并继续对该位置//（下标i）重复上面比较过程。12345678910111213141516171819202122bool duplicate(int numbers[], int length, int* duplication) { bool res = false; if (length == 0) return res; int i = 0; while(i&lt;length) { if (numbers[i] == i) { i++; continue; } if (numbers[numbers[i]] == numbers[i]) { res = true; *duplication = numbers[i]; break; } else { int tmp = numbers[i]; numbers[i] = numbers[tmp]; numbers[tmp] = tmp; } } return res;} 剑指offer 51 构建乘积数组给定一个数组A[0, 1, …, n - 1], 请构建一个数组B[0, 1, …, n - 1],其中B中的元素B[i] = A[0] A[1] … A[i - 1] A[i + 1] … A[n - 1]。不能使用除法。12345678910111213141516171819202122232425262728293031323334// recurrent O(n\\*n)vector&lt;int&gt; multiplyN2(const vector&lt;int&gt;&amp; A) { vector&lt;int&gt; B; if (A.empty()) return B; for (int i = 0; i &lt; A.size(); i++) { B.push_back(ABhelper(A, A.size()-1, i)); } return B;}int ABhelper(vector&lt;int&gt; A, int n, int k) { if (n == k &amp;&amp; n == 0) return 1; if (n == k &amp;&amp; n &gt; 0) return ABhelper(A, n - 1, k); if (n == 0) return A[0]; return ABhelper(A, n - 1, k) * A[n];}// 上下三角求解合并//链接：https://www.nowcoder.com/questionTerminal/94a4d381a68b47b7a8bed86f2975db46?f=discussionvector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) { vector&lt;int&gt; B; if (A.empty()) return B; int len = A.size(); // cal up triangle B.push_back(1); for (int i = 1; i &lt; len; i++) { B.push_back(B[i - 1] * A[i - 1]); } // cal down triangle int down =1; for (int i = len - 2; i &gt;= 0; i--) { down *= A[i + 1]; B[i] *= down; } return B;} 剑指offer 52 正则表达式匹配//请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配12345678910111213141516171819202122232425262728293031323334bool match(char* str, char* pattern){ if (str == NULL || pattern == NULL) return false; int strIndex = 0, patternIndex = 0; return matchHelper(str, pattern);}bool matchHelper(char* str, char* pattern) { // str到尾，pattern到尾，匹配成功 // 注意下指针和string字符串判断是否为空的区别 if (*str == &apos;\\0&apos; &amp;&amp; *pattern == &apos;\\0&apos;) return true; // pattern为空，str不空，匹配必定失败 if (*pattern == &apos;\\0&apos; &amp;&amp; *str != &apos;\\0&apos;) return false; // 如果pattern下一个字符不为&apos;*&apos; if (*(pattern + 1) != &apos;*&apos;) { // 匹配成功情况： // 1. 当前str字符==当前pattern字符 // 2. pattern为&apos;.&apos;且当前str不为空 if (*pattern == *str || (*pattern == &apos;.&apos; &amp;&amp; *str != &apos;\\0&apos;)){ return matchHelper(str+1, pattern+1); } else return false; } // 如果pattern下一个字符为&apos;*&apos; else { // 继续匹配的情况： // 1. 当‘*’匹配0个字符时，str当前字符不变，pattern当前字符后移两位，跳过这个‘*’符号； // 2. 当‘*’匹配1个或多个时，str当前字符移向下一个，pattern当前字符不变。 if (*pattern == *str || (*pattern == &apos;.&apos; &amp;&amp; *str != &apos;\\0&apos;)) { return matchHelper(str+1,pattern) || matchHelper(str, pattern+2); } else return matchHelper(str, pattern+2); }} 剑指offer 53 表示数值的字符串// 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。1234567891011121314151617181920212223242526bool isNumeric(char* string){ if (string == nullptr) return false; // 标记符号、小数点、e是否出现过 bool sign = false, decimal = false, hasE = false; for (int i = 0; i &lt; strlen(string); i++) { if (string[i] == &apos;+&apos; || string[i] == &apos;-&apos;) { // 第二次出现+-符号，必须紧接在e之后 if (sign &amp;&amp; string[i-1] != &apos;e&apos; &amp;&amp; string[i-1] != &apos;E&apos;) return false; // 第一次出现+-符号，且不是在字符串开头，也必须紧接在e之后 if (!sign &amp;&amp; i&gt;0 &amp;&amp; string[i-1] != &apos;e&apos; &amp;&amp; string[i-1] != &apos;E&apos;) return false; } else if (string[i] == &apos;e&apos; || string[i] == &apos;E&apos;) { // e后面一定要接数字 || 不能同时存在两个e if (i == strlen(string) - 1 || hasE) return false; hasE = true; } else if (string[i] == &apos;.&apos;) { // e后面不能接小数点，小数点不能出现两次 if (hasE || decimal) return false; decimal = true; } else if (string[i] &lt; &apos;0&apos; || string[i] &gt; &apos;9&apos;) return false; } return true;} 剑指offer 54 字符流中第一个不重复的字符// 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。如果当前字符流没有存在出现一次的字符，返回#字符。123456789101112131415161718string s;char hash[256] = {0};//Insert one char from stringstreamvoid Insert(char ch){ s += ch; hash[ch]++;}//return the first appearence once char in current stringstreamchar FirstAppearingOnce(){ for (int i = 0; i &lt; s.size(); i++) { if (hash[s[i]] == 1) { return s[i]; } } return &apos;#&apos;;} 剑指offer 55 链表中环的入口节点// 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。12345678910111213141516171819202122232425ListNode* EntryNodeOfLoop(ListNode* pHead){ if (pHead == nullptr) return nullptr; ListNode* fast = pHead; ListNode* slow = pHead; ListNode* meetingNode = nullptr; while (fast-&gt;next &amp;&amp; slow) { fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast == slow) { meetingNode = fast; break; } } if (meetingNode) { ListNode* p1 = meetingNode; ListNode* p2 = pHead; while (p1 != p2) { p1 = p1-&gt;next; p2 = p2-&gt;next; } return p1; } return nullptr;} 剑指offer 56 删除链表中重复的节点// 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;512345678910111213141516171819202122232425ListNode* deleteDuplication(ListNode* pHead){ if (pHead == nullptr) return nullptr; ListNode *root = pHead, *pre; while (root != nullptr) { if (root-&gt;next-&gt;val != root-&gt;val) { pre = root; root = root-&gt;next; } else { while (root-&gt;next &amp;&amp; root-&gt;next-&gt;val == root-&gt;val) { root = root-&gt;next; } if (root-&gt;next) { pre-&gt;next = root-&gt;next; root = root-&gt;next; } else { pre-&gt;next = nullptr; return pHead; } } } return pHead;} 剑指offer 57 二叉树的下一个节点// 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。1234567TreeLinkNode* GetNext(TreeLinkNode* pNode){ if (pNode == nullptr) return pNode; while (pNode-&gt;right) { pNode = pNode-&gt;left; }} 剑指offer 58 对称的二叉树// 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。1234567891011121314bool isSymmetrical(TreeNode* pRoot){ if (pRoot == nullptr) return true; return isSymmetricalHelper(pRoot-&gt;left, pRoot-&gt;right);}bool isSymmetricalHelper(TreeNode* p1, TreeNode* p2) { if (p1 &amp;&amp; p2 == nullptr) return false; else if (p2 &amp;&amp; p1 == nullptr) return false; else if (p1 == nullptr &amp;&amp; p2 == nullptr) return true; if (p1-&gt;val == p2-&gt;val) { return isSymmetricalHelper(p1-&gt;left, p2-&gt;right) &amp;&amp; isSymmetricalHelper(p2-&gt;left, p1-&gt;right); } else return false;} 剑指offer 59 之字形打印二叉树// 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。12345678910111213141516171819202122232425262728293031vector&lt;vector&lt;int&gt; &gt; PrintZ(TreeNode* pRoot) { vector&lt;vector&lt;int&gt; &gt; res; if (pRoot == nullptr) return res; vector&lt;TreeNode*&gt; d; d.push_back(pRoot); vector&lt;int&gt; init; init.push_back(pRoot-&gt;val); res.push_back(init); int layer = 1; while (!d.empty()) { layer++; vector&lt;TreeNode*&gt; tmp; for (int i = 0; i &lt; d.size(); i++) { if (d[i]-&gt;left) tmp.push_back(d[i]-&gt;left); if (d[i]-&gt;right) tmp.push_back(d[i]-&gt;right); } vector&lt;int&gt; tmpInt; for (int i = 0; i &lt; tmp.size(); i++) { tmpInt.push_back(tmp[i]-&gt;val); } if (layer % 2 == 1 &amp;&amp; !tmpInt.empty()) { res.push_back(tmpInt); } else if (layer % 2 == 0 &amp;&amp; !tmpInt.empty()) { reverse(tmpInt.begin(), tmpInt.end()); res.push_back(tmpInt); } d = tmp; } return res;} 剑指offer 60 把二叉树打印成多行（层序遍历）从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。1234567891011121314151617181920212223vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) { vector&lt;vector&lt;int&gt; &gt; vec; if(pRoot == NULL) return vec; queue&lt;TreeNode*&gt; q; q.push(pRoot); while(!q.empty()) { int lo = 0, hi = q.size(); vector&lt;int&gt; c; while(lo++ &lt; hi) { TreeNode *t = q.front(); q.pop(); c.push_back(t-&gt;val); if(t-&gt;left) q.push(t-&gt;left); if(t-&gt;right) q.push(t-&gt;right); } vec.push_back(c); } return vec;} 剑指offer 61 序列化二叉树二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。 二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。12345678910111213141516171819202122232425262728293031323334353637typedef TreeNode node;typedef TreeNode* pnode;typedef int* pint;class Solution { vector&lt;int&gt; buf; void dfs(pnode p){ if(!p) buf.push_back(0x23333); else{ buf.push_back(p -&gt; val); dfs(p -&gt; left); dfs(p -&gt; right); } } pnode dfs2(pint&amp; p){ if(*p == 0x23333){ ++p; return NULL; } pnode res = new node(*p); ++p; res -&gt; left = dfs2(p); res -&gt; right = dfs2(p); return res; }public: char* Serialize(TreeNode *p) { buf.clear(); dfs(p); int *res = new int[buf.size()]; for(unsigned int i = 0; i &lt; buf.size(); ++i) res[i] = buf[i]; return (char*)res; } TreeNode* Deserialize(char *str) { int *p = (int*)str; return dfs2(p); }}; 剑指offer 62 二叉搜索树的第k个结点给定一棵二叉搜索树，请找出其中的第k小的结点。例如,(5，3，7，2，4，6，8)中，按结点数值大小顺序第三小结点的值为4。12345678910111213141516171819202122232425262728293031323334// 递归int cnt = 0;TreeNode* KthNode(TreeNode* pRoot, int k){ if (pRoot) { TreeNode* node = KthNode(pRoot-&gt;left, k); if (node) return node; cnt++; if (cnt == k) return pRoot; node = KthNode(pRoot-&gt;right, k); if (node) return node; } return nullptr;}// 非递归 中序遍历TreeNode* KthNode(TreeNode* pRoot, int k){ if (pRoot == nullptr || k &lt; 1) return nullptr; stack&lt;TreeNode*&gt; S; int cnt = 0; TreeNode* node = pRoot; while (!S.empty() || node) { while (node) { S.push(node); node = node-&gt;left; } node = S.top(); S.pop(); cnt++; if (cnt == k) return node; node = node-&gt;right; } return nullptr;} 剑指offer 63 数据流中的中位数如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。12345678910111213141516171819202122// 法1：大顶堆+小顶堆 // 法2：AVL 平衡二叉搜索树// 法3：排序vector&lt;int&gt; dataStream;void Insert(int num){ dataStream.push_back(num); sort(dataStream.begin(), dataStream.end());}double GetMedian(){ int sz = dataStream.size(); double res; if (sz % 2 == 0) { res = (double) (dataStream[sz/2] + dataStream[sz/2-1]) / 2; } else { res = (double) dataStream[sz/2]; } return res;} 剑指offer 64 滑动窗口的最大值给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}。1234567891011121314151617181920212223242526272829303132333435363738394041// 暴力法 O(n * size)int FindMaxVal(vector&lt;int&gt; num, int st, int ed) { int MaxVal = num[st]; for (int i = st; i &lt;= ed; i++) { if (num[i] &gt; MaxVal) MaxVal = num[i]; } return MaxVal;}vector&lt;int&gt; maxInWindows1(const vector&lt;int&gt;&amp; num, unsigned int size){ vector&lt;int&gt; res; if (num.size() == 0 || size &lt; 1) return res; for (int i = 0; i &lt;= num.size()-size; i++) { int tmp = FindMaxVal(num, i, i+size-1); res.push_back(tmp); } return res;}// 双端队列 O(n)vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size){ vector&lt;int&gt; res; if (num.size() == 0 || size &lt; 1) return res; deque&lt;int&gt; d; for (int i = 0; i &lt; num.size(); ++i) { // 从后面依次弹出队列汇总比当前num值小的元素，同时保证队首元素为当前窗口最大值下标 while (d.size() &amp;&amp; num[d.back()] &lt;= num[i]) { d.pop_back(); } // 当当前窗口移出队首元素所在的位置，即队首元素坐标对应的num不在窗口中，需要弹出 if (d.size() &amp;&amp; i-d.front()+1 &gt; size) { d.pop_front(); } d.push_back(i); // 当滑动窗口首地址i大于等于size时才开始写入窗口最大值 if (i &gt;= size - 1) { res.push_back(num[d.front()]); } } return res;} 剑指offer 65 矩阵中的路径请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。1234567891011121314151617181920212223242526272829303132bool dfs(char* matrix, int i, int j, int rows, int cols, char* str, vector&lt;vector&lt;bool&gt; &gt; path) { if (*str == &apos;\\0&apos;) return true; if (matrix[i * cols + j] != str[0]) return false; bool hasPath = false; if (j &gt;= 0 &amp;&amp; i &gt;=0 &amp;&amp; i &lt; rows &amp;&amp; j &lt; cols &amp;&amp; !path[i][j] &amp;&amp; matrix[i * cols + j] == str[0]) { path[i][j] = true; hasPath = dfs(matrix, i-1, j, rows, cols, str+1, path) || dfs(matrix, i+1, j, rows, cols, str+1, path) || dfs(matrix, i, j-1, rows, cols, str+1, path) || dfs(matrix, i, j+1, rows, cols, str+1, path); if (!hasPath) path[i][j] = false; } return hasPath;}bool hasPath(char* matrix, int rows, int cols, char* str){ if (matrix == nullptr || str == nullptr) return false; vector&lt;vector&lt;bool&gt; &gt; path(rows, vector&lt;bool&gt;(cols, false)); bool res = false; for (int row = 0; row &lt; rows; row++) { for (int col = 0; col &lt; cols; col++) { if (matrix[row * cols + col] == str[0]) { res = dfs(matrix, row, col, rows, cols, str, path); } if (res) return res; } } return res;} 剑指offer 66 机器人的动作范围地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？1234567891011121314151617181920212223242526272829303132333435363738int movingCount(int threshold, int rows, int cols){ bool* flag=new bool[rows*cols]; for(int i=0;i&lt;rows*cols;i++) flag[i]=false; int count=moving(threshold,rows,cols,0,0,flag);//从（0,0）坐标开始访问; delete[] flag; return count;}//计算最大移动位置int moving(int threshold,int rows,int cols,int i,int j,bool* flag) { int count=0; if(check(threshold,rows,cols,i,j,flag)) { flag[i*cols+j]=true; //标记访问过，这个标志flag不需要回溯，因为只要被访问过即可。 //因为如果能访问，访问过会加1.不能访问，也会标记下访问过。 count=1+moving(threshold,rows,cols,i-1,j,flag) + moving(threshold,rows,cols,i,j-1,flag) +moving(threshold,rows,cols,i+1,j,flag) + moving(threshold,rows,cols,i,j+1,flag); } return count;}//检查当前位置是否可以访问bool check(int threshold,int rows,int cols,int i,int j,bool* flag) { if(i&gt;=0 &amp;&amp; i&lt;rows &amp;&amp; j&gt;=0 &amp;&amp; j&lt;cols &amp;&amp; getSum(i)+getSum(j)&lt;=threshold &amp;&amp; flag[i*cols+j]==false) return true; return false;}//计算位置的数值int getSum(int number) { int sum=0; while(number&gt;0) { sum+=number%10; number/=10; } return sum;} 剑指offer 67 剪绳子给你一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。123456789101112131415161718/* 首先判断k[0]到k[m]可能有哪些数字，实际上只可能是2或者3。 * 5&lt;2*3,6&lt;3*3,比6更大的数字我们就更不用考虑了，肯定要继续分。 * 其次看2和3的数量，2的数量肯定小于3个，为什么呢？因为2*2*2&lt;3*3，那么题目就简单了。 * 直接用n除以3，根据得到的余数判断是一个2还是两个2还是没有2就行了。 * 由于题目规定m&gt;1，所以2只能是1*1，3只能是2*1，这两个特殊情况直接返回就行了。 */long long n_max_3(long long n) { if (n == 2) return 1; if (n == 3) return 2; long long x = n % 3; long long y = n / 3; if (x == 0) { return pow(3, y); } else if (x == 1) { return 2 * 2 * (long long) pow(3, y - 1); } else { return 2 * (long long) pow(3, y); }}","link":"/2020/03/06/ckwasv95y0016v45c68su3c00/"},{"title":"clion连接postgresql","text":"Clion连接postgresqlClion是Jetbrains家的面向跨平台开发的C/C++集成开发环境. 有时候开发需要连接到数据库进行query查询. 安装postgresql教程可用菜单栏上的pgAdmin查询自己的数据库名、端口 安装Clion参考详细文档Clion使用 设置database连接 clion界面右侧-&gt;+号-&gt;Data Source-&gt;PostgreSQL 检查数据库信息，用户名和密码是否正确，点击Test Connection，成功可返回；不成功查看下一步。 若无法连接外网，点击下方的Download，无法下载，但要把网址上的.jar包下载下来，后面用到；点击左侧drivers-&gt;PostgreSQL，在Dirver files下点击+号，加载刚下载的jar包，然后左侧的Data source，点击Test Connection可以看到数据库具体信息。 有时候clion首页会重新让输入数据库用户名和密码，输入即可","link":"/2020/03/21/ckwasv94z000pv45c90hwsduc/"},{"title":"Postgresql+postgis地图开发说明","text":"Postgresql+postgis地图开发说明实习期间需要部署路网数据库查询服务，windows和ubuntu下的安装部署大同小异，现以postgresql 10+postgis 2.5.0为例 1. 安装postgresql+postgis部署地图数据查询服务ubuntu: sudo apt install libpq-dev postgresql-server-dev-10 postgresql-server-dev-all windows:参考博客csdn blog 2. 下载openstreetmap地图osm数据 下载国家地图数据，在www.openstreetmap.org，无法具体到省份城市 下载具体省份城市地图下载可参考省市地图 更小区域地图下载，可使用www.openstreetmap.org限定经纬度直接导出 3. 创建数据库，并支持postgis和pgrouting 方式一，命令行 createdb -U postgres XXX（数据库名称，后续都用XXX代替） 进入数据库\\c XXX,输入以下语句使数据库支持空间分析和空间查询 123456CREATE EXTENSION postgis; CREATE EXTENSION pgrouting;CREATE EXTENSION postgis_topology; CREATE EXTENSION fuzzystrmatch; CREATE EXTENSION postgis_tiger_geocoder; CREATE EXTENSION address_standardizer; 方式二：在pgAdmin中打开，直接以postgis数据库为模版创建数据库，这样创建的数据库直接支持空间查询和空间分析。 4. 将osm数据导入数据库blog4.1 安装OSM数据导入工具osm2pgsql(Ubuntu操作)： sudo apt install osm2pgsql (windows操作)： osm2pgsql下载地址：http://customdebug.com/osm/osm2pgsql.zip default.style文件:https://github.com/openstreetmap/osm2pgsql/blob/master/default.style osm2pgsql下载好之后解压，解压完成之后，将下载的default.style放入到.\\osm2pgsql\\x64文件夹下 4.2 进入数据库windows: cmd输入psql -U postgres -d XXX进入数据库 ubuntu: psql -U user_name -d database_name -h localhost 4.3 为了避免后面出现要输入密码或者出现Error: Connection to database failed: fe_sendauth: no password supplied错误，将文件pg_hba.conf（文件路径：...\\PostgreSQL\\10\\data）里面的md5，下图所示的两个md5改为trust4.4 (windwos)加载postgis对象和函数定义（postgis.sql） 在数据库安装位置bin文件夹下打开dos窗口，输入命令psql -U postgres -d osm -f “此处为postgis.sql文件的路径”。 postgis.sql文件在...PostgreSQL\\10\\share\\contrib\\postgis-2.5文件夹下 4.5 (windows)加载EPSG坐标系统定义（spatial_ref_sys.sql） 在dos窗口下输入命令psql -U postgres -d osm -f 此处为postgis.sql文件的路径 postgis.sql文件在...PostgreSQL\\10\\share\\contrib\\postgis-2.4文件夹下 4.6 导入OSM数据 ubuntu osm2pgsql -d XXX –U username -P portID -C 12000 -S /home/china-latest.osm.pbf -H localhost -W windows 在下载的osm2pgsql的.\\osm2pgsql\\x64文件夹下打开dos窗口，输入命令osm2pgsql -d XXX –U username -P portID -C 12000 -S &quot;C:\\develop\\postsql-gis\\osm2pgsql\\x64\\default.style&quot; china-latest.osm.pbf 4.7 验证数据是否成功 (linux) \\d发现多了几张table和view说明导入成功 (windows) 从菜单栏的postgressql打开pgAdmin，发现XXX库中多了4张表，说明导入成功 5. 创建路网拓扑图和查询数据表5.1 创建数据表，选择指定列，并重新排序gid 选择指定列：CREATE TABLE XXX AS (SELECT osm_id,name,ref,highway,oneway,bridge,way FROM planet_osm_roads); 添加起点id：ALTER TABLE XXX ADD COLUMN source integer; 添加终点id：ALTER TABLE XXX ADD COLUMN target integer; 添加道路权重值: ALTER TABLE XXX ADD COLUMN length double precision; 创建序列： 123456CREATE SEQUENCE test_id_seqSTART WITH 1INCREMENT BY 1NO MINVALUENO MAXVALUECACHE 1; 更新自增ID： 123alter table XXX add column gid int;alter table XXX alter column gid set default nextval(&apos;test_id_seq&apos;);update XXX set gid=nextval(&apos;test_id_seq&apos;); 修改数据表中列名way为geom: alter table XXX rename way to geom 5.2 创建路网拓扑 SELECT pgr_createTopology('XXX',0.00001, 'geom', 'gid');5.3 为length赋值 update XXX set length =st_length(geom);6. 使用QGIS加载数据表和在线地图6.1 QGIS连接postgressql 连接PostGIS数据源——数据库管理器——导入数据——加载数据 输入数据库名称 端口 用户名和密码 双击数据表即可显示图层 6.2 安装在线地图插件显示地图图层 打开QGIS，在插件下搜QGIS cloud插件，选择 add background layer 即可添加google map，bing map，openstreet map 作为底图","link":"/2020/03/19/ckwasv955000zv45cdl3mxslw/"},{"title":"Git","text":"Git &amp; Linux operations python程序后台运行程序后台运行，打印结果到out.log文件nohup python -u test.py &gt; out.log 2&gt;&amp;1 &amp;说明： 末尾的“&amp;”：表示后台运行程序 “nohup” ：保证程序不被挂起 “python”：是执行python代码的命令 “-u”：表示不启用缓存，实时输出打印信息到日志文件（如果不加-u，则会导致日志文件不会实时刷新代码中的print函数的信息） “Job.py”：是python的源代码文件 “log.log”：是输出的日志文件 “&gt;”：是指将打印信息指定到日志文件 “2&gt;&amp;1”：将标准错误输出转变化标准输出，可以将错误信息也输出到日志文件中（0-&gt; stdin, 1-&gt;stdout, 2-&gt;stderr） 查询下进程 ，可查看pidps -ef | grep xxx 终止脚本进程kill -9 pid to be continue…","link":"/2020/01/08/ckwasv94z000ov45cis0z2mdk/"},{"title":"链表的算法合集整理","text":"链表的算法合集大全(C/C++) 1. 链表结构体定义 2. 链表初始化，可以快速创建样例 3. 链表遍历打印，检验算法正确性 4. 输出单链表倒数第 K 个节点 5. 判断链表是否有环 6. 定位环的入口 7. 计算环的长度 8. 链表实现大数加法 9. 有序链表合并 10. K个有序链表合并 11. O(1)复杂度删除链表中结点 12. 从尾到头打印链表 13. 反转链表 14. 复杂链表的复制 15. 逆序构造单链表 16. 链表升序排序 17. 找出单链表的中间结点 1. 链表结构体定义1234567struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { }}; 2. 链表初始化，可以快速创建样例12345678910111213// 链表初始化，创造样例ListNode* linkedListInit(vector&lt;int&gt; v) { if (v.empty()) return NULL; ListNode* root = new ListNode(v[0]); ListNode* node = root; int i = 1; while (i&lt;v.size()) { node-&gt;next = new ListNode(v[i]); node = node-&gt;next; i++; } return root;} 3. 链表遍历打印，检验算法正确性123456789// 打印链表元素值，检验算法void PrintLinkedList(ListNode* root) { if (root == NULL) return; while (root != NULL) { cout&lt;&lt;root-&gt;val&lt;&lt;&quot; &quot;; root = root-&gt;next; } cout&lt;&lt;endl;} 4. 输出单链表倒数第 K 个节点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 输出单链表倒数第 K 个节点// 法一：两次遍历ListNode* findKthTail1(ListNode *pHead, int k) { if (pHead == NULL || k &lt;= 0) return NULL; int len = 0; ListNode* root = pHead; while (pHead != NULL) { pHead = pHead-&gt;next; len++; } if (len&lt;k) return NULL; int countdown = len-k; while (countdown--&gt;0) { root = root-&gt;next; } return root;}// 法二：递归**int cnt = 0;ListNode* findKthTail2(ListNode* pHead, int k) { if (pHead == NULL) return NULL; ListNode* node = findKthTail2(pHead-&gt;next, k); // 没找到就返回NULL，找到一直返回结点 if (node == NULL) { cnt++; if (cnt == k) return pHead; else return NULL; } else { return node; }}// 法三：快慢指针***ListNode* findKthTail3(ListNode* pHead, int k) { if (pHead == NULL || k &lt;= 0) return NULL; ListNode* slow = pHead; ListNode* fast = pHead; for(int i=0;i&lt;k;i++) { //快指针先走k步 if(fast) fast = fast-&gt;next; else return NULL; } while(fast) { fast = fast-&gt;next; slow = slow-&gt;next; } return slow;} 5. 判断链表是否有环123456789101112131415// 判断链表是否有环// 法一：穷举比较 O(n^2)// 法二：哈希缓存 O(n)// 法三：快慢指针 O(n)~O(n^2)环很大时bool isExistRing3(ListNode* pHead) { if (pHead == NULL) return false; ListNode* fast = pHead; ListNode* slow = pHead; while (fast-&gt;next &amp;&amp; slow) { fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast == slow) return true; } return false;} 6. 定位环的入口12345678910111213141516171819202122232425// 定位环的入口***hard***ListNode* getEntryNodeOfRing(ListNode* pHead) { ListNode* meetingnode = getMeetingNode(pHead); if (meetingnode == NULL) return NULL; // 没环则相遇尾结点 ListNode* p1 = meetingnode; ListNode* p2 = pHead; // p1和p2以相同的速度向前移动，当p2指向环的入口节点时 // p1已经围绕着环走了n圈又回到了入口节点。 while(p1 != p2) { p1 = p1-&gt;next; p2 = p2-&gt;next; } return p1;}ListNode* getMeetingNode(ListNode* pHead) { if (pHead == NULL) return NULL; ListNode* fast = pHead; ListNode* slow = pHead; while (fast-&gt;next &amp;&amp; slow) { fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast == slow) return slow; } return NULL;} 7. 计算环的长度12345678910111213141516// 计算环的长度// 找到slow与fast的相遇节点，令slow与fast指针从相遇节点出发，// 按照之前的前进规则，当slow与fast再次相遇时，slow走过的长度正好为环的长度。int getLengthOfRing(ListNode* pHead) { if (pHead == NULL) return 0; ListNode* meetingnode = getMeetingNode(pHead); if (meetingnode == NULL) return 0; // 防止无环 ListNode* fast = meetingnode-&gt;next-&gt;next; ListNode* slow = meetingnode-&gt;next; int length = 1; while (fast != slow) { fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; } return length;} 8. 链表实现大数加法1234567891011121314151617181920212223242526272829303132// 链表实现大数加法ListNode* numberAddAsList(ListNode* l1, ListNode* l2) { ListNode *ret = l1, *pre = l2; int up = 0; // 进位 while (l1 != NULL &amp;&amp; l2 != NULL) { l1-&gt;val = l1-&gt;val + l2-&gt;val +up; up = l1-&gt;val / 10; l1-&gt;val %= 10; pre = l1; //记录当前结点位置 l1 = l1-&gt;next; l2 = l2-&gt;next; } // 若l1到达末尾，说明l1长度小于l2 if (l1 == NULL) { pre-&gt;next = l2; // pre-&gt;next指向l2当前位置 } l1 = pre-&gt;next; // l1指针指向l2结点当前位置,即把l2拼到l1上继续计算 // 继续计算剩余结点，防止9999999+1这种情况 while (l1 != NULL) { l1-&gt;val = l1-&gt;val + up; up = l1-&gt;val / 10; l1-&gt;val %= 10; pre = l1; l1 = l1-&gt;next; } // 最高位有进位，新建一个结点保留最高位 if (up != 0) { ListNode* tmp = new ListNode(up); pre-&gt;next = tmp; } return ret;} 9. 有序链表合并12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 有序链表合并// 递归ListNode* mergeTwoOrderedListsRec(ListNode* pHead1, ListNode* pHead2){ if(pHead1 == NULL) return pHead2; if(pHead2 == NULL) return pHead1; if(pHead1-&gt;val &gt; pHead2-&gt;val) { pHead2-&gt;next = mergeTwoOrderedListsRec(pHead1, pHead2-&gt;next); return pHead2; } else { pHead1-&gt;next = mergeTwoOrderedListsRec(pHead1-&gt;next, pHead2); return pHead1; }}// 非递归ListNode* mergeTwoOrderedListsNotRec(ListNode* pHead1, ListNode* pHead2) { if (pHead1 == NULL) return pHead2; else if (pHead2 == NULL) return pHead1; else { ListNode* pTail = NULL; // 新链表最后一个结点 ListNode* newHead = NULL; // 合并后链表第一个结点 if (pHead1-&gt;val &lt; pHead2-&gt;val) { newHead = pHead1; pHead1 = pHead1-&gt;next; } else { newHead = pHead2; pHead2 = pHead2-&gt;next; } pTail = newHead; // 指向第一个结点 while (pHead1 &amp;&amp; pHead2) { if (pHead1-&gt;val &lt;= pHead2-&gt;val) { pTail-&gt;next = pHead1; pHead1 = pHead1-&gt;next; } else { pTail-&gt;next = pHead2; pHead2 = pHead2-&gt;next; } pTail = pTail-&gt;next; } if (pHead1 == NULL) pTail-&gt;next = pHead2; else if (pHead2 == NULL) pTail-&gt;next = pHead1; return newHead; }} 10. K个有序链表合并12345678910111213// K个有序链表合并// 归并排序，复杂度O(nlogk)ListNode* mergeKsortedLists(vector&lt;ListNode*&gt; lists) { int amount = lists.size(); int gap = 1; while (gap &lt; amount) { for (int i=0; i&lt; amount-gap; i+=gap*2) { lists[i] = mergeTwoOrderedListsRec(lists[i], lists[i+gap]); } gap *= 2; } return amount&gt;0?lists[0]:NULL;} 11. O(1)复杂度删除链表中结点12345678910111213141516171819202122232425void deleteNode(ListNode **pHead, ListNode* pDelNode) { if (pDelNode == NULL) return; if (pDelNode-&gt;next != NULL) { ListNode* pNext = pDelNode-&gt;next; // 下一个节点的值赋给删除节点 pDelNode-&gt;val = pNext-&gt;val; pDelNode-&gt;next = pNext-&gt;next; delete pNext; // delete是删除指针指向的内容 pNext = NULL; // 不指向NULL会成为野指针 } else if (*pHead == pDelNode) { //头结点 delete pDelNode; pDelNode = NULL; *pHead = NULL; } else { //删除尾结点 ListNode *pNode = *pHead; while (pNode-&gt;next != pDelNode) { pNode = pNode-&gt;next; } pNode-&gt;next = NULL; delete pDelNode; pDelNode = NULL; }} 12. 从尾到头打印链表1234567891011121314151617181920212223242526272829303132333435363738394041424344// 递归vector&lt;int&gt; printListFromTailToHead1(ListNode* head) { vector&lt;int&gt; res; if(head!=NULL){ if(head-&gt;next!=NULL){ res = printListFromTailToHead1(head-&gt;next); } res.push_back(head-&gt;val); } return res;}//栈vector&lt;int&gt; printListFromTailToHead2(ListNode* head) { vector&lt;int&gt; res; stack&lt;int&gt; sta; while(head!=NULL){ sta.push(head-&gt;val); head=head-&gt;next; } while(!sta.empty()){ res.push_back(sta.top()); sta.pop(); } return res;}// **链表原地反转**vector&lt;int&gt; printListFromTailToHead3(struct ListNode* head) { vector&lt;int&gt; vec; ListNode *buf=head; ListNode *pre=buf; if(head==NULL) return vec; while(head-&gt;next!=NULL){ /*这里还没看懂*/ buf=head-&gt;next; head-&gt;next=buf-&gt;next; buf-&gt;next=pre; pre=buf; } while(buf){ vec.push_back(buf-&gt;val); buf=buf-&gt;next; } return vec;} 13. 反转链表123456789101112131415161718192021222324// 迭代（链表的原地反转）ListNode* reverseList1(ListNode* head) { ListNode* pre = NULL; ListNode* cur = head; while (cur != NULL) { ListNode* next = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = next; } return pre;}// 递归ListNode* reverseList2(ListNode* head) { if (head == NULL || head-&gt;next == NULL) { return head; } ListNode* rhead = reverseList2(head-&gt;next); // head-&gt;next此刻指向head后面的链表的尾节点 // head-&gt;next-&gt;next = head把head节点放在了尾部 head-&gt;next-&gt;next = head; head-&gt;next = NULL; return rhead;} 14. 复杂链表的复制123456789101112131415161718192021222324252627282930// （每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针// 指向任意一个节点），返回结果为复制后复杂链表的head。RandomListNode* Clone(RandomListNode* pHead){ if(pHead==NULL) return NULL; RandomListNode* currentNode=pHead; //复制每个结点，将其插入结点后面 while(currentNode!=NULL){ RandomListNode* cloneNode = new RandomListNode(currentNode-&gt;label); RandomListNode* nextNode = currentNode-&gt;next; currentNode-&gt;next=cloneNode; cloneNode-&gt;next=nextNode; currentNode=nextNode; } currentNode=pHead; //复制老结点的随机指针给新结点 while(currentNode!=NULL){ currentNode-&gt;next-&gt;random = currentNode-&gt;random==NULL?NULL:currentNode-&gt;random-&gt;next; currentNode=currentNode-&gt;next-&gt;next; } //拆分链表 currentNode=pHead; RandomListNode* pCloneHead=pHead-&gt;next; while(currentNode!=NULL){ RandomListNode* cloneNode=currentNode-&gt;next; currentNode-&gt;next=cloneNode-&gt;next; cloneNode-&gt;next=cloneNode-&gt;next==NULL?NULL:cloneNode-&gt;next-&gt;next; currentNode=currentNode-&gt;next; } return pCloneHead;} 15. 逆序构造单链表输入数据：[1,2,3,4,5],构造单链表:5-&gt;4-&gt;3-&gt;2-&gt;1 1234567891011// 逆序构造单链表ListNode* desc_construct(vector&lt;int&gt; input) { if (input.empty()) return NULL; ListNode* pre = NULL; for (int i=0;i&lt;input.size();i++) { ListNode* cur = new ListNode(input[i]); cur-&gt;next = pre; pre = cur; } return pre;} 16. 链表升序排序快排是需要一个指针指向头，一个指针指向尾，然后两个指针相向运动并按一定规律交换值，最后使得支点左边小于支点，支点右边大于支点，但是对于单链表而言，指向结尾的指针很好办，但是这个指针如何往前，我们只有一个 next（这并不是一个双向链表）。 我们只需要两个指针 i 和 j，这两个指针均往 next 方向移动，移动的过程中始终保持区间 [1, i] 的 data 都小于 base（位置 0 是主元），区间 [i+1, j) 的 data 都大于等于 base，那么当 j 走到末尾的时候便完成了一次支点的寻找。若以 swap 操作即 if 判断语句成立作为基本操作，其操作数和快速排序相同，故该方法的平均时间复杂度亦为$T(n) = O(nlogn)$。 1234567891011121314151617181920212223// 链表升序排序/** * @param begin 链表的第一个结点，即header-&gt;next * @param end 链表的最后一个结点的next */void asc_sort(ListNode* begin, ListNode* end) { // 链表为空或只有一个结点 if (begin == end || begin-&gt;next == end) return; int base = begin-&gt;val; ListNode* i = begin; ListNode* j = begin-&gt;next; while (j != end) { if (j-&gt;val &lt; base) { i = i-&gt;next; swap(i-&gt;val, j-&gt;val); } j = j-&gt;next; } swap (i-&gt;val, begin-&gt;val); asc_sort(begin, i); asc_sort(i-&gt;next, end);}// usage: asc_sort(header-&gt;next, nullptr); 17. 找出单链表的中间结点123456789101112// 找出单链表的中间结点（类似倒数第k个结点）// 法一：遍历一次，再遍历到n/2,复杂度为O(n+n/2)// 法二：快慢指针ListNode* find_middle(ListNode* head) { ListNode* fast = head; ListNode* slow = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) { slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; } return slow;}","link":"/2019/08/21/ckwasv952000uv45cop72vhaz/"},{"title":"2019中兴捧月算法大赛——无线信道估计","text":"Github项目：https://github.com/dlc1994/2019ZTE-Algorithm-Competition 本来想参加深度学习题目的，但看到用caffe，还要现学就作罢了 傅里叶门派有三个题目，一开始想做了智能调度，但是看了半天题目也没理解，随便提交了一个上去（最后发现一共才50多份提交，悔不当初） 看到这个有点像曲线拟合，题目就是用最少的导频数，估计带噪声的其余一共250个频点的信道值 看上去有点像曲线拟合，所以我就往曲线拟合方向做了 1 导频数用62，此时导频和误差百分比大致在50% 2 导频分开实部和虚部分开进行拟合，拟合函数使用SmoothingSpline 3 拟合出来函数是带噪声的，接下来去噪 4 用小波变换，小波基为coif5,分解层数为10层 5 输出最终结果，感觉有点过拟合了 最后一天做了半天，只能提高到36名了，看到进决赛拿蓝剑的那些大神还是很羡慕的，应该多花些时间的，从原理上改进而不是简单的去噪拟合 大佬的思路： 1 多种组合构成个闭环优化，中兴专家做的，好像用20个导频左右拿了第一 2 用CNN，这个可能是从autoencoder方向想，但是数据集够用？","link":"/2019/05/24/ckwasv9580015v45c14o92392/"},{"title":"LeetCode Solutions","text":"Here are my solutions to the LeetCode problems, linking to my Github repository: EASY Leetcode 1 Two Sum Leetcode 9 Palindrome Number Leetcode 13 roman2integer Leetcode 14 longestcommonprefix Leetcode 20 valid parentheses Leetcode 21 merge2sortedlist Leetcode 73 矩阵置零 给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。进阶：一个直观的解决方案是使用 O(mn) 的额外空间，但这并不是一个好的解决方案。一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。你能想出一个仅使用常量空间的解决方案吗？示例 1：输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]输出：[[1,0,1],[0,0,0],[1,0,1]]示例 2：输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]] 1234567891011121314151617181920212223242526272829代码：class Solution {public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int m = matrix.size(); int n = matrix[0].size(); int flag_col0 = false; for (int i = 0; i &lt; m; i++) { if (!matrix[i][0]) { flag_col0 = true; } for (int j = 1; j &lt; n; j++) { if (!matrix[i][j]) { matrix[i][0] = matrix[0][j] = 0; } } } for (int i = m - 1; i &gt;= 0; i--) { for (int j = 1; j &lt; n; j++) { if (!matrix[i][0] || !matrix[0][j]) { matrix[i][j] = 0; } } if (flag_col0) { matrix[i][0] = 0; } } }}; Leetcode 150 逆波兰表达式求值 逆波兰表达式：逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) ( 3 + 4 ) 。该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) ) 。逆波兰表达式主要有以下两个优点：去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + 也可以依据次序计算出正确结果。适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中根据 逆波兰表示法，求表达式的值。有效的算符包括 +、-、、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。说明：整数除法只保留整数部分。给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。示例 1：输入：tokens = [“2”,”1”,”+”,”3”,”“]输出：9解释：该算式转化为常见的中缀算术表达式为：((2 + 1) 3) = 9示例 2：输入：tokens = [“4”,”13”,”5”,”/“,”+”]输出：6解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 123456789101112131415class Solution: def evalRPN(self, tokens: List[str]) -&gt; int: if len(tokens) == 1: return int(tokens[0]) stack = [] for token in tokens: if token not in &apos;+-*/&apos;: stack.append(token) else: if len(stack) != 0: num1 = stack.pop() num2 = stack.pop() num3 = int(eval(str(num2) + token + str(num1))) stack.append(num3) return stack[0] Leetcode 191 位1的个数 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。提示：请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。示例 1：输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。示例 2：输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。示例 3：输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。提示：输入必须是长度为 32 的 二进制串 。 1234567891011121314代码：class Solution {public: int hammingWeight(uint32_t n) { int res = 0; while (n &gt; 0) { if (n &amp; 1 == 1) { ++res; } n /= 2; } return res; }}; Leetcode 461 Hamming Distance Leetcode 709 To Lower Case Leetcode 771 Jewels and Stones Leetcode 804 Unique Morse Code Words Circle Leetcode 832 Flipping an Image MEDIUM Leetcode 12 int2roman Leetcode 21 merge2sortedlist Leetcode 22 generateParentheses Leetcode 29 DivideTwoIntegers Leetcode 33 SearchInRotatedSortedArray Leetcode 34 FindFirstAndLastPositionInSortedArray Leetcode 36 SearchInRotatedSortedArray Leetcode 341 扁平化嵌套列表迭代器 问题描述：给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。示例 1:输入: [[1,1],2,[1,1]]输出: [1,1,2,1,1]解释: 通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。示例 2:输入: [1,[4,[6]]]输出: [1,4,6]解释: 通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,4,6]。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657代码：/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger { * public: * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector&lt;NestedInteger&gt; &amp;getList() const; * }; */class NestedIterator {public: NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) { Hello(nestedList); } void Hello(vector&lt;NestedInteger&gt; &amp;nestedList) { for (int i = 0; i &lt; nestedList.size(); i++) { if (nestedList[i].isInteger()) { nestedList_.push_back(nestedList[i].getInteger()); continue; } else { Hello(nestedList[i].getList()); } } } int next() { return nestedList_[count++]; } bool hasNext() { if (count &lt; nestedList_.size()) { return true; } else { return false; } }private: vector&lt;int&gt; nestedList_; int count = 0;};/** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i(nestedList); * while (i.hasNext()) cout &lt;&lt; i.next(); */ Leetcode 516 LongestPalindSubstring 回旋镖的数量 给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。回旋镖 是由点 (i, j, k) 表示的元组 ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。返回平面上所有回旋镖的数量。示例 1：输入：points = [[0,0],[1,0],[2,0]]输出：2解释：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]示例 2：输入：points = [[1,1],[2,2],[3,3]]输出：2示例 3：输入：points = [[1,1]]输出：0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 class Solution1 {public: int numberOfBoomerangs(vector&lt;vector&lt;int&gt;&gt;&amp; points) { int ans = 0; for (auto&amp; p : points) { unordered_map&lt;int, int&gt; cnt; for (auto&amp; q : points) { int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]); ++cnt[dis]; } for (auto&amp; [_, m] : cnt) { ans += m * (m - 1); } } return ans; }};class Solution {public: int CalculateDistance(vector&lt;int&gt; pointX, vector&lt;int&gt; pointY) { return (pointX[0] - pointY[0]) * (pointX[0] - pointY[0]) + (pointX[1] - pointY[1]) * (pointX[1] - pointY[1]); } int CountHuixuanbiao(vector&lt;tuple&lt;int, int, int&gt;&gt;&amp; distanceTuple) { auto totalCount = 0; auto lastCount = 1; auto currentCount = 0; int lastDistance; for (auto i = distanceTuple.begin(); i != distanceTuple.end(); ++i) { auto x = get&lt;0&gt;(*i); auto y = get&lt;1&gt;(*i); auto z = get&lt;2&gt;(*i); if (currentCount++ == 0) { lastDistance = z; continue; } if (z == lastDistance) { // equal lastCount++; if (i == distanceTuple.end() - 1) { totalCount += lastCount * (lastCount - 1); } continue; } else { // not equal lastDistance = z; if (lastCount == 1) { continue; } else { totalCount += lastCount * (lastCount - 1); lastCount = 1; lastDistance = z; } } } return totalCount; } int numberOfBoomerangs(vector&lt;vector&lt;int&gt;&gt;&amp; points) { if (points.empty()) { return 0; } else if (points[0].empty()) { return 0; } int pointSize = points.size(); auto totalCount = 0; for (auto i = 0; i &lt; pointSize; i++) { vector&lt;tuple&lt;int, int, int&gt;&gt; distanceTuple; for (auto j = 0; j &lt; pointSize; j++) { if (i != j) { distanceTuple.emplace_back(i, j, CalculateDistance(points[i], points[j])); } } //printf(&quot;\\n&quot;); sort(distanceTuple.begin(), distanceTuple.end(), [](const tuple&lt;int, int, int&gt;&amp; a, const tuple&lt;int, int, int&gt;&amp; b) -&gt; bool {return get&lt;2&gt;(a) &lt; get&lt;2&gt;(b); }); totalCount += CountHuixuanbiao(distanceTuple); //for (auto [x, y, z] : distanceTuple) { // cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; z &lt;&lt; &quot; &quot; &lt;&lt; totalCount &lt;&lt; endl; //} } return totalCount; }}; HARD Leetcode 23 mergeKsortedlists","link":"/2018/07/30/ckwasv94t000ev45c5ge6rvkx/"},{"title":"常用排序算法（python）","text":"常用排序算法（python） 冒泡排序1234567def bubbleSort(alist): for i in range(len(alist)): for j in range(len(alist)-i-1): if alist[j]&gt;alist[j+1]: tmp = alist[j] alist[j] = alist[j+1] alist[j+1] = tmp 选择排序123456789def selectSort(alist): for i in range(len(alist)): minPos = i for j in range(i+1, len(alist)): if alist[i]&gt;alist[j]: minPos = j tmp = alist[i] alist[i] = alist[minPos] alist[minPos] = tmp 插入排序12345678def insertSort(alist): for i in range(1, len(alist)): current = alist[i] pos = i while pos&gt;0 and current&lt;alist[pos-1]: alist[pos] = alist[pos-1] pos-=1 alist[pos] = current 希尔排序1234567891011def shellSort(alist): gap = len(alist)//2 while gap&gt;0: for i in range(gap, len(alist)): j = i current = alist[i] while j-gap&gt;0 and current&lt;alist[j-gap]: alist[j] = alist[j-gap] j = j - gap alist[j] = current gap = gap // 2 归并排序1234567891011121314151617181920212223242526def mergeSort(alist): if len(alist)&gt;1: mid = len(alist) // 2 left = alist[:mid] right = alist[mid:] mergeSort(left) mergeSort(right) i,j,k = 0,0,0 while i&lt;len(left) and j&lt;len(right): if left[i]&lt;right[j]: alist[k] = left[i] i+=1 else: alist[k] = right[j] j+=1 k+=1 while i&lt;len(left): alist[k] = left[i] k+=1 i+=1 while j&lt;len(right): alist[k] = right[j] k+=1 j+=1 快速排序1234567891011121314151617181920212223242526272829def quickSort(alist): quickSortHelper(alist, 0, len(alist)-1)def quickSortHelper(alist, first, last): if first&lt;last: splitpoint = partition(alist, first, last) quickSortHelper(alist, first, splitpoint-1) quickSortHelper(alist, splitpoint + 1, last)def partition(alist, first, last): pivot = alist[first] leftmark = first + 1 rightmark = last done = False while not done: while leftmark &lt;= rightmark and alist[leftmark] &lt;= pivot: leftmark += 1 while rightmark &gt;= leftmark and alist[rightmark] &gt;= pivot: rightmark -= 1 if rightmark &lt; leftmark: done = True else: tmp = alist[leftmark] alist[leftmark] = alist[rightmark] alist[rightmark] = tmp tmp = alist[first] alist[first] = alist[rightmark] alist[rightmark] = tmp return rightmark","link":"/2019/04/19/ckwasv9560011v45cpu1p6utb/"},{"title":"Water Filling Algorithm and Matlab Simulation","text":"注水算法是根据某种准则，并根据信道状况对发送功率进行自适应分配，通常是信道状况好的时刻，多分配功率，信道差的时候，少分配功率，从而最大化传输速率。当接收端完全已知CSI（信道状态信息）而发送端未知CSI时，发送天线阵列中的功率平均分配是合理的。 实现功率的“注水”分配，发送端必须知道CSI。 直观而言，就如下图所示： 图1 注水原理示意图（白色平台越高代表信道条件越差，注入的水就越少） 注水原理可以建模为下述优化问题： \\begin{align} & \\underset{P_1,P_2,...,P_N}{\\mathop{\\max }}\\,\\text{ }{C_{sum}}=\\sum_{n=1}^{N}{\\log \\left( 1+\\frac{P_n{\\left| {h_n} \\right|}^2}{N_0} \\right)} \\\\ & \\text{subject to }\\sum_{n=1}^{N}{P_n}={P}_{sum},n=1,2,...,N \\ \\end{align}其中${C}_{sum}$表示系统总信道容量，$N$为信道数，${P}_{n}$为第$n$个信道的功率，${h}_{n}$为第$n$个信道的信道增益，${N}_{0}$为噪声功率谱密度，${P}_{sum}$为传输总功率，也就是总水量。 该优化问题为凸优化问题，可以用拉格朗日乘数法求得全局最优解。 \\mathcal{L}(\\lambda ,{P_1},{P_2},...,{P_N})=\\sum_{n=1}^{N}{\\log \\left( 1+\\frac{P_n{\\left| {h_n} \\right|}^2}{N_0} \\right)}+\\lambda (\\sum_{n=1}^{N}{P_n}-P_{sum})令$\\frac{\\partial \\mathcal{L} }{\\partial P_n}=\\frac{\\partial \\mathcal{L} }{\\partial \\lambda }=0$，解得最优功率分配方案为： P_{n}^{*}={\\left( \\frac{1}{\\lambda }-\\frac{N_0}{\\left| {h}_{n} \\right|}^{2} \\right)}^{+}其中${(\\centerdot )}^{+}$表示取值非负。 MATLAB实现 1234567891011121314151617181920212223242526272829303132333435363738394041clear all;channel_n=10; %channel numberM=[5,10,20,50]; %transmitted powerN0=0.5; h_1= random(&apos;rayleigh&apos;,1,1,channel_n); %Rayleigh fadingh_2=h_1.^2; %|h|.^2h_2_sorted=sort(h_2); %sort the channel gainh=h_2_sorted/N0; syms lamdafor m=1:length(M) fprintf(&apos;transmitted power is %d watt&apos;,M(m)); for k=1:channel_n p=zeros(1,channel_n); sum=0; for i=k:channel_n sum=sum+(1/lamda-1/h(i)); end f=sum-M(m); x=solve(f,lamda); %find lamda if k==1 if vpa(x)&gt;0 &amp;&amp; vpa(x)&lt;h(k) for i=k:channel_n p(i)=1/x-1/h(i); %allocate power capacity=capacity+log2(1+p(i)*h(i));%compute the capacity end p(i)=vpa(p(i),3) capacity=vpa(capacity,3) end else if vpa(x)&gt;h(k-1) &amp;&amp; vpa(x)&lt;h(k) capacity=0; for i=k:channel_n p(i)=1/x-1/h(i); %allocate power capacity=capacity+log2(1+p(i)*h(i)); %compute the capacity end p(i)=vpa(p(i),3) capacity=vpa(capacity,3) end end endend","link":"/2018/07/18/ckwasv94w000jv45c7a4j6wj3/"},{"title":"LeetCode Single Week Contest 264","text":"做出来两道题，排名1557 / 4658 2047. 句子中的有效单词数 [EASY]句子仅由小写字母（’a’ 到 ‘z’）、数字（’0’ 到 ‘9’）、连字符（’-‘）、标点符号（’!’、’.’ 和 ‘,’）以及空格（’ ‘）组成。每个句子可以根据空格分解成 一个或者多个 token ，这些 token 之间由一个或者多个空格 ‘ ‘ 分隔。 如果一个 token 同时满足下述条件，则认为这个 token 是一个有效单词： 仅由小写字母、连字符和/或标点（不含数字）。 至多一个 连字符 ‘-‘ 。如果存在，连字符两侧应当都存在小写字母（”a-b” 是一个有效单词，但 “-ab” 和 “ab-“ 不是有效单词）。 至多一个 标点符号。如果存在，标点符号应当位于 token 的 末尾 。 这里给出几个有效单词的例子：”a-b.”、”afad”、”ba-c”、”a!” 和 “!” 。 给你一个字符串 sentence ，请你找出并返回 sentence 中 有效单词的数目 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* 审题：没啥好说的，就是注意各种情况，自己需要构造一些测试用例比如&quot;a-!&quot;等*/class Solution {public: bool isValidWord(const string&amp; word) { if (word.empty()) { return false; } for (size_t i = 0; i &lt; word.size(); i++) { if (word[i] - &apos;a&apos; &gt;=0 &amp;&amp; word[i] - &apos;a&apos; &lt; 26) { // go on } else if (word[i] == &apos;-&apos;) { if (symbolShowed || i == 0 || i == word.size() - 1) { return false; } else { symbolShowed = true; } } else if (word[i] == &apos;!&apos; || word[i] == &apos;.&apos; || word[i] == &apos;,&apos;) { if (i == word.size() - 1) { if (word.size() == 1 || word.size() &gt; 1 &amp;&amp; word[word.size() - 2] != &apos;-&apos;) { return true; } else { return false; } } return false;; } else { // other symbols return false; } } return true; } int countValidWords(string sentence) { int strLen = sentence.size(); int start = 0; int result = 0; for (int i = 0; i &lt; strLen; i++) { if (sentence[i] == &apos; &apos; || i == strLen - 1) { int count; if (sentence[i] == &apos; &apos;) { count = i - start; } else if (i == strLen - 1) { count = i - start + 1; } string word = sentence.substr(start, count); result += static_cast&lt;int&gt;(isValidWord(word)); start = i + 1; } } return result; }}; 2048. 下一个更大的数值平衡数 [MEDIUM]如果整数 x 满足：对于每个数位 d ，这个数位 恰好 在 x 中出现 d 次。那么整数 x 就是一个 数值平衡数 。 给你一个整数 n ，请你返回 严格大于 n 的 最小数值平衡数 。 示例 1：输入：n = 1输出：22解释：22 是一个数值平衡数，因为： 数字 2 出现 2 次这也是严格大于 1 的最小数值平衡数。 示例 2：输入：n = 1000输出：1333解释：1333 是一个数值平衡数，因为： 数字 1 出现 1 次。 数字 3 出现 3 次。这也是严格大于 1000 的最小数值平衡数。注意，1022 不能作为本输入的答案，因为数字 0 的出现次数超过了 0 。 示例 3：输入：n = 3000输出：3133解释：3133 是一个数值平衡数，因为： 数字 1 出现 1 次。 数字 3 出现 3 次。这也是严格大于 3000 的最小数值平衡数。 提示：0 &lt;= n &lt;= 10612345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/*审题：这题不会暴力法先提交了一次，没过！然后想貌似可以取巧，反正数字也不多，存到vector里查找就可以了，确实可以看评论说暴力也能过，原来是因为我用的map（yydlj）*/// 暴力#include &lt;vector&gt;class Solution {public: bool isBeautifulNumber(int number) { vector&lt;int&gt; bitCount(10, 0); while (number &gt; 0) { int res = number % 10; bitCount[res]++; number /= 10; } for (int i = 0; i &lt; 10; i++) { if (bitCount[i] &amp;&amp; bitCount[i] != i) { return false; } } return true; } int nextBeautifulNumber(int n) { int number = n + 1; while (!isBeautifulNumber(number)) { ++number; } return number; }};// 打表#include &lt;unordered_map&gt;class Solution {public: bool isBeautifulNumber(int number) { unordered_map&lt;int, int&gt; bitCount; while (number &gt; 0) { int res = number % 10; bitCount[res]++; number /= 10; } for (auto&amp; i : bitCount) { if (i.first != i.second) { return false; } } return true; } int nextBeautifulNumber(int n) { int number = n + 1; vector&lt;int&gt; allLists = {1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, 212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444}; auto item = std::lower_bound(allLists.begin(), allLists.end(), number); return *item; }}; 2049. 统计最高分的节点数目 [MEDIUM]给你一棵根节点为 0 的 二叉树 ，它总共有 n 个节点，节点编号为 0 到 n - 1 。同时给你一个下标从 0 开始的整数数组 parents 表示这棵树，其中 parents[i] 是节点 i 的父节点。由于节点 0 是根，所以 parents[0] == -1 。 一个子树的 大小 为这个子树内节点的数目。每个节点都有一个与之关联的 分数 。求出某个节点分数的方法是，将这个节点和与它相连的边全部 删除 ，剩余部分是若干个 非空 子树，这个节点的 分数 为所有这些子树 大小的乘积 。 请你返回有 最高得分 节点的 数目 。 示例 1: 输入：parents = [-1,2,0,2,0]输出：3解释： 节点 0 的分数为：3 * 1 = 3 节点 1 的分数为：4 = 4 节点 2 的分数为：1 1 2 = 2 节点 3 的分数为：4 = 4 节点 4 的分数为：4 = 4最高得分为 4 ，有三个节点得分为 4 （分别是节点 1，3 和 4 ）。 示例 2： 输入：parents = [-1,2,0]输出：2解释： 节点 0 的分数为：2 = 2 节点 1 的分数为：2 = 2 节点 2 的分数为：1 * 1 = 1最高分数为 2 ，有两个节点分数为 2 （分别为节点 0 和 1 ）。 提示： n == parents.length 2 &lt;= n &lt;= 105 parents[0] == -1 对于 i != 0 ，有 0 &lt;= parents[i] &lt;= n - 1 parents 表示一棵二叉树。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758审题：看到题目理解了好久，想着要不要建树，但感觉又想到了不建的方法，但是要递归遍历好多次vector，纠结着就放弃了大神解题思路：在这里我们可以把这棵二叉树树看成一个无向图，在这个图中，我们删除一个节点，最多形成 33个连通分量， 即* 左子树（如果存在）* 右子树（如果存在） 除了 自身和两棵子树的其他部分（如果存在）1. 先使用 dfs 初始化出以各个节点为根节点的子树所包含的节点总数。2. 接着我们开始遍历每一个删除的节点， 求出删除此节点后剩余三部分各自的节点数量， 最后对三者做乘积，结果就是这个节点的分数。Tips： 在求解分数的过程中，可能会超出32位，所以我们应该开long long;class Solution {public: vector&lt;vector&lt;int&gt;&gt; child; vector&lt;int&gt; childTreeNums; long long ans = INT_MIN; int len, sum, ret = 0; int countHighestScoreNodes(vector&lt;int&gt;&amp; parents) { len = parents.size(); child = vector&lt;vector&lt;int&gt;&gt;(len); childTreeNums = vector&lt;int&gt;(len,0); //保存孩子节点 for(int i = 0; i &lt; len; ++i) if(parents[i] != -1) child[parents[i]].push_back(i); dfs(0); //节点总数 sum = childTreeNums[0]; //获得等于最大值的最大数目 for(int i = 0; i &lt; len; i++) { long long temp = getScore(i); if(temp &gt; ans){ ret = 1; ans = temp; }else if(temp == ans) ret++; } return ret; } //获得所有子树的值 int dfs(int root){ if(not child[root].size()) return (childTreeNums[root] = 1); for(int i = 0; i &lt; child[root].size(); i++) childTreeNums[root] += dfs(child[root][i]); return ++childTreeNums[root]; } //得出删去item节点的分数，注意要开Long long long long getScore(int item){ long long score = 1; score = childTreeNums[0] - childTreeNums[item] == 0 ? 1 : childTreeNums[0] - childTreeNums[item]; for(int i = 0; i &lt; child[item].size(); i++) score *= childTreeNums[child[item][i]]; return score; }};作者：Tanyf链接：https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/solution/tan-tan-zhu-code-shuang-bai-c-shen-sou-j-gi7s/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2050. 并行课程 III [HARD]给你一个整数 n ，表示有 n 节课，课程编号从 1 到 n 。同时给你一个二维整数数组 relations ，其中 relations[j] = [prevCoursej, nextCoursej] ，表示课程 prevCoursej 必须在课程 nextCoursej 之前 完成（先修课的关系）。同时给你一个下标从 0 开始的整数数组 time ，其中 time[i] 表示完成第 (i+1) 门课程需要花费的 月份 数。 请你根据以下规则算出完成所有课程所需要的 最少 月份数： 如果一门课的所有先修课都已经完成，你可以在 任意 时间开始这门课程。你可以 同时 上 任意门课程 。请你返回完成所有课程所需要的 最少 月份数。 注意：测试数据保证一定可以完成所有课程（也就是先修课的关系构成一个有向无环图）。 示例 1:输入：n = 3, relations = [[1,3],[2,3]], time = [3,2,5]输出：8解释：上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。你可以在月份 0 同时开始课程 1 和 2 。课程 1 花费 3 个月，课程 2 花费 2 个月。所以，最早开始课程 3 的时间是月份 3 ，完成所有课程所需时间为 3 + 5 = 8 个月。 示例 2：输入：n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5]输出：12解释：上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。你可以在月份 0 同时开始课程 1 ，2 和 3 。在月份 1，2 和 3 分别完成这三门课程。课程 4 需在课程 3 之后开始，也就是 3 个月后。课程 4 在 3 + 4 = 7 月完成。课程 5 需在课程 1，2，3 和 4 之后开始，也就是在 max(1,2,3,7) = 7 月开始。所以完成所有课程所需的最少时间为 7 + 5 = 12 个月。 提示： 1 &lt;= n &lt;= 5 * 104 0 &lt;= relations.length &lt;= min(n (n - 1) / 2, 5 104) relations[j].length == 2 1 &lt;= prevCoursej, nextCoursej &lt;= nprevCoursej != nextCoursej 所有的先修课程对 [prevCoursej, nextCoursej] 都是 互不相同 的。 time.length == n 1 &lt;= time[i] &lt;= 104 先修课程图是一个有向无环图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748审题：排序后，合并区间比如[3,4], [4,5]先合成[3,5]，然后分层级取每层最大值，比如例2分3层，1,2,3为一层，最大值为3，4为第二层，最大值为4，5为第三层，最大值为5，加起来12。但是合并已经比较麻烦，分层也很难，比如遇到两个区间，[1, 2, 4]和[2, 3, 4]，需要继续合并，然后成为[1,2,3,4]，还是有点难看到新概念**DAG图**，**拓扑排序**，就是上面审题里的合并分层了（扶额，还是太菜了）- 在图论中，如果一个有向图从任意顶点出发无法经过若干条边回到该点，则这个图是一个有向无环图（DAG, Directed Acyclic Graph）。- 拓扑排序有向无环图的拓扑排序为所有边的起点都出现在其终点之前的排序。能构成拓扑排序的图一定没有环，因为环中的一条边必定从排序较后的顶点指向比其排序更前的顶点。基于此，拓扑排序可以被用来定义有向无环图：当且仅当一个有向图有拓扑排序，它是有向无环图。一般情况下，拓扑排序并非唯一。有向无环图仅仅在存在一条路径可以包含其所有顶点的情况下，有唯一的拓扑排序方式，这时，拓扑排序与它们在这条路径中出现的顺序相同。大神题解：https://leetcode-cn.com/problems/parallel-courses-iii/solution/tuo-bu-pai-xu-dong-tai-gui-hua-by-dutsc-7yei/https://leetcode-cn.com/problems/parallel-courses-iii/solution/tan-tan-zhu-code-cban-zi-ti-tuo-bu-pai-x-oav4/class Solution {public: int ans = INT_MIN; int minimumTime(int n, vector&lt;vector&lt;int&gt;&gt;&amp; relations, vector&lt;int&gt;&amp; time) { queue&lt;int&gt; q; //拓扑排序所用到的队列 vector&lt;int&gt; dp(n+1, INT_MIN); //dp数组 vector&lt;int&gt; degree(n+1,0); //每个节点的入度 vector&lt;vector&lt;int&gt;&gt; edges(n+1); //邻接表 //初始化邻接表矩阵和每个点的入度 for(auto relation : relations){ edges[relation[0]].push_back(relation[1]); degree[relation[1]]++; } //初始化队列 for(int i = 1; i &lt;= n; i++) { if(not degree[i]) { q.push(i); dp[i] = time[i-1]; ans = max(ans, time[i-1]); } } //拓扑排序 while(not q.empty()){ int curNode = q.front(); q.pop(); for(auto next : edges[curNode]){ degree[next]--; dp[next] = max(dp[next], dp[curNode] + time[next-1]); //每次更新时间长度 if(degree[next] == 0) q.push(next); ans = max(ans, dp[next]); } } return ans; }};","link":"/2021/10/24/ckwasv950000qv45cpr0jcopr/"},{"title":"LeetCode Week Contest 262","text":"第一次参加leetcode周赛，做出来两道题，排名2124 / 4260 2032. 至少在两个数组中出现的值给你三个整数数组 nums1、nums2 和 nums3 ，请你构造并返回一个 不同 数组，且由 至少 在 两个 数组中出现的所有值组成。数组中的元素可以按 任意 顺序排列。 示例 1： 输入：nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3]输出：[3,2]解释：至少在两个数组中出现的所有值为： 3 ，在全部三个数组中都出现过。 2 ，在数组 nums1 和 nums2 中出现过。示例 2： 输入：nums1 = [3,1], nums2 = [2,3], nums3 = [1,2]输出：[2,3,1]解释：至少在两个数组中出现的所有值为： 2 ，在数组 nums2 和 nums3 中出现过。 3 ，在数组 nums1 和 nums2 中出现过。 1 ，在数组 nums1 和 nums3 中出现过。示例 3： 输入：nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5]输出：[]解释：不存在至少在两个数组中出现的值。 1 &lt;= nums1.length, nums2.length, nums3.length &lt;= 1001 &lt;= nums1[i], nums2[j], nums3[k] &lt;= 100 123456789101112131415161718192021222324252627282930313233/* 审题：由于数字范围为1到100，那我先将三个数组压入三个不同的hash表，然后遍历1到100，用O(3)的复杂度判断该数字是否在三个hash表中，把结果累加输出，总复杂度是O(n1 + n2 + n3 + 3 * 100)*/vector&lt;int&gt; twoOutOfThree(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3) { unordered_map&lt;int, int&gt; numMap1; unordered_map&lt;int, int&gt; numMap2; unordered_map&lt;int, int&gt; numMap3; for (auto i = 0; i &lt; nums1.size(); i++) { auto num = nums1[i]; numMap1[num]++; } for (auto i = 0; i &lt; nums2.size(); i++) { auto num = nums2[i]; numMap2[num]++; } for (auto i = 0; i &lt; nums3.size(); i++) { auto num = nums3[i]; numMap3[num]++; } vector&lt;int&gt; result; for (int i = 1; i &lt;= 100; i++) { int numCount = 0; numCount += static_cast&lt;bool&gt;(numMap1.count(i)) + static_cast&lt;bool&gt;(numMap2.count(i)) + static_cast&lt;bool&gt;(numMap3.count(i)); if (numCount &gt; 1) { result.push_back(i); } } return result;} 2033. 获取单值网格的最小操作数给你一个大小为 m x n 的二维整数网格 grid 和一个整数 x 。每一次操作，你可以对 grid 中的任一元素 加 x 或 减 x 。 单值网格 是全部元素都相等的网格。 返回使网格化为单值网格所需的 最小 操作数。如果不能，返回 -1 。 示例 1： 输入：grid = [[2,4],[6,8]], x = 2输出：4解释：可以执行下述操作使所有元素都等于 4 ： 2 加 x 一次。 6 减 x 一次。 8 减 x 两次。共计 4 次操作。示例 2： 输入：grid = [[1,5],[2,3]], x = 1输出：5解释：可以使所有元素都等于 3 。示例 3： 输入：grid = [[1,2],[3,4]], x = 2输出：-1解释：无法使所有元素相等。 提示： m == grid.lengthn == grid[i].length1 &lt;= m, n &lt;= 1051 &lt;= m * n &lt;= 1051 &lt;= x, grid[i][j] &lt;= 104 1234567891011121314151617181920212223242526272829/*审题：这题不会看了解析，取中位数，然后遍历所有元素做差看是否能整除x*/int minOperations(vector&lt;vector&lt;int&gt;&gt;&amp; grd, int x) { int n = grd.size(); int m = grd[0].size(); vector&lt;int&gt; cnt(n * m); int index = 0; for(int i = 0; i &lt; n; i ++){ for(int j = 0; j &lt; m; j ++){ cnt[index++] = grd[i][j]; } } sort(cnt.begin(), cnt.end()); int t = cnt.size()/ 2; int res = 0; for(int i = 0; i &lt; cnt.size(); i ++){ if(cnt[i] != cnt[t]) { int k = abs(cnt[i] - cnt[t]); if(k % x == 0) { res += k / x; } else return -1; } } return res;}","link":"/2021/10/10/ckwasv951000tv45cakpalb6b/"},{"title":"Introduction to Machine Learning","text":"做了与机器学习相关的项目好久了，但对机器学习一直没有一个系统的认识，导致在切入一些新的领域时力有不逮，总感觉理解有偏差或者理解困难，因此想系统地、详细地学习机器学习，就从周志华的西瓜书和Andrew Ng的机器学习视频开始吧。 众所周知， 机器学习是研究计算机怎样模拟或实现人类的学习行为，以获取新是研究计算机怎样模拟或实现人类的学习行为。 来自卡内基梅隆大学的Tom Mitchell提出的关于机器学习的定义较为人所接受，他定义的机器学习是，一个程序被认为能从经验E中学习，解决任务T，达到性能度量值P，当且仅当，有了经验E后，经过P评判，程序在处理T时的性能有所提升。 一般而言，我把机器学习分为监督学习、无监督学习和增强学习，而深度学习和大数据是拓展也是紧密的关联，如下图所示： 监督学习，顾名思义，就是有人指导你，告诉你这个学习正确与否。专业点来讲，就是数据集中每个样本都会带有一个正确答案，比如在西瓜分类里，“红瓤，有蒂”带有标签“甜”，“黄瓤，无蒂”带有标签“不甜”；在回归里，房价预测里每个样本都带有房价。分类和回归的区别在于预测的是一组离散的结果，而回归可以预测连续的输出。 无监督学习，从上图可以看出，我们事先不知道样本是哪一类或者是哪一个值，也就是没有任何的标签或“答案”。一个比较著名的例子就是鸡尾酒宴问题：许多人坐在一起参加鸡尾酒会，大家都在同一时间说话，声音此起彼伏，重重叠叠，要想分离出不同人说话的声音，就是一个聚类问题，也是无监督学习问题。这个例子可能比较难懂，再说一个就是在无线通信中，有时会根据用户的行为特征对用户进行分类，便于进行一些资源的调度和统一管理，而如何判断一堆用户里哪些用户是类似的，比如上班族、学生党、旅客等，这就是一个典型的聚类问题。 增强学习则是要解决这样的问题，一个能感知环境的自治agent，怎样通过学习选择能达到其目标的最优动作。当agent（机器人，下棋，在无线领域则可以是用户、基站和operator）在环境中作出某个动作时，会产生不同的奖励值或者惩罚值，agent的任务就是从这个非直接的，有延迟的回报中学习，以便后续的动作产生最大的累积效应。 在后续的文章中，我们会对各个算法有比较详细的学习过程，敬请期待啦。","link":"/2018/11/28/ckwasv94r000av45c6ctg0o6y/"},{"title":"","text":"在primal simplex算法中，每轮迭代都需要选择most candidate的方向并移动到邻近的顶点上，那么，用什么来评估方向的好坏呢？我们知道，选择一个方向走下去对目标值的改善程度是由方向和步长决定的，对于标准型的线性规划问题而言，使目标值下降的方向是reduced cost $d_j &lt;= 0$的那些非基变量，理论上来说，任意一个满足$d_j &lt;= 0$条件的非基变量都可以作为入基，但是我们不是那么随便的人，肯定不会随便选，那要如何选择呢？ 用一高一矮两个人来比喻，同样是走100步，你觉得是高的人走的远还是矮的人走得远呢（莫杠，正常场景）？同理，我这里当然是选择单位步长下能走更远的非基变量，当然，步长也是决定你能走多远的重要因素，这里暂且不论，就考虑最基本的dantzig的选基算法，即 q\\in \\underset{j\\in N}{\\argmin} \\bar{z}_j选入基的法则非常简单对不对，那么假设你处在某一次迭代中，想要计算所有非基变量的reduced cost $d_j, j\\in N$，难道需要用reduced cost的计算公式每次计算？ \\bar{z}_N = c_N - N^TB^{-T}c_B显然大家不会那么傻，就跟revised simplex的$B^{-1}$更新一样，两次迭代间的reduced cost也是有关联关系的，接下来就给大家推导一下，不感兴趣的可以直接跳到结论了哈。 对于一个genenal形式的LP问题： \\begin{aligned} \\min:& \\quad c^T x \\\\ s.t.:& \\quad a \\le Ax \\le b, \\\\ & \\quad l \\le x \\le u \\end{aligned}通过增加结构变量的形式可以转成一般形式的LP问题： \\begin{aligned} \\min:& \\quad c^T x \\\\ s.t.:& \\quad Ax = b, \\\\ & \\quad l \\le x \\le u \\end{aligned}注意到当前的$x$包含原始变量和结构变量，记为$x_c$和$x_r$。 假设primal feasible，由对偶问题性质$Ay+s=c$，那么对于任意迭代时刻，都有如下条件满足 \\begin{cases} B x_B + s_B = c_B \\\\ N x_N + s_N = c_N \\\\ s_B = 0 \\end{cases}其中$s_B, s_N$分别为对应基矩阵和非基矩阵的reduced costs。","link":"/2021/06/22/ckwasv9560012v45ce41ug1vs/"},{"title":"常用数据结构——栈 (python)","text":"本科学过c++的数据结构了，但研究生转无线通信后就忘的差不多了，现在重新复习下栈。 栈（stack）、队列（queues）、双端队列（deques）和列表都是有序数据容器，元素添加后在容器内的位置跟其他元素添加和删除的顺序有关，像这样的容器被称作线性数据结构（linear data structure）。 栈可以想象为只有一端开口的瓶子，假设每放一个东西进去都会把前面放的完全盖住，那么这时你想取出最里面的东西显然是不可能的，所以你只能把上面的一个个拿出来才能取到你想要的，这就叫做后进先出（LIFO, last-in first-out）。 1. 栈的主要方法及实现 栈的方法主要有下面几种： Stack() creates a new stack that is empty. It needs no parameters and returns an empty stack. push(item) adds a new item to the top of the stack. It needs the item and returns nothing. pop() removes the top item from the stack. It needs no parameters and returns the item. The stack is modified. peek() returns the top item from the stack but does not remove it. It needs no parameters. The stack is not modified. isEmpty() tests to see whether the stack is empty. It needs no parameters and returns a boolean value. size() returns the number of items on the stack. It needs no parameters and returns an integer.在python中是没有栈的实现的，所以栈需要自己实现，简单点可以用个list充当下，更一般的要实现上面各种方法还是面向对象创造一个类比较好，实现代码如下所示：123456789101112131415161718class Stack: def __init__(self): self.items = [] def isEmpty(self): return self.items == [] def push(self, item): self.items.append(item) def pop(self): return self.items.pop() def peek(self): return self.items[len(self.items)-1] def size(self): return len(self.items) 2. 栈的主要应用2.1 字符串反转 那么，费尽心机创造一个栈有啥用呢？首先可以用来翻转字符串，当然python有超级多方式可以反转字符串，最简单的自然是string[::-1]。12345678def stringReverse(self, stringstring): s = Stack() output = &quot;&quot; for ss in stringstring: s.push(ss) while not s.isEmpty(): output = output + s.pop() return output 2.2 简单括号匹配 除此之外，还有简单的括号匹配问题，也可以利用栈的特性来解决：1234567891011121314151617181920def parChecker(symbolString): s = Stack() balanced = True index = 0 while index &lt; len(symbolString) and balanced: symbol = symbolString[index] if symbol == &quot;(&quot;: s.push(symbol) else: if s.isEmpty(): balanced = False else: s.pop() index = index + 1 if balanced and s.isEmpty(): return True else: return False 其实吧，也可以不用栈解决呀（不是我杠，笔试时间也是很重要的）123456789def parChecker(symbolString): left = 0 right = 0 for s in symbolString: if s == &apos;(&apos;: left+=1 else: right+=1 return left==right 2.3 多重括号匹配 拓展到更复杂一点的括号匹配问题——多重括号匹配：12345678910111213141516171819202122232425def parChecker(symbolString): s = Stack() balanced = True index = 0 while index &lt; len(symbolString) and balanced: symbol = symbolString[index] if symbol in &quot;([{&quot;: s.push(symbol) else: if s.isEmpty(): balanced = False else: top = s.pop() if not matches(top,symbol): balanced = False index = index + 1 if balanced and s.isEmpty(): return True else: return Falsedef matches(open,close): opens = &quot;([{&quot; closers = &quot;)]}&quot; return opens.index(open) == closers.index(close) 当然，我又“杠”了，主要不想想这么复杂的结构2333：12345678910111213141516def parChecker(symbolString): l1,l2,l3,r1,r2,r3=0,0,0,0,0,0 for s in symbolString: if s==&apos;{&apos;: l1+=1 elif s==&apos;}&apos;: r1+=1 elif s==&apos;(&apos;: l2+=1 elif s==&apos;)&apos;: r2+=1 elif s==&apos;[&apos;: l3+=1 else: r3+=1 return [l1,l2,l3]==[r1,r2,r3] 2.4 将十进制数转换为各种进制 想将10进制数（Decimal）转换为2进制（Binary）、8进制（Octal）或者16进制（Hexidecimal），就将这个数不断除进制数，然后将余数逆序输出，不想贴图了自己百度查下。1234567891011121314def baseConverter(decNumber,base): digits = &quot;0123456789ABCDEF&quot; remstack = Stack() while decNumber &gt; 0: rem = decNumber % base remstack.push(rem) decNumber = decNumber // base newString = &quot;&quot; while not remstack.isEmpty(): newString = newString + digits[remstack.pop()] return newString 2.5 中缀表达式、前后缀表达式 接下来就是栈的重点操作了（就是比较复杂一点）。 什么是中缀表达式呢？就是一般的表达式，比如A+B, C*D等。 顾名思义，前缀表达式就是操作符在前面，后缀就是在后面，给几个例子体会一下： Infix Expression Prefix Expression Postfix Expression A + B C + D + + A B C D A B C + D + (A + B) (C + D) + A B + C D A B + C D + A B + C D + A B C D A B C D + A + B + C + D + + + A B C D A B + C + D + 将中缀表达式转换为后缀表达式，利用栈可以写为：123456789101112131415161718192021222324252627282930def infixToPostfix(infixexpr): prec = {} prec[&quot;*&quot;] = 3 prec[&quot;/&quot;] = 3 prec[&quot;+&quot;] = 2 prec[&quot;-&quot;] = 2 prec[&quot;(&quot;] = 1 opStack = Stack() postfixList = [] tokenList = infixexpr.split() for token in tokenList: if token in &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; or token in &quot;0123456789&quot;: postfixList.append(token) elif token == &apos;(&apos;: opStack.push(token) elif token == &apos;)&apos;: topToken = opStack.pop() while topToken != &apos;(&apos;: postfixList.append(topToken) topToken = opStack.pop() else: while (not opStack.isEmpty()) and \\ (prec[opStack.peek()] &gt;= prec[token]): postfixList.append(opStack.pop()) opStack.push(token) while not opStack.isEmpty(): postfixList.append(opStack.pop()) return &quot; &quot;.join(postfixList) 假如直接给你一个后缀表达式让你计算呢，这就是需要再写一个算法了，不过比较简单，贴上来：1234567891011121314151617181920212223def postfixEval(postfixExpr): operandStack = Stack() tokenList = postfixExpr.split() for token in tokenList: if token in &quot;0123456789&quot;: operandStack.push(int(token)) else: operand2 = operandStack.pop() operand1 = operandStack.pop() result = doMath(token,operand1,operand2) operandStack.push(result) return operandStack.pop()def doMath(op, op1, op2): if op == &quot;*&quot;: return op1 * op2 elif op == &quot;/&quot;: return op1 / op2 elif op == &quot;+&quot;: return op1 + op2 else: return op1 - op2 栈就目前学完了，后续有的话还会补充。","link":"/2019/04/29/ckwasv9570013v45csar12lvv/"},{"title":"暑期实习招聘笔试题3月(更新ing)","text":"实习笔试试题，有些没投（准备好先），拿过来先看了看 12 头条笔试题1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;numeric&gt;using namespace std;int main(){ int N; cin&gt;&gt;N; for(int n=0;n&lt;N;++n){ int L, minVal, minPos; minVal = 1000; minPos = 0; cin&gt;&gt;L; vector&lt;int&gt; v(L, 0); for(int l=0;l&lt;L;l++){ cin&gt;&gt;v[l]; if(v[l]&lt;minVal){ minVal = v[l]; minPos = l; } } vector&lt;int&gt; reward(v.size(), 0); reward[minPos] = 1; for(int k=0;k&lt;L;k++){ int pos = k+minPos; if (pos&gt;=L){ pos = pos - L; } if(pos==0){ if(v[pos]&gt;v[L-1]) reward[pos] = reward[L-1]+1; else if(v[pos]==v[L-1]) reward[pos] = reward[L-1] - 1; else reward[pos]=reward[pos]; } else{ if(v[pos]&gt;v[pos-1]) reward[pos] = reward[pos-1]+1; else if(v[pos]==v[pos-1]) reward[pos] = reward[pos-1] - 1; else reward[pos]=reward[pos]; } } cout&lt;&lt;accumulate(reward.begin(),reward.end(),0)&lt;&lt;endl; } return 0;} 3 头条笔试题1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;numeric&gt;using namespace std;vector&lt;int&gt; zhaoqian(int N){ vector&lt;int&gt; v(4,0); N = 1024 - N; int value[4] = {64, 16, 4, 1}; for(int i=0;i&lt;(sizeof(value)/sizeof(value[0]));i++){ cout&lt;&lt;i&lt;&lt;endl; int a = N/value[i]; v[i] = a; N = N%value[i]; } return v;}int main(){ int N; cin&gt;&gt;N; vector&lt;int&gt; vv; vv = zhaoqian(N); cout&lt;&lt;accumulate(vv.begin(), vv.end(), 0)&lt;&lt;endl; return 0;} 4 招行笔试题题目描述：切不等高的蛋糕，蛋糕N份，每刀切平一部分，切下来的不得超过k份，整块蛋糕切平最少需要几刀，比如如下输入5 61 2 3 4 5提示：第一刀可以切到2，切下来刚好是6份，剩下蛋糕为1 2 2 2 2第二刀全切到1，最少需要2刀12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &lt;iostream&gt;#include &lt;numeric&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;list&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;int main(){ int N,k; cin&gt;&gt;N&gt;&gt;k; vector&lt;int&gt; v(N, 0); for(int l=0;l&lt;N;l++){ cin&gt;&gt;v[l]; } sort(v.begin(),v.end()); int minVal = v.front(); int maxVal = v.back(); int dao = 0; bool hello = false; int i = 0; while(i&lt;v.size()){ if(hello) i=0; if(minVal==maxVal) break; int sum = 0; bool flag = true; int minVal1=v[i]; for(int j=v.size()-1;j&gt;i;--j){ sum = sum+(v[j]-minVal1); if(sum&gt;k){ flag = false; break; } } if(flag){ dao++; hello = true; for(int g=v.size()-1;g&gt;i;g--){ v[g] = v[g]-(v[g]-minVal1); } } maxVal=v.back(); i++; } cout&lt;&lt;dao; return 0;}","link":"/2019/03/16/ckwasv9580014v45cjw0apmo7/"},{"title":"Linear Regression","text":"就从最简单的线性回归模型（Linear Regression model）开始学习吧。 从这个模型的名字我们可以看出，因变量和变量之间的关系是线性的，预测值可以通过计算输入特征的权重给出： \\hat{y} = \\theta_0+\\theta_1x_1+\\theta_2x_2+...+\\theta_nx_n其中，$\\hat{y}$是预测值，$n$是特征数量，$\\theta_0$是bias，$x_i$是第$i$个特征值，$\\theta_j$是第$j$个特征的模型参数。如果获取了模型的所有参数，给定一个样本我们就可以用上面这个公式模型得到预测值。 为了表达更简洁，一般用向量表示： \\hat{y} = h_{\\mathbf{\\theta}}(\\mathbf{x}) = \\mathbf{\\theta}^T \\mathbf{x}其中$h_{\\mathbf{\\theta}}()$是hypothesis function是关于$\\mathbf{\\theta}$的假设函数，$\\mathbf{\\theta} = [\\theta_0;\\theta_1;…;\\theta_n]$，$\\mathbf{x} = [x_0, x_1, x_2, …, x_n]$并且$x_0=1$。 我们的目标当然是想要所有预测值都跟实际值相等，因此，目标函数或者称代价函数建模为： \\text{MSE}(\\mathbf{X},h_{\\mathbf{\\theta}}) = \\frac{1}{m}\\sum_{i=1}^{m}\\left(\\mathbf{\\theta}^T\\cdot\\mathbf{x}^{(i)}-y^{(i)}\\right)^2其中$\\mathbf{X}$为所有样本的集合，数量为$m$。 标准闭式解 基于均方误差最小化来进行模型求解的方法称为“最小二乘法”（least square method）。在线性回归中，最小二乘法就是试图找到一条直线，使所有样本到直线上的欧氏距离之和最小。 一般地，我们利用最小二乘法对$\\mathbf{\\theta}$进行估计。数据集$\\mathbf{X}$表示为： \\mathbf{X}=\\left( \\begin{array}{ccc} 1 & x_{11} & x_{12} & \\cdots\\ & x_{1d}\\\\ 1 & x_{21} & x_{22} & \\cdots\\ & x_{23} \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\\\\ 1 & x_{m1} & x_{m2} & \\cdots\\ & x_{md}\\\\ \\end{array} \\right) =\\left( \\begin{array}{ccc} 1 & \\mathbf{x}_1^T \\\\ 1 & \\mathbf{x}_2^T \\\\ \\vdots & \\vdots \\\\ 1 & \\mathbf{x}_m^T \\\\ \\end{array} \\right) 然后把实际值也写成向量模式$\\mathbf{y}=(y_1;y_2;…;y_m)$，因此优化问题为： \\mathbf{\\theta}^*=\\underset{\\mathbf{\\theta}}{\\text{arg}\\min}(\\mathbf{y}-\\mathbf{\\theta}^T\\mathbf{X})^T(\\mathbf{y}-\\mathbf{\\theta}^T\\mathbf{X}) 令$E_{\\mathbf{\\theta}}=(\\mathbf{y}-\\mathbf{\\theta}^T\\mathbf{X})^T(\\mathbf{y}-\\mathbf{\\theta}^T\\mathbf{X})$，对$\\mathbf{\\theta}$求导可得： \\frac{\\partial E_{\\mathbf{\\theta}}}{\\partial \\mathbf{\\theta}}=2\\mathbf{X}^T(\\mathbf{\\theta}^T\\mathbf{X}-\\mathbf{y}) 令上式等于0可解得 \\mathbf{\\theta}^*=(\\mathbf{X}^T\\mathbf{X})^{-1}\\mathbf{X}^T\\mathbf{y} 如果$\\mathbf{X}^T\\mathbf{X}$不可逆怎么办，这可能是由于矩阵中存在冗余特征，在线性代数里说明矩阵并非线性不相关，因此可以删除多余特征；也有可能是由于特征数大于等于样本数，也就是$m \\le n$，可以通过删除一些特征或者使用正则化（regularization，后续介绍）。 给出python一个实现例子如下： 12345678910111213141516171819import numpy as np X = 2 * np.random.rand(100, 1)y = 2 + 6 * X + np.random.randn(100, 1)X_b = np.c_[np.ones((100, 1)), X] # add x0 = 1 to each instancetheta_best = np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(y)print(theta_best)# [[1.74568681] [6.27246194]]X_new = np.array([[0], [2]])X_new_b = np.c_[np.ones((2, 1)), X_new] # add x0 = 1 to each instancey_predict = X_new_b.dot(theta_best)print(y_predict) #[[ 1.74568681] [14.29061069]]plt.plot(X_new, y_predict, &quot;r-&quot;)plt.plot(X, y, &quot;b.&quot;)plt.axis([0, 2, 0, 15])plt.show() 如果用sklearn实现的话，代码如下：12345678&gt;&gt;&gt; from sklearn.linear_model import LinearRegression&gt;&gt;&gt; lin_reg = LinearRegression()&gt;&gt;&gt; lin_reg.fit(X, y)&gt;&gt;&gt; lin_reg.intercept_, lin_reg.coef_(array([ 4.21509616]), array([[ 2.77011339]]))&gt;&gt;&gt; lin_reg.predict(X_new)array([[ 4.21509616],[ 9.75532293]]) 这种方式实现的计算复杂度只要在矩阵求逆上，对于一个$n \\times n$的矩阵，求逆复杂度大约是$O(n^{2.4})$到$O(n^{3})$，当特征数量很大时（比如100,000以上时），标准闭式解会变得很慢；另一方面，对于样本数量其复杂度是$O(m)$，也就是线性的；此外，模型训练完成后，预测的复杂度对于样本数量和特征数量复杂度都很快。 梯度下降法 梯度下降法是十分常用的优化算法，目的是通过迭代过程不断更新参数进而最小化代价函数，每次优化的方向都是斜率绝对值最大的方向。Note： 需要谨慎选择步长（step size）或者叫做学习率（learning rate），太小的话，需要许多次迭代才能走到最优点，而步子太大，则有可能跨过最优点，然后陷入震荡。 凸优化问题找到最优点比较容易，而非凸问题则容易陷入局部最优点或者陷入平台（plateau)。线性回归问题是个凸优化问题。 最好在使用梯度下降法前对数据进行标准化处理，不然“碗”太长需要更多的迭代次数。 问题参数越多，维度越大，参数空间越大，搜索最优解也就越难。 Batch Gradient Descent Batch是批的意思，批梯度下降就是在每次迭代过程中把所有数据都来计算代价函数的偏导，也就是梯度。代价函数对于参数$\\theta_j$的偏导为： \\frac{\\partial \\text{MSE}(\\theta)}{\\partial{\\theta}_j}=\\frac{2}{m}\\sum_{i=1}^{m}\\left(\\theta^T \\cdot \\mathbf{x}^{(i)}-y^{(i)}\\right)x_j^{(i)} 用向量来表示梯度下降为： \\nabla_{\\theta}\\text{MSE}(\\theta)=\\left( \\begin{array}{ccc} \\frac{\\partial \\text{MSE}(\\theta)}{\\partial \\theta_0}\\\\ \\frac{\\partial \\text{MSE}(\\theta)}{\\partial \\theta_1}\\\\ \\vdots\\\\ \\frac{\\partial \\text{MSE}(\\theta)}{\\partial \\theta_0} \\end{array} \\right) =\\frac{2}{m}\\mathbf{X}^T\\cdot(\\mathbf{X}\\cdot \\theta-\\mathbf{y}) 由此，我们可以得到梯度下降的步骤： \\theta^{(n+1)} = \\theta^{(n)}-\\eta \\nabla_{\\theta}\\text{MSE}(\\theta) 推导出这个公式之后就可以实现了：1234567eta = 0.1 # learning raten_iterations = 1000m = 100theta = np.random.randn(2,1) # random initializationfor iteration in range(n_iterations): gradients = 2/m * X_b.T.dot(X_b.dot(theta) - y) theta = theta - eta * gradients Stochastic Gradient Descent 在前面讲过，BGD在每次迭代中是把所有数据都用于计算的，因此当数据量很大时，算法会变得难以忍受的慢，因此需要使用其他梯度下降算法。随机梯度下降法跟批梯度下降是两个极端，SGD在每次迭代中会随机从训练集中选择一个样本，然后只用这个样本计算并更新梯度。因此，这个算法计算比BGD快很多很多；但也由于其随机特性，优化曲线不会“直接”向着最优点前进，而是来回波动，但最终会抵达最优值附近。其算法如下图所示： Python实现如下：1234567891011121314n_epochs = 50t0, t1 = 5, 50 # learning schedule hyperparametersdef learning_schedule(t):return t0 / (t + t1)theta = np.random.randn(2,1) # random initializationfor epoch in range(n_epochs): for i in range(m): random_index = np.random.randint(m) xi = X_b[random_index:random_index+1] yi = y[random_index:random_index+1] gradients = 2 * xi.T.dot(xi.dot(theta) - yi) eta = learning_schedule(epoch * m + i) theta = theta - eta * gradientsprint(theta) 如果用sklearn来实现的话，代码就简单多了：1234from sklearn.linear_model import SGDRegressorsgd_reg = SGDRegressor(n_iter=50, penalty=None, eta0=0.1)sgd_reg.fit(X, y.ravel())print(sgd_reg.intercept_, sgd_reg.coef_) NOTE: epoch是指把所有数据样本都遍历一遍，iteration表示更新一次参数，batch则是指数据样本的大小，在SGD中，iteration=batch=1，epoch=num_X/batch Mini-batch Gradient Descent Mini-batch GD介于SGD和BGD之间，也就是每次用来更新参数的样本不是一也不是所有（吴恩达说在2-400之间，他倾向于用10），它吸收了BGD和SGD的优缺点的折中，收敛更快，随机性较小，但也难抵达最优值，其算法流程如下图所示： 这里介绍的标准闭式解只适用于线性回归问题，但梯度下降法可以用来训练许多模型，在深度学习中也有广泛应用，将他们比较如下： Algorithm Large m Out-of-core Support Large n Hyperparameters Scaling Required Sklearn Normal Equation Fast No Slow 0 No LinearRegression Batch GD Slow No Fast 2 Yes n/a Stochastic GD Fast Yes Fast $\\ge$2 Yes SGDRegressor Mini-batch GD Fast Yes Fast $\\ge $2 Yes n/a Polynomial Regression 如果数据并非一条直线呢，那么还可以用线性模型吗？实际上是可以的，主要方法就是把一个特征拓展成多维的，比如$x^2, x^3,…, x^k$，然后将其作为另一个维度的特征，比如$x_1 = x, x_2 = x^2$，那么就可以用线性模型按照上面的方法进行训练了，用sklearn实现如下： 1234567891011121314151617181920import numpy as npimport matplotlib.pyplot as pltfrom sklearn.preprocessing import PolynomialFeaturesfrom sklearn.linear_model import LinearRegressionm = 100X = 6 * np.random.rand(m, 1) - 3y = 1 * X**2 + X + 2 + np.random.randn(m, 1)plt.scatter(X, y)poly_features = PolynomialFeatures(degree=2, include_bias=False)X_poly = poly_features.fit_transform(X)lin_reg = LinearRegression()lin_reg.fit(X_poly, y)print(lin_reg.intercept_, lin_reg.coef_)xx = np.array((range(-3, 4)))print(xx)yy = xx*0.98134428+xx*xx*0.94365742+1.94555083plt.plot(xx, yy, c=&apos;r&apos;)plt.show() 此外，需要注意，PolynomialFeatures(degree=d)会把一个包含n个特征的矩阵转化为包含$\\frac{(n+d)!}{d!n!}$个特征的矩阵，即如果对于两个特征a和b，令degree=3，那么特征不仅有$a^2$，$a^3$，$b^2$，$b^3$，还会有$ab$，$a^2b$和$ab^2$.","link":"/2018/11/28/ckwasv94s000cv45ccn2cwuij/"},{"title":"How to Make a Visual Mark Up and Revision of Significant Differences between Two Latex Files by Latexdiff","text":"Recently my survey was rejected and required minor revision, while I have to submit a revised article with the “editing mode” feature turned on. Because I use Miktex+Texstudio to edit my paper in windows 10, Latexdiff is considered of course. Latexdiff is a Perl script for visual mark up and revision of significant differences between two LATEX files. Various options are available for visual mark up using standard LATEX packages such as color. Changes not di­rectly af­fect­ing vis­i­ble text, for ex­am­ple in for­mat­ting com­mands, are still marked in the LATEX source. A rudi­men­tary re­vi­sion fa­cilil­ity is pro­vided by an­other Perl script, la­texre­vise, which ac­cepts or re­jects all changes. Man­ual edit­ing of the dif­fer­ence file can be used to over­ride this de­fault be­haviour and ac­cept or re­ject se­lected changes only. Step 1:For a pure rookie, first of all, you need to install CTEX (for Chinese users) or Miktex. Step 2:Then, win+R and open cmd, input command latexdiff, if returns 12 and only 2 non-option arguments required. Write latexdiff -h to get help Congrats! You have successfully installed latexdiff and you can turn to Step 3.3. Step 3:Otherwise, don’t worry, I encountered the same situation as you. Do as follows. 3.1 Install Latexdiff PackageAfter you install a Tex, open Start Menu-&gt;Ctex or Miktex-&gt;Package Manager (Admin). Search Latexdiff in column Name: as follows Click the + button and install it. 3.2 Install PerlLatexdiff is a Perl script, so you can go to Perl download corresponding version in your computer. Technically, ActivePerl and StrawberryPerl is both ok. Same steps in Step 2, if you have problem as 12latexdiff: The Perl script could not be found. latexdiff: Data: scripts/latexdiff/perl/latexdiff.pl It’s a common problem and you can find the answer in 这里 or Here. It is worth mentioning that if you have the following problem which confused me for a long time 12latexmk: the script engine could not be found latexdiff: data: scriptengine=&quot;perl.exe&quot; Actually I have no idea how I successfully solve it. You may do the trials as what I have done. Check the System Path of Perl and Tex, especially according to x86 or x64 Reinstall Perl, if not work, change to ActivePerl or StrawberryPerl Restart your windows after you make some changes 3.3 LatexdiffPut your origin tex version (e.g., old.tex) and your modified tex version (e.g., new.tex) in a same file. cmd to this path, and input 1latexdiff old.tex new.tex &gt;diff.tex where diff.tex is the editted version, add the required files to this path and compile it. Then you can have the results If you encounter some errors in compiling, just google it because they are just some common LATEX errors. Enjoy. !!!Tips: if you suffer any problem, first go to google or baidu it. Please discover the truth by yourself.","link":"/2018/06/19/ckwasv94t000dv45cnpjaa07w/"},{"title":"A Stupid Mistake I Made about Sorting in Python DataFrame","text":"One day when I try to sort a DataFrame by a column, an amazing mistake happens!I will reproduce this stupid thing here. Firstly, make a dataframe example: 12345 a b c0 9 4 61 2 7 52 5 -3 83 1 2 3 123frame = pd.DataFrame({&quot;a&quot;:[9,2,5,1],&quot;b&quot;:[4,7,-3,2],&quot;c&quot;:[6,5,8,3]})frame.sort_values(&apos;a&apos;,inplace=True)print(frame) What do you think the result will be? What I expect it will get is like this: 12345 a b c3 1 2 31 2 7 52 5 -3 80 9 4 6 However, what I actually get is 12345 a b c0 9 4 61 2 7 52 5 -3 83 1 2 3 I get really confused, so I try all the arg in function DataFrame.sort_values(by, axis=0, ascending=True, inplace=False, kind=’quicksort’, na_position=’last’) I find out that only if the inplace= is set to True, the result is as expected. But the usage of this function I searched in google, did not meantion this parameter. Therefore, I look for an instruction of inplace， and I find that the inplace parameter is a generic term w.r.t pandas and not specific to sort_values alone. You can see it in several functions like pd.fillna, pd.replace etc. Whenever the inplace is set to True, it modifies the existing data frame and you need not assign it to a new data frame. Ohhhh… Then I find out where the mistake really lies in. In my previous code, the DataFrame frame I sorted has not been modified only if the parameter inplace is set to True, so I modify the code as follow: 123frame = pd.DataFrame({&quot;a&quot;:[9,2,5,1],&quot;b&quot;:[4,7,-3,2],&quot;c&quot;:[6,5,8,3]})df = frame.sort_values(&apos;a&apos;,inplace=True)print(df) The problem is solved! How stupid I was!","link":"/2018/06/12/ckwasv94g0001v45cizyyth84/"},{"title":"Hexo: setup a static blog","text":"​ Before we start, you have to know what is the difference between static site and dynamic site. Let’s take a look at the definition in Wiki: A static web page (sometimes called a flat page/stationary page) is a web page that is delivered to the user exactly as stored, in contrast to dynamic web pages which are generated by a web application. Consequently, a static web page displays the same information for all users, from all contexts, subject to modern capabilities of a web server to negotiate content-type or language of the document where such versions are available and the server is configured to do so. It’s pros and cons are listed as follows: Advantages of a static website Provide improved security over dynamic websites Improved performance for end users compared to dynamic websites Fewer or no dependencies on systems such as databases or other application servers Disadvantages of a static website Dynamic functionality has to be added separately ​ Dynamic site is not our topic here. I wil talk about how to deploy a hexo blog in Github repository under the environment of Window 10. 1. Github initialization​ From the very beginning, you have to create a GitHub account and new a repository, note that the repository name need to be the same with your owner name (the alarm is appeared cause I have already newed a same one). REMEMBER the repository address (two kinds of address—- SSH: git@github.com:dlc1994/dlc1994.github.io.git and HTTPS: https://github.com/dlc1994/dlc1994.github.io.git). The configuration of SSH can be seen in here, and HTTPS has no need of extra operation. Install Git tool and the rest of operations is done through this tool. 2. Install the necessary componentsAfter that, install Node.js, in case of the low speed, you can also download it in here. Now it’s time to install Hexo in your machine, click right-hand button anywhere and open Git Bash, then input 12npm install hexo-cli -gnpm install hexo-deployer-git --save Wait a minute you can check if the component is installed successfully. Input directly in Git Bash, or Win+R and input cmd, then input codes as follow: 123git --versionnode -vnpm -v If return the version number then you can go on, otherwise just google your mistake during your installation. After Hexo is installed, go to the place where you want to save your blog and open Git Bash. Input hexo init, you can find that a lot of files are created. 3. Create your first blogUse file editor like Notepad++, open file _config.yml, find the codes and edit it as you want 123456789101112131415# Sitetitle: DLC&apos;s Blog #your blog namesubtitle: Find myself in the darkest place #your blog subtitledescription: Personal Blog #description of your blogkeywords:author: language: timezone: Asia/Shanghaitheme: landscape #your blog theme, I will talk about how to change it to `Next`deploy: type: repository: git@github.com:dlc1994/dlc1994.github.io.git #your repository address branch: master In Git Bash, input hexo g and hexo s, it will return (perfectly) Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. Open your browser and input localhost:4000 in address bar, you can see that (Ok it is really ugly) Lastly, you have to deploy it to your github repository, continue to input hexo d. Luckily, there is no error and you can see it in your repository address like git@github.com:dlc1994/dlc1994.github.io.git. If not, go to google for help. Create a new blog use hexo new &quot;postname&quot; or in your blog path blogpath\\source\\_posts new a .md file and edit it use Markdown (Typora is recommended here). More commands can be found here. I will update the process of blog beautification in my next blogs. !!!Tips: if you suffer any problem, first go to google or baidu it. Please discover the truth by yourself.","link":"/2018/06/12/ckwasv94q0009v45c7mm267jp/"}],"tags":[{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"DataFrame","slug":"DataFrame","link":"/tags/DataFrame/"},{"name":"Sorting","slug":"Sorting","link":"/tags/Sorting/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Binary Tree","slug":"Binary-Tree","link":"/tags/Binary-Tree/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"C/C++","slug":"C-C","link":"/tags/C-C/"},{"name":"Linear Regression","slug":"Linear-Regression","link":"/tags/Linear-Regression/"},{"name":"Polynomial Regression","slug":"Polynomial-Regression","link":"/tags/Polynomial-Regression/"},{"name":"Gradient Decent Methods","slug":"Gradient-Decent-Methods","link":"/tags/Gradient-Decent-Methods/"},{"name":"Latex","slug":"Latex","link":"/tags/Latex/"},{"name":"Algorithms","slug":"Algorithms","link":"/tags/Algorithms/"},{"name":"Matlab","slug":"Matlab","link":"/tags/Matlab/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"函数指针","slug":"函数指针","link":"/tags/函数指针/"},{"name":"内存管理","slug":"内存管理","link":"/tags/内存管理/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"Clion","slug":"Clion","link":"/tags/Clion/"},{"name":"Database","slug":"Database","link":"/tags/Database/"},{"name":"Postgresql","slug":"Postgresql","link":"/tags/Postgresql/"},{"name":"Week-contest","slug":"Week-contest","link":"/tags/Week-contest/"},{"name":"DAG图","slug":"DAG图","link":"/tags/DAG图/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/拓扑排序/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"LinkedList","slug":"LinkedList","link":"/tags/LinkedList/"},{"name":"多线程","slug":"多线程","link":"/tags/多线程/"},{"name":"Map","slug":"Map","link":"/tags/Map/"},{"name":"Postgis","slug":"Postgis","link":"/tags/Postgis/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"Wireless communications","slug":"Wireless-communications","link":"/tags/Wireless-communications/"}],"categories":[{"name":"Data Processing","slug":"Data-Processing","link":"/categories/Data-Processing/"},{"name":"Optimization Algorithms","slug":"Optimization-Algorithms","link":"/categories/Optimization-Algorithms/"},{"name":"Algorithm and Data Structure","slug":"Algorithm-and-Data-Structure","link":"/categories/Algorithm-and-Data-Structure/"},{"name":"HEXO","slug":"HEXO","link":"/categories/HEXO/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/categories/Machine-Learning/"},{"name":"Paper Work","slug":"Paper-Work","link":"/categories/Paper-Work/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"Competition","slug":"Competition","link":"/categories/Competition/"},{"name":"Wireless Communications","slug":"Wireless-Communications","link":"/categories/Wireless-Communications/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"Development","slug":"Development","link":"/categories/Development/"}]}