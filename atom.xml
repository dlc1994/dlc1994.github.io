<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LC-Garden</title>
  
  <subtitle>博客没维护好，丢失源文件了，之后慢慢加回来吧</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dlc1994.github.io/"/>
  <updated>2022-03-20T14:50:14.445Z</updated>
  <id>https://dlc1994.github.io/</id>
  
  <author>
    <name>Lingcheng Dai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode Weekly Contest 285</title>
    <link href="https://dlc1994.github.io/2022/03/20/cl0zeby7l0010p45cyyx76e4s/"/>
    <id>https://dlc1994.github.io/2022/03/20/cl0zeby7l0010p45cyyx76e4s/</id>
    <published>2022-03-20T04:00:00.000Z</published>
    <updated>2022-03-20T14:50:14.445Z</updated>
    
    <content type="html"><![CDATA[<p>排名1515 / 7501。<br><a id="more"></a></p><h1 id="6027-统计数组中峰和谷的数量-EASY"><a href="#6027-统计数组中峰和谷的数量-EASY" class="headerlink" title="6027. 统计数组中峰和谷的数量 [EASY]"></a>6027. 统计数组中峰和谷的数量 [EASY]</h1><p>给你一个下标从 0 开始的整数数组 nums 。如果两侧距 i 最近的不相等邻居的值均小于 nums[i] ，则下标 i 是 nums 中，某个峰的一部分。类似地，如果两侧距 i 最近的不相等邻居的值均大于 nums[i] ，则下标 i 是 nums 中某个谷的一部分。对于相邻下标 i 和 j ，如果 nums[i] == nums[j] ， 则认为这两下标属于 同一个 峰或谷。</p><p>注意，要使某个下标所做峰或谷的一部分，那么它左右两侧必须 都 存在不相等邻居。</p><p>返回 nums 中峰和谷的数量。</p><p>示例 1：<br>输入：nums = [2,4,1,1,6,5]<br>输出：3<br>解释：<br>在下标 0 ：由于 2 的左侧不存在不相等邻居，所以下标 0 既不是峰也不是谷。<br>在下标 1 ：4 的最近不相等邻居是 2 和 1 。由于 4 &gt; 2 且 4 &gt; 1 ，下标 1 是一个峰。<br>在下标 2 ：1 的最近不相等邻居是 4 和 6 。由于 1 &lt; 4 且 1 &lt; 6 ，下标 2 是一个谷。<br>在下标 3 ：1 的最近不相等邻居是 4 和 6 。由于 1 &lt; 4 且 1 &lt; 6 ，下标 3 符合谷的定义，但需要注意它和下标 2 是同一个谷的一部分。<br>在下标 4 ：6 的最近不相等邻居是 1 和 5 。由于 6 &gt; 1 且 6 &gt; 5 ，下标 4 是一个峰。<br>在下标 5 ：由于 5 的右侧不存在不相等邻居，所以下标 5 既不是峰也不是谷。<br>共有 3 个峰和谷，所以返回 3 。</p><p>示例 2：<br>输入：nums = [6,6,5,5,4,1]<br>输出：0<br>解释：<br>在下标 0 ：由于 6 的左侧不存在不相等邻居，所以下标 0 既不是峰也不是谷。<br>在下标 1 ：由于 6 的左侧不存在不相等邻居，所以下标 1 既不是峰也不是谷。<br>在下标 2 ：5 的最近不相等邻居是 6 和 4 。由于 5 &lt; 6 且 5 &gt; 4 ，下标 2 既不是峰也不是谷。<br>在下标 3 ：5 的最近不相等邻居是 6 和 4 。由于 5 &lt; 6 且 5 &gt; 4 ，下标 3 既不是峰也不是谷。<br>在下标 4 ：4 的最近不相等邻居是 5 和 1 。由于 4 &lt; 5 且 4 &gt; 1 ，下标 4 既不是峰也不是谷。<br>在下标 5 ：由于 1 的右侧不存在不相等邻居，所以下标 5 既不是峰也不是谷。<br>共有 0 个峰和谷，所以返回 0 。</p><p>提示：<br>3 &lt;= nums.length &lt;= 100<br>1 &lt;= nums[i] &lt;= 100</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">审题：先遍历一次剔除重复元素，再遍历一次判断波峰波谷</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countHillValley(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        vector&lt;int&gt; numsTmp;</span><br><span class="line">        numsTmp.push_back(nums[0]);</span><br><span class="line">        for (int i = 1; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            if (nums[i] == nums[i - 1]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            numsTmp.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        // for (int i = 0; i &lt; numsTmp.size(); i++) &#123;</span><br><span class="line">        //     cout &lt;&lt; numsTmp[i] &lt;&lt; &quot;, &quot;;</span><br><span class="line">        // &#125;</span><br><span class="line">        // cout &lt;&lt; endl;</span><br><span class="line">        for (int i = 1; i &lt; numsTmp.size() - 1; i++) &#123;</span><br><span class="line">            if ((i + 1 &lt;= numsTmp.size() - 1) &amp;&amp; (numsTmp[i] &gt; numsTmp[i - 1]) &amp;&amp; (numsTmp[i] &gt; numsTmp[i + 1])) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">            if ((i + 1 &lt;= numsTmp.size() - 1) &amp;&amp; (numsTmp[i] &lt; numsTmp[i - 1]) &amp;&amp; (numsTmp[i] &lt; numsTmp[i + 1])) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="6028-统计道路上的碰撞次数-MEDIUM"><a href="#6028-统计道路上的碰撞次数-MEDIUM" class="headerlink" title="6028. 统计道路上的碰撞次数 [MEDIUM]"></a>6028. 统计道路上的碰撞次数 [MEDIUM]</h1><p>在一条无限长的公路上有 n 辆汽车正在行驶。汽车按从左到右的顺序按从 0 到 n - 1 编号，每辆车都在一个 独特的 位置。</p><p>给你一个下标从 0 开始的字符串 directions ，长度为 n 。directions[i] 可以是 ‘L’、’R’ 或 ‘S’ 分别表示第 i 辆车是向 左 、向 右 或者 停留 在当前位置。每辆车移动时 速度相同 。</p><p>碰撞次数可以按下述方式计算：</p><p>当两辆移动方向 相反 的车相撞时，碰撞次数加 2 。<br>当一辆移动的车和一辆静止的车相撞时，碰撞次数加 1 。<br>碰撞发生后，涉及的车辆将无法继续移动并停留在碰撞位置。除此之外，汽车不能改变它们的状态或移动方向。</p><p>返回在这条道路上发生的 碰撞总次数 。</p><p>示例 1：<br>输入：directions = “RLRSLL”<br>输出：5<br>解释：<br>将会在道路上发生的碰撞列出如下：</p><ul><li>车 0 和车 1 会互相碰撞。由于它们按相反方向移动，碰撞数量变为 0 + 2 = 2 。</li><li>车 2 和车 3 会互相碰撞。由于 3 是静止的，碰撞数量变为 2 + 1 = 3 。</li><li>车 3 和车 4 会互相碰撞。由于 3 是静止的，碰撞数量变为 3 + 1 = 4 。</li><li>车 4 和车 5 会互相碰撞。在车 4 和车 3 碰撞之后，车 4 会待在碰撞位置，接着和车 5 碰撞。碰撞数量变为 4 + 1 = 5 。<br>因此，将会在道路上发生的碰撞总次数是 5 。</li></ul><p>示例 2：<br>输入：directions = “LLRR”<br>输出：0<br>解释：<br>不存在会发生碰撞的车辆。因此，将会在道路上发生的碰撞总次数是 0 。</p><p>提示：<br>1 &lt;= directions.length &lt;= 105<br>directions[i] 的值为 ‘L’、’R’ 或 ‘S’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">审题：写的状态转移，代码比较多。实际掐头（去掉左边的&apos;L&apos;）去尾（去掉右边的&apos;R&apos;），中间的所有的非&apos;S&apos;的车最后都是停止的，那么只要统计中间的所有的非&apos;S&apos;的车的数量就可以（&apos;RL&apos;两辆都停所以+2）</span><br><span class="line">https://leetcode-cn.com/problems/count-collisions-on-a-road/solution/jie-lun-ti-san-xing-gao-ding-by-endlessc-bvnw/</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    enum State &#123;</span><br><span class="line">        INIT = -1,</span><br><span class="line">        LEFT = 0,</span><br><span class="line">        RIGHT = 1,</span><br><span class="line">        STATIC = 2</span><br><span class="line">    &#125;;</span><br><span class="line">    int countCollisions(string directions) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        int state = INIT;</span><br><span class="line">        int add = 0;</span><br><span class="line">        for (int i = 0; i &lt; directions.size(); i++) &#123;</span><br><span class="line">            // cout &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; directions[i] &lt;&lt; &quot;, &quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">            if (directions[i] == &apos;L&apos;) &#123;</span><br><span class="line">                switch (state) &#123;</span><br><span class="line">                    case INIT:</span><br><span class="line">                        state = LEFT;</span><br><span class="line">                        continue;</span><br><span class="line">                    case LEFT:</span><br><span class="line">                        continue;</span><br><span class="line">                    case RIGHT:</span><br><span class="line">                        result += 2 + add;</span><br><span class="line">                        add = 0;</span><br><span class="line">                        state = STATIC;</span><br><span class="line">                        continue;</span><br><span class="line">                    case STATIC:</span><br><span class="line">                        result += 1;</span><br><span class="line">                        state = STATIC;</span><br><span class="line">                        continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (directions[i] == &apos;R&apos;) &#123;</span><br><span class="line">                switch (state) &#123;</span><br><span class="line">                    case INIT:</span><br><span class="line">                    case LEFT:</span><br><span class="line">                    case STATIC:</span><br><span class="line">                        state = RIGHT;</span><br><span class="line">                        continue;</span><br><span class="line">                    case RIGHT:</span><br><span class="line">                        add++;</span><br><span class="line">                        continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                switch (state) &#123;</span><br><span class="line">                    case INIT:</span><br><span class="line">                        state = STATIC;</span><br><span class="line">                        continue;</span><br><span class="line">                    case STATIC:</span><br><span class="line">                        continue;</span><br><span class="line">                    case LEFT:</span><br><span class="line">                        state = STATIC;</span><br><span class="line">                        continue;</span><br><span class="line">                    case RIGHT:</span><br><span class="line">                        result += 1 + add;</span><br><span class="line">                        add = 0;</span><br><span class="line">                        state = STATIC;</span><br><span class="line">                        continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="6029-射箭比赛中的最大得分-MEDIUM"><a href="#6029-射箭比赛中的最大得分-MEDIUM" class="headerlink" title="6029. 射箭比赛中的最大得分 [MEDIUM]"></a>6029. 射箭比赛中的最大得分 [MEDIUM]</h1><p>Alice 和 Bob 是一场射箭比赛中的对手。比赛规则如下：</p><p>Alice 先射 numArrows 支箭，然后 Bob 也射 numArrows 支箭。<br>分数按下述规则计算：<br>箭靶有若干整数计分区域，范围从 0 到 11 （含 0 和 11）。<br>箭靶上每个区域都对应一个得分 k（范围是 0 到 11），Alice 和 Bob 分别在得分 k 区域射中 ak 和 bk 支箭。如果 ak &gt;= bk ，那么 Alice 得 k 分。如果 ak &lt; bk ，则 Bob 得 k 分<br>如果 ak == bk == 0 ，那么无人得到 k 分。<br>例如，Alice 和 Bob 都向计分为 11 的区域射 2 支箭，那么 Alice 得 11 分。如果 Alice 向计分为 11 的区域射 0 支箭，但 Bob 向同一个区域射 2 支箭，那么 Bob 得 11 分。</p><p>给你整数 numArrows 和一个长度为 12 的整数数组 aliceArrows ，该数组表示 Alice 射中 0 到 11 每个计分区域的箭数量。现在，Bob 想要尽可能 最大化 他所能获得的总分。</p><p>返回数组 bobArrows ，该数组表示 Bob 射中 0 到 11 每个 计分区域的箭数量。且 bobArrows 的总和应当等于 numArrows 。</p><p>如果存在多种方法都可以使 Bob 获得最大总分，返回其中 任意一种 即可。</p><p>示例 1：<br><img src="/2022/03/20/cl0zeby7l0010p45cyyx76e4s/1647744752-kQKrXw-image.png" alt=""><br>输入：numArrows = 9, aliceArrows = [1,1,0,1,0,0,2,1,0,1,2,0]<br>输出：[0,0,0,0,1,1,0,0,1,2,3,1]<br>解释：上表显示了比赛得分情况。<br>Bob 获得总分 4 + 5 + 8 + 9 + 10 + 11 = 47 。<br>可以证明 Bob 无法获得比 47 更高的分数。</p><p>示例 2：<br><img src="/2022/03/20/cl0zeby7l0010p45cyyx76e4s/1647744785-cMHzaC-image.png" alt=""><br>输入：numArrows = 3, aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]<br>输出：[0,0,0,0,0,0,0,0,1,1,1,0]<br>解释：上表显示了比赛得分情况。<br>Bob 获得总分 8 + 9 + 10 = 27 。<br>可以证明 Bob 无法获得比 27 更高的分数。</p><p>提示：<br>1 &lt;= numArrows &lt;= 105<br>aliceArrows.length == bobArrows.length == 12<br>0 &lt;= aliceArrows[i], bobArrows[i] &lt;= numArrows<br>sum(aliceArrows[i]) == numArrows<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">审题：我用dfs做的，有个[binary enum](https://leetcode-cn.com/problems/maximum-points-in-an-archery-competition/solution/er-jin-zhi-mei-ju-by-endlesscheng-rjul/)，学到了</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxPoint = 0;</span><br><span class="line">    vector&lt;int&gt; bobArrows_;</span><br><span class="line">    void dfs(const vector&lt;int&gt;&amp; aliceArrows, int start, int resArrows, int sumPoint, vector&lt;int&gt;&amp; bobArrows) &#123;</span><br><span class="line">        if (resArrows &lt; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sumPoint &gt;= maxPoint) &#123;</span><br><span class="line">            maxPoint = sumPoint;</span><br><span class="line">            bobArrows_ = bobArrows; </span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = start; j &gt;= 0; j--) &#123;</span><br><span class="line">            if (j == 0) &#123;</span><br><span class="line">                bobArrows[j] = resArrows;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                bobArrows[j] = aliceArrows[j] + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(aliceArrows, j - 1, resArrows - bobArrows[j], sumPoint + j, bobArrows);</span><br><span class="line">            bobArrows[j] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; maximumBobPoints(int numArrows, vector&lt;int&gt;&amp; aliceArrows) &#123;</span><br><span class="line">        vector&lt;int&gt; bobArrows(12, 0);</span><br><span class="line">        dfs(aliceArrows, 11, numArrows, 0, bobArrows);</span><br><span class="line">        return bobArrows_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="6030-由单个字符重复的最长子字符串-HARD"><a href="#6030-由单个字符重复的最长子字符串-HARD" class="headerlink" title="6030. 由单个字符重复的最长子字符串 [HARD]"></a>6030. 由单个字符重复的最长子字符串 [HARD]</h1><p>给你一个下标从 0 开始的字符串 s 。另给你一个下标从 0 开始、长度为 k 的字符串 queryCharacters ，一个下标从 0 开始、长度也是 k 的整数 下标 数组 queryIndices ，这两个都用来描述 k 个查询。</p><p>第 i 个查询会将 s 中位于下标 queryIndices[i] 的字符更新为 queryCharacters[i] 。</p><p>返回一个长度为 k 的数组 lengths ，其中 lengths[i] 是在执行第 i 个查询 之后 s 中仅由 单个字符重复 组成的 最长子字符串 的 长度 。</p><p>示例 1：<br>输入：s = “babacc”, queryCharacters = “bcb”, queryIndices = [1,3,3]<br>输出：[3,3,4]<br>解释：</p><ul><li>第 1 次查询更新后 s = “bbbacc” 。由单个字符重复组成的最长子字符串是 “bbb” ，长度为 3 。</li><li>第 2 次查询更新后 s = “bbbccc” 。由单个字符重复组成的最长子字符串是 “bbb” 或 “ccc”，长度为 3 。</li><li>第 3 次查询更新后 s = “bbbbcc” 。由单个字符重复组成的最长子字符串是 “bbbb” ，长度为 4 。<br>因此，返回 [3,3,4] 。</li></ul><p>示例 2：<br>输入：s = “abyzz”, queryCharacters = “aa”, queryIndices = [2,1]<br>输出：[2,3]<br>解释：</p><ul><li>第 1 次查询更新后 s = “abazz” 。由单个字符重复组成的最长子字符串是 “zz” ，长度为 2 。</li><li>第 2 次查询更新后 s = “aaazz” 。由单个字符重复组成的最长子字符串是 “aaa” ，长度为 3 。<br>因此，返回 [2,3] 。</li></ul><p>提示：<br>1 &lt;= s.length &lt;= 105<br>s 由小写英文字母组成<br>k == queryCharacters.length == queryIndices.length<br>1 &lt;= k &lt;= 105<br>queryCharacters 由小写英文字母组成<br>0 &lt;= queryIndices[i] &lt; s.length</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">审题：写的暴力，果然超时</span><br><span class="line"></span><br><span class="line">评论的题解：</span><br><span class="line">1.线段树https://leetcode-cn.com/problems/longest-substring-of-one-repeating-character/solution/by-endlesscheng-qpbw/</span><br><span class="line">2. 模拟https://leetcode-cn.com/problems/longest-substring-of-one-repeating-character/solution/by-tsreaper-7axn/</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    inline int getLongest(const string&amp; s) &#123;</span><br><span class="line">        int longest = 0;</span><br><span class="line">        char state = s[0];</span><br><span class="line">        int cnt = 1;</span><br><span class="line">        for (int i = 1; i &lt; s.size(); i++) &#123;</span><br><span class="line">            if (s[i] == s[i - 1]) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (cnt &gt; longest) &#123;</span><br><span class="line">                    longest = cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            // cout &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; s[i] &lt;&lt; &quot;, &quot; &lt;&lt; longest &lt;&lt; &quot;, &quot; &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        if (cnt &gt; longest) &#123;</span><br><span class="line">            longest = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        // cout &lt;&lt; longest &lt;&lt; &quot;, &quot; &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        return longest;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; longestRepeating(string s, string queryCharacters, vector&lt;int&gt;&amp; queryIndices) &#123;</span><br><span class="line">        vector&lt;int&gt; result(queryIndices.size(), 0);</span><br><span class="line">        for (int i = 0; i &lt; queryIndices.size(); i++) &#123;</span><br><span class="line">            s[queryIndices[i]] = queryCharacters[i];</span><br><span class="line">            result[i] = getLongest(s);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排名1515 / 7501。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://dlc1994.github.io/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
      <category term="Week-contest" scheme="https://dlc1994.github.io/tags/Week-contest/"/>
    
      <category term="Binary enumerate" scheme="https://dlc1994.github.io/tags/Binary-enumerate/"/>
    
      <category term="线段树" scheme="https://dlc1994.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://dlc1994.github.io/2022/03/13/cl0zeby79000jp45cveo1z25l/"/>
    <id>https://dlc1994.github.io/2022/03/13/cl0zeby79000jp45cveo1z25l/</id>
    <published>2022-03-13T14:57:07.000Z</published>
    <updated>2022-03-13T15:55:44.467Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://labuladong.github.io/algo/2/20/40/">labuladong</a></p><p>通用模板，路径压缩</p><p>应用场景</p><ul><li>克鲁斯卡尔最小生成树<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">class UF &#123;</span><br><span class="line">public:</span><br><span class="line">    // n 为图中节点的个数</span><br><span class="line">    explicit UF(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        count_ = n;</span><br><span class="line">        parent_ = new T[n];</span><br><span class="line">        for (T i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            parent_[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将节点 p 和节点 q 连通</span><br><span class="line">    void Union(T p, T q) &#123;</span><br><span class="line">        T rootP = Find(p);</span><br><span class="line">        T rootQ = Find(q);</span><br><span class="line"></span><br><span class="line">        if (rootP == rootQ) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parent_[rootQ] = rootP;</span><br><span class="line">        // 两个连通分量合并成一个连通分量</span><br><span class="line">        count_--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断节点 p 和节点 q 是否连通</span><br><span class="line">    bool Connected(T p, T q) &#123;</span><br><span class="line">        T rootP = Find(p);</span><br><span class="line">        T rootQ = Find(q);</span><br><span class="line">        return rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回图中的连通分量个数</span><br><span class="line">    [[nodiscard]] int Count() const &#123;</span><br><span class="line">        return count_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回节点 x 的连通分量根节点</span><br><span class="line">private:</span><br><span class="line">    T Find(T x) &#123;</span><br><span class="line">        while (parent_[x] != x) &#123;</span><br><span class="line">            // 进行路径压缩</span><br><span class="line">            parent_[x] = parent_[parent_[x]];</span><br><span class="line">            x = parent_[x];</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    // 连通分量个数</span><br><span class="line">    int count_;</span><br><span class="line">    // 存储每个节点的父节点</span><br><span class="line">    T* parent_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="990-等式方程的可满足性"><a href="#990-等式方程的可满足性" class="headerlink" title="990. 等式方程的可满足性"></a><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/">990. 等式方程的可满足性</a></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool equationsPossible(vector&lt;string&gt;&amp; equations) &#123;</span><br><span class="line">        int n = equations.size();</span><br><span class="line">        UF&lt;int&gt; uf(26);</span><br><span class="line">        for (const auto&amp; eq :equations) &#123;</span><br><span class="line">            if (eq.substr(1, 2) == &quot;==&quot;) &#123;</span><br><span class="line">                uf.Union(eq[0] - &apos;a&apos;, eq[3] - &apos;a&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (const auto&amp; eq :equations) &#123;</span><br><span class="line">            if (eq.substr(1, 2) == &quot;!=&quot;) &#123;</span><br><span class="line">                if (uf.Connected(eq[0] - &apos;a&apos;, eq[3] - &apos;a&apos;)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://labuladong.github.io/algo/2/20/40/&quot;&gt;labuladong&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通用模板，路径压缩&lt;/p&gt;
&lt;p&gt;应用场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;克鲁斯卡尔最小生成树&lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://dlc1994.github.io/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="https://dlc1994.github.io/tags/leetcode/"/>
    
      <category term="Union Find" scheme="https://dlc1994.github.io/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>岛屿问题</title>
    <link href="https://dlc1994.github.io/2022/03/10/cl0zeby720009p45c4pq9eoxi/"/>
    <id>https://dlc1994.github.io/2022/03/10/cl0zeby720009p45c4pq9eoxi/</id>
    <published>2022-03-10T04:50:07.000Z</published>
    <updated>2022-03-13T15:55:46.090Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://labuladong.github.io/algo/1/9/">labuladong</a></p><h1 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j, int m, int n) &#123;</span><br><span class="line">        if (i &lt; 0 || i &gt; m - 1 || j &lt; 0 || j &gt; n - 1) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (grid[i][j] == &apos;0&apos;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = &apos;0&apos;;</span><br><span class="line">        dfs(grid, i - 1, j, m, n);</span><br><span class="line">        dfs(grid, i + 1, j, m, n);</span><br><span class="line">        dfs(grid, i, j - 1, m, n);</span><br><span class="line">        dfs(grid, i, j + 1, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        int m = grid.size();</span><br><span class="line">        int n= grid[0].size();</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (grid[i][j] == &apos;1&apos;) &#123;</span><br><span class="line">                    result++;</span><br><span class="line">                    dfs(grid, i, j, m, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="1254-统计封闭岛屿的数目"><a href="#1254-统计封闭岛屿的数目" class="headerlink" title="1254. 统计封闭岛屿的数目"></a><a href="https://leetcode-cn.com/problems/number-of-closed-islands/">1254. 统计封闭岛屿的数目</a></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j, int m, int n) &#123;</span><br><span class="line">        if (i &lt; 0 || i &gt; m - 1 || j &lt; 0 || j &gt; n - 1) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (grid[i][j] == 1) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = 1;</span><br><span class="line">        dfs(grid, i - 1, j, m, n);</span><br><span class="line">        dfs(grid, i + 1, j, m, n);</span><br><span class="line">        dfs(grid, i, j - 1, m, n);</span><br><span class="line">        dfs(grid, i, j + 1, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    int closedIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        int m = grid.size();</span><br><span class="line">        int n = grid[0].size();</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            dfs(grid, i, 0, m, n);</span><br><span class="line">            dfs(grid, i, n - 1, m, n);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(grid, 0, i, m, n);</span><br><span class="line">            dfs(grid, m - 1, i, m, n);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (grid[i][j] == 0) &#123;</span><br><span class="line">                    result++;</span><br><span class="line">                    dfs(grid, i, j, m, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="1020-飞地的数量"><a href="#1020-飞地的数量" class="headerlink" title="1020. 飞地的数量"></a><a href="https://leetcode-cn.com/problems/number-of-enclaves/">1020. 飞地的数量</a></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j, int m, int n) &#123;</span><br><span class="line">        if (i &lt; 0 || i &gt; m - 1 || j &lt; 0 || j &gt; n - 1) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (grid[i][j] == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = 0;</span><br><span class="line">        dfs(grid, i - 1, j, m, n);</span><br><span class="line">        dfs(grid, i + 1, j, m, n);</span><br><span class="line">        dfs(grid, i, j - 1, m, n);</span><br><span class="line">        dfs(grid, i, j + 1, m, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int numEnclaves(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        int m = grid.size();</span><br><span class="line">        int n = grid[0].size();</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            dfs(grid, i, 0, m, n);</span><br><span class="line">            dfs(grid, i, n - 1, m, n);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(grid, 0, i, m, n);</span><br><span class="line">            dfs(grid, m - 1, i, m, n);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                result += (grid[i][j] == 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxArea = 0;</span><br><span class="line">    int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j, int m, int n) &#123;</span><br><span class="line">        if (i &lt; 0 || i &gt; m - 1 || j &lt; 0 || j &gt; n - 1) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (grid[i][j] == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = 0;</span><br><span class="line">        return dfs(grid, i - 1, j, m, n) + dfs(grid, i + 1, j, m, n) + dfs(grid, i, j - 1, m, n) + dfs(grid, i, j + 1, m, n) + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int m = grid.size();</span><br><span class="line">        int n = grid[0].size();</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    maxArea = max(maxArea, dfs(grid, i, j, m, n));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="1905-统计子岛屿"><a href="#1905-统计子岛屿" class="headerlink" title="1905. 统计子岛屿"></a><a href="https://leetcode-cn.com/problems/count-sub-islands/">1905. 统计子岛屿</a></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool dfs(const vector&lt;vector&lt;int&gt;&gt;&amp; grid1, vector&lt;vector&lt;int&gt;&gt;&amp; grid2, int i, int j, int m, int n) &#123;</span><br><span class="line">        if (i &lt; 0 || i &gt; m - 1 || j &lt; 0 || j &gt; n - 1) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (grid2[i][j] == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (grid1[i][j] == 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        grid2[i][j] = 0;</span><br><span class="line">        bool a = dfs(grid1, grid2, i - 1, j, m, n);</span><br><span class="line">        bool b = dfs(grid1, grid2, i + 1, j, m, n);</span><br><span class="line">        bool c = dfs(grid1, grid2, i, j - 1, m, n);</span><br><span class="line">        bool d = dfs(grid1, grid2, i, j + 1, m, n);</span><br><span class="line">        return a &amp;&amp; b &amp;&amp; c &amp;&amp; d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int countSubIslands(vector&lt;vector&lt;int&gt;&gt;&amp; grid1, vector&lt;vector&lt;int&gt;&gt;&amp; grid2) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        int m = grid1.size();</span><br><span class="line">        int n = grid1[0].size();</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (grid1[i][j] &amp;&amp; grid2[i][j]) &#123;</span><br><span class="line">                    result += dfs(grid1, grid2, i, j, m, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="694-不同的岛屿数量"><a href="#694-不同的岛屿数量" class="headerlink" title="694. 不同的岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-distinct-islands/">694. 不同的岛屿数量</a></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int numDistinctIslands(int[][] grid) &#123;</span><br><span class="line"></span><br><span class="line">    int m = grid.length, n = grid[0].length;</span><br><span class="line"></span><br><span class="line">    // 记录所有岛屿的序列化结果</span><br><span class="line"></span><br><span class="line">    HashSet&lt;String&gt; islands = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line"></span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line"></span><br><span class="line">            if (grid[i][j] == 1) &#123;</span><br><span class="line"></span><br><span class="line">                // 淹掉这个岛屿，同时存储岛屿的序列化结果</span><br><span class="line"></span><br><span class="line">                StringBuilder sb = new StringBuilder();</span><br><span class="line"></span><br><span class="line">                // 初始的方向可以随便写，不影响正确性</span><br><span class="line"></span><br><span class="line">                dfs(grid, i, j, sb, 666);</span><br><span class="line"></span><br><span class="line">                islands.add(sb.toString());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 不相同的岛屿数量</span><br><span class="line"></span><br><span class="line">    return islands.size();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://labuladong.github.io/algo/1/9/&quot;&gt;labuladong&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;200-岛屿数量&quot;&gt;&lt;a href=&quot;#200-岛屿数量&quot; class=&quot;headerlink&quot; title=&quot;200. 
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://dlc1994.github.io/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="https://dlc1994.github.io/tags/leetcode/"/>
    
      <category term="DFS" scheme="https://dlc1994.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode biweekly-contest-68</title>
    <link href="https://dlc1994.github.io/2021/12/25/cl0zeby7l000zp45c7un3crpc/"/>
    <id>https://dlc1994.github.io/2021/12/25/cl0zeby7l000zp45c7un3crpc/</id>
    <published>2021-12-25T14:30:00.000Z</published>
    <updated>2022-01-17T15:24:41.845Z</updated>
    
    <content type="html"><![CDATA[<p>排名1143 / 2854<br><a id="more"></a></p><h1 id="2114-句子中的最多单词数-EASY"><a href="#2114-句子中的最多单词数-EASY" class="headerlink" title="2114. 句子中的最多单词数[EASY]"></a>2114. 句子中的最多单词数[EASY]</h1><p>一个 句子 由一些 单词 以及它们之间的单个空格组成，句子的开头和结尾不会有多余空格。</p><p>给你一个字符串数组 sentences ，其中 sentences[i] 表示单个 句子 。</p><p>请你返回单个句子里 单词的最多数目 。</p><p>示例 1：<br>输入：sentences = [“alice and bob love leetcode”, “i think so too”, “this is great thanks very much”]<br>输出：6<br>解释：</p><ul><li>第一个句子 “alice and bob love leetcode” 总共有 5 个单词。</li><li>第二个句子 “i think so too” 总共有 4 个单词。</li><li>第三个句子 “this is great thanks very much” 总共有 6 个单词。<br>所以，单个句子中有最多单词数的是第三个句子，总共有 6 个单词。</li></ul><p>示例 2：<br>输入：sentences = [“please wait”, “continue to fight”, “continue to win”]<br>输出：3<br>解释：可能有多个句子有相同单词数。<br>这个例子中，第二个句子和第三个句子（加粗斜体）有相同数目的单词数。</p><p>提示：<br>1 &lt;= sentences.length &lt;= 100<br>1 &lt;= sentences[i].length &lt;= 100<br>sentences[i] 只包含小写英文字母和 ‘ ‘ 。<br>sentences[i] 的开头和结尾都没有空格。<br>sentences[i] 中所有单词由单个空格隔开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">审题：比较简单就不说了</span><br><span class="line">*/</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int mostWordsFound(vector&lt;string&gt;&amp; sentences) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        for (auto&amp; sentence : sentences) &#123;</span><br><span class="line">            int spaceNum = std::count(sentence.begin(), sentence.end(), &apos; &apos;) + 1;</span><br><span class="line">            if (spaceNum &gt; result) &#123;</span><br><span class="line">                result = spaceNum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2115-从给定原材料中找到所有可以做出的菜-MEDIUM"><a href="#2115-从给定原材料中找到所有可以做出的菜-MEDIUM" class="headerlink" title="2115. 从给定原材料中找到所有可以做出的菜 [MEDIUM]"></a>2115. 从给定原材料中找到所有可以做出的菜 [MEDIUM]</h1><p>你有 n 道不同菜的信息。给你一个字符串数组 recipes 和一个二维字符串数组 ingredients 。第 i 道菜的名字为 recipes[i] ，如果你有它 所有 的原材料 ingredients[i] ，那么你可以 做出 这道菜。一道菜的原材料可能是 另一道 菜，也就是说 ingredients[i] 可能包含 recipes 中另一个字符串。</p><p>同时给你一个字符串数组 supplies ，它包含你初始时拥有的所有原材料，每一种原材料你都有无限多。</p><p>请你返回你可以做出的所有菜。你可以以 任意顺序 返回它们。</p><p>注意两道菜在它们的原材料中可能互相包含。</p><p>示例 1：<br>输入：recipes = [“bread”], ingredients = [[“yeast”,”flour”]], supplies = [“yeast”,”flour”,”corn”]<br>输出：[“bread”]<br>解释：<br>我们可以做出 “bread” ，因为我们有原材料 “yeast” 和 “flour” 。</p><p>示例 2：<br>输入：recipes = [“bread”,”sandwich”], ingredients = [[“yeast”,”flour”],[“bread”,”meat”]], supplies = [“yeast”,”flour”,”meat”]<br>输出：[“bread”,”sandwich”]<br>解释：<br>我们可以做出 “bread” ，因为我们有原材料 “yeast” 和 “flour” 。<br>我们可以做出 “sandwich” ，因为我们有原材料 “meat” 且可以做出原材料 “bread” 。</p><p>示例 3：<br>输入：recipes = [“bread”,”sandwich”,”burger”], ingredients = [[“yeast”,”flour”],[“bread”,”meat”],[“sandwich”,”meat”,”bread”]], supplies = [“yeast”,”flour”,”meat”]<br>输出：[“bread”,”sandwich”,”burger”]<br>解释：<br>我们可以做出 “bread” ，因为我们有原材料 “yeast” 和 “flour” 。<br>我们可以做出 “sandwich” ，因为我们有原材料 “meat” 且可以做出原材料 “bread” 。<br>我们可以做出 “burger” ，因为我们有原材料 “meat” 且可以做出原材料 “bread” 和 “sandwich” 。</p><p>示例 4：<br>输入：recipes = [“bread”], ingredients = [[“yeast”,”flour”]], supplies = [“yeast”]<br>输出：[]<br>解释：<br>我们没法做出任何菜，因为我们只有原材料 “yeast” 。</p><p>提示：<br>n == recipes.length == ingredients.length<br>1 &lt;= n &lt;= 100<br>1 &lt;= ingredients[i].length, supplies.length &lt;= 100<br>1 &lt;= recipes[i].length, ingredients[i][j].length, supplies[k].length &lt;= 10<br>recipes[i], ingredients[i][j] 和 supplies[k] 只包含小写英文字母。<br>所有 recipes 和 supplies 中的值互不相同。<br>ingredients[i] 中的字符串互不相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">审题：BFS终于做出来了</span><br><span class="line">*/</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool dfs(string&amp; recipe, vector&lt;string&gt;&amp; recipes, vector&lt;vector&lt;string&gt;&gt;&amp; ingredients, unordered_map&lt;string, bool&gt;&amp; supMap, unordered_map&lt;string, vector&lt;string&gt;&gt;&amp; recipeGredients)</span><br><span class="line">    &#123;</span><br><span class="line">        if (supMap[recipe]) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!recipeGredients.count(recipe)) &#123;</span><br><span class="line">            // 不在菜谱里</span><br><span class="line">            supMap[recipe] = false;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 在菜谱里，看看能不能做</span><br><span class="line">        bool canCooked = true;</span><br><span class="line">        for (auto&amp; gredient : recipeGredients[recipe]) &#123;</span><br><span class="line">            if (supMap.count(gredient) &gt; 0) &#123;</span><br><span class="line">                // 烹饪清单里有</span><br><span class="line">                if (supMap[gredient]) &#123;</span><br><span class="line">                    // 可以烹饪</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 不能烹饪</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 烹饪清单里没有还是菜谱里的，继续dfs</span><br><span class="line">                canCooked = dfs(gredient, recipes, ingredients, supMap, recipeGredients);</span><br><span class="line">                if (!canCooked) &#123;</span><br><span class="line">                    // 无法烹饪</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 可以做</span><br><span class="line">        supMap[recipe] = true;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;string&gt; findAllRecipes(vector&lt;string&gt;&amp; recipes, vector&lt;vector&lt;string&gt;&gt;&amp; ingredients, vector&lt;string&gt;&amp; supplies) &#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        unordered_map&lt;string, bool&gt; supMap;</span><br><span class="line">        for (auto&amp; supply : supplies) &#123;</span><br><span class="line">            supMap[supply] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; recipeGredients;</span><br><span class="line">        for (auto i = 0; i &lt; recipes.size(); ++i) &#123;</span><br><span class="line">            recipeGredients[recipes[i]] = ingredients[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for (auto i = 0; i &lt; recipes.size(); ++i) &#123;</span><br><span class="line">            if (dfs(recipes[i], recipes, ingredients, supMap, recipeGredients)) &#123;</span><br><span class="line">                result.emplace_back(recipes[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="2116-判断一个括号字符串是否有效-MEDIUM"><a href="#2116-判断一个括号字符串是否有效-MEDIUM" class="headerlink" title="2116. 判断一个括号字符串是否有效[MEDIUM]"></a>2116. 判断一个括号字符串是否有效[MEDIUM]</h1><p>一个括号字符串是只由 ‘(‘ 和 ‘)’ 组成的 非空 字符串。如果一个字符串满足下面 任意 一个条件，那么它就是有效的：</p><p>字符串为 ().<br>它可以表示为 AB（A 与 B 连接），其中A 和 B 都是有效括号字符串。<br>它可以表示为 (A) ，其中 A 是一个有效括号字符串。<br>给你一个括号字符串 s 和一个字符串 locked ，两者长度都为 n 。locked 是一个二进制字符串，只包含 ‘0’ 和 ‘1’ 。对于 locked 中 每一个 下标 i ：</p><p>如果 locked[i] 是 ‘1’ ，你 不能 改变 s[i] 。<br>如果 locked[i] 是 ‘0’ ，你 可以 将 s[i] 变为 ‘(‘ 或者 ‘)’ 。<br>如果你可以将 s 变为有效括号字符串，请你返回 true ，否则返回 false 。</p><p>示例 1：<br>输入：s = “))()))”, locked = “010100”<br>输出：true<br>解释：locked[1] == ‘1’ 和 locked[3] == ‘1’ ，所以我们无法改变 s[1] 或者 s[3] 。<br>我们可以将 s[0] 和 s[4] 变为 ‘(‘ ，不改变 s[2] 和 s[5] ，使 s 变为有效字符串。</p><p>示例 2：<br>输入：s = “()()”, locked = “0000”<br>输出：true<br>解释：我们不需要做任何改变，因为 s 已经是有效字符串了。</p><p>示例 3：<br>输入：s = “)”, locked = “0”<br>输出：false<br>解释：locked 允许改变 s[0] 。<br>但无论将 s[0] 变为 ‘(‘ 或者 ‘)’ 都无法使 s 变为有效字符串。</p><p>提示：<br>n == s.length == locked.length<br>1 &lt;= n &lt;= 105<br>s[i] 要么是 ‘(‘ 要么是 ‘)’ 。<br>locked[i] 要么是 ‘0’ 要么是 ‘1’ 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">审题：以为做出来了，太菜</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canBeValid(string s, string locked) &#123;</span><br><span class="line">        int n=s.size(),l=0,r=0;</span><br><span class="line">        if(n%2==1) return false;</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            if(locked[i]==&apos;1&apos;&amp;&amp;s[i]==&apos;)&apos;)&#123;</span><br><span class="line">                r++;</span><br><span class="line">                if(i+1-r&lt;r) return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=n-1;i&gt;=0;i--)&#123;</span><br><span class="line">            if(locked[i]==&apos;1&apos;&amp;&amp;s[i]==&apos;(&apos;)&#123;</span><br><span class="line">                l++;</span><br><span class="line">                if(n-i-l&lt;l) return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：qia-mi-z</span><br><span class="line">链接：https://leetcode-cn.com/problems/check-if-a-parentheses-string-can-be-valid/solution/qian-hou-ge-bian-li-yi-ci-fen-bie-pan-du-w5nu/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h1 id="2117-一个区间内所有数乘积的缩写-HARD"><a href="#2117-一个区间内所有数乘积的缩写-HARD" class="headerlink" title="2117. 一个区间内所有数乘积的缩写 [HARD]"></a>2117. 一个区间内所有数乘积的缩写 [HARD]</h1><p>没做到，看了眼题解，做到 也不会T.T</p><p><a href="https://leetcode-cn.com/problems/abbreviating-the-product-of-a-range/solution/yi-ge-shu-ju-tuan-mie-jue-da-bu-fen-dai-234yd/">https://leetcode-cn.com/problems/abbreviating-the-product-of-a-range/solution/yi-ge-shu-ju-tuan-mie-jue-da-bu-fen-dai-234yd/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排名1143 / 2854&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://dlc1994.github.io/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
      <category term="Week-contest" scheme="https://dlc1994.github.io/tags/Week-contest/"/>
    
      <category term="BFS" scheme="https://dlc1994.github.io/tags/BFS/"/>
    
      <category term="括号匹配" scheme="https://dlc1994.github.io/tags/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Weekly Contest 272</title>
    <link href="https://dlc1994.github.io/2021/12/19/cl0zeby7k000yp45ccg5bi5ys/"/>
    <id>https://dlc1994.github.io/2021/12/19/cl0zeby7k000yp45ccg5bi5ys/</id>
    <published>2021-12-19T04:00:00.000Z</published>
    <updated>2022-01-17T15:24:39.542Z</updated>
    
    <content type="html"><![CDATA[<p>前三道题很简单，半个小时完成，最后一道题着实有点难，思路都错了，最后排名1695 / 4697。<br><a id="more"></a></p><h1 id="5956-找出数组中的第一个回文字符串-EASY"><a href="#5956-找出数组中的第一个回文字符串-EASY" class="headerlink" title="5956. 找出数组中的第一个回文字符串 [EASY]"></a>5956. 找出数组中的第一个回文字符串 [EASY]</h1><p>给你一个字符串数组 words ，找出并返回数组中的 第一个回文字符串 。如果不存在满足要求的字符串，返回一个 空字符串 “” 。</p><p>回文字符串 的定义为：如果一个字符串正着读和反着读一样，那么该字符串就是一个 回文字符串 。</p><p>示例 1：<br>输入：words = [“abc”,”car”,”ada”,”racecar”,”cool”]<br>输出：”ada”<br>解释：第一个回文字符串是 “ada” 。<br>注意，”racecar” 也是回文字符串，但它不是第一个。</p><p>示例 2：<br>输入：words = [“notapalindrome”,”racecar”]<br>输出：”racecar”<br>解释：第一个也是唯一一个回文字符串是 “racecar” 。</p><p>示例 3：<br>输入：words = [“def”,”ghi”]<br>输出：””<br>解释：不存在回文字符串，所以返回一个空字符串。</p><p>提示：<br>1 &lt;= words.length &lt;= 100<br>1 &lt;= words[i].length &lt;= 100<br>words[i] 仅由小写英文字母组成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">审题：反转一下字符串比较一下就可以了</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string firstPalindrome(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        for (auto&amp; word : words) &#123;</span><br><span class="line">            string wordReverse(word.rbegin(), word.rend());</span><br><span class="line">            if (wordReverse == word) &#123;</span><br><span class="line">                return word;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="5957-向字符串添加空格-MEDIUM"><a href="#5957-向字符串添加空格-MEDIUM" class="headerlink" title="5957. 向字符串添加空格 [MEDIUM]"></a>5957. 向字符串添加空格 [MEDIUM]</h1><p>给你一个下标从 0 开始的字符串 s ，以及一个下标从 0 开始的整数数组 spaces 。</p><p>数组 spaces 描述原字符串中需要添加空格的下标。每个空格都应该插入到给定索引处的字符值 之前 。</p><p>例如，s = “EnjoyYourCoffee” 且 spaces = [5, 9] ，那么我们需要在 ‘Y’ 和 ‘C’ 之前添加空格，这两个字符分别位于下标 5 和下标 9 。因此，最终得到 “Enjoy Your Coffee” 。<br>请你添加空格，并返回修改后的字符串。</p><p>示例 1：<br>输入：s = “LeetcodeHelpsMeLearn”, spaces = [8,13,15]<br>输出：”Leetcode Helps Me Learn”<br>解释：<br>下标 8、13 和 15 对应 “LeetcodeHelpsMeLearn” 中加粗斜体字符。<br>接着在这些字符前添加空格。</p><p>示例 2：<br>输入：s = “icodeinpython”, spaces = [1,5,7,9]<br>输出：”i code in py thon”<br>解释：<br>下标 1、5、7 和 9 对应 “icodeinpython” 中加粗斜体字符。<br>接着在这些字符前添加空格。</p><p>示例 3：<br>输入：s = “spacing”, spaces = [0,1,2,3,4,5,6]<br>输出：” s p a c i n g”<br>解释：<br>字符串的第一个字符前可以添加空格。</p><p>提示：<br>1 &lt;= s.length &lt;= 3 <em> 105<br>s 仅由大小写英文字母组成<br>1 &lt;= spaces.length &lt;= 3 </em> 105<br>0 &lt;= spaces[i] &lt;= s.length - 1<br>spaces 中的所有值 严格递增<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">审题：感觉不算中等题，spaces有序就用两个指针按Index插入最后的字符串就可以了</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string addSpaces(string s, vector&lt;int&gt;&amp; spaces) &#123;</span><br><span class="line">        int originSize = s.size();</span><br><span class="line">        int spaceSize = spaces.size();</span><br><span class="line">        int finalSize = originSize + spaces.size();</span><br><span class="line">        string result;</span><br><span class="line">        result.resize(finalSize);</span><br><span class="line">        int index = 0;</span><br><span class="line">        int sIndex = 0;</span><br><span class="line">        for (int i = 0; i &lt; finalSize; ++i) &#123;</span><br><span class="line">            if (index &lt; spaceSize &amp;&amp; sIndex == spaces[index]) &#123;</span><br><span class="line">                result[i] = &apos; &apos;;</span><br><span class="line">                index++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result[i] = s[sIndex++];</span><br><span class="line">            &#125;</span><br><span class="line">            // cout &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; index &lt;&lt; &quot;, &quot; &lt;&lt; sIndex &lt;&lt; &quot;, &quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="5958-股票平滑下跌阶段的数目-MEDIUM"><a href="#5958-股票平滑下跌阶段的数目-MEDIUM" class="headerlink" title="5958. 股票平滑下跌阶段的数目 [MEDIUM]"></a>5958. 股票平滑下跌阶段的数目 [MEDIUM]</h1><p>给你一个整数数组 prices ，表示一支股票的历史每日股价，其中 prices[i] 是这支股票第 i 天的价格。</p><p>一个 平滑下降的阶段 定义为：对于 连续一天或者多天 ，每日股价都比 前一日股价恰好少 1 ，这个阶段第一天的股价没有限制。</p><p>请你返回 平滑下降阶段 的数目。</p><p>示例 1：<br>输入：prices = [3,2,1,4]<br>输出：7<br>解释：总共有 7 个平滑下降阶段：<br>[3], [2], [1], [4], [3,2], [2,1] 和 [3,2,1]<br>注意，仅一天按照定义也是平滑下降阶段。</p><p>示例 2：<br>输入：prices = [8,6,7,7]<br>输出：4<br>解释：总共有 4 个连续平滑下降阶段：[8], [6], [7] 和 [7]<br>由于 8 - 6 ≠ 1 ，所以 [8,6] 不是平滑下降阶段。</p><p>示例 3：<br>输入：prices = [1]<br>输出：1<br>解释：总共有 1 个平滑下降阶段：[1]</p><p>提示：<br>1 &lt;= prices.length &lt;= 105<br>1 &lt;= prices[i] &lt;= 105</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">审题：动态规划，遍历一次Ok</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    long long getDescentPeriods(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        long long result = 1;</span><br><span class="line">        int dp = 1;</span><br><span class="line">        for (int i = 1; i &lt; prices.size(); ++i) &#123;</span><br><span class="line">            if (prices[i - 1] - prices[i] == 1) &#123;</span><br><span class="line">                dp += 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            result += dp;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="5959-使数组-K-递增的最少操作次数-HARD"><a href="#5959-使数组-K-递增的最少操作次数-HARD" class="headerlink" title="5959. 使数组 K 递增的最少操作次数 [HARD]"></a>5959. 使数组 K 递增的最少操作次数 [HARD]</h1><p>给你一个下标从 0 开始包含 n 个正整数的数组 arr ，和一个正整数 k 。</p><p>如果对于每个满足 k &lt;= i &lt;= n-1 的下标 i ，都有 arr[i-k] &lt;= arr[i] ，那么我们称 arr 是 K 递增 的。</p><p>比方说，arr = [4, 1, 5, 2, 6, 2] 对于 k = 2 是 K 递增的，因为：<br>arr[0] &lt;= arr[2] (4 &lt;= 5)<br>arr[1] &lt;= arr[3] (1 &lt;= 2)<br>arr[2] &lt;= arr[4] (5 &lt;= 6)<br>arr[3] &lt;= arr[5] (2 &lt;= 2)<br>但是，相同的数组 arr 对于 k = 1 不是 K 递增的（因为 arr[0] &gt; arr[1]），对于 k = 3 也不是 K 递增的（因为 arr[0] &gt; arr[3] ）。<br>每一次 操作 中，你可以选择一个下标 i 并将 arr[i] 改成任意 正整数。</p><p>请你返回对于给定的 k ，使数组变成 K 递增的 最少操作次数 。</p><p>示例 1：<br>输入：arr = [5,4,3,2,1], k = 1<br>输出：4<br>解释：<br>对于 k = 1 ，数组最终必须变成非递减的。<br>可行的 K 递增结果数组为 [5,6,7,8,9]，[1,1,1,1,1]，[2,2,3,4,4] 。它们都需要 4 次操作。<br>次优解是将数组变成比方说 [6,7,8,9,10] ，因为需要 5 次操作。<br>显然我们无法使用少于 4 次操作将数组变成 K 递增的。</p><p>示例 2：<br>输入：arr = [4,1,5,2,6,2], k = 2<br>输出：0<br>解释：<br>这是题目描述中的例子。<br>对于每个满足 2 &lt;= i &lt;= 5 的下标 i ，有 arr[i-2] &lt;= arr[i] 。<br>由于给定数组已经是 K 递增的，我们不需要进行任何操作。</p><p>示例 3：<br>输入：arr = [4,1,5,2,6,2], k = 3<br>输出：2<br>解释：<br>下标 3 和 5 是仅有的 3 &lt;= i &lt;= 5 且不满足 arr[i-3] &lt;= arr[i] 的下标。<br>将数组变成 K 递增的方法之一是将 arr[3] 变为 4 ，且将 arr[5] 变成 5 。<br>数组变为 [4,1,5,4,6,5] 。<br>可能有其他方法将数组变为 K 递增的，但没有任何一种方法需要的操作次数小于 2 次。</p><p>提示：<br>1 &lt;= arr.length &lt;= 105<br>1 &lt;= arr[i], k &lt;= arr.length</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">审题：这题着实没想到，一上来就以为是DFS，后面想着修改了矩阵可能会导致其他位置元素不满足，然后搞个循环继续dfs。最后看题解其实是分组LIS，确实挺难的。</span><br><span class="line"></span><br><span class="line">评论的C++题解 https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-k-increasing/solution/fen-zu-lis-by-elegant-kapitsaexi-prmn/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前三道题很简单，半个小时完成，最后一道题着实有点难，思路都错了，最后排名1695 / 4697。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://dlc1994.github.io/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
      <category term="Week-contest" scheme="https://dlc1994.github.io/tags/Week-contest/"/>
    
      <category term="LIS" scheme="https://dlc1994.github.io/tags/LIS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Weekly Contest 271</title>
    <link href="https://dlc1994.github.io/2021/12/12/cl0zeby7m0012p45ct49kw66n/"/>
    <id>https://dlc1994.github.io/2021/12/12/cl0zeby7m0012p45ct49kw66n/</id>
    <published>2021-12-12T04:00:00.000Z</published>
    <updated>2022-01-17T15:24:32.937Z</updated>
    
    <content type="html"><![CDATA[<p>这次的题挺简单的，早上起这么早，困的不行下去买了杯瑞幸，喝的好腻犯恶心，状态这么差还是半个小时就写完3道题了，最后一道题差一点就写出来了，走去聚餐的路上想到思路了，最后排名1087 / 4561。可惜，差点达成第一次ak的操作，下次一定！<br><a id="more"></a></p><h1 id="5952-环和杆-EASY"><a href="#5952-环和杆-EASY" class="headerlink" title="5952. 环和杆 [EASY]"></a>5952. 环和杆 [EASY]</h1><p>总计有 n 个环，环的颜色可以是红、绿、蓝中的一种。这些环分布穿在 10 根编号为 0 到 9 的杆上。</p><p>给你一个长度为 2n 的字符串 rings ，表示这 n 个环在杆上的分布。rings 中每两个字符形成一个 颜色位置对 ，用于描述每个环：</p><p>第 i 对中的 第一个 字符表示第 i 个环的 颜色（’R’、’G’、’B’）。<br>第 i 对中的 第二个 字符表示第 i 个环的 位置，也就是位于哪根杆上（’0’ 到 ‘9’）。<br>例如，”R3G2B1” 表示：共有 n == 3 个环，红色的环在编号为 3 的杆上，绿色的环在编号为 2 的杆上，蓝色的环在编号为 1 的杆上。</p><p>找出所有集齐 全部三种颜色 环的杆，并返回这种杆的数量。</p><p>示例 1：<br>输入：rings = “B0B6G0R6R0R6G9”<br>输出：1<br>解释：</p><ul><li>编号 0 的杆上有 3 个环，集齐全部颜色：红、绿、蓝。</li><li>编号 6 的杆上有 3 个环，但只有红、蓝两种颜色。</li><li>编号 9 的杆上只有 1 个绿色环。<br>因此，集齐全部三种颜色环的杆的数目为 1 。</li></ul><p>示例 2：<br>输入：rings = “B0R0G0R9R0B0G0”<br>输出：1<br>解释：</p><ul><li>编号 0 的杆上有 6 个环，集齐全部颜色：红、绿、蓝。</li><li>编号 9 的杆上只有 1 个红色环。<br>因此，集齐全部三种颜色环的杆的数目为 1 。</li></ul><p>示例 3：<br>输入：rings = “G4”<br>输出：0<br>解释：<br>只给了一个环，因此，不存在集齐全部三种颜色环的杆。</p><p>提示：<br>rings.length == 2 * n<br>1 &lt;= n &lt;= 100<br>如 i 是 偶数 ，则 rings[i] 的值可以取 ‘R’、’G’ 或 ‘B’（下标从 0 开始计数）<br>如 i 是 奇数 ，则 rings[i] 的值可以取 ‘0’ 到 ‘9’ 中的一个数字（下标从 0 开始计数）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">审题：</span><br><span class="line">挺简单的</span><br><span class="line">1. 遍历一遍，记录每个环三个颜色的数量</span><br><span class="line">2. 遍历一遍所有环，如果每个环都有三个颜色就++</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    enum color &#123;</span><br><span class="line">        RED = 0, </span><br><span class="line">        GREEN = 1,</span><br><span class="line">        BLUE = 2</span><br><span class="line">    &#125;;</span><br><span class="line">    int countPoints(string rings) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; sticks(10, vector&lt;int&gt;(3, 0));</span><br><span class="line">        int i = 0;</span><br><span class="line">        while (i &lt; rings.size()) &#123;</span><br><span class="line">            if (rings[i] == &apos;R&apos;) &#123;</span><br><span class="line">                sticks[rings[i + 1] - &apos;0&apos;][RED]++;</span><br><span class="line">            &#125; else if (rings[i] == &apos;G&apos;) &#123;</span><br><span class="line">                sticks[rings[i + 1] - &apos;0&apos;][GREEN]++;</span><br><span class="line">            &#125; else if (rings[i] == &apos;B&apos;) &#123;</span><br><span class="line">                sticks[rings[i + 1] - &apos;0&apos;][BLUE]++;</span><br><span class="line">            &#125;</span><br><span class="line">            i += 2;</span><br><span class="line">        &#125;</span><br><span class="line">        int num = 0;</span><br><span class="line">        for (auto&amp; stick : sticks) &#123;</span><br><span class="line">            num += (stick[0] &gt; 0 &amp;&amp; stick[1] &gt; 0 &amp;&amp; stick[2] &gt; 0);</span><br><span class="line">        &#125;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="5953-子数组范围和-MEDIUM"><a href="#5953-子数组范围和-MEDIUM" class="headerlink" title="5953. 子数组范围和 [MEDIUM]"></a>5953. 子数组范围和 [MEDIUM]</h1><p>给你一个整数数组 nums 。nums 中，子数组的 范围 是子数组中最大元素和最小元素的差值。</p><p>返回 nums 中 所有 子数组范围的 和 。</p><p>子数组是数组中一个连续 非空 的元素序列。</p><p>示例 1：<br>输入：nums = [1,2,3]<br>输出：4<br>解释：nums 的 6 个子数组如下所示：<br>[1]，范围 = 最大 - 最小 = 1 - 1 = 0<br>[2]，范围 = 2 - 2 = 0<br>[3]，范围 = 3 - 3 = 0<br>[1,2]，范围 = 2 - 1 = 1<br>[2,3]，范围 = 3 - 2 = 1<br>[1,2,3]，范围 = 3 - 1 = 2<br>所有范围的和是 0 + 0 + 0 + 1 + 1 + 2 = 4</p><p>示例 2：<br>输入：nums = [1,3,3]<br>输出：4<br>解释：nums 的 6 个子数组如下所示：<br>[1]，范围 = 最大 - 最小 = 1 - 1 = 0<br>[3]，范围 = 3 - 3 = 0<br>[3]，范围 = 3 - 3 = 0<br>[1,3]，范围 = 3 - 1 = 2<br>[3,3]，范围 = 3 - 3 = 0<br>[1,3,3]，范围 = 3 - 1 = 2<br>所有范围的和是 0 + 0 + 0 + 2 + 0 + 2 = 4</p><p>示例 3：<br>输入：nums = [4,-2,-3,4,1]<br>输出：59<br>解释：nums 中所有子数组范围的和是 59</p><p>提示：</p><p>1 &lt;= nums.length &lt;= 1000<br>-109 &lt;= nums[i] &lt;= 109<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">审题：暴力法，果不其然超时了（这该死的侥幸心理）</span><br><span class="line">乖乖滑动窗口，pass</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    long long subArrayRanges(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int length = nums.size();</span><br><span class="line">        long long int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; length; ++i) &#123;</span><br><span class="line">            int maximum = nums[i];</span><br><span class="line">            int minimum = nums[i];</span><br><span class="line">            for (int j = i + 1; j &lt; length; ++j) &#123;</span><br><span class="line">                // auto result = *std::max_element(nums.begin() + i, nums.begin() + j + 1) - *std::min_element(nums.begin() + i, nums.begin() + j + 1);</span><br><span class="line">                // // cout &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; j &lt;&lt; &quot;, &quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">                // sum += result;</span><br><span class="line">                if (nums[j] &gt; maximum) &#123;</span><br><span class="line">                    maximum = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                if (nums[j] &lt; minimum) &#123;</span><br><span class="line">                    minimum = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                sum += maximum - minimum;</span><br><span class="line">                // cout &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; j &lt;&lt; &quot;, &quot; &lt;&lt; minimum &lt;&lt; &quot;, &quot; &lt;&lt; maximum &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="5954-给植物浇水-II-MEDIUM"><a href="#5954-给植物浇水-II-MEDIUM" class="headerlink" title="5954. 给植物浇水 II [MEDIUM]"></a>5954. 给植物浇水 II [MEDIUM]</h1><p>Alice 和 Bob 打算给花园里的 n 株植物浇水。植物排成一行，从左到右进行标记，编号从 0 到 n - 1 。其中，第 i 株植物的位置是 x = i 。</p><p>每一株植物都需要浇特定量的水。Alice 和 Bob 每人有一个水罐，最初是满的 。他们按下面描述的方式完成浇水：</p><p> Alice 按 从左到右 的顺序给植物浇水，从植物 0 开始。Bob 按 从右到左 的顺序给植物浇水，从植物 n - 1 开始。他们 同时 给植物浇水。<br>如果没有足够的水 完全 浇灌下一株植物，他 / 她会立即重新灌满浇水罐。<br>不管植物需要多少水，浇水所耗费的时间都是一样的。<br>不能 提前重新灌满水罐。<br>每株植物都可以由 Alice 或者 Bob 来浇水。<br>如果 Alice 和 Bob 到达同一株植物，那么当前水罐中水更多的人会给这株植物浇水。如果他俩水量相同，那么 Alice 会给这株植物浇水。<br>给你一个下标从 0 开始的整数数组 plants ，数组由 n 个整数组成。其中，plants[i] 为第 i 株植物需要的水量。另有两个整数 capacityA 和 capacityB 分别表示 Alice 和 Bob 水罐的容量。返回两人浇灌所有植物过程中重新灌满水罐的 次数 。</p><p>示例 1：<br>输入：plants = [2,2,3,3], capacityA = 5, capacityB = 5<br>输出：1<br>解释：</p><ul><li>最初，Alice 和 Bob 的水罐中各有 5 单元水。</li><li>Alice 给植物 0 浇水，Bob 给植物 3 浇水。</li><li>Alice 和 Bob 现在分别剩下 3 单元和 2 单元水。</li><li>Alice 有足够的水给植物 1 ，所以她直接浇水。Bob 的水不够给植物 2 ，所以他先重新装满水，再浇水。<br>所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 + 0 + 1 + 0 = 1 。</li></ul><p>示例 2：<br>输入：plants = [2,2,3,3], capacityA = 3, capacityB = 4<br>输出：2<br>解释：</p><ul><li>最初，Alice 的水罐中有 3 单元水，Bob 的水罐中有 4 单元水。</li><li>Alice 给植物 0 浇水，Bob 给植物 3 浇水。</li><li>Alice 和 Bob 现在都只有 1 单元水，并分别需要给植物 1 和植物 2 浇水。</li><li>由于他们的水量均不足以浇水，所以他们重新灌满水罐再进行浇水。<br>所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 + 1 + 1 + 0 = 2 。</li></ul><p>示例 3：<br>输入：plants = [5], capacityA = 10, capacityB = 8<br>输出：0<br>解释：</p><ul><li>只有一株植物</li><li>Alice 的水罐有 10 单元水，Bob 的水罐有 8 单元水。因此 Alice 的水罐中水更多，她会给这株植物浇水。<br>所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 。</li></ul><p>示例 4：<br>输入：plants = [1,2,4,4,5], capacityA = 6, capacityB = 5<br>输出：2<br>解释：</p><ul><li>最初，Alice 的水罐中有 6 单元水，Bob 的水罐中有 5 单元水。</li><li>Alice 给植物 0 浇水，Bob 给植物 4 浇水。</li><li>Alice 和 Bob 现在分别剩下 5 单元和 0 单元水。</li><li>Alice 有足够的水给植物 1 ，所以她直接浇水。Bob 的水不够给植物 3 ，所以他先重新装满水，再浇水。</li><li>Alice 和 Bob 现在分别剩下 3 单元和 1 单元水。</li><li>由于 Alice 的水更多，所以由她给植物 2 浇水。然而，她水罐里的水不够给植物 2 ，所以她先重新装满水，再浇水。<br>所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 + 0 + 1 + 1 + 0 = 2 。</li></ul><p>示例 5：<br>输入：plants = [2,2,5,2,2], capacityA = 5, capacityB = 5<br>输出：1<br>解释：<br>Alice 和 Bob 都会到达中间的植物，并且此时他俩剩下的水量相同，所以 Alice 会给这株植物浇水。<br>由于她到达时只剩下 1 单元水，所以需要重新灌满水罐。<br>这是唯一一次需要重新灌满水罐的情况。所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 1 。</p><p>提示：<br>n == plants.length<br>1 &lt;= n &lt;= 105<br>1 &lt;= plants[i] &lt;= 106<br>max(plants[i]) &lt;= capacityA, capacityB &lt;= 109</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">审题：easy case，左右各管各的，到同一位置的时候判断一下特殊情况就可以了，代码写的有点丑，committer就这？</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minimumRefill(vector&lt;int&gt;&amp; plants, int capacityA, int capacityB) &#123;</span><br><span class="line">        int length = plants.size();</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = length - 1;</span><br><span class="line">        int result = 0;</span><br><span class="line">        int resA = capacityA;</span><br><span class="line">        int resB = capacityB;</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            if (left == right) &#123;</span><br><span class="line">                if (resA &gt;= plants[left]) &#123;</span><br><span class="line">                    // alice够水</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // alice不够</span><br><span class="line">                    if (resB &gt;= plants[left]) &#123;</span><br><span class="line">                        // bob够</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 两个都不够浇水, alice 充满浇水</span><br><span class="line">                        result++;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (resA &gt;= plants[left]) &#123;</span><br><span class="line">                // alice还够</span><br><span class="line">                resA -= plants[left];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // alice不够了,充满再浇水一次</span><br><span class="line">                result++;</span><br><span class="line">                resA = capacityA - plants[left];</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            </span><br><span class="line">            if (resB &gt;= plants[right]) &#123;</span><br><span class="line">                resB -= plants[right];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result++;</span><br><span class="line">                resB = capacityB - plants[right];</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="5955-摘水果-HARD"><a href="#5955-摘水果-HARD" class="headerlink" title="5955. 摘水果 [HARD]"></a>5955. 摘水果 [HARD]</h1><p>在一个无限的 x 坐标轴上，有许多水果分布在其中某些位置。给你一个二维整数数组 fruits ，其中 fruits[i] = [positioni, amounti] 表示共有 amounti 个水果放置在 positioni 上。fruits 已经按 positioni 升序排列 ，每个 positioni 互不相同 。</p><p>另给你两个整数 startPos 和 k 。最初，你位于 startPos 。从任何位置，你可以选择 向左或者向右 走。在 x 轴上每移动 一个单位 ，就记作 一步 。你总共可以走 最多 k 步。你每达到一个位置，都会摘掉全部的水果，水果也将从该位置消失（不会再生）。</p><p>返回你可以摘到水果的 最大总数 。</p><p>示例 1：<br>输入：fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4<br>输出：9<br>解释：<br>最佳路线为：</p><ul><li>向右移动到位置 6 ，摘到 3 个水果</li><li>向右移动到位置 8 ，摘到 6 个水果<br>移动 3 步，共摘到 3 + 6 = 9 个水果</li></ul><p>示例 2：<br>输入：fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4<br>输出：14<br>解释：<br>可以移动最多 k = 4 步，所以无法到达位置 0 和位置 10 。<br>最佳路线为：</p><ul><li>在初始位置 5 ，摘到 7 个水果</li><li>向左移动到位置 4 ，摘到 1 个水果</li><li>向右移动到位置 6 ，摘到 2 个水果</li><li>向右移动到位置 7 ，摘到 4 个水果<br>移动 1 + 3 = 4 步，共摘到 7 + 1 + 2 + 4 = 14 个水果</li></ul><p>示例 3：<br>输入：fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2<br>输出：0<br>解释：<br>最多可以移动 k = 2 步，无法到达任一有水果的地方</p><p>提示：<br>1 &lt;= fruits.length &lt;= 105<br>fruits[i].length == 2<br>0 &lt;= startPos, positioni &lt;= 2 <em> 105<br>对于任意 i &gt; 0 ，positioni-1 &lt; positioni 均成立（下标从 0 开始计数）<br>1 &lt;= amounti &lt;= 104<br>0 &lt;= k &lt;= 2 </em> 105</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">审题：这题一上来思路没错，是用dfs，但是尺度搞错了，不应该一步一步走，看到排好序就应该知道走的尺度应该是一个个的坐标轴，附上超时代码</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxFruits = 0;</span><br><span class="line">    int miniPos = 0;</span><br><span class="line">    int maxiPos = 0;</span><br><span class="line">    void dfs(int currentPos, int currentFruit, int resStep, int resFruit, vector&lt;int&gt;&amp; path)</span><br><span class="line">    &#123;</span><br><span class="line">        // cout &lt;&lt; currentPos &lt;&lt; &quot;, &quot; &lt;&lt; currentFruit &lt;&lt; &quot;, &quot; &lt;&lt; resStep &lt;&lt; endl;</span><br><span class="line">        if (resStep &lt; 0 || !resFruit || currentPos &lt; miniPos || currentPos &gt; maxiPos) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        currentFruit += path[currentPos];</span><br><span class="line">        if (path[currentPos] &gt; 0) &#123;</span><br><span class="line">            resFruit--;</span><br><span class="line">        &#125;</span><br><span class="line">        if (currentFruit &gt; maxFruits) &#123;</span><br><span class="line">            maxFruits = currentFruit;</span><br><span class="line">        &#125;</span><br><span class="line">        path[currentPos] = 0;</span><br><span class="line">        // left</span><br><span class="line">        int restore = -1;</span><br><span class="line">        if (currentPos - 1 &gt;= 0) &#123;</span><br><span class="line">            restore = path[currentPos - 1];</span><br><span class="line">        &#125; </span><br><span class="line">        dfs(currentPos - 1, currentFruit, resStep - 1, resFruit, path);</span><br><span class="line">        if (restore != -1) &#123;</span><br><span class="line">            path[currentPos - 1] = restore;</span><br><span class="line">            restore = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // right</span><br><span class="line">        if (currentPos + 1 &lt;= maxiPos) &#123;</span><br><span class="line">            restore = path[currentPos + 1];</span><br><span class="line">        &#125; </span><br><span class="line">        dfs(currentPos + 1, currentFruit, resStep - 1, resFruit, path);</span><br><span class="line">        if (restore != -1) &#123;</span><br><span class="line">            path[currentPos + 1] = restore;</span><br><span class="line">            restore = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int maxTotalFruits(vector&lt;vector&lt;int&gt;&gt;&amp; fruits, int startPos, int k) &#123;</span><br><span class="line">        int length = fruits.size();</span><br><span class="line">        maxiPos = fruits[length - 1][0];</span><br><span class="line">        int resFruit = length;</span><br><span class="line">        vector&lt;int&gt; path(maxiPos + 1, 0);</span><br><span class="line">        for (auto&amp; fruit : fruits) &#123;</span><br><span class="line">            path[fruit[0]] = fruit[1];</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(startPos, 0, k, resFruit, path);</span><br><span class="line">        return maxFruits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次的题挺简单的，早上起这么早，困的不行下去买了杯瑞幸，喝的好腻犯恶心，状态这么差还是半个小时就写完3道题了，最后一道题差一点就写出来了，走去聚餐的路上想到思路了，最后排名1087 / 4561。可惜，差点达成第一次ak的操作，下次一定！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://dlc1994.github.io/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
      <category term="Week-contest" scheme="https://dlc1994.github.io/tags/Week-contest/"/>
    
      <category term="BFS" scheme="https://dlc1994.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode biweekly-contest-67</title>
    <link href="https://dlc1994.github.io/2021/12/11/cl0zeby7f000tp45cxm86d4pm/"/>
    <id>https://dlc1994.github.io/2021/12/11/cl0zeby7f000tp45cxm86d4pm/</id>
    <published>2021-12-11T14:30:00.000Z</published>
    <updated>2022-01-17T15:24:19.473Z</updated>
    
    <content type="html"><![CDATA[<p>今天加班了一天，回家已经好累了，洗个澡精神一下继续冲题了，不知道是不是题目比较简单还是自己提高了，状态这么差每道题还都有思路，第二道题和第四道题超时了，实在没脑子了，第一次进1000，排名711 / 2923<br><a id="more"></a></p><h1 id="5934-找到和最大的长度为-K-的子序列-EASY"><a href="#5934-找到和最大的长度为-K-的子序列-EASY" class="headerlink" title="5934. 找到和最大的长度为 K 的子序列[EASY]"></a>5934. 找到和最大的长度为 K 的子序列[EASY]</h1><p>给你一个整数数组 nums 和一个整数 k 。你需要找到 nums 中长度为 k 的 子序列 ，且这个子序列的 和最大 。</p><p>请你返回 任意 一个长度为 k 的整数子序列。</p><p>子序列 定义为从一个数组里删除一些元素后，不改变剩下元素的顺序得到的数组。</p><p>示例 1：<br>输入：nums = [2,1,3,3], k = 2<br>输出：[3,3]<br>解释：<br>子序列有最大和：3 + 3 = 6 。</p><p>示例 2：<br>输入：nums = [-1,-2,3,4], k = 3<br>输出：[-1,3,4]<br>解释：<br>子序列有最大和：-1 + 3 + 4 = 6 。</p><p>示例 3：<br>输入：nums = [3,4,3,3], k = 2<br>输出：[3,4]<br>解释：<br>子序列有最大和：3 + 4 = 7 。<br>另一个可行的子序列为 [4, 3] 。</p><p>提示：<br>1 &lt;= nums.length &lt;= 1000<br>-105 &lt;= nums[i] &lt;= 105<br>1 &lt;= k &lt;= nums.length</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">审题：</span><br><span class="line">这题搞复杂了，当时脑子的思路是</span><br><span class="line">1. 先push index和value</span><br><span class="line">2. 对value排个序</span><br><span class="line">3. 取出前k个index和value的pair</span><br><span class="line">4. 再对index排序</span><br><span class="line"></span><br><span class="line">实际可以这样</span><br><span class="line">1. push index和value</span><br><span class="line">2. 直接对value和index排序，value从大到小，index从小到大</span><br><span class="line">这样直接输出就ok了</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxSubsequence(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; indexValue(nums.size(), vector&lt;int&gt;(2, 0));</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            indexValue[i][0] = i;</span><br><span class="line">            indexValue[i][1] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(indexValue.begin(), indexValue.end(), [](const vector&lt;int&gt;&amp; x, const vector&lt;int&gt;&amp; y) &#123;</span><br><span class="line">            return x[1] &gt; y[1];</span><br><span class="line">        &#125;);</span><br><span class="line">        // for (auto&amp; i : indexValue) &#123;</span><br><span class="line">        //     cout &lt;&lt; i[0] &lt;&lt; &quot;, &quot; &lt;&lt; i[1] &lt;&lt; endl;</span><br><span class="line">        // &#125;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res(k, vector&lt;int&gt;());</span><br><span class="line">        for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">            res[i] = indexValue[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(res.begin(), res.end(), [](const vector&lt;int&gt;&amp; x, const vector&lt;int&gt;&amp; y) &#123;</span><br><span class="line">            return x[0] &lt; y[0];</span><br><span class="line">        &#125;);</span><br><span class="line">        vector&lt;int&gt; result(k);</span><br><span class="line">        for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">            result[i] = res[i][1];</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="5935-适合打劫银行的日子-MEDIUM"><a href="#5935-适合打劫银行的日子-MEDIUM" class="headerlink" title="5935. 适合打劫银行的日子 [MEDIUM]"></a>5935. 适合打劫银行的日子 [MEDIUM]</h1><p>你和一群强盗准备打劫银行。给你一个下标从 0 开始的整数数组 security ，其中 security[i] 是第 i 天执勤警卫的数量。日子从 0 开始编号。同时给你一个整数 time 。</p><p>如果第 i 天满足以下所有条件，我们称它为一个适合打劫银行的日子：</p><p>第 i 天前和后都分别至少有 time 天。<br>第 i 天前连续 time 天警卫数目都是非递增的。<br>第 i 天后连续 time 天警卫数目都是非递减的。<br>更正式的，第 i 天是一个合适打劫银行的日子当且仅当：security[i - time] &gt;= security[i - time + 1] &gt;= … &gt;= security[i] &lt;= … &lt;= security[i + time - 1] &lt;= security[i + time].</p><p>请你返回一个数组，包含 所有 适合打劫银行的日子（下标从 0 开始）。返回的日子可以 任意 顺序排列。</p><p>示例 1：<br>输入：security = [5,3,3,3,5,6,2], time = 2<br>输出：[2,3]<br>解释：<br>第 2 天，我们有 security[0] &gt;= security[1] &gt;= security[2] &lt;= security[3] &lt;= security[4] 。<br>第 3 天，我们有 security[1] &gt;= security[2] &gt;= security[3] &lt;= security[4] &lt;= security[5] 。<br>没有其他日子符合这个条件，所以日子 2 和 3 是适合打劫银行的日子。</p><p>示例 2：<br>输入：security = [1,1,1,1,1], time = 0<br>输出：[0,1,2,3,4]<br>解释：<br>因为 time 等于 0 ，所以每一天都是适合打劫银行的日子，所以返回每一天。</p><p>示例 3：<br>输入：security = [1,2,3,4,5,6], time = 2<br>输出：[]<br>解释：<br>没有任何一天的前 2 天警卫数目是非递增的。<br>所以没有适合打劫银行的日子，返回空数组。</p><p>示例 4：<br>输入：security = [1], time = 5<br>输出：[]<br>解释：<br>没有日子前面和后面有 5 天时间。<br>所以没有适合打劫银行的日子，返回空数组。</p><p>提示：<br>1 &lt;= security.length &lt;= 105<br>0 &lt;= security[i], time &lt;= 105<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">审题：银行出的题搞了个打劫的题目，也是挺搞笑的。先写了一道暴力破解的题，果不其然超时了（心存侥幸）。后面想到了一种方法：</span><br><span class="line">1. 从左到右遍历一遍，动态拿到每个位置的最大</span><br><span class="line">2. 从右到左遍历一遍，动态拿到每个位置的最大递减（从左到右看就是递增）</span><br><span class="line">3. 再遍历一遍，找到左右的最大递增递减的长度大于time的</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    inline bool isGoodRobDay(int i, vector&lt;int&gt;&amp; security, int time)</span><br><span class="line">    &#123;</span><br><span class="line">        int minimum = INT_MAX;</span><br><span class="line">        for (int day = i - time; day &lt;= i; day++) &#123;</span><br><span class="line">            if (security[day] &lt;= minimum) &#123;</span><br><span class="line">                minimum = security[day];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int maximum = -INT_MAX;</span><br><span class="line">        for (int day = i; day &lt;= i + time; day++) &#123;</span><br><span class="line">            if (security[day] &gt;= maximum) &#123;</span><br><span class="line">                maximum = security[day];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; goodDaysToRobBank(vector&lt;int&gt;&amp; security, int time) &#123;</span><br><span class="line">        int days = security.size();</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        for (int i = time; i &lt; days - time; i++) &#123;</span><br><span class="line">            if (isGoodRobDay(i, security, time)) &#123;</span><br><span class="line">                result.emplace_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="5936-引爆最多的炸弹-MEDIUM"><a href="#5936-引爆最多的炸弹-MEDIUM" class="headerlink" title="5936. 引爆最多的炸弹[MEDIUM]"></a>5936. 引爆最多的炸弹[MEDIUM]</h1><p>给你一个炸弹列表。一个炸弹的 爆炸范围 定义为以炸弹为圆心的一个圆。</p><p>炸弹用一个下标从 0 开始的二维整数数组 bombs 表示，其中 bombs[i] = [xi, yi, ri] 。xi 和 yi 表示第 i 个炸弹的 X 和 Y 坐标，ri 表示爆炸范围的 半径 。</p><p>你需要选择引爆 一个 炸弹。当这个炸弹被引爆时，所有 在它爆炸范围内的炸弹都会被引爆，这些炸弹会进一步将它们爆炸范围内的其他炸弹引爆。</p><p>给你数组 bombs ，请你返回在引爆 一个 炸弹的前提下，最多 能引爆的炸弹数目。</p><p>示例 1：<br>输入：bombs = [[2,1,3],[6,1,4]]<br>输出：2<br>解释：<br>上图展示了 2 个炸弹的位置和爆炸范围。<br>如果我们引爆左边的炸弹，右边的炸弹不会被影响。<br>但如果我们引爆右边的炸弹，两个炸弹都会爆炸。<br>所以最多能引爆的炸弹数目是 max(1, 2) = 2 。</p><p>示例 2：<br>输入：bombs = [[1,1,5],[10,10,5]]<br>输出：1<br>解释：<br>引爆任意一个炸弹都不会引爆另一个炸弹。所以最多能引爆的炸弹数目为 1 。</p><p>示例 3：<br>输入：bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]<br>输出：5<br>解释：<br>最佳引爆炸弹为炸弹 0 ，因为：</p><ul><li>炸弹 0 引爆炸弹 1 和 2 。红色圆表示炸弹 0 的爆炸范围。</li><li>炸弹 2 引爆炸弹 3 。蓝色圆表示炸弹 2 的爆炸范围。</li><li>炸弹 3 引爆炸弹 4 。绿色圆表示炸弹 3 的爆炸范围。<br>所以总共有 5 个炸弹被引爆。</li></ul><p>提示：<br>1 &lt;= bombs.length &lt;= 100<br>bombs[i].length == 3<br>1 &lt;= xi, yi, ri &lt;= 105</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">审题：这题做出来很开心，因为之前碰到BFS的题除了二叉树层序遍历都没做出来过（又想起在学校实习面微软3面就差BFS做出来了，可惜可恨，人生轨迹都变了）。回到正题，这题思路这样的：</span><br><span class="line">1. 计算每个炸弹是否能炸到其他炸弹，存个矩阵</span><br><span class="line">2. 遍历每个炸弹</span><br><span class="line">3. 用BFS，能炸到的不重复的炸弹放进stack里面，每次pop一个看它还能不能炸到其他不重复的炸弹，直到stack为空</span><br><span class="line"></span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int BFS(int i, vector&lt;vector&lt;int&gt;&gt;&amp; bombMap, vector&lt;vector&lt;int&gt;&gt;&amp; bombs)</span><br><span class="line">    &#123;</span><br><span class="line">        int m = bombs.size();</span><br><span class="line">        stack&lt;int&gt; bombStack;</span><br><span class="line">        bombStack.push(i);</span><br><span class="line">        int number = 0;</span><br><span class="line">        vector&lt;bool&gt; visited(m, false);</span><br><span class="line">        while (!bombStack.empty()) &#123;</span><br><span class="line">            int top = bombStack.top();</span><br><span class="line">            bombStack.pop();</span><br><span class="line">            if (visited[top]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            visited[top] = true;</span><br><span class="line">            for (int k = 0; k &lt; m; k++) &#123;</span><br><span class="line">                if (bombMap[top][k]) &#123;</span><br><span class="line">                    bombStack.push(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int maximumDetonation(vector&lt;vector&lt;int&gt;&gt;&amp; bombs) &#123;</span><br><span class="line">        int m = bombs.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; bombMap(m, vector&lt;int&gt;(m, 0));</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; m; j++) &#123;</span><br><span class="line">                double x = (bombs[i][0] - bombs[j][0]);</span><br><span class="line">                double y = (bombs[i][1] - bombs[j][1]);</span><br><span class="line">                double distance = sqrt(x * x + y * y);</span><br><span class="line">                if (distance &lt;= bombs[i][2]) &#123;</span><br><span class="line">                    bombMap[i][j] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">                if (distance &lt;= bombs[j][2]) &#123;</span><br><span class="line">                    bombMap[j][i] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int maxBomb = 0;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            int numBomb = BFS(i, bombMap, bombs);</span><br><span class="line">            // cout &lt;&lt; &quot;numbBomb &quot; &lt;&lt; numBomb &lt;&lt; endl;</span><br><span class="line">            if (numBomb &gt; maxBomb) &#123;</span><br><span class="line">                maxBomb = numBomb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">//         for (auto&amp; bomb : bombMap) &#123;</span><br><span class="line">//             for (auto&amp; dis : bomb) &#123;</span><br><span class="line">//                 cout &lt;&lt; dis &lt;&lt; &quot;, &quot;;</span><br><span class="line">//             &#125;</span><br><span class="line">//             cout &lt;&lt; endl;</span><br><span class="line">//         &#125;</span><br><span class="line">        return maxBomb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="5937-序列顺序查询-HARD"><a href="#5937-序列顺序查询-HARD" class="headerlink" title="5937. 序列顺序查询 [HARD]"></a>5937. 序列顺序查询 [HARD]</h1><p>一个观光景点由它的名字 name 和景点评分 score 组成，其中 name 是所有观光景点中 唯一 的字符串，score 是一个整数。景点按照最好到最坏排序。景点评分 越高 ，这个景点越好。如果有两个景点的评分一样，那么 字典序较小 的景点更好。</p><p>你需要搭建一个系统，查询景点的排名。初始时系统里没有任何景点。这个系统支持：</p><p>添加 景点，每次添加 一个 景点。<br>查询 已经添加景点中第 i 好 的景点，其中 i 是系统目前位置查询的次数（包括当前这一次）。<br>比方说，如果系统正在进行第 4 次查询，那么需要返回所有已经添加景点中第 4 好的。<br>注意，测试数据保证 任意查询时刻 ，查询次数都 不超过 系统中景点的数目。</p><p>请你实现 SORTracker 类：</p><p>SORTracker() 初始化系统。<br>void add(string name, int score) 向系统中添加一个名为 name 评分为 score 的景点。<br>string get() 查询第 i 好的景点，其中 i 是目前系统查询的次数（包括当前这次查询）。</p><p>示例：</p><p>输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&quot;SORTracker&quot;, &quot;add&quot;, &quot;add&quot;, &quot;get&quot;, &quot;add&quot;, &quot;get&quot;, &quot;add&quot;, &quot;get&quot;, &quot;add&quot;, &quot;get&quot;, &quot;add&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[], [&quot;bradford&quot;, 2], [&quot;branford&quot;, 3], [], [&quot;alps&quot;, 2], [], [&quot;orland&quot;, 2], [], [&quot;orlando&quot;, 3], [], [&quot;alpine&quot;, 2], [], [\]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, &quot;branford&quot;, null, &quot;alps&quot;, null, &quot;bradford&quot;, null, &quot;bradford&quot;, null, &quot;bradford&quot;, &quot;orland&quot;]</span><br></pre></td></tr></table></figure></p><p>解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SORTracker tracker = new SORTracker(); // 初始化系统</span><br><span class="line">tracker.add(&quot;bradford&quot;, 2); // 添加 name=&quot;bradford&quot; 且 score=2 的景点。</span><br><span class="line">tracker.add(&quot;branford&quot;, 3); // 添加 name=&quot;branford&quot; 且 score=3 的景点。</span><br><span class="line">tracker.get();              // 从好带坏的景点为：branford ，bradford 。</span><br><span class="line">                            // 注意到 branford 比 bradford 好，因为它的 评分更高 (3 &gt; 2) 。</span><br><span class="line">                            // 这是第 1 次调用 get() ，所以返回最好的景点：&quot;branford&quot; 。</span><br><span class="line">tracker.add(&quot;alps&quot;, 2);     // 添加 name=&quot;alps&quot; 且 score=2 的景点。</span><br><span class="line">tracker.get();              // 从好到坏的景点为：branford, alps, bradford 。</span><br><span class="line">                            // 注意 alps 比 bradford 好，虽然它们评分相同，都为 2 。</span><br><span class="line">                            // 这是因为 &quot;alps&quot; 字典序 比 &quot;bradford&quot; 小。</span><br><span class="line">                            // 返回第 2 好的地点 &quot;alps&quot; ，因为当前为第 2 次调用 get() 。</span><br><span class="line">tracker.add(&quot;orland&quot;, 2);   // 添加 name=&quot;orland&quot; 且 score=2 的景点。</span><br><span class="line">tracker.get();              // 从好到坏的景点为：branford, alps, bradford, orland 。</span><br><span class="line">                            // 返回 &quot;bradford&quot; ，因为当前为第 3 次调用 get() 。</span><br><span class="line">tracker.add(&quot;orlando&quot;, 3);  // 添加 name=&quot;orlando&quot; 且 score=3 的景点。</span><br><span class="line">tracker.get();              // 从好到坏的景点为：branford, orlando, alps, bradford, orland 。</span><br><span class="line">                            // 返回 &quot;bradford&quot;.</span><br><span class="line">tracker.add(&quot;alpine&quot;, 2);   // 添加 name=&quot;alpine&quot; 且 score=2 的景点。</span><br><span class="line">tracker.get();              // 从好到坏的景点为：branford, orlando, alpine, alps, bradford, orland 。</span><br><span class="line">                            // 返回 &quot;bradford&quot; 。</span><br><span class="line">tracker.get();              // 从好到坏的景点为：branford, orlando, alpine, alps, bradford, orland 。</span><br><span class="line">                            // 返回 &quot;orland&quot; 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><p>name 只包含小写英文字母，且每个景点名字互不相同。<br>1 &lt;= name.length &lt;= 10<br>1 &lt;= score &lt;= 105<br>任意时刻，调用 get 的次数都不超过调用 add 的次数。<br>总共 调用 add 和 get 不超过 4 * 104 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">审题：这题系统题，基本都是考数据结构，不懂为啥会超时，可能是vector insert的时候需要移动元素太慢了吧，应该用个可以排序的非连续存储的数据结构比如set或者hashmap之类的就可以</span><br><span class="line"></span><br><span class="line">class SORTracker &#123;</span><br><span class="line">public:</span><br><span class="line">    SORTracker() &#123;</span><br><span class="line">        sites_.resize(4e4 + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void add(string name, int score) &#123;</span><br><span class="line">        // auto pos = std::lower_bound(sites_.begin(), sites_.end(), make_pair(name, score), </span><br><span class="line">        //                            [](const pair&lt;string, int&gt;&amp; x, const pair&lt;string, int&gt;&amp; y) &#123;</span><br><span class="line">        //                               if (x.second != y.second) &#123;</span><br><span class="line">        //                                   return x.second &gt; y.second;</span><br><span class="line">        //                               &#125; else &#123;</span><br><span class="line">        //                                   return x.first &lt; y.first;</span><br><span class="line">        //                               &#125;</span><br><span class="line">        //                            &#125;);</span><br><span class="line">        // sites_.insert(pos, make_pair(name, score));</span><br><span class="line">        sites_.emplace_back(make_pair(name, score));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    string get() &#123;</span><br><span class="line">        sort(sites_.begin(), sites_.end(), </span><br><span class="line">                                   [](const pair&lt;string, int&gt;&amp; x, const pair&lt;string, int&gt;&amp; y) &#123;</span><br><span class="line">                                      if (x.second != y.second) &#123;</span><br><span class="line">                                          return x.second &gt; y.second;</span><br><span class="line">                                      &#125; else &#123;</span><br><span class="line">                                          return x.first &lt; y.first;</span><br><span class="line">                                      &#125;</span><br><span class="line">                                   &#125;);</span><br><span class="line">        return sites_[currentQuery_++].first;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    </span><br><span class="line">    int currentQuery_&#123;0&#125;;</span><br><span class="line">    </span><br><span class="line">    vector&lt;pair&lt;string, int&gt;&gt; sites_;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your SORTracker object will be instantiated and called as such:</span><br><span class="line"> * SORTracker* obj = new SORTracker();</span><br><span class="line"> * obj-&gt;add(name,score);</span><br><span class="line"> * string param_2 = obj-&gt;get();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天加班了一天，回家已经好累了，洗个澡精神一下继续冲题了，不知道是不是题目比较简单还是自己提高了，状态这么差每道题还都有思路，第二道题和第四道题超时了，实在没脑子了，第一次进1000，排名711 / 2923&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://dlc1994.github.io/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
      <category term="Week-contest" scheme="https://dlc1994.github.io/tags/Week-contest/"/>
    
      <category term="BFS" scheme="https://dlc1994.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Weekly Contest 269</title>
    <link href="https://dlc1994.github.io/2021/11/28/cl0zeby7i000xp45c2xf6b8ki/"/>
    <id>https://dlc1994.github.io/2021/11/28/cl0zeby7i000xp45c2xf6b8ki/</id>
    <published>2021-11-28T04:00:00.000Z</published>
    <updated>2022-01-17T15:24:30.940Z</updated>
    
    <content type="html"><![CDATA[<p>这次的题还是挺简单的，还是做出来3道题，最后一道题审题失误，先写了一份回头就来不及了，思路还是有的，排名2017 / 4292，提交错误被罚时，导致排名比上周下降了<br><a id="more"></a></p><h1 id="5938-找出数组排序后的目标下标-EASY"><a href="#5938-找出数组排序后的目标下标-EASY" class="headerlink" title="5938. 找出数组排序后的目标下标 [EASY]"></a>5938. 找出数组排序后的目标下标 [EASY]</h1><p>给你一个下标从 0 开始的整数数组 nums 以及一个目标元素 target 。</p><p>目标下标 是一个满足 nums[i] == target 的下标 i 。</p><p>将 nums 按 非递减 顺序排序后，返回由 nums 中目标下标组成的列表。如果不存在目标下标，返回一个 空 列表。返回的列表必须按 递增 顺序排列。</p><p>示例 1：<br>输入：nums = [1,2,5,2,3], target = 2<br>输出：[1,2]<br>解释：排序后，nums 变为 [1,2,2,3,5] 。<br>满足 nums[i] == 2 的下标是 1 和 2 。</p><p>示例 2：<br>输入：nums = [1,2,5,2,3], target = 3<br>输出：[3]<br>解释：排序后，nums 变为 [1,2,2,3,5] 。<br>满足 nums[i] == 3 的下标是 3 。</p><p>示例 3：<br>输入：nums = [1,2,5,2,3], target = 5<br>输出：[4]<br>解释：排序后，nums 变为 [1,2,2,3,5] 。<br>满足 nums[i] == 5 的下标是 4 。</p><p>示例 4：<br>输入：nums = [1,2,5,2,3], target = 4<br>输出：[]<br>解释：nums 中不含值为 4 的元素。</p><p>提示：<br>1 &lt;= nums.length &lt;= 100<br>1 &lt;= nums[i], target &lt;= 100</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">审题：</span><br><span class="line">这题不难，先排序，然后二分法查找即可</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; targetIndices(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        auto index = std::lower_bound(nums.begin(), nums.end(), target);</span><br><span class="line">        auto distance = index - nums.begin();</span><br><span class="line">        if (distance &gt;= nums.size()) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums[distance] == target) &#123;</span><br><span class="line">            for (int i = distance; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">                if (nums[i] == target) &#123;</span><br><span class="line">                    result.emplace_back(i);   </span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="5939-半径为-k-的子数组平均值-MEDIUM"><a href="#5939-半径为-k-的子数组平均值-MEDIUM" class="headerlink" title="5939. 半径为 k 的子数组平均值 [MEDIUM]"></a>5939. 半径为 k 的子数组平均值 [MEDIUM]</h1><p>给你一个下标从 0 开始的数组 nums ，数组中有 n 个整数，另给你一个整数 k 。</p><p>半径为 k 的子数组平均值 是指：nums 中一个以下标 i 为 中心 且 半径 为 k 的子数组中所有元素的平均值，即下标在 i - k 和 i + k 范围（含 i - k 和 i + k）内所有元素的平均值。如果在下标 i 前或后不足 k 个元素，那么 半径为 k 的子数组平均值 是 -1 。</p><p>构建并返回一个长度为 n 的数组 avgs ，其中 avgs[i] 是以下标 i 为中心的子数组的 半径为 k 的子数组平均值 。</p><p>x 个元素的 平均值 是 x 个元素相加之和除以 x ，此时使用截断式 整数除法 ，即需要去掉结果的小数部分。</p><p>例如，四个元素 2、3、1 和 5 的平均值是 (2 + 3 + 1 + 5) / 4 = 11 / 4 = 3.75，截断后得到 3 。</p><p>示例 1：<br><img src="/2021/11/28/cl0zeby7i000xp45c2xf6b8ki/eg1.png" alt=""><br>输入：nums = [7,4,3,9,1,8,5,2,6], k = 3<br>输出：[-1,-1,-1,5,4,4,-1,-1,-1]<br>解释：</p><ul><li>avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。</li><li>中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。<br>使用截断式 整数除法，avg[3] = 37 / 7 = 5 。</li><li>中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。</li><li>中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。</li><li>avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。</li><li>示例 2：<br>输入：nums = [100000], k = 0<br>输出：[100000]<br>解释：</li><li>中心为下标 0 且半径 0 的子数组的元素总和是：100000 。<br>avg[0] = 100000 / 1 = 100000 。</li></ul><p>示例 3：<br>输入：nums = [8], k = 100000<br>输出：[-1]<br>解释：</p><ul><li>avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。</li></ul><p>提示：<br>n == nums.length<br>1 &lt;= n &lt;= 105<br>0 &lt;= nums[i], k &lt;= 105<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">审题：虽然是一道中等题，但比较简单，找到合理的区间，滑动过程中删左加右即可，注意求和用int会溢出</span><br><span class="line">*/</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; getAverages(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        vector&lt;int&gt; result(nums.size(), -1);</span><br><span class="line">        if (2 * k + 1 &gt; nums.size()) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        int centre = k;</span><br><span class="line">        long long curSum = 0;</span><br><span class="line">        for (int i = 0; i &lt;= 2 * k; ++i) &#123;</span><br><span class="line">            curSum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        result[centre] = floor(curSum / (2 * k + 1));</span><br><span class="line">        </span><br><span class="line">        while (++centre &lt; nums.size()) &#123;</span><br><span class="line">            // cout &lt;&lt; centre &lt;&lt; &quot;, &quot; &lt;&lt; curSum &lt;&lt; endl;</span><br><span class="line">            if (centre &gt; k &amp;&amp; centre &lt; nums.size() - k) &#123;</span><br><span class="line">                curSum -= nums[centre - k - 1];</span><br><span class="line">                curSum += nums[centre + k];</span><br><span class="line">                result[centre] = floor(curSum / (2 * k + 1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="5940-从数组中移除最大值和最小值-MEDIUM"><a href="#5940-从数组中移除最大值和最小值-MEDIUM" class="headerlink" title="5940. 从数组中移除最大值和最小值 [MEDIUM]"></a>5940. 从数组中移除最大值和最小值 [MEDIUM]</h1><p>给你一个下标从 0 开始的数组 nums ，数组由若干 互不相同 的整数组成。</p><p>nums 中有一个值最小的元素和一个值最大的元素。分别称为 最小值 和 最大值 。你的目标是从数组中移除这两个元素。</p><p>一次 删除 操作定义为从数组的 前面 移除一个元素或从数组的 后面 移除一个元素。</p><p>返回将数组中最小值和最大值 都 移除需要的最小删除次数。</p><p>示例 1：<br>输入：nums = [2,10,7,5,4,1,8,6]<br>输出：5<br>解释：<br>数组中的最小元素是 nums[5] ，值为 1 。<br>数组中的最大元素是 nums[1] ，值为 10 。<br>将最大值和最小值都移除需要从数组前面移除 2 个元素，从数组后面移除 3 个元素。<br>结果是 2 + 3 = 5 ，这是所有可能情况中的最小删除次数。</p><p>示例 2：<br>输入：nums = [0,-4,19,1,8,-2,-3,5]<br>输出：3<br>解释：<br>数组中的最小元素是 nums[1] ，值为 -4 。<br>数组中的最大元素是 nums[2] ，值为 19 。<br>将最大值和最小值都移除需要从数组前面移除 3 个元素。<br>结果是 3 ，这是所有可能情况中的最小删除次数。</p><p>示例 3：<br>输入：nums = [101]<br>输出：1<br>解释：<br>数组中只有这一个元素，那么它既是数组中的最小值又是数组中的最大值。<br>移除它只需要 1 次删除操作。</p><p>提示：<br>1 &lt;= nums.length &lt;= 105<br>-105 &lt;= nums[i] &lt;= 105<br>nums 中的整数 互不相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">审题：这题有点简单，一共就四种删除的方式，删左删左，删左删右，删右删左，删右删右，四种情况都比较取最小就行了，然后删左删右和删右删左是同一种</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minimumDeletions(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int numsLen = nums.size();</span><br><span class="line">        if (numsLen == 1) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (numsLen == 2) &#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        int minIndex = -1;</span><br><span class="line">        int maxIndex = -1;</span><br><span class="line">        int minValue = INT_MAX;</span><br><span class="line">        int maxValue = -INT_MAX;</span><br><span class="line">        for (int i = 0; i &lt; numsLen; ++i) &#123;</span><br><span class="line">            if (nums[i] &gt; maxValue) &#123;</span><br><span class="line">                maxValue = nums[i];</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[i] &lt; minValue) &#123;</span><br><span class="line">                minValue = nums[i];</span><br><span class="line">                minIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int left = min(minIndex, maxIndex);</span><br><span class="line">        int right = max(minIndex, maxIndex);</span><br><span class="line">        </span><br><span class="line">        int minOps = INT_MAX; </span><br><span class="line">        </span><br><span class="line">        int Ops;</span><br><span class="line">        &#123;</span><br><span class="line">            // left, left</span><br><span class="line">            Ops = right + 1;</span><br><span class="line">            if (Ops &lt; minOps) &#123;</span><br><span class="line">                minOps = Ops;</span><br><span class="line">            &#125;</span><br><span class="line">            // left, right</span><br><span class="line">            Ops = (left + 1) + (numsLen - right);</span><br><span class="line">            if (Ops &lt; minOps) &#123;</span><br><span class="line">                minOps = Ops;</span><br><span class="line">            &#125;</span><br><span class="line">            // right, right</span><br><span class="line">            Ops = numsLen - left;</span><br><span class="line">            if (Ops &lt; minOps) &#123;</span><br><span class="line">                minOps = Ops;</span><br><span class="line">            &#125;</span><br><span class="line">            // right, left</span><br><span class="line">            Ops = (numsLen - right) + (left + 1);</span><br><span class="line">            if (Ops &lt; minOps) &#123;</span><br><span class="line">                minOps = Ops;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return minOps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="5941-找出知晓秘密的所有专家-HARD"><a href="#5941-找出知晓秘密的所有专家-HARD" class="headerlink" title="5941. 找出知晓秘密的所有专家 [HARD]"></a>5941. 找出知晓秘密的所有专家 [HARD]</h1><p>给你一个整数 n ，表示有 n 个专家从 0 到 n - 1 编号。另外给你一个下标从 0 开始的二维整数数组 meetings ，其中 meetings[i] = [xi, yi, timei] 表示专家 xi 和专家 yi 在时间 timei 要开一场会。一个专家可以同时参加 多场会议 。最后，给你一个整数 firstPerson 。</p><p>专家 0 有一个 秘密 ，最初，他在时间 0 将这个秘密分享给了专家 firstPerson 。接着，这个秘密会在每次有知晓这个秘密的专家参加会议时进行传播。更正式的表达是，每次会议，如果专家 xi 在时间 timei 时知晓这个秘密，那么他将会与专家 yi 分享这个秘密，反之亦然。</p><p>秘密共享是 瞬时发生 的。也就是说，在同一时间，一个专家不光可以接收到秘密，还能在其他会议上与其他专家分享。</p><p>在所有会议都结束之后，返回所有知晓这个秘密的专家列表。你可以按 任何顺序 返回答案。</p><p>示例 1：<br>输入：n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1<br>输出：[0,1,2,3,5]<br>解释：<br>时间 0 ，专家 0 将秘密与专家 1 共享。<br>时间 5 ，专家 1 将秘密与专家 2 共享。<br>时间 8 ，专家 2 将秘密与专家 3 共享。<br>时间 10 ，专家 1 将秘密与专家 5 共享。<br>因此，在所有会议结束后，专家 0、1、2、3 和 5 都将知晓这个秘密。</p><p>示例 2：<br>输入：n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3<br>输出：[0,1,3]<br>解释：<br>时间 0 ，专家 0 将秘密与专家 3 共享。<br>时间 2 ，专家 1 与专家 2 都不知晓这个秘密。<br>时间 3 ，专家 3 将秘密与专家 0 和专家 1 共享。<br>因此，在所有会议结束后，专家 0、1 和 3 都将知晓这个秘密。</p><p>示例 3：<br>输入：n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1<br>输出：[0,1,2,3,4]<br>解释：<br>时间 0 ，专家 0 将秘密与专家 1 共享。<br>时间 1 ，专家 1 将秘密与专家 2 共享，专家 2 将秘密与专家 3 共享。<br>注意，专家 2 可以在收到秘密的同一时间分享此秘密。<br>时间 2 ，专家 3 将秘密与专家 4 共享。<br>因此，在所有会议结束后，专家 0、1、2、3 和 4 都将知晓这个秘密。</p><p>示例 4：<br>输入：n = 6, meetings = [[0,2,1],[1,3,1],[4,5,1]], firstPerson = 1<br>输出：[0,1,2,3]<br>解释：<br>时间 0 ，专家 0 将秘密与专家 1 共享。<br>时间 1 ，专家 0 将秘密与专家 2 共享，专家 1 将秘密与专家 3 共享。<br>因此，在所有会议结束后，专家 0、1、2 和 3 都将知晓这个秘密。</p><p>提示：<br>2 &lt;= n &lt;= 105<br>1 &lt;= meetings.length &lt;= 105<br>meetings[i].length == 3<br>0 &lt;= xi, yi &lt;= n - 1<br>xi != yi<br>1 &lt;= timei &lt;= 105<br>1 &lt;= firstPerson &lt;= n - 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">审题：这题上来忘记`在同一时间，一个专家不光可以接收到秘密，还能在其他会议上与其他专家分享`这个条件，就只记录已知的人，然后根据会议时间进行传染；其实应该按时间找同一时间内各已知人的连通图，然后标记已知的人，最后输出知道的人</span><br><span class="line"></span><br><span class="line">BFS或者并查集甚至同一时间将知道的人排序在前也可以</span><br><span class="line"></span><br><span class="line">[官方解答](https://leetcode-cn.com/problems/find-all-people-with-secret/solution/zhao-chu-zhi-xiao-mi-mi-de-suo-you-zhuan-fzxf/)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次的题还是挺简单的，还是做出来3道题，最后一道题审题失误，先写了一份回头就来不及了，思路还是有的，排名2017 / 4292，提交错误被罚时，导致排名比上周下降了&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://dlc1994.github.io/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
      <category term="Week-contest" scheme="https://dlc1994.github.io/tags/Week-contest/"/>
    
      <category term="BFS" scheme="https://dlc1994.github.io/tags/BFS/"/>
    
      <category term="并查集" scheme="https://dlc1994.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode biweekly-contest-66</title>
    <link href="https://dlc1994.github.io/2021/11/27/cl0zeby7f000sp45csae8frtp/"/>
    <id>https://dlc1994.github.io/2021/11/27/cl0zeby7f000sp45csae8frtp/</id>
    <published>2021-11-27T14:30:00.000Z</published>
    <updated>2022-01-17T15:24:37.380Z</updated>
    
    <content type="html"><![CDATA[<p>晚上唱K失败，团队唱K热情不足呀，还是乖乖回来刷题吧，这次前两题轻松拿下，第三道题DFS又超时，我想了好久的剪枝都没想出来，没想到其实每个格子的权重并不是都不一样，最后一道题就没看了，排名1322 / 2803，唉，一直都是average的水平<br><a id="more"></a></p><h1 id="5922-统计出现过一次的公共字符串-EASY"><a href="#5922-统计出现过一次的公共字符串-EASY" class="headerlink" title="5922. 统计出现过一次的公共字符串 [EASY]"></a>5922. 统计出现过一次的公共字符串 [EASY]</h1><p>给你两个字符串数组 words1 和 words2 ，请你返回在两个字符串数组中 都恰好出现一次 的字符串的数目。</p><p>示例 1：<br>输入：words1 = [“leetcode”,”is”,”amazing”,”as”,”is”], words2 = [“amazing”,”leetcode”,”is”]<br>输出：2<br>解释：</p><ul><li>“leetcode” 在两个数组中都恰好出现一次，计入答案。</li><li>“amazing” 在两个数组中都恰好出现一次，计入答案。</li><li>“is” 在两个数组中都出现过，但在 words1 中出现了 2 次，不计入答案。</li><li>“as” 在 words1 中出现了一次，但是在 words2 中没有出现过，不计入答案。<br>所以，有 2 个字符串在两个数组中都恰好出现了一次。</li></ul><p>示例 2：<br>输入：words1 = [“b”,”bb”,”bbb”], words2 = [“a”,”aa”,”aaa”]<br>输出：0<br>解释：没有字符串在两个数组中都恰好出现一次。</p><p>示例 3：<br>输入：words1 = [“a”,”ab”], words2 = [“a”,”a”,”a”,”ab”]<br>输出：1<br>解释：唯一在两个数组中都出现一次的字符串是 “ab” 。</p><p>提示：<br>1 &lt;= words1.length, words2.length &lt;= 1000<br>1 &lt;= words1[i].length, words2[j].length &lt;= 30<br>words1[i] 和 words2[j] 都只包含小写英文字母。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">审题：</span><br><span class="line">这题好像做过，迅速搞定了，当然跟那些一分钟写完的大神还是不敢比的（他们真的是人吗）</span><br><span class="line">*/</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countWords(vector&lt;string&gt;&amp; words1, vector&lt;string&gt;&amp; words2) &#123;</span><br><span class="line">        unordered_map&lt;string, int&gt; wordMap1;</span><br><span class="line">        unordered_map&lt;string, int&gt; wordMap2;</span><br><span class="line">        set&lt;string&gt; wordSet;</span><br><span class="line">        for (auto&amp; word : words1) &#123;</span><br><span class="line">            wordMap1[word]++;</span><br><span class="line">            wordSet.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        for (auto&amp; word : words2) &#123;</span><br><span class="line">            wordMap2[word]++;</span><br><span class="line">            wordSet.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (auto&amp; word : wordSet) &#123;</span><br><span class="line">            sum += (wordMap1[word] == 1 &amp;&amp; wordMap2[word] == 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="5923-从房屋收集雨水需要的最少水桶数-MEDIUM"><a href="#5923-从房屋收集雨水需要的最少水桶数-MEDIUM" class="headerlink" title="5923. 从房屋收集雨水需要的最少水桶数 [MEDIUM]"></a>5923. 从房屋收集雨水需要的最少水桶数 [MEDIUM]</h1><p>给你一个下标从 0 开始的字符串 street 。street 中每个字符要么是表示房屋的 ‘H’ ，要么是表示空位的 ‘.’ 。</p><p>你可以在 空位 放置水桶，从相邻的房屋收集雨水。位置在 i - 1 或者 i + 1 的水桶可以收集位置为 i 处房屋的雨水。一个水桶如果相邻两个位置都有房屋，那么它可以收集 两个 房屋的雨水。</p><p>在确保 每个 房屋旁边都 至少 有一个水桶的前提下，请你返回需要的 最少 水桶数。如果无解请返回 -1 。</p><p>示例 1：<br>输入：street = “H..H”<br>输出：2<br>解释：<br>我们可以在下标为 1 和 2 处放水桶。<br>“H..H” -&gt; “HBBH”（’B’ 表示放置水桶）。<br>下标为 0 处的房屋右边有水桶，下标为 3 处的房屋左边有水桶。<br>所以每个房屋旁边都至少有一个水桶收集雨水</p><p>示例 2：<br>输入：street = “.H.H.”<br>输出：1<br>解释：<br>我们可以在下标为 2 处放置一个水桶。<br>“.H.H.” -&gt; “.HBH.”（’B’ 表示放置水桶）。<br>下标为 1 处的房屋右边有水桶，下标为 3 处的房屋左边有水桶。<br>所以每个房屋旁边都至少有一个水桶收集雨水。</p><p>示例 3：<br>输入：street = “.HHH.”<br>输出：-1<br>解释：<br>没有空位可以放置水桶收集下标为 2 处的雨水。<br>所以没有办法收集所有房屋的雨水。</p><p>示例 4：<br>输入：street = “H”<br>输出：-1<br>解释：<br>没有空位放置水桶。<br>所以没有办法收集所有房屋的雨水。</p><p>示例 5：<br>输入：street = “.”<br>输出：0<br>解释：<br>没有房屋需要收集雨水。<br>所以需要 0 个水桶。</p><p>提示：<br>1 &lt;= street.length &lt;= 105<br>street[i] 要么是 ‘H’ ，要么是 ‘.’ 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">审题：这题写的比较丑，分的情况太多，圈复杂度太大了</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minimumBuckets(string street) &#123;</span><br><span class="line">        int length = street.size();</span><br><span class="line">        if (length == 1) &#123;</span><br><span class="line">            if (street[0] == &apos;.&apos;) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        bool hasBucket = false;</span><br><span class="line">        for (int i = 0; i &lt; length; ++i) &#123;</span><br><span class="line">            if (street[i] == &apos;H&apos;) &#123;</span><br><span class="line">                if (i == 0) &#123;</span><br><span class="line">                    if (street[i + 1] == &apos;.&apos;) &#123;</span><br><span class="line">                        street[i + 1] = &apos;B&apos;;</span><br><span class="line">                        ++sum;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        return -1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (i == length - 1) &#123;</span><br><span class="line">                    if (street[i - 1] == &apos;.&apos;) &#123;</span><br><span class="line">                        ++sum;</span><br><span class="line">                    &#125; else if (street[i - 1] == &apos;B&apos;) &#123;</span><br><span class="line">                        return sum;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        return -1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (street[i - 1] == &apos;.&apos;) &#123;</span><br><span class="line">                        if (street[i + 1] == &apos;.&apos;) &#123;</span><br><span class="line">                            street[i + 1] = &apos;B&apos;;</span><br><span class="line">                            ++sum;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            street[i - 1] = &apos;B&apos;;</span><br><span class="line">                            ++sum;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else if (street[i - 1] == &apos;B&apos;) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // i - 1 == &apos;H&apos;</span><br><span class="line">                        if (street[i + 1] == &apos;.&apos;) &#123;</span><br><span class="line">                            street[i + 1] = &apos;B&apos;;</span><br><span class="line">                            ++sum;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            return - 1;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="5924-网格图中机器人回家的最小代价-MEDIUM"><a href="#5924-网格图中机器人回家的最小代价-MEDIUM" class="headerlink" title="5924. 网格图中机器人回家的最小代价 [MEDIUM]"></a>5924. 网格图中机器人回家的最小代价 [MEDIUM]</h1><p>给你一个 m x n 的网格图，其中 (0, 0) 是最左上角的格子，(m - 1, n - 1) 是最右下角的格子。给你一个整数数组 startPos ，startPos = [startrow, startcol] 表示 初始 有一个 机器人 在格子 (startrow, startcol) 处。同时给你一个整数数组 homePos ，homePos = [homerow, homecol] 表示机器人的 家 在格子 (homerow, homecol) 处。</p><p>机器人需要回家。每一步它可以往四个方向移动：上，下，左，右，同时机器人不能移出边界。每一步移动都有一定代价。再给你两个下标从 0 开始的额整数数组：长度为 m 的数组 rowCosts  和长度为 n 的数组 colCosts 。</p><p>如果机器人往 上 或者往 下 移动到第 r 行 的格子，那么代价为 rowCosts[r] 。<br>如果机器人往 左 或者往 右 移动到第 c 列 的格子，那么代价为 colCosts[c] 。<br>请你返回机器人回家需要的 最小总代价 。</p><p><img src="/2021/11/27/cl0zeby7f000sp45csae8frtp/eg-1.png" alt=""><br>示例 1：<br>输入：startPos = [1, 0], homePos = [2, 3], rowCosts = [5, 4, 3], colCosts = [8, 2, 6, 7]<br>输出：18<br>解释：一个最优路径为：<br>从 (1, 0) 开始<br>-&gt; 往下走到 (2, 0) 。代价为 rowCosts[2] = 3 。<br>-&gt; 往右走到 (2, 1) 。代价为 colCosts[1] = 2 。<br>-&gt; 往右走到 (2, 2) 。代价为 colCosts[2] = 6 。<br>-&gt; 往右走到 (2, 3) 。代价为 colCosts[3] = 7 。<br>总代价为 3 + 2 + 6 + 7 = 18</p><p>示例 2：<br>输入：startPos = [0, 0], homePos = [0, 0], rowCosts = [5], colCosts = [26]<br>输出：0<br>解释：机器人已经在家了，所以不需要移动。总代价为 0 。</p><p>提示：<br>m == rowCosts.length<br>n == colCosts.length<br>1 &lt;= m, n &lt;= 105<br>0 &lt;= rowCosts[r], colCosts[c] &lt;= 104<br>startPos.length == 2<br>homePos.length == 2<br>0 &lt;= startrow, homerow &lt; m<br>0 &lt;= startcol, homecol &lt; n</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">审题：这题审题漏了最重要的</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">如果机器人往 上 或者往 下 移动到第 r 行 的格子，那么代价为 rowCosts[r] 。</span><br><span class="line">如果机器人往 左 或者往 右 移动到第 c 列 的格子，那么代价为 colCosts[c] 。</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">写了正常的dfs，应该也没有其他剪枝手段了，会超时</span><br><span class="line">要移动到target格子，不管怎么走，都是要走fabs(target_x - start_x)和fabs(target_y - start_y)的代价，所以横直竖下的走是代价最小的</span><br><span class="line"></span><br><span class="line">// 超时版本</span><br><span class="line">#include &lt;numeric&gt; </span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minCost_ = INT_MAX;</span><br><span class="line">    int ites = 0;</span><br><span class="line">    void dfs(int curRow, int curCol, vector&lt;int&gt;&amp; homePos, vector&lt;int&gt;&amp; rowCosts, vector&lt;int&gt;&amp; colCosts, int cost, vector&lt;vector&lt;bool&gt;&gt;&amp; visited) &#123;</span><br><span class="line">        // cout &lt;&lt; curRow &lt;&lt; &quot;,&quot; &lt;&lt; curCol &lt;&lt; &quot;,&quot; &lt;&lt; ites++ &lt;&lt; &quot;, &quot; &lt;&lt; cost &lt;&lt; &quot;,&quot; &lt;&lt; minCost_ &lt;&lt; endl;</span><br><span class="line">        if (curRow == homePos[0] &amp;&amp; curCol == homePos[1]) &#123;</span><br><span class="line">            minCost_ = min(minCost_, cost);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (visited[curRow][curCol] || cost &gt;= minCost_) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[curRow][curCol] = true;</span><br><span class="line">        // up</span><br><span class="line">        if (curRow - 1 &gt;= 0) &#123;</span><br><span class="line">            dfs(curRow - 1, curCol, homePos, rowCosts, colCosts, cost + rowCosts[curRow - 1], visited);</span><br><span class="line">        &#125;</span><br><span class="line">        if (curRow - 1 == homePos[0] &amp;&amp; curCol == homePos[1]) &#123;</span><br><span class="line">            visited[curRow][curCol] = false;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // down</span><br><span class="line">        if (curRow + 1 &lt;= rowCosts.size() - 1) &#123;</span><br><span class="line">            dfs(curRow + 1, curCol, homePos, rowCosts, colCosts, cost + rowCosts[curRow + 1], visited);</span><br><span class="line">        &#125;</span><br><span class="line">        if (curRow + 1 == homePos[0] &amp;&amp; curCol == homePos[1]) &#123;</span><br><span class="line">            visited[curRow][curCol] = false;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // left</span><br><span class="line">        if (curCol - 1 &gt;= 0) &#123;</span><br><span class="line">            dfs(curRow, curCol - 1, homePos, rowCosts, colCosts, cost + colCosts[curCol - 1], visited);</span><br><span class="line">        &#125;</span><br><span class="line">        if (curRow == homePos[0] &amp;&amp; curCol - 1 == homePos[1]) &#123;</span><br><span class="line">            visited[curRow][curCol] = false;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // right</span><br><span class="line">        if (curCol + 1 &lt;= colCosts.size() - 1) &#123;</span><br><span class="line">            dfs(curRow, curCol + 1, homePos, rowCosts, colCosts, cost + colCosts[curCol + 1], visited);</span><br><span class="line">        &#125;</span><br><span class="line">        visited[curRow][curCol] = false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int minCost(vector&lt;int&gt;&amp; startPos, vector&lt;int&gt;&amp; homePos, vector&lt;int&gt;&amp; rowCosts, vector&lt;int&gt;&amp; colCosts) &#123;</span><br><span class="line">        vector&lt;vector&lt;bool&gt;&gt; visited(rowCosts.size(), vector&lt;bool&gt;(colCosts.size(), false));</span><br><span class="line">        dfs(startPos[0], startPos[1], homePos, rowCosts, colCosts, 0, visited);</span><br><span class="line">        return minCost_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="5925-统计农场中肥沃金字塔的数目-HARD"><a href="#5925-统计农场中肥沃金字塔的数目-HARD" class="headerlink" title="5925. 统计农场中肥沃金字塔的数目 [HARD]"></a>5925. 统计农场中肥沃金字塔的数目 [HARD]</h1><p>有一个 矩形网格 状的农场，划分为 m 行 n 列的单元格。每个格子要么是 肥沃的 （用 1 表示），要么是 贫瘠 的（用 0 表示）。网格图以外的所有与格子都视为贫瘠的。</p><p>农场中的 金字塔 区域定义如下：</p><p>区域内格子数目 大于 1 且所有格子都是 肥沃的 。<br>金字塔 顶端 是这个金字塔 最上方 的格子。金字塔的高度是它所覆盖的行数。令 (r, c) 为金字塔的顶端且高度为 h ，那么金字塔区域内包含的任一格子 (i, j) 需满足 r &lt;= i &lt;= r + h - 1 且 c - (i - r) &lt;= j &lt;= c + (i - r) 。<br>一个 倒金字塔 类似定义如下：</p><p>区域内格子数目 大于 1 且所有格子都是 肥沃的 。<br>倒金字塔的 顶端 是这个倒金字塔 最下方 的格子。倒金字塔的高度是它所覆盖的行数。令 (r, c) 为金字塔的顶端且高度为 h ，那么金字塔区域内包含的任一格子 (i, j) 需满足 r - h + 1 &lt;= i &lt;= r 且 c - (r - i) &lt;= j &lt;= c + (r - i) 。<br>下图展示了部分符合定义和不符合定义的金字塔区域。黑色区域表示肥沃的格子。<br><img src="/2021/11/27/cl0zeby7f000sp45csae8frtp/image.png" alt=""><br>给你一个下标从 0 开始且大小为 m x n 的二进制矩阵 grid ，它表示农场，请你返回 grid 中金字塔和倒金字塔的 总数目 。</p><p>示例 1：<br><img src="/2021/11/27/cl0zeby7f000sp45csae8frtp/exa12.png" alt=""><br>输入：grid = [[0,1,1,0],[1,1,1,1]]<br>输出：2<br>解释：<br>2 个可能的金字塔区域分别如上图蓝色和红色区域所示。<br>这个网格图中没有倒金字塔区域。<br>所以金字塔区域总数为 2 + 0 = 2 。</p><p>示例 2：<br><img src="/2021/11/27/cl0zeby7f000sp45csae8frtp/eg21.png" alt=""><br>输入：grid = [[1,1,1],[1,1,1]]<br>输出：2<br>解释：<br>金字塔区域如上图蓝色区域所示，倒金字塔如上图红色区域所示。<br>所以金字塔区域总数目为 1 + 1 = 2 。</p><p>示例 3：<br><img src="/2021/11/27/cl0zeby7f000sp45csae8frtp/eg3.png" alt=""><br>输入：grid = [[1,0,1],[0,0,0],[1,0,1]]<br>输出：0<br>解释：<br>网格图中没有任何金字塔或倒金字塔区域。</p><p>示例 4：<br><img src="/2021/11/27/cl0zeby7f000sp45csae8frtp/eg41.png" alt=""><br>输入：grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]]<br>输出：13<br>解释：<br>有 7 个金字塔区域。上图第二和第三张图中展示了它们中的 3 个。<br>有 6 个倒金字塔区域。上图中最后一张图展示了它们中的 2 个。<br>所以金字塔区域总数目为 7 + 6 = 13.</p><p>提示：<br>m == grid.length<br>n == grid[i].length<br>1 &lt;= m, n &lt;= 1000<br>1 &lt;= m * n &lt;= 105<br>grid[i][j] 要么是 0 ，要么是 1 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">审题：这题没怎么看</span><br><span class="line"></span><br><span class="line">[官方解答](https://leetcode-cn.com/problems/count-fertile-pyramids-in-a-land/solution/tong-ji-nong-chang-zhong-fei-wo-jin-zi-t-paok/)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;晚上唱K失败，团队唱K热情不足呀，还是乖乖回来刷题吧，这次前两题轻松拿下，第三道题DFS又超时，我想了好久的剪枝都没想出来，没想到其实每个格子的权重并不是都不一样，最后一道题就没看了，排名1322 / 2803，唉，一直都是average的水平&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://dlc1994.github.io/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
      <category term="Week-contest" scheme="https://dlc1994.github.io/tags/Week-contest/"/>
    
      <category term="BFS" scheme="https://dlc1994.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Weekly Contest 268</title>
    <link href="https://dlc1994.github.io/2021/11/21/cl0zeby7g000vp45c08s66q5b/"/>
    <id>https://dlc1994.github.io/2021/11/21/cl0zeby7g000vp45c08s66q5b/</id>
    <published>2021-11-21T04:00:00.000Z</published>
    <updated>2022-01-17T15:24:28.270Z</updated>
    
    <content type="html"><![CDATA[<p>这次的题感觉还是挺简单的，做出来3道题，但是第一道题浪费太多时间了，排名1242 / 4397，进步很大，继续努力<br><a id="more"></a></p><h1 id="2078-两栋颜色不同且距离最远的房子-EASY"><a href="#2078-两栋颜色不同且距离最远的房子-EASY" class="headerlink" title="2078. 两栋颜色不同且距离最远的房子 [EASY]"></a>2078. 两栋颜色不同且距离最远的房子 [EASY]</h1><p>街上有 n 栋房子整齐地排成一列，每栋房子都粉刷上了漂亮的颜色。给你一个下标从 0 开始且长度为 n 的整数数组 colors ，其中 colors[i] 表示第  i 栋房子的颜色。</p><p>返回 两栋 颜色 不同 房子之间的 最大 距离。</p><p>第 i 栋房子和第 j 栋房子之间的距离是 abs(i - j) ，其中 abs(x) 是 x 的绝对值。</p><p>示例 1：</p><p>输入：colors = [1,1,1,6,1,1,1]<br>输出：3<br>解释：上图中，颜色 1 标识成蓝色，颜色 6 标识成红色。<br>两栋颜色不同且距离最远的房子是房子 0 和房子 3 。<br>房子 0 的颜色是颜色 1 ，房子 3 的颜色是颜色 6 。两栋房子之间的距离是 abs(0 - 3) = 3 。<br>注意，房子 3 和房子 6 也可以产生最佳答案。</p><p>示例 2：</p><p>输入：colors = [1,8,3,8,3]<br>输出：4<br>解释：上图中，颜色 1 标识成蓝色，颜色 8 标识成黄色，颜色 3 标识成绿色。<br>两栋颜色不同且距离最远的房子是房子 0 和房子 4 。<br>房子 0 的颜色是颜色 1 ，房子 4 的颜色是颜色 3 。两栋房子之间的距离是 abs(0 - 4) = 4 。</p><p>示例 3：<br>输入：colors = [0,1]<br>输出：1<br>解释：两栋颜色不同且距离最远的房子是房子 0 和房子 1 。<br>房子 0 的颜色是颜色 0 ，房子 1 的颜色是颜色 1 。两栋房子之间的距离是 abs(0 - 1) = 1 。</p><p>提示：<br>n == colors.length<br>2 &lt;= n &lt;= 100<br>0 &lt;= colors[i] &lt;= 100<br>生成的测试数据满足 至少 存在 2 栋颜色不同的房子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">审题：</span><br><span class="line">一开始考虑复杂了，还想着用最常不重复子串，写完发现不太对，原来很简单的左右判断一下最大不相等距离就行了</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDistance(vector&lt;int&gt;&amp; colors) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = colors.size() - 1;</span><br><span class="line">        int maxDistance1 = 1;</span><br><span class="line">        int maxDistance2 = 1;</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            if (colors[left] == colors[right]) &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                maxDistance1 = right - left;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left = 0;</span><br><span class="line">        right = colors.size() - 1;</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            if (colors[left] == colors[right]) &#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                maxDistance2 = right - left;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max(maxDistance1, maxDistance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2079-给植物浇水-MEDIUM"><a href="#2079-给植物浇水-MEDIUM" class="headerlink" title="2079. 给植物浇水 [MEDIUM]"></a>2079. 给植物浇水 [MEDIUM]</h1><p>你打算用一个水罐给花园里的 n 株植物浇水。植物排成一行，从左到右进行标记，编号从 0 到 n - 1 。其中，第 i 株植物的位置是 x = i 。x = -1 处有一条河，你可以在那里重新灌满你的水罐。</p><p>每一株植物都需要浇特定量的水。你将会按下面描述的方式完成浇水：</p><p>按从左到右的顺序给植物浇水。<br>在给当前植物浇完水之后，如果你没有足够的水 完全 浇灌下一株植物，那么你就需要返回河边重新装满水罐。<br>你 不能 提前重新灌满水罐。<br>最初，你在河边（也就是，x = -1），在 x 轴上每移动 一个单位 都需要 一步 。</p><p>给你一个下标从 0 开始的整数数组 plants ，数组由 n 个整数组成。其中，plants[i] 为第 i 株植物需要的水量。另有一个整数 capacity 表示水罐的容量，返回浇灌所有植物需要的 步数 。</p><p>示例 1：<br>输入：plants = [2,2,3,3], capacity = 5<br>输出：14<br>解释：从河边开始，此时水罐是装满的：</p><ul><li>走到植物 0 (1 步) ，浇水。水罐中还有 3 单位的水。</li><li>走到植物 1 (1 步) ，浇水。水罐中还有 1 单位的水。</li><li>由于不能完全浇灌植物 2 ，回到河边取水 (2 步)。</li><li>走到植物 2 (3 步) ，浇水。水罐中还有 2 单位的水。</li><li>由于不能完全浇灌植物 3 ，回到河边取水 (3 步)。</li><li>走到植物 3 (4 步) ，浇水。<br>需要的步数是 = 1 + 1 + 2 + 3 + 3 + 4 = 14 。</li></ul><p>示例 2：<br>输入：plants = [1,1,1,4,2,3], capacity = 4<br>输出：30<br>解释：从河边开始，此时水罐是装满的：</p><ul><li>走到植物 0，1，2 (3 步) ，浇水。回到河边取水 (3 步)。</li><li>走到植物 3 (4 步) ，浇水。回到河边取水 (4 步)。</li><li>走到植物 4 (5 步) ，浇水。回到河边取水 (5 步)。</li><li>走到植物 5 (6 步) ，浇水。<br>需要的步数是 = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30 。</li></ul><p>示例 3：<br>输入：plants = [7,7,7,7,7,7,7], capacity = 8<br>输出：49<br>解释：每次浇水都需要重新灌满水罐。<br>需要的步数是 = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49 。</p><p>提示：<br>n == plants.length<br>1 &lt;= n &lt;= 1000<br>1 &lt;= plants[i] &lt;= 106<br>max(plants[i]) &lt;= capacity &lt;= 109<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">审题：比较简单，模拟一下过程，一次遍历就可以</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int wateringPlants(vector&lt;int&gt;&amp; plants, int capacity) &#123;</span><br><span class="line">        int step = 0;</span><br><span class="line">        int current = capacity;</span><br><span class="line">        int currentPos = -1;</span><br><span class="line">        for (int i = 0; i &lt; plants.size(); ++i) &#123;</span><br><span class="line">            if (current &gt;= plants[i]) &#123;</span><br><span class="line">                current -= plants[i];</span><br><span class="line">                step += (i - currentPos);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                step += 2 * i + 1;</span><br><span class="line">                current = capacity - plants[i];</span><br><span class="line">            &#125;</span><br><span class="line">            currentPos = i;</span><br><span class="line">        &#125;</span><br><span class="line">        return step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="2080-区间内查询数字的频率-MEDIUM"><a href="#2080-区间内查询数字的频率-MEDIUM" class="headerlink" title="2080. 区间内查询数字的频率 [MEDIUM]"></a>2080. 区间内查询数字的频率 [MEDIUM]</h1><p>请你设计一个数据结构，它能求出给定子数组内一个给定值的 频率 。</p><p>子数组中一个值的 频率 指的是这个子数组中这个值的出现次数。</p><p>请你实现 RangeFreqQuery 类：</p><p>RangeFreqQuery(int[] arr) 用下标从 0 开始的整数数组 arr 构造一个类的实例。<br>int query(int left, int right, int value) 返回子数组 arr[left…right] 中 value 的 频率 。<br>一个 子数组 指的是数组中一段连续的元素。arr[left…right] 指的是 nums 中包含下标 left 和 right 在内 的中间一段连续元素。</p><p>示例 1：<br>输入：<br>[“RangeFreqQuery”, “query”, “query”]<br>[[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]<br>输出：<br>[null, 1, 2]</p><p>解释：<br>RangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]);<br>rangeFreqQuery.query(1, 2, 4); // 返回 1 。4 在子数组 [33, 4] 中出现 1 次。<br>rangeFreqQuery.query(0, 11, 33); // 返回 2 。33 在整个子数组中出现 2 次。</p><p>提示：<br>1 &lt;= arr.length &lt;= 105<br>1 &lt;= arr[i], value &lt;= 104<br>0 &lt;= left &lt;= right &lt; arr.length<br>调用 query 不超过 105 次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">审题：暴力写了一下果然超时，后面想通了可以初始化存下相同元素的index，然后用二分法找区间内的元素个数，后面还是超时，然后删除一个中间赋值就通过了？这个编译用的O0吗，还是跟并发数有关，搞不懂</span><br><span class="line"></span><br><span class="line">class RangeFreqQuery &#123;</span><br><span class="line">public:</span><br><span class="line">    RangeFreqQuery(vector&lt;int&gt;&amp; arr) &#123;</span><br><span class="line">        array_.resize(1e4 + 1);</span><br><span class="line">        for (int i = 0; i &lt; arr.size(); ++i) &#123;</span><br><span class="line">            array_[arr[i]].emplace_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int query(int left, int right, int value) &#123;</span><br><span class="line">        auto lb = std::lower_bound(array_[value].begin(), array_[value].end(), left);</span><br><span class="line">        auto up = std::upper_bound(array_[value].begin(), array_[value].end(), right);</span><br><span class="line">        return (up - array_[value].begin()) - (lb - array_[value].begin());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; array_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your RangeFreqQuery object will be instantiated and called as such:</span><br><span class="line"> * RangeFreqQuery* obj = new RangeFreqQuery(arr);</span><br><span class="line"> * int param_1 = obj-&gt;query(left,right,value);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h1 id="2081-k-镜像数字的和-HARD"><a href="#2081-k-镜像数字的和-HARD" class="headerlink" title="2081. k 镜像数字的和 [HARD]"></a>2081. k 镜像数字的和 [HARD]</h1><p>一个 k 镜像数字 指的是一个在十进制和 k 进制下从前往后读和从后往前读都一样的 没有前导 0 的 正 整数。</p><p>比方说，9 是一个 2 镜像数字。9 在十进制下为 9 ，二进制下为 1001 ，两者从前往后读和从后往前读都一样。<br>相反地，4 不是一个 2 镜像数字。4 在二进制下为 100 ，从前往后和从后往前读不相同。<br>给你进制 k 和一个数字 n ，请你返回 k 镜像数字中 最小 的 n 个数 之和 。</p><p>示例 1：<br>输入：k = 2, n = 5<br>输出：25<br>解释：<br>最小的 5 个 2 镜像数字和它们的二进制表示如下：<br>  十进制       二进制<br>    1          1<br>    3          11<br>    5          101<br>    7          111<br>    9          1001<br>它们的和为 1 + 3 + 5 + 7 + 9 = 25 。</p><p>示例 2：<br>输入：k = 3, n = 7<br>输出：499<br>解释：<br>7 个最小的 3 镜像数字和它们的三进制表示如下：<br>  十进制       三进制<br>    1          1<br>    2          2<br>    4          11<br>    8          22<br>    121        11111<br>    151        12121<br>    212        21212<br>它们的和为 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499 。</p><p>示例 3：<br>输入：k = 7, n = 17<br>输出：20379000<br>解释：17 个最小的 7 镜像数字分别为：<br>1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596</p><p>提示：<br>2 &lt;= k &lt;= 9<br>1 &lt;= n &lt;= 30</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">审题：这题只剩十几分钟了，按照我的速度肯定是写不完的，但是有思路，就是每个数计算一下进制位，然后判断一下，当然肯定超时，但是n只有30，也可以用打表法把镜像数存起来</span><br><span class="line"></span><br><span class="line">[官方解答](https://leetcode-cn.com/problems/sum-of-k-mirror-numbers/solution/k-jing-xiang-shu-zi-de-he-by-leetcode-so-nyos/)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次的题感觉还是挺简单的，做出来3道题，但是第一道题浪费太多时间了，排名1242 / 4397，进步很大，继续努力&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://dlc1994.github.io/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
      <category term="Week-contest" scheme="https://dlc1994.github.io/tags/Week-contest/"/>
    
      <category term="BFS" scheme="https://dlc1994.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Weekly Contest 265</title>
    <link href="https://dlc1994.github.io/2021/10/31/cl0zeby7g000up45ciu22ples/"/>
    <id>https://dlc1994.github.io/2021/10/31/cl0zeby7g000up45ciu22ples/</id>
    <published>2021-10-31T04:00:00.000Z</published>
    <updated>2022-01-17T15:24:25.478Z</updated>
    
    <content type="html"><![CDATA[<p>这次的题感觉还是挺简单的，前两道题半小时做完了，第三道题用DFS栈溢出（不懂剪枝没做够？），最后一道题只剩半小时不够时间了，还是只做出来两道题，排名2206 / 4181<br><a id="more"></a></p><h1 id="5914-值相等的最小索引-EASY"><a href="#5914-值相等的最小索引-EASY" class="headerlink" title="5914. 值相等的最小索引 [EASY]"></a>5914. 值相等的最小索引 [EASY]</h1><p>给你一个下标从 0 开始的整数数组 nums ，返回 nums 中满足 i mod 10 == nums[i] 的最小下标 i ；如果不存在这样的下标，返回 -1 。</p><p>x mod y 表示 x 除以 y 的 余数 。</p><p>示例 1：</p><p>输入：nums = [0,1,2]<br>输出：0<br>解释：<br>i=0: 0 mod 10 = 0 == nums[0].<br>i=1: 1 mod 10 = 1 == nums[1].<br>i=2: 2 mod 10 = 2 == nums[2].<br>所有下标都满足 i mod 10 == nums[i] ，所以返回最小下标 0</p><p>示例 2：<br>输入：nums = [4,3,2,1]<br>输出：2<br>解释：<br>i=0: 0 mod 10 = 0 != nums[0].<br>i=1: 1 mod 10 = 1 != nums[1].<br>i=2: 2 mod 10 = 2 == nums[2].<br>i=3: 3 mod 10 = 3 != nums[3].<br>2 唯一一个满足 i mod 10 == nums[i] 的下标</p><p>示例 3：<br>输入：nums = [1,2,3,4,5,6,7,8,9,0]<br>输出：-1<br>解释：不存在满足 i mod 10 == nums[i] 的下标<br>示例 4：</p><p>输入：nums = [2,1,3,5,2]<br>输出：1<br>解释：1 是唯一一个满足 i mod 10 == nums[i] 的下标</p><p>提示：<br>1 &lt;= nums.length &lt;= 100<br>0 &lt;= nums[i] &lt;= 9</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">审题：</span><br><span class="line">没啥好说的，过于简单还让我多审了两次题</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int smallestEqual(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            if (i % 10 == nums[i]) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="5915-找出临界点之间的最小和最大距离-MEDIUM"><a href="#5915-找出临界点之间的最小和最大距离-MEDIUM" class="headerlink" title="5915. 找出临界点之间的最小和最大距离 [MEDIUM]"></a>5915. 找出临界点之间的最小和最大距离 [MEDIUM]</h1><p>链表中的 临界点 定义为一个 局部极大值点 或 局部极小值点 。</p><p>如果当前节点的值 严格大于 前一个节点和后一个节点，那么这个节点就是一个  局部极大值点 。</p><p>如果当前节点的值 严格小于 前一个节点和后一个节点，那么这个节点就是一个  局部极小值点 。</p><p>注意：节点只有在同时存在前一个节点和后一个节点的情况下，才能成为一个 局部极大值点 / 极小值点 。</p><p>给你一个链表 head ，返回一个长度为 2 的数组 [minDistance, maxDistance] ，其中 minDistance 是任意两个不同临界点之间的最小距离，maxDistance 是任意两个不同临界点之间的最大距离。如果临界点少于两个，则返回 [-1，-1] 。</p><p>示例 1：<br>输入：head = [3,1]<br>输出：[-1,-1]<br>解释：链表 [3,1] 中不存在临界点。</p><p>示例 2：<br>输入：head = [5,3,1,2,5,1,2]<br>输出：[1,3]<br>解释：存在三个临界点：</p><ul><li>[5,3,1,2,5,1,2]：第三个节点是一个局部极小值点，因为 1 比 3 和 2 小。</li><li>[5,3,1,2,5,1,2]：第五个节点是一个局部极大值点，因为 5 比 2 和 1 大。</li><li>[5,3,1,2,5,1,2]：第六个节点是一个局部极小值点，因为 1 比 5 和 2 小。<br>第五个节点和第六个节点之间距离最小。minDistance = 6 - 5 = 1 。<br>第三个节点和第六个节点之间距离最大。maxDistance = 6 - 3 = 3 。</li></ul><p>示例 3：<br>输入：head = [1,3,2,2,3,2,2,2,7]<br>输出：[3,3]<br>解释：存在两个临界点：</p><ul><li>[1,3,2,2,3,2,2,2,7]：第二个节点是一个局部极大值点，因为 3 比 1 和 2 大。</li><li>[1,3,2,2,3,2,2,2,7]：第五个节点是一个局部极大值点，因为 3 比 2 和 2 大。<br>最小和最大距离都存在于第二个节点和第五个节点之间。<br>因此，minDistance 和 maxDistance 是 5 - 2 = 3 。<br>注意，最后一个节点不算一个局部极大值点，因为它之后就没有节点了。</li></ul><p>示例 4：<br>输入：head = [2,3,3,2]<br>输出：[-1,-1]<br>解释：链表 [2,3,3,2] 中不存在临界点。</p><p>提示：<br>链表中节点的数量在范围 [2, 105] 内<br>1 &lt;= Node.val &lt;= 105<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">审题：这题先把极值点找出来，标记下坐标（这个过程保证坐标有序），然后最远的肯定是第一个和最后一个，</span><br><span class="line">遍历下坐标点，找出距离最近的，输出即可</span><br><span class="line">*/</span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; nodesBetweenCriticalPoints(ListNode* head) &#123;</span><br><span class="line">        vector&lt;int&gt; result(2, 0);</span><br><span class="line">        vector&lt;int&gt; pointIndex;</span><br><span class="line">        auto node = head;</span><br><span class="line">        int preNodeVal = -1;</span><br><span class="line">        int index = 0;</span><br><span class="line">        while (node-&gt;next) &#123;</span><br><span class="line">            // cout &lt;&lt; index &lt;&lt; &quot;, &quot; &lt;&lt; node-&gt;val &lt;&lt; endl;</span><br><span class="line">            if (node == head) &#123;</span><br><span class="line">            &#125; else if (node-&gt;val &gt; node-&gt;next-&gt;val &amp;&amp; node-&gt;val &gt; preNodeVal) &#123;</span><br><span class="line">                // 极大值</span><br><span class="line">                pointIndex.push_back(index);</span><br><span class="line">            &#125; else if (node-&gt;val &lt; node-&gt;next-&gt;val &amp;&amp; node-&gt;val &lt; preNodeVal) &#123;</span><br><span class="line">                // 极小值</span><br><span class="line">                pointIndex.push_back(index);</span><br><span class="line">            &#125;</span><br><span class="line">            preNodeVal = node-&gt;val;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        // for (auto&amp; point : pointIndex) &#123;</span><br><span class="line">        //     cout &lt;&lt; pointIndex.size() &lt;&lt; &quot; : &quot; &lt;&lt; point &lt;&lt; &quot;, &quot;;</span><br><span class="line">        // &#125;</span><br><span class="line">        // cout &lt;&lt; endl;</span><br><span class="line">        if (pointIndex.size() &lt; 2) &#123;</span><br><span class="line">            result[0] = -1;</span><br><span class="line">            result[1] = -1;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        int minDistance = 100000;</span><br><span class="line">        int maxDistance = pointIndex.back() - pointIndex[0];</span><br><span class="line">        if (pointIndex.size() == 2) &#123;</span><br><span class="line">            result[0] = maxDistance;</span><br><span class="line">            result[1] = maxDistance;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        for (auto i = 1; i &lt; pointIndex.size(); i++) &#123;</span><br><span class="line">            if (pointIndex[i] - pointIndex[i - 1] &lt; minDistance) &#123;</span><br><span class="line">                minDistance = pointIndex[i] - pointIndex[i - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result[0] = minDistance;</span><br><span class="line">        result[1] = maxDistance;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="5916-转化数字的最小运算数-MEDIUM"><a href="#5916-转化数字的最小运算数-MEDIUM" class="headerlink" title="5916. 转化数字的最小运算数 [MEDIUM]"></a>5916. 转化数字的最小运算数 [MEDIUM]</h1><p>给你一个下标从 0 开始的整数数组 nums ，该数组由 互不相同 的数字组成。另给你两个整数 start 和 goal 。</p><p>整数 x 的值最开始设为 start ，你打算执行一些运算使 x 转化为 goal 。你可以对数字 x 重复执行下述运算：</p><p>如果 0 &lt;= x &lt;= 1000 ，那么，对于数组中的任一下标 i（0 &lt;= i &lt; nums.length），可以将 x 设为下述任一值：</p><p>x + nums[i]<br>x - nums[i]<br>x ^ nums[i]（按位异或 XOR）<br>注意，你可以按任意顺序使用每个 nums[i] 任意次。使 x 越过 0 &lt;= x &lt;= 1000 范围的运算同样可以生效，但该该运算执行后将不能执行其他运算。</p><p>返回将 x = start 转化为 goal 的最小操作数；如果无法完成转化，则返回 -1 。</p><p>示例 1：<br>输入：nums = [1,3], start = 6, goal = 4<br>输出：2<br>解释：<br>可以按 6 → 7 → 4 的转化路径进行，只需执行下述 2 次运算：</p><ul><li>6 ^ 1 = 7</li><li>7 ^ 3 = 4</li></ul><p>示例 2：<br>输入：nums = [2,4,12], start = 2, goal = 12<br>输出：2<br>解释：<br>可以按 2 → 14 → 12 的转化路径进行，只需执行下述 2 次运算：</p><ul><li>2 + 12 = 14</li><li>14 - 2 = 12</li></ul><p>示例 3：<br>输入：nums = [3,5,7], start = 0, goal = -4<br>输出：2<br>解释：<br>可以按 0 → 3 → -4 的转化路径进行，只需执行下述 2 次运算：</p><ul><li>0 + 3 = 3</li><li>3 - 7 = -4<br>注意，最后一步运算使 x 超过范围 0 &lt;= x &lt;= 1000 ，但该运算仍然可以生效。</li></ul><p>示例 4：<br>输入：nums = [2,8,16], start = 0, goal = 1<br>输出：-1<br>解释：<br>无法将 0 转化为 1</p><p>示例 5：<br>输入：nums = [1], start = 0, goal = 3<br>输出：3<br>解释：<br>可以按 0 → 1 → 2 → 3 的转化路径进行，只需执行下述 3 次运算：</p><ul><li>0 + 1 = 1 </li><li>1 + 1 = 2</li><li>2 + 1 = 3</li></ul><p>提示：<br>1 &lt;= nums.length &lt;= 1000<br>-109 &lt;= nums[i], goal &lt;= 109<br>0 &lt;= start &lt;= 1000<br>start != goal<br>nums 中的所有整数互不相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">审题：看着就像DFS可以做出来的题，加了操作数大于已知最小退出、出现过数字退出这两个剪枝策略都没用，看讨论要用BFS</span><br><span class="line"></span><br><span class="line">// stack-overflow</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    long long minOpt_ = INT_MAX;</span><br><span class="line">    void dfs(const vector&lt;int&gt;&amp; nums, int x, int goal, int operation, vector&lt;int&gt;&amp; asMap) &#123;</span><br><span class="line">        if (x == goal) &#123;</span><br><span class="line">            if (operation &lt; minOpt_) &#123;</span><br><span class="line">                minOpt_ = operation;</span><br><span class="line">            &#125; </span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (x &lt; 0 || x &gt; 1000 || operation &gt;= minOpt_ || asMap[x]) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        asMap[x]++;</span><br><span class="line">        for (size_t i = 0; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            // add</span><br><span class="line">            dfs(nums, x + nums[i], goal, operation + 1, asMap);</span><br><span class="line">            // minus</span><br><span class="line">            dfs(nums, x - nums[i], goal, operation + 1, asMap);</span><br><span class="line">            // xor</span><br><span class="line">            dfs(nums, x ^ nums[i], goal, operation + 1, asMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int minimumOperations(vector&lt;int&gt;&amp; nums, int start, int goal) &#123;</span><br><span class="line">        vector&lt;int&gt; asMap(1000, 0);</span><br><span class="line">        dfs(nums, start, goal, 0, asMap);</span><br><span class="line">        return minOpt_ == INT_MAX ? -1 : minOpt_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="5917-同源字符串检测-HARD"><a href="#5917-同源字符串检测-HARD" class="headerlink" title="5917. 同源字符串检测 [HARD]"></a>5917. 同源字符串检测 [HARD]</h1><p>原字符串由小写字母组成，可以按下述步骤编码：</p><p>任意将其 分割 为由若干 非空 子字符串组成的一个 序列 。<br>任意选择序列中的一些元素（也可能不选择），然后将这些元素替换为元素各自的长度（作为一个数字型的字符串）。<br>重新 顺次连接 序列，得到编码后的字符串。<br>例如，编码 “abcdefghijklmnop” 的一种方法可以描述为：</p><p>将原字符串分割得到一个序列：[“ab”, “cdefghijklmn”, “o”, “p”] 。<br>选出其中第二个和第三个元素并分别替换为它们自身的长度。序列变为 [“ab”, “12”, “1”, “p”] 。<br>重新顺次连接序列中的元素，得到编码后的字符串：”ab121p” 。<br>给你两个编码后的字符串 s1 和 s2 ，由小写英文字母和数字 1-9 组成。如果存在能够同时编码得到 s1 和 s2 原字符串，返回 true ；否则，返回 false。</p><p>注意：生成的测试用例满足 s1 和 s2 中连续数字数不超过 3 。</p><p>示例 1：<br>输入：s1 = “internationalization”, s2 = “i18n”<br>输出：true<br>解释：”internationalization” 可以作为原字符串</p><ul><li>“internationalization”<br>-&gt; 分割：      [“internationalization”]<br>-&gt; 不替换任何元素<br>-&gt; 连接：      “internationalization”，得到 s1</li><li>“internationalization”<br>-&gt; 分割：      [“i”, “nternationalizatio”, “n”]<br>-&gt; 替换：      [“i”, “18”,                 “n”]<br>-&gt; 连接：      “i18n”，得到 s2</li></ul><p>示例 2：<br>输入：s1 = “l123e”, s2 = “44”<br>输出：true<br>解释：”leetcode” 可以作为原字符串</p><ul><li>“leetcode”<br>-&gt; 分割：       [“l”, “e”, “et”, “cod”, “e”]<br>-&gt; 替换：       [“l”, “1”, “2”,  “3”,   “e”]<br>-&gt; 连接：       “l123e”，得到 s1</li><li>“leetcode”<br>-&gt; 分割：       [“leet”, “code”]<br>-&gt; 替换：       [“4”,    “4”]<br>-&gt; 连接：       “44”，得到 s2</li></ul><p>示例 3：<br>输入：s1 = “a5b”, s2 = “c5b”<br>输出：false<br>解释：不存在这样的原字符串</p><ul><li>编码为 s1 的字符串必须以字母 ‘a’ 开头</li><li>编码为 s2 的字符串必须以字母 ‘c’ 开头</li><li>示例 4：<br>输入：s1 = “112s”, s2 = “g841”<br>输出：true<br>解释：”gaaaaaaaaaaaas” 可以作为原字符串</li><li>“gaaaaaaaaaaaas”<br>-&gt; 分割：       [“g”, “aaaaaaaaaaaa”, “s”]<br>-&gt; 替换：       [“1”, “12”,           “s”]<br>-&gt; 连接：       “112s”，得到 s1</li><li>“gaaaaaaaaaaaas”<br>-&gt; 分割：       [“g”, “aaaaaaaa”, “aaaa”, “s”]<br>-&gt; 替换：       [“g”, “8”,        “4”,    “1”]<br>-&gt; 连接         “g841”，得到 s2</li></ul><p>示例 5：<br>输入：s1 = “ab”, s2 = “a2”<br>输出：false<br>解释：不存在这样的原字符串</p><ul><li>编码为 s1 的字符串由两个字母组成</li><li>编码为 s2 的字符串由三个字母组成</li></ul><p>提示：</p><p>1 &lt;= s1.length, s2.length &lt;= 40<br>s1 和 s2 仅由数字 1-9 和小写英文字母组成<br>s1 和 s2 中连续数字数不超过 3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">审题：第三题卡太久了，这题只留了半小时不到，知道做不完还是写一下，我的想法就是先把字符串分割，然后排列组合成多种，再遍历这两个s1和s2的所有组合，只写完了字符串分割(c++真难搞)。虽然后面的排列组合和比较估计也很难写，看答案应该是用动态规划，待续。。。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次的题感觉还是挺简单的，前两道题半小时做完了，第三道题用DFS栈溢出（不懂剪枝没做够？），最后一道题只剩半小时不够时间了，还是只做出来两道题，排名2206 / 4181&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://dlc1994.github.io/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
      <category term="Week-contest" scheme="https://dlc1994.github.io/tags/Week-contest/"/>
    
      <category term="BFS" scheme="https://dlc1994.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Weekly Contest 264</title>
    <link href="https://dlc1994.github.io/2021/10/24/cl0zeby7m0011p45c10ziib89/"/>
    <id>https://dlc1994.github.io/2021/10/24/cl0zeby7m0011p45c10ziib89/</id>
    <published>2021-10-24T02:30:00.000Z</published>
    <updated>2022-01-17T15:24:45.960Z</updated>
    
    <content type="html"><![CDATA[<p>做出来两道题，排名1557 / 4658<br><a id="more"></a></p><h1 id="2047-句子中的有效单词数-EASY"><a href="#2047-句子中的有效单词数-EASY" class="headerlink" title="2047. 句子中的有效单词数 [EASY]"></a>2047. 句子中的有效单词数 [EASY]</h1><p>句子仅由小写字母（’a’ 到 ‘z’）、数字（’0’ 到 ‘9’）、连字符（’-‘）、标点符号（’!’、’.’ 和 ‘,’）以及空格（’ ‘）组成。每个句子可以根据空格分解成 一个或者多个 token ，这些 token 之间由一个或者多个空格 ‘ ‘ 分隔。</p><p>如果一个 token 同时满足下述条件，则认为这个 token 是一个有效单词：</p><ul><li>仅由小写字母、连字符和/或标点（不含数字）。</li><li>至多一个 连字符 ‘-‘ 。如果存在，连字符两侧应当都存在小写字母（”a-b” 是一个有效单词，但 “-ab” 和 “ab-“ 不是有效单词）。</li><li>至多一个 标点符号。如果存在，标点符号应当位于 token 的 末尾 。</li></ul><p>这里给出几个有效单词的例子：”a-b.”、”afad”、”ba-c”、”a!” 和 “!” 。</p><p>给你一个字符串 sentence ，请你找出并返回 sentence 中 有效单词的数目 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">审题：</span><br><span class="line">没啥好说的，就是注意各种情况，自己需要构造一些测试用例比如&quot;a-!&quot;等</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidWord(const string&amp; word) &#123;</span><br><span class="line">        if (word.empty()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (size_t i = 0; i &lt; word.size(); i++) &#123;</span><br><span class="line">            if (word[i] - &apos;a&apos; &gt;=0 &amp;&amp; word[i] - &apos;a&apos; &lt; 26) &#123;</span><br><span class="line">                // go on</span><br><span class="line">            &#125; else if (word[i] == &apos;-&apos;) &#123;</span><br><span class="line">                if (symbolShowed || i == 0 || i == word.size() - 1) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    symbolShowed = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (word[i] == &apos;!&apos; || word[i] == &apos;.&apos; || word[i] == &apos;,&apos;) &#123;</span><br><span class="line">                if (i == word.size() - 1) &#123;</span><br><span class="line">                    if (word.size() == 1 || word.size() &gt;  1 &amp;&amp; word[word.size() - 2] != &apos;-&apos;) &#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return false;;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // other symbols</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    int countValidWords(string sentence) &#123;</span><br><span class="line">        int strLen = sentence.size();</span><br><span class="line">        int start = 0;</span><br><span class="line">        int result = 0;</span><br><span class="line">        for (int i = 0; i &lt; strLen; i++) &#123;</span><br><span class="line">            if (sentence[i] == &apos; &apos; || i == strLen - 1) &#123;</span><br><span class="line">                int count;</span><br><span class="line">                if (sentence[i] == &apos; &apos;) &#123;</span><br><span class="line">                    count = i - start;</span><br><span class="line">                &#125; else if (i == strLen - 1) &#123;</span><br><span class="line">                    count = i - start + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                string word = sentence.substr(start, count);</span><br><span class="line">                result += static_cast&lt;int&gt;(isValidWord(word));</span><br><span class="line">                start = i + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2048-下一个更大的数值平衡数-MEDIUM"><a href="#2048-下一个更大的数值平衡数-MEDIUM" class="headerlink" title="2048. 下一个更大的数值平衡数 [MEDIUM]"></a>2048. 下一个更大的数值平衡数 [MEDIUM]</h1><p>如果整数  x 满足：对于每个数位 d ，这个数位 恰好 在 x 中出现 d 次。那么整数 x 就是一个 数值平衡数 。</p><p>给你一个整数 n ，请你返回 严格大于 n 的 最小数值平衡数 。</p><p>示例 1：<br>输入：n = 1<br>输出：22<br>解释：<br>22 是一个数值平衡数，因为：</p><ul><li>数字 2 出现 2 次<br>这也是严格大于 1 的最小数值平衡数。</li></ul><p>示例 2：<br>输入：n = 1000<br>输出：1333<br>解释：<br>1333 是一个数值平衡数，因为：</p><ul><li>数字 1 出现 1 次。</li><li>数字 3 出现 3 次。<br>这也是严格大于 1000 的最小数值平衡数。<br>注意，1022 不能作为本输入的答案，因为数字 0 的出现次数超过了 0 。</li></ul><p>示例 3：<br>输入：n = 3000<br>输出：3133<br>解释：<br>3133 是一个数值平衡数，因为：</p><ul><li>数字 1 出现 1 次。</li><li>数字 3 出现 3 次。<br>这也是严格大于 3000 的最小数值平衡数。</li></ul><p>提示：<br>0 &lt;= n &lt;= 106<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">审题：这题不会</span><br><span class="line">暴力法先提交了一次，没过！</span><br><span class="line"></span><br><span class="line">然后想貌似可以取巧，反正数字也不多，存到vector里查找就可以了，确实可以</span><br><span class="line"></span><br><span class="line">看评论说暴力也能过，原来是因为我用的map（yydlj）</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 暴力</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isBeautifulNumber(int number) &#123;</span><br><span class="line">        vector&lt;int&gt; bitCount(10, 0);</span><br><span class="line">        while (number &gt; 0) &#123;</span><br><span class="line">            int res = number % 10;</span><br><span class="line">            bitCount[res]++;</span><br><span class="line">            number /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            if (bitCount[i] &amp;&amp; bitCount[i] != i) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int nextBeautifulNumber(int n) &#123;</span><br><span class="line">        int number = n + 1;</span><br><span class="line">        while (!isBeautifulNumber(number)) &#123;</span><br><span class="line">            ++number;</span><br><span class="line">        &#125;</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 打表</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isBeautifulNumber(int number) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; bitCount;</span><br><span class="line">        while (number &gt; 0) &#123;</span><br><span class="line">            int res = number % 10;</span><br><span class="line">            bitCount[res]++;</span><br><span class="line">            number /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        for (auto&amp; i : bitCount) &#123;</span><br><span class="line">            if (i.first != i.second) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int nextBeautifulNumber(int n) &#123;</span><br><span class="line">        int number = n + 1;</span><br><span class="line">        vector&lt;int&gt; allLists = &#123;1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, 212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444&#125;;</span><br><span class="line">        auto item = std::lower_bound(allLists.begin(), allLists.end(), number);</span><br><span class="line">        </span><br><span class="line">        return *item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="2049-统计最高分的节点数目-MEDIUM"><a href="#2049-统计最高分的节点数目-MEDIUM" class="headerlink" title="2049. 统计最高分的节点数目 [MEDIUM]"></a>2049. 统计最高分的节点数目 [MEDIUM]</h1><p>给你一棵根节点为 0 的 二叉树 ，它总共有 n 个节点，节点编号为 0 到 n - 1 。同时给你一个下标从 0 开始的整数数组 parents 表示这棵树，其中 parents[i] 是节点 i 的父节点。由于节点 0 是根，所以 parents[0] == -1 。</p><p>一个子树的 大小 为这个子树内节点的数目。每个节点都有一个与之关联的 分数 。求出某个节点分数的方法是，将这个节点和与它相连的边全部 删除 ，剩余部分是若干个 非空 子树，这个节点的 分数 为所有这些子树 大小的乘积 。</p><p>请你返回有 最高得分 节点的 数目 。</p><p>示例 1:<br><img src="/2021/10/24/cl0zeby7m0011p45c10ziib89/example-1.png" alt="example-1"></p><p>输入：parents = [-1,2,0,2,0]<br>输出：3<br>解释：</p><ul><li>节点 0 的分数为：3 * 1 = 3</li><li>节点 1 的分数为：4 = 4</li><li>节点 2 的分数为：1 <em> 1 </em> 2 = 2</li><li>节点 3 的分数为：4 = 4</li><li>节点 4 的分数为：4 = 4<br>最高得分为 4 ，有三个节点得分为 4 （分别是节点 1，3 和 4 ）。</li></ul><p>示例 2：<br><img src="/2021/10/24/cl0zeby7m0011p45c10ziib89/example-2.png" alt="example-2"></p><p>输入：parents = [-1,2,0]<br>输出：2<br>解释：</p><ul><li>节点 0 的分数为：2 = 2</li><li>节点 1 的分数为：2 = 2</li><li>节点 2 的分数为：1 * 1 = 1<br>最高分数为 2 ，有两个节点分数为 2 （分别为节点 0 和 1 ）。</li></ul><p>提示：</p><ul><li>n == parents.length</li><li>2 &lt;= n &lt;= 105</li><li>parents[0] == -1</li><li>对于 i != 0 ，有 0 &lt;= parents[i] &lt;= n - 1</li><li>parents 表示一棵二叉树。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">审题：看到题目理解了好久，想着要不要建树，但感觉又想到了不建的方法，但是要递归遍历好多次vector，纠结着就放弃了</span><br><span class="line"></span><br><span class="line">大神解题思路：</span><br><span class="line">在这里我们可以把这棵二叉树树看成一个无向图，在这个图中，我们删除一个节点，最多形成 33个连通分量， 即</span><br><span class="line"></span><br><span class="line">* 左子树（如果存在）</span><br><span class="line">* 右子树（如果存在）</span><br><span class="line"> 除了 自身和两棵子树的其他部分（如果存在）</span><br><span class="line"></span><br><span class="line">1. 先使用 dfs 初始化出以各个节点为根节点的子树所包含的节点总数。</span><br><span class="line">2. 接着我们开始遍历每一个删除的节点， 求出删除此节点后剩余三部分各自的节点数量， 最后对三者做乘积，结果就是这个节点的分数。</span><br><span class="line"></span><br><span class="line">Tips： 在求解分数的过程中，可能会超出32位，所以我们应该开long long;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; child;</span><br><span class="line">    vector&lt;int&gt; childTreeNums;</span><br><span class="line">long long ans = INT_MIN;</span><br><span class="line">int len, sum, ret = 0;</span><br><span class="line">    int countHighestScoreNodes(vector&lt;int&gt;&amp; parents) &#123;</span><br><span class="line">    len = parents.size();</span><br><span class="line">    child = vector&lt;vector&lt;int&gt;&gt;(len);</span><br><span class="line">    childTreeNums = vector&lt;int&gt;(len,0);</span><br><span class="line">        //保存孩子节点</span><br><span class="line">    for(int i = 0; i &lt; len; ++i) if(parents[i] != -1) child[parents[i]].push_back(i);</span><br><span class="line">    dfs(0);</span><br><span class="line">        //节点总数</span><br><span class="line">    sum = childTreeNums[0];</span><br><span class="line">        //获得等于最大值的最大数目</span><br><span class="line">    for(int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    long long temp = getScore(i);</span><br><span class="line">    if(temp &gt; ans)&#123;</span><br><span class="line">    ret = 1;</span><br><span class="line">    ans = temp;</span><br><span class="line">    &#125;else if(temp == ans) ret++;</span><br><span class="line">    &#125; </span><br><span class="line">    return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    //获得所有子树的值</span><br><span class="line">   int dfs(int root)&#123;</span><br><span class="line">   if(not child[root].size()) return (childTreeNums[root] = 1);</span><br><span class="line">   for(int i = 0; i &lt; child[root].size(); i++)childTreeNums[root] += dfs(child[root][i]);</span><br><span class="line">   return ++childTreeNums[root];</span><br><span class="line">   &#125;</span><br><span class="line">    //得出删去item节点的分数，注意要开Long long</span><br><span class="line">    long long getScore(int item)&#123;</span><br><span class="line">    long long score = 1;</span><br><span class="line">    score = childTreeNums[0] - childTreeNums[item] == 0 ? 1 : childTreeNums[0] - childTreeNums[item];</span><br><span class="line">    for(int i = 0; i &lt; child[item].size(); i++)score *= childTreeNums[child[item][i]];</span><br><span class="line">    return score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：Tanyf</span><br><span class="line">链接：https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/solution/tan-tan-zhu-code-shuang-bai-c-shen-sou-j-gi7s/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h1 id="2050-并行课程-III-HARD"><a href="#2050-并行课程-III-HARD" class="headerlink" title="2050. 并行课程 III [HARD]"></a>2050. 并行课程 III [HARD]</h1><p>给你一个整数 n ，表示有 n 节课，课程编号从 1 到 n 。同时给你一个二维整数数组 relations ，其中 relations[j] = [prevCoursej, nextCoursej] ，表示课程 prevCoursej 必须在课程 nextCoursej 之前 完成（先修课的关系）。同时给你一个下标从 0 开始的整数数组 time ，其中 time[i] 表示完成第 (i+1) 门课程需要花费的 月份 数。</p><p>请你根据以下规则算出完成所有课程所需要的 最少 月份数：</p><p>如果一门课的所有先修课都已经完成，你可以在 任意 时间开始这门课程。<br>你可以 同时 上 任意门课程 。<br>请你返回完成所有课程所需要的 最少 月份数。</p><p>注意：测试数据保证一定可以完成所有课程（也就是先修课的关系构成一个有向无环图）。</p><p>示例 1:<br><img src="/2021/10/24/cl0zeby7m0011p45c10ziib89/ex1.png" alt="example-1"><br>输入：n = 3, relations = [[1,3],[2,3]], time = [3,2,5]<br>输出：8<br>解释：上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。<br>你可以在月份 0 同时开始课程 1 和 2 。<br>课程 1 花费 3 个月，课程 2 花费 2 个月。<br>所以，最早开始课程 3 的时间是月份 3 ，完成所有课程所需时间为 3 + 5 = 8 个月。</p><p>示例 2：<br><img src="/2021/10/24/cl0zeby7m0011p45c10ziib89/ex2.png" alt="example-2"><br>输入：n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5]<br>输出：12<br>解释：上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。<br>你可以在月份 0 同时开始课程 1 ，2 和 3 。<br>在月份 1，2 和 3 分别完成这三门课程。<br>课程 4 需在课程 3 之后开始，也就是 3 个月后。课程 4 在 3 + 4 = 7 月完成。<br>课程 5 需在课程 1，2，3 和 4 之后开始，也就是在 max(1,2,3,7) = 7 月开始。<br>所以完成所有课程所需的最少时间为 7 + 5 = 12 个月。</p><p>提示：</p><ul><li>1 &lt;= n &lt;= 5 * 104</li><li>0 &lt;= relations.length &lt;= min(n <em> (n - 1) / 2, 5 </em> 104)</li><li>relations[j].length == 2</li><li>1 &lt;= prevCoursej, nextCoursej &lt;= n<br>prevCoursej != nextCoursej</li><li>所有的先修课程对 [prevCoursej, nextCoursej] 都是 互不相同 的。</li><li>time.length == n</li><li>1 &lt;= time[i] &lt;= 104</li><li>先修课程图是一个有向无环图。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">审题：排序后，合并区间比如[3,4], [4,5]先合成[3,5]，然后分层级取每层最大值，比如例2分3层，1,2,3为一层，最大值为3，4为第二层，最大值为4，5为第三层，最大值为5，加起来12。但是合并已经比较麻烦，分层也很难，比如遇到两个区间，[1, 2, 4]和[2, 3, 4]，需要继续合并，然后成为[1,2,3,4]，还是有点难</span><br><span class="line"></span><br><span class="line">看到新概念**DAG图**，**拓扑排序**，就是上面审题里的合并分层了（扶额，还是太菜了）</span><br><span class="line">- 在图论中，如果一个有向图从任意顶点出发无法经过若干条边回到该点，则这个图是一个有向无环图（DAG, Directed Acyclic Graph）。</span><br><span class="line">- 拓扑排序</span><br><span class="line">有向无环图的拓扑排序为所有边的起点都出现在其终点之前的排序。能构成拓扑排序的图一定没有环，因为环中的一条边必定从排序较后的顶点指向比其排序更前的顶点。基于此，拓扑排序可以被用来定义有向无环图：当且仅当一个有向图有拓扑排序，它是有向无环图。一般情况下，拓扑排序并非唯一。有向无环图仅仅在存在一条路径可以包含其所有顶点的情况下，有唯一的拓扑排序方式，这时，拓扑排序与它们在这条路径中出现的顺序相同。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">大神题解：</span><br><span class="line">https://leetcode-cn.com/problems/parallel-courses-iii/solution/tuo-bu-pai-xu-dong-tai-gui-hua-by-dutsc-7yei/</span><br><span class="line"></span><br><span class="line">https://leetcode-cn.com/problems/parallel-courses-iii/solution/tan-tan-zhu-code-cban-zi-ti-tuo-bu-pai-x-oav4/</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">int ans = INT_MIN;</span><br><span class="line">    int minimumTime(int n, vector&lt;vector&lt;int&gt;&gt;&amp; relations, vector&lt;int&gt;&amp; time) &#123;</span><br><span class="line">        queue&lt;int&gt; q;                       //拓扑排序所用到的队列</span><br><span class="line">        vector&lt;int&gt; dp(n+1, INT_MIN);       //dp数组 </span><br><span class="line">        vector&lt;int&gt; degree(n+1,0);          //每个节点的入度</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; edges(n+1);     //邻接表</span><br><span class="line">        //初始化邻接表矩阵和每个点的入度</span><br><span class="line">        for(auto relation : relations)&#123;</span><br><span class="line">        edges[relation[0]].push_back(relation[1]);</span><br><span class="line">        degree[relation[1]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        //初始化队列</span><br><span class="line">        for(int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            if(not degree[i]) &#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">                dp[i] = time[i-1]; </span><br><span class="line">                ans = max(ans, time[i-1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //拓扑排序</span><br><span class="line">    while(not q.empty())&#123;</span><br><span class="line">    int curNode = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    for(auto next : edges[curNode])&#123;</span><br><span class="line">    degree[next]--;</span><br><span class="line">                dp[next] = max(dp[next], dp[curNode] + time[next-1]);   //每次更新时间长度</span><br><span class="line">    if(degree[next] == 0) q.push(next);</span><br><span class="line">                ans = max(ans, dp[next]);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做出来两道题，排名1557 / 4658&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://dlc1994.github.io/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
      <category term="Week-contest" scheme="https://dlc1994.github.io/tags/Week-contest/"/>
    
      <category term="DAG图" scheme="https://dlc1994.github.io/tags/DAG%E5%9B%BE/"/>
    
      <category term="拓扑排序" scheme="https://dlc1994.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Weekly Contest 262</title>
    <link href="https://dlc1994.github.io/2021/10/10/cl0zeby7h000wp45cctbieojx/"/>
    <id>https://dlc1994.github.io/2021/10/10/cl0zeby7h000wp45cctbieojx/</id>
    <published>2021-10-10T04:50:07.000Z</published>
    <updated>2022-01-17T15:25:00.116Z</updated>
    
    <content type="html"><![CDATA[<p>第一次参加leetcode周赛，做出来两道题，排名2124 / 4260<br><a id="more"></a></p><h1 id="2032-至少在两个数组中出现的值"><a href="#2032-至少在两个数组中出现的值" class="headerlink" title="2032. 至少在两个数组中出现的值"></a>2032. 至少在两个数组中出现的值</h1><p>给你三个整数数组 nums1、nums2 和 nums3 ，请你构造并返回一个 不同 数组，且由 至少 在 两个 数组中出现的所有值组成。数组中的元素可以按 任意 顺序排列。</p><p>示例 1：</p><p>输入：nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3]<br>输出：[3,2]<br>解释：至少在两个数组中出现的所有值为：</p><ul><li>3 ，在全部三个数组中都出现过。</li><li>2 ，在数组 nums1 和 nums2 中出现过。<br>示例 2：</li></ul><p>输入：nums1 = [3,1], nums2 = [2,3], nums3 = [1,2]<br>输出：[2,3,1]<br>解释：至少在两个数组中出现的所有值为：</p><ul><li>2 ，在数组 nums2 和 nums3 中出现过。</li><li>3 ，在数组 nums1 和 nums2 中出现过。</li><li>1 ，在数组 nums1 和 nums3 中出现过。<br>示例 3：</li></ul><p>输入：nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5]<br>输出：[]<br>解释：不存在至少在两个数组中出现的值。</p><p>1 &lt;= nums1.length, nums2.length, nums3.length &lt;= 100<br>1 &lt;= nums1[i], nums2[j], nums3[k] &lt;= 100</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">审题：</span><br><span class="line">由于数字范围为1到100，那我先将三个数组压入三个不同的hash表，</span><br><span class="line">然后遍历1到100，用O(3)的复杂度判断该数字是否在三个hash表中，</span><br><span class="line">把结果累加输出，总复杂度是O(n1 + n2 + n3 + 3 * 100)</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; twoOutOfThree(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3) &#123;</span><br><span class="line">    unordered_map&lt;int, int&gt; numMap1;</span><br><span class="line">    unordered_map&lt;int, int&gt; numMap2;</span><br><span class="line">    unordered_map&lt;int, int&gt; numMap3;</span><br><span class="line">    for (auto i = 0; i &lt; nums1.size(); i++) &#123;</span><br><span class="line">        auto num = nums1[i];</span><br><span class="line">        numMap1[num]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (auto i = 0; i &lt; nums2.size(); i++) &#123;</span><br><span class="line">        auto num = nums2[i];</span><br><span class="line">        numMap2[num]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (auto i = 0; i &lt; nums3.size(); i++) &#123;</span><br><span class="line">        auto num = nums3[i];</span><br><span class="line">        numMap3[num]++;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    for (int i = 1; i &lt;= 100; i++) &#123;</span><br><span class="line">        int numCount = 0;</span><br><span class="line">        numCount += static_cast&lt;bool&gt;(numMap1.count(i)) + static_cast&lt;bool&gt;(numMap2.count(i)) + static_cast&lt;bool&gt;(numMap3.count(i));</span><br><span class="line">        if (numCount &gt; 1) &#123;</span><br><span class="line">            result.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2033-获取单值网格的最小操作数"><a href="#2033-获取单值网格的最小操作数" class="headerlink" title="2033. 获取单值网格的最小操作数"></a>2033. 获取单值网格的最小操作数</h1><p>给你一个大小为 m x n 的二维整数网格 grid 和一个整数 x 。每一次操作，你可以对 grid 中的任一元素 加 x 或 减 x 。</p><p>单值网格 是全部元素都相等的网格。</p><p>返回使网格化为单值网格所需的 最小 操作数。如果不能，返回 -1 。</p><p>示例 1：</p><p>输入：grid = [[2,4],[6,8]], x = 2<br>输出：4<br>解释：可以执行下述操作使所有元素都等于 4 ： </p><ul><li>2 加 x 一次。</li><li>6 减 x 一次。</li><li>8 减 x 两次。<br>共计 4 次操作。<br>示例 2：</li></ul><p>输入：grid = [[1,5],[2,3]], x = 1<br>输出：5<br>解释：可以使所有元素都等于 3 。<br>示例 3：</p><p>输入：grid = [[1,2],[3,4]], x = 2<br>输出：-1<br>解释：无法使所有元素相等。</p><p>提示：</p><p>m == grid.length<br>n == grid[i].length<br>1 &lt;= m, n &lt;= 105<br>1 &lt;= m * n &lt;= 105<br>1 &lt;= x, grid[i][j] &lt;= 104</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">审题：这题不会</span><br><span class="line">看了解析，取中位数，然后遍历所有元素做差看是否能整除x</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int minOperations(vector&lt;vector&lt;int&gt;&gt;&amp; grd, int x) &#123;</span><br><span class="line">    int n = grd.size();</span><br><span class="line">    int m = grd[0].size();</span><br><span class="line">    vector&lt;int&gt; cnt(n * m);</span><br><span class="line">    int index = 0;</span><br><span class="line">    for(int i = 0; i &lt; n; i ++)&#123;</span><br><span class="line">        for(int j = 0; j &lt; m; j ++)&#123;</span><br><span class="line">            cnt[index++] = grd[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(cnt.begin(), cnt.end());</span><br><span class="line">    int t = cnt.size()/ 2;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for(int i = 0; i &lt; cnt.size(); i ++)&#123;</span><br><span class="line">        if(cnt[i] != cnt[t]) &#123;</span><br><span class="line">            int k = abs(cnt[i] - cnt[t]);</span><br><span class="line">            if(k % x  == 0) &#123;</span><br><span class="line">                res += k / x;</span><br><span class="line">            &#125;</span><br><span class="line">            else return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次参加leetcode周赛，做出来两道题，排名2124 / 4260&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://dlc1994.github.io/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
      <category term="Week-contest" scheme="https://dlc1994.github.io/tags/Week-contest/"/>
    
  </entry>
  
  <entry>
    <title>如何编写高效、优雅、可信代码系列（4）——今天教你学会用函数指针</title>
    <link href="https://dlc1994.github.io/2021/07/19/cl0zeby7d000pp45cvccm8m6r/"/>
    <id>https://dlc1994.github.io/2021/07/19/cl0zeby7d000pp45cvccm8m6r/</id>
    <published>2021-07-19T15:59:53.000Z</published>
    <updated>2021-07-19T16:10:06.855Z</updated>
    
    <content type="html"><![CDATA[<p>故事的起源来自于，没错，又是来自于业务。</p><p>事实是这样的，我在重构一段代码的时候，发现有两个函数的代码近乎80%都是相同的，区别在于根据不同的条件局部调用不同的两个函数，很难搞，因为一是抽个abstract class太麻烦，二是函数里是循环，在循环里判断又影响性能，不管吧，也影响代码重复率。这个时候我想到了函数指针！<br><a id="more"></a></p><h1 id="1-函数指针的定义和作用"><a href="#1-函数指针的定义和作用" class="headerlink" title="1. 函数指针的定义和作用"></a>1. 函数指针的定义和作用</h1><p>我们先来看看wiki的定义</p><blockquote><p>【from wiki】 A function pointer, also called a <code>subroutine pointer</code> or <code>procedure pointer</code>, is a pointer that points to a function. As opposed to referencing a data value, a function pointer points to executable code within memory. Dereferencing the function pointer yields the referenced function, which can be invoked and passed arguments just as in a normal function call. Such an invocation is also known as an “indirect” call, because the <strong>function is being invoked indirectly through a variable instead of directly through a fixed identifier or address</strong>.</p><p>Function pointers can be used to <strong>simplify code</strong> by providing a simple way to select a function to execute based on <strong>run-time</strong> values.  </p></blockquote><p>重点已经在上面标出来了，函数指针的作用之一是简化代码。</p><p>那么c++标准委员会仅仅是为了让我们写clean code吗？</p><p>Obviously not! Another use for function pointers is setting up <strong>“listener”</strong> or <strong>“callback”</strong> functions that are invoked when a particular event happens. </p><p>什么是回调函数呢？比如你为图形用户界面 (GUI) 编写代码时。大多数情况下，用户将与允许鼠标指针移动并重绘界面的循环进行交互。但是，有时用户会单击按钮或在字段中输入文本。这些操作是“事件”，可能需要您的程序需要处理的响应。你的代码怎么知道发生了什么？使用回调函数！用户的点击应该会导致界面调用您编写的用于处理事件的函数。</p><h1 id="2-函数指针的用法"><a href="#2-函数指针的用法" class="headerlink" title="2. 函数指针的用法"></a>2. 函数指针的用法</h1><p>说了这么多，你是不是已经跃跃欲试，恨不得马上重构自己的代码以降低重复率了，hold on! hold on!先看完用法再去操作，磨刀不误砍柴工。</p><h2 id="2-1-函数指针的声明"><a href="#2-1-函数指针的声明" class="headerlink" title="2.1 函数指针的声明"></a>2.1 函数指针的声明</h2><p>先来看看函数指针的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *(*foo)(int *);</span><br></pre></td></tr></table></figure><p>表达式的最里面的元素是 <code>*foo</code>，它应该指向一个返回 <code>void *</code> 并采用 <code>int *</code>作为参数的函数。因此，foo是指向这样一个函数的指针。</p><p>还可以用<code>typedef</code>简化函数指针的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int test(int a)</span><br><span class="line">&#123;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    typedef int (*foo)(int a);</span><br><span class="line">    foo f = test;</span><br><span class="line">    cout &lt;&lt; foo(2) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-函数指针的初始化"><a href="#2-2-函数指针的初始化" class="headerlink" title="2.2 函数指针的初始化"></a>2.2 函数指针的初始化</h2><p>为了初始化一个函数指针，需要给它一个程序内的函数地址，比如下面的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void MyFun(int x)</span><br><span class="line">&#123;</span><br><span class="line">    printf( &quot;我是%d颗大西瓜。\n&quot;, x );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // way 1</span><br><span class="line">    void (*foo)(int);</span><br><span class="line">    foo = &amp;MyFun;</span><br><span class="line">    // way 2</span><br><span class="line">    void (*foo)(int) = &amp;MyFun;</span><br><span class="line">    // way 3</span><br><span class="line">    auto foo = &amp;MyFun;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三种方式都是可以的。如果是指向类函数呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">        A(int aa = 0):a(aa)&#123;&#125;</span><br><span class="line">        ~A()&#123;&#125;</span><br><span class="line">        void SetA(int aa = 1)</span><br><span class="line">        &#123;</span><br><span class="line">            a = aa;</span><br><span class="line">        &#125;</span><br><span class="line">        virtual void Print()</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;A: &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    private:</span><br><span class="line">        int a;</span><br><span class="line">&#125;;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    A a;</span><br><span class="line">    void (A::*ptr)(int) = &amp;A::setA;</span><br><span class="line">    A* pa = &amp;a;</span><br><span class="line">    </span><br><span class="line">    //对于非虚函数，返回其在内存的真实地址</span><br><span class="line">    printf(&quot;A::Set(): %p\n&quot;, &amp;A::SetA);</span><br><span class="line">    //对于虚函数， 返回其在虚函数表的偏移位置</span><br><span class="line">    printf(&quot;A::Print(): %p\n&quot;, &amp;A::print);</span><br><span class="line"> </span><br><span class="line">    a.Print();</span><br><span class="line">    a.SetA(10);</span><br><span class="line">    //对于指向类成员函数的函数指针，引用时必须传入一个类对象的this指针，所以必须由类实体调用(如果是在类内调用就用*this)</span><br><span class="line">    (pa-&gt;*ptr)(1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-让我们来看看成果"><a href="#2-3-让我们来看看成果" class="headerlink" title="2.3 让我们来看看成果"></a>2.3 让我们来看看成果</h2><p>下面是用不同的order进行的选择排序代码，请看成片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;utility&gt; // for std::swap</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">// Note our user-defined comparison is the third parameter</span><br><span class="line">void selectionSort(int *array, int size, bool (*comparisonFcn)(int, int))</span><br><span class="line">&#123;</span><br><span class="line">    // Step through each element of the array</span><br><span class="line">    for (int startIndex &#123;0&#125;; startIndex &lt; (size - 1); ++startIndex) &#123;</span><br><span class="line">        // bestIndex is the index of the smallest/largest element we&apos;ve encountered so far.</span><br><span class="line">        int bestIndex &#123;startIndex&#125;;</span><br><span class="line">        // Look for smallest/largest element remaining in the array (starting at startIndex+1)</span><br><span class="line">        for (int currentIndex&#123; startIndex + 1 &#125;; currentIndex &lt; size; ++currentIndex) &#123;</span><br><span class="line">            // If the current element is smaller/larger than our previously found smallest</span><br><span class="line">            if (comparisonFcn(array[bestIndex], array[currentIndex])) &#123; // COMPARISON DONE HERE</span><br><span class="line">                // This is the new smallest/largest number for this iteration</span><br><span class="line">                bestIndex = currentIndex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // Swap our start element with our smallest/largest element</span><br><span class="line">        std::swap(array[startIndex], array[bestIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// Here is a comparison function that sorts in ascending order</span><br><span class="line">bool ascending(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    return x &gt; y; // swap if the first element is greater than the second</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// Here is a comparison function that sorts in descending order</span><br><span class="line">bool descending(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    return x &lt; y; // swap if the second element is greater than the first</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// This function prints out the values in the array</span><br><span class="line">void printArray(int *array, int size)</span><br><span class="line">&#123;</span><br><span class="line">    for (int index&#123; 0 &#125;; index &lt; size; ++index) &#123;</span><br><span class="line">        std::cout &lt;&lt; array[index] &lt;&lt; &apos; &apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; &apos;\n&apos;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int array[9] &#123; 3, 7, 9, 5, 6, 1, 8, 2, 4 &#125;;</span><br><span class="line"> </span><br><span class="line">    // Sort the array in descending order using the descending() function</span><br><span class="line">    selectionSort(array, 9, descending);</span><br><span class="line">    printArray(array, 9);</span><br><span class="line"> </span><br><span class="line">    // Sort the array in ascending order using the ascending() function</span><br><span class="line">    selectionSort(array, 9, ascending);</span><br><span class="line">    printArray(array, 9);</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-后记"><a href="#3-后记" class="headerlink" title="3. 后记"></a>3. 后记</h1><p>是不是看起来还挺优雅的，函数指针的好处可以总结如下</p><ul><li><strong>GOOD1: 函数指针提供了一种传递有关如何做某事的指令的方法</strong></li><li><strong>GOOD2: 可以编写灵活的函数和库，允许程序员通过将函数指针作为参数传递来选择行为（当然这种灵活性也可以通过使用具有虚函数的类来实现）</strong></li><li><strong>GOOD3: 可以简化代码</strong></li></ul><p>但是every coin has two sides，函数指针也不是百利而无一害，我也总结了一些，大家可以继续补充</p><ul><li><strong>BAD1: 性能开销。</strong> 让我们回到它的定义，正如一个指针变量保存的是变量的地址一样，只不过函数指针保存的是函数的地址，并且是运行时才能确定的变量。理论来说，直接函数调用开销更小，因为函数指针调用需要先访问数据区，再访问函数，增加指令开销，同时，数据取值与函数指令加载必须串行执行，影响CPU流水性能；普通的函数调用可以做内联优化。<em>不过幸好编译器可以将函数指针的调用开销优化到跟普通的函数调用相同（优化选项O1及以上，具体可参考<a href="https://zhuanlan.zhihu.com/p/84887035）">https://zhuanlan.zhihu.com/p/84887035）</a></em></li><li><strong>BAD2: 代码可读性。</strong> 区别于传统的函数调用，我们在进入到使用函数指针作为参数的函数中时，有时会很抓狂，比如上面的<code>selectionSort()</code>，我在阅读到<code>comparisonFcn()</code>的时候无法确认这个函数的行为，需要往外跳一层才能知道什么情况下这个函数是升序还是降序；更令人抓狂的是，更为复杂的函数中（假如作者不写任何注释），你会破口大骂谁写的函数指针，而且点跳转还无法跳转到相应的函数实现中（没错，我有时候是会骂自己的T.T）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;故事的起源来自于，没错，又是来自于业务。&lt;/p&gt;
&lt;p&gt;事实是这样的，我在重构一段代码的时候，发现有两个函数的代码近乎80%都是相同的，区别在于根据不同的条件局部调用不同的两个函数，很难搞，因为一是抽个abstract class太麻烦，二是函数里是循环，在循环里判断又影响性能，不管吧，也影响代码重复率。这个时候我想到了函数指针！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="https://dlc1994.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://dlc1994.github.io/tags/C/"/>
    
      <category term="函数指针" scheme="https://dlc1994.github.io/tags/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>如何编写高效、优雅、可信代码系列（3）——类成员初始化的三种方式</title>
    <link href="https://dlc1994.github.io/2021/06/28/cl0zeby7c000op45cp8bfty0r/"/>
    <id>https://dlc1994.github.io/2021/06/28/cl0zeby7c000op45cp8bfty0r/</id>
    <published>2021-06-28T03:11:53.000Z</published>
    <updated>2021-06-28T15:36:20.927Z</updated>
    
    <content type="html"><![CDATA[<p>首先，先得了解一下C++支持哪几种类成员初始化的方式，你常用的又是哪一种。<br><a id="more"></a></p><ul><li><p>初始化方式一：初始化列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int a; // 初始化列表</span><br><span class="line">    A(int a_):a(a_)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>初始化方式二：构造函数初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int a; // 初始化列表</span><br><span class="line">    A(int a_, bool b) &#123; a = a_; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>初始化方式三：声明时初始化（也称就地初始化，c++11后支持）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int a = 1; // 声明时初始化</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>在C++98中，支持了在类声明中使用等号“=”加初始值的方式，来初始化类中静态成员常量。这种声明方式我们也称之为“就地”声明。就地声明在代码编写时非常便利，不过C++98对类中就地声明的要求却非常高。如果静态成员不满足常量性，则不可以就地声明，而且即使常量的静态成员也只能是整型或者枚举型才能就地初始化。而非静态成员变量的初始化则必须在构造函数中进行。比如，如下代码在c++98中编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Init</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Init(): a(0) []</span><br><span class="line">    Init(int d): a(d) &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    int a;</span><br><span class="line">    const static int b = 0;</span><br><span class="line"></span><br><span class="line">    int c = 1;           // member, cannot pass build</span><br><span class="line">    static int d = 0;    // member, cannot pass build</span><br><span class="line"></span><br><span class="line">    static const double e = 1.3;      // not int or enum type, cannot pass build</span><br><span class="line">    stati const char* const f = &quot;e&quot;;  // not int or enum type, cannot pass build</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这非常不方便，所以在C++11中，标准允许非静态成员变量的初始化有多种形式。具体而言，除了初始化列表外，在C++11中，标准还允许使用<strong>等号=</strong> 或者 <strong>花括号{}</strong> 进行就地的非静态成员变量初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct init &#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    double b &#123;1.2&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>大家知道，有几种情况下推荐优先使用列表初始化</p><ul><li><strong>const成员变量只能用成员初始化列表来完成初始化，而不能在构造函数内赋值</strong></li><li><strong>初始化的数据成员是对象</strong></li><li><strong>需要初始化引用成员数据</strong></li></ul><p>具体的原因这里不细述，大家可以去看一下《C++ Primer》。</p><p>构造函数初始化的本质是赋值操作（”=”），这个方法存在两个问题，一个是比起初始化列表和就地初始化，此方式的效率偏低；第二个是可能存在错误隐患。</p><p>先说第一个，赋值过程中会产生临时对象，临时对象的构造析构会造成效率损耗，初始化列表的方式就避免了产生临时对象缩带来的问题。</p><p>第二个是，如果你没有重写或者禁止赋值构造函数，c++会悄悄的加上默认的赋值构造函数，这个时候也有可能带来问题。</p><p>从C++11之后，这三种初始化的方法都可以使用，并不会存在冲突，但是，他们之间是有优先级顺序的，这个优先级来源于他们在初始化的时间顺序，后面初始化的会把前面的覆盖掉，成员变量的初始化顺序是</p><p><strong>声明时初始化-&gt;初始化列表-&gt;构造函数初始化</strong></p><p>因此假如三种初始化方式同时存在的话，那么最后保留的成员变量值肯定是构造函数中初始化的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int a = 1;</span><br><span class="line">    A(int a_) :a(2) &#123; a = 3; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    A a;</span><br><span class="line">    cout &lt;&lt; &quot;a.a=&quot; &lt;&lt; a.a &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// a.a=3</span><br></pre></td></tr></table></figure></p><p>既然初始化方式这么多，那么什么时候适用哪种呢？</p><p><strong>1. 声明时初始化的使用场景</strong></p><ul><li>一个优点是直观，你在声明的时候顺便给一个初始值，bravo，别人在看你代码的时候，点一下调到声明也能看到你赋予的初始值，不用再去看构造函数那里给的什么值</li><li>第二个优点更有用了，比如你要定义多个构造函数，每个构造函数都用列表初始化的方法初始化，多麻烦呀，请看下面的例子，妈妈看了再也不用担心我想用其他初始化方法了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Group &#123;</span><br><span class="line">public:</span><br><span class="line">    Group() &#123;&#125;</span><br><span class="line">    Group(int a): data(a) &#123;&#125;</span><br><span class="line">    Group(Mem m): mem(m) &#123;&#125;</span><br><span class="line">    Group(int a, Mem m, string n): data(a), mem(m), name(n) &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    int data = 1;</span><br><span class="line">    Mem mem&#123;0&#125;;</span><br><span class="line">    string name&#123;&quot;Group&quot;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>2. 列表初始化的使用场景</strong><br>前面说过了三个场景，这里赘述一下</p><ul><li>const成员变量只能用成员初始化列表来完成初始化，而不能在构造函数内赋值</li><li>初始化的数据成员是对象</li><li>需要初始化引用成员数据</li></ul><p>但是，需要注意列表初始化的顺序，不过IDE会提示你的</p><p><strong>3. 构造函数初始化的使用场景</strong></p><ul><li>第一个就是拷贝和赋值构造函数里（不然怎么叫赋值构造函数呢）</li><li>第二个就是比较无聊的情况了，比如你想把几个成员函数都初始化成一个值，请看下面例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Group &#123;</span><br><span class="line">public:</span><br><span class="line">    Group() &#123;data1 = data2 = data3 = 0;&#125;</span><br><span class="line">private:</span><br><span class="line">    int data1;</span><br><span class="line">    int data2;</span><br><span class="line">    int data3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>一言以蔽之，优先就地初始化和列表初始化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，先得了解一下C++支持哪几种类成员初始化的方式，你常用的又是哪一种。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="https://dlc1994.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://dlc1994.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>如何编写高效、优雅、可信代码系列（2）——你真的会用new吗</title>
    <link href="https://dlc1994.github.io/2021/06/28/cl0zeby7e000qp45czbdaz2u8/"/>
    <id>https://dlc1994.github.io/2021/06/28/cl0zeby7e000qp45czbdaz2u8/</id>
    <published>2021-06-28T03:11:53.000Z</published>
    <updated>2021-10-25T15:53:19.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h1><h2 id="1-c-内存分配"><a href="#1-c-内存分配" class="headerlink" title="1. c++内存分配"></a>1. c++内存分配</h2><p>c++中的程序加载到内存后按照代码区、数据区、堆区、栈区进行布局，其中数据区又可以分为自由存储区、全局/静态存储区和常量存储区，各区所长如下：<br><a id="more"></a></p><ul><li>栈区<br>函数执行的时候，局部变量的存储单元都在栈上创建，函数执行结束后存储单元会自动释放。<strong>栈内存分配运算内置于处理器指令集中，效率高，但分配内存容量有限。</strong></li><li>堆区<br>堆就是new出来的内存块，编译器不管释放，由应用程序控制，<strong>new对应delete</strong>。如果没释放掉，程序结束后，操作系统会自动回收。</li><li>自由存储区<br>C中malloc分配的内存块。用free结束生命周期。</li><li>全局/静态存储区<br>全局变量和静态变量被分配到同一块内存中，<strong>定义的时候就会初始化</strong>。</li><li>常量存储区<br>比较特殊的存储区，存放常量，不允许修改。</li></ul><p>堆和栈的区别</p><ul><li>管理方式<br>栈由编译器自动管理，堆由程序员控制</li><li>空间大小<br>32位系统下，堆内存可以达到4GB，栈有一定的空间大小</li><li>碎片管理<br>对于堆，频繁的new/delete肯定造成内存空间的不连续，产生大量内存碎片降低程序效率；栈由于遵循先进后出的规则，不会产生空隙</li><li>生长方向<br>堆是向上生长的，即向着内存地址增加的方向增长；而栈是向着内存地址减小的方向增长的</li><li>分配方式<br>堆是动态分配的，栈有动态分配和静态分配之分：静态分配由编译器完成，动态分配由alloca函数完成，即使是动态分配，依然是编译器自动释放</li><li>分配效率<br>计算机底层提供了栈的支持，分配了专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这决定了栈的效率会比较高。堆则是由C/C++函数库提供的，机制比较复杂，比如为了分配某个大小的内存需要在堆内存中搜索可用足够大小的空间，效率比栈要低的多</li></ul><h2 id="2-new-delete和new-delete"><a href="#2-new-delete和new-delete" class="headerlink" title="2. new/delete和new []/delete []"></a>2. new/delete和new []/delete []</h2><ul><li>回收new分配的单个对象内存空间时用delete，回收用new[]分配的一组对象时用delete[]</li><li>对于内置类型(int/double/float/char/…)，由于new[]申请内存时，编译器还会悄悄在内存中保存整数，表示指针数组的个数，所以delete/delete[]都可以正确释放所申请的内存空间</li><li>建议在调用new时使用的[]，那么调用delete也使用[]</li></ul><h2 id="3-new的三种形态"><a href="#3-new的三种形态" class="headerlink" title="3. new的三种形态"></a>3. new的三种形态</h2><ul><li><strong>new operator</strong> 常用的new，语言函数内建，不能重载。调用过程中实际完成的有三件事：<ol><li>为类型对象分配内存；</li><li>调用构造函数初始化内存对象；</li><li>返回对象指针<br>如果是在堆上建立对象，直接使用new operator。</li></ol></li><li><strong>operator new</strong> 普通操作符，可以重载。如果仅仅是分配内存，那么应该调用operator new，但不负责初始化。系统默认提供的分配器在时间和空间两方面都存在一些问题：分配器速度较慢，分配小型对象时空间浪费严重，重载new/delete有三方面好处：<ol><li>改善效率</li><li>检测代码中的内存错误</li><li>获得内存使用的统计数据</li></ol><ul><li>C++标准规定，重载的operator new必须是类成员函数或全局函数，全局的operator new重载不应该改变原有签名，而是直接无缝替换原有版本。全局重载很有侵略性，别人使用你的库无法使用默认的new，而具体类的重载只会影响本class和其派生类，但是类的operator new函数重载必须声明为static，因为operator new是在类的具体对象被构建出来之前调用的。</li><li>为了获得2和3的优势，重载的operator new需要如下函数声明<code>void* operator new(size_t, const char* file, int line);</code></li><li></li></ul></li><li><strong>placement new</strong> 定义在库&lt;<new>&gt;中。如果想在一块已经获得内存里建立对象，那么应该调用placement new。通常情况不建议使用，但在<strong>某些对时间要求非常高的应用中</strong>可以考虑，因为选择合适的构造函数完成对象初始化是一个时间相对较长的过程。</new></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-内存管理&quot;&gt;&lt;a href=&quot;#C-内存管理&quot; class=&quot;headerlink&quot; title=&quot;C++内存管理&quot;&gt;&lt;/a&gt;C++内存管理&lt;/h1&gt;&lt;h2 id=&quot;1-c-内存分配&quot;&gt;&lt;a href=&quot;#1-c-内存分配&quot; class=&quot;headerlink&quot; title=&quot;1. c++内存分配&quot;&gt;&lt;/a&gt;1. c++内存分配&lt;/h2&gt;&lt;p&gt;c++中的程序加载到内存后按照代码区、数据区、堆区、栈区进行布局，其中数据区又可以分为自由存储区、全局/静态存储区和常量存储区，各区所长如下：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="https://dlc1994.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://dlc1994.github.io/tags/C/"/>
    
      <category term="内存管理" scheme="https://dlc1994.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>如何编写高效、优雅、可信代码系列（1）——C++多线程强制终止</title>
    <link href="https://dlc1994.github.io/2021/06/28/cl0zeby7p0016p45c3yghazw6/"/>
    <id>https://dlc1994.github.io/2021/06/28/cl0zeby7p0016p45c3yghazw6/</id>
    <published>2021-06-28T03:11:53.000Z</published>
    <updated>2021-06-28T15:38:12.906Z</updated>
    
    <content type="html"><![CDATA[<p>故事的起因来源于我在优化他人c++源码的时候，想通过多线程的方式提升程序的运算效率，主要存在以下需求和难点：</p><ol><li>多个线程并行跑模型，看哪个模型跑的快，跑出来后结束其他线程，线程间独立运行无通信过程</li><li>源码模型很复杂，函数调用较多，不好改动，因此不太适合通过信号或标志进行通信终止<a id="more"></a></li></ol><p>网上搜索了一下线程结束的几种方式：</p><ol><li><strong>线程函数的return返回（建议）</strong>。这种退出线程的方式是最安全的，在线程函数return返回后, 会清理函数内申请的类对象, 即调用这些对象的析构函数.。然后会自动调用 _endthreadex()函数来清理 _beginthreadex()函数申请的资源(主要是创建的tiddata对象)。</li><li><strong>同一个进程或另一个进程中的线程调用TerminateThread函数（应避免使用该方法）</strong>。TerminateThread能够撤消任何线程，其中hThread参数用于标识被终止运行的线程的句柄。当线程终止运行时，它的退出代码成为你作为dwExitCode参数传递的值。同时，线程的内核对象的使用计数也被递减。注意TerminateThread函数是异步运行的函数，也就是说，它告诉系统你想要线程终止运行，但是，当函数返回时，不能保证线程被撤消。如果需要确切地知道该线程已经终止运行，必须调用WaitForSingleObject或者类似的函数，传递线程的句柄。</li><li><strong>通过调用ExitThread函数，线程将自行撤消（最好不使用该方法）</strong>。该函数将终止线程的运行，并导致操作系统清除该线程使用的所有操作系统资源。但是，C++资源（如C++类对象）将不被析构。</li><li><strong>ExitProcess和TerminateProcess函数也可以用来终止线程的运行（应避免使用该方法）</strong>。</li></ol><p>选项2和3可能会导致内存泄漏，实际上，没有任何语言或操作系统可以为你提供异步突然终止线程的便利，且不会警告你不要使用它们。所有这些执行环境都强烈建议开发人员，甚至要求在协作或同步线程终止的基础上构建多线程应用程序。</p><p>现有的线程结束函数，包括linux系统的<code>pthread.h</code>中的<code>pthread_exit()</code>和<code>pthread_cancel()</code>，windows系统的<code>win32.h</code>中的<code>ExitThread()</code>和<code>TerminateThread()</code>，也就是说，<strong>C++没有提供kill掉某个线程的能力，只能被动地等待某个线程的自然结束</strong>，析构函数<code>~thread()</code>也不能停止线程，析构函数只能在线程静止时终止线程<code>joinable</code>，对于连接/分离的线程，析构函数根本无法终止线程。</p><p>要终止与OS /编译器相关的函数的线程，我们需要知道如何从C++获取本机线程数据类型std::thread。幸运的是，在调用或之前<code>std::thread</code>提供了一个API <code>native_handle()</code>以获取线程的本机句柄类型。并且可以将此本地句柄传递给本地OS线程终止函数，例如<code>join() detach() pthread_cancel()</code>。</p><p>以下代码用于显示<code>std::thread::native_handle()</code>，<code>std::thread::get_id()</code>并<code>pthread_self()</code>返回相同的代码<code>pthread_t</code>来处理Linux / GCC的C++线程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"> </span><br><span class="line">std::mutex iomutex;</span><br><span class="line">void f(int num)</span><br><span class="line">&#123;</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::seconds(1));</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lk(iomutex);</span><br><span class="line">    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; num &lt;&lt; &quot; pthread_t &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::thread t1(f, 1), t2(f, 2);</span><br><span class="line">    </span><br><span class="line">    //t1.join(); t2.join();  ----------------pos 1</span><br><span class="line">    //t1.detach(); t2.detach(); -------------pos 2</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Thread 1 thread id &quot; &lt;&lt; t1.get_id() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;Thread 2 thread id &quot; &lt;&lt; t2.get_id() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Thread 1 native handle &quot; &lt;&lt; t1.native_handle() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;Thread 2 native handle &quot; &lt;&lt; t2.native_handle() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    t1.join(); t2.join();</span><br><span class="line">    //t1.detach(); t2.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行后可以得到结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -Wall -std=c++11 cpp_thread_pthread.cc -o cpp_thread_pthread -pthread -lpthread</span><br><span class="line">$ ./cpp_thread_pthread </span><br><span class="line">Thread 1 thread id 140109390030592</span><br><span class="line">Thread 2 thread id 140109381637888</span><br><span class="line">Thread 1 native handle 140109390030592</span><br><span class="line">Thread 2 native handle 140109381637888</span><br><span class="line">Thread 1 pthread_t 140109390030592</span><br><span class="line">Thread 2 pthread_t 140109381637888</span><br></pre></td></tr></table></figure></p><p><code>uncomment</code>pos 1或者pos 2后，即调用join()或之后detach()，C++线程会丢失本机句柄类型的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./cpp_thread_pthread</span><br><span class="line">Thread 1 pthread_t 139811504355072</span><br><span class="line">Thread 2 pthread_t 139811495962368</span><br><span class="line">Thread 1 thread id thread::id of a non-executing thread</span><br><span class="line">Thread 2 thread id thread::id of a non-executing thread</span><br><span class="line">Thread 1 native handle 0</span><br><span class="line">Thread 2 native handle 0</span><br></pre></td></tr></table></figure></p><p>因此，要有效地调用本机线程终止函数（例如<code>pthread_cancel</code>），需要在调用<code>std::thread::join()</code>时或之前保存本机句柄<code>std::thread::detach()</code>。这样，始终可以使用有效的本机句柄终止线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">    void sleep_for(const std::string &amp;tname, int num)</span><br><span class="line">    &#123;</span><br><span class="line">        prctl(PR_SET_NAME,tname.c_str(),0,0,0);        </span><br><span class="line">        sleep(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void start_thread(const std::string &amp;tname)</span><br><span class="line">    &#123;</span><br><span class="line">        std::thread thrd = std::thread(&amp;Foo::sleep_for, this, tname, 3600);</span><br><span class="line">        tm_[tname] = thrd.native_handle();</span><br><span class="line">        thrd.detach();</span><br><span class="line">        std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; tname &lt;&lt; &quot; created:&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void stop_thread(const std::string &amp;tname)</span><br><span class="line">    &#123;</span><br><span class="line">        ThreadMap::const_iterator it = tm_.find(tname);</span><br><span class="line">        if (it != tm_.end()) &#123;</span><br><span class="line">            pthread_cancel(it-&gt;second);</span><br><span class="line">            tm_.erase(tname);</span><br><span class="line">            std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; tname &lt;&lt; &quot; killed:&quot; &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    typedef std::unordered_map&lt;std::string, pthread_t&gt; ThreadMap;</span><br><span class="line">    ThreadMap tm_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    std::string keyword(&quot;test_thread&quot;);</span><br><span class="line">    std::string tname1 = keyword + &quot;1&quot;;</span><br><span class="line">    std::string tname2 = keyword + &quot;2&quot;;</span><br><span class="line"></span><br><span class="line">    // create and kill thread 1</span><br><span class="line">    foo.start_thread(tname1);</span><br><span class="line">    foo.stop_thread(tname1);</span><br><span class="line"></span><br><span class="line">    // create and kill thread 2</span><br><span class="line">    foo.start_thread(tname2);</span><br><span class="line">    foo.stop_thread(tname2);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -Wall -std=c++11 kill_cpp_thread.cc -o kill_cpp_thread -pthread -lpthread</span><br><span class="line">$ ./kill_cpp_thread </span><br><span class="line">Thread test_thread1 created:</span><br><span class="line">30332 30333 pts/5    00:00:00 test_thread1</span><br><span class="line">Thread test_thread1 killed:</span><br><span class="line">Thread test_thread2 created:</span><br><span class="line">30332 30340 pts/5    00:00:00 test_thread2</span><br><span class="line">Thread test_thread2 killed:</span><br></pre></td></tr></table></figure></p><p>当然，条件允许的话最好还是使用返回或信号的方式终止线程，这样也符合安全可信的要求。</p><p>【转载声明】转载请附上原贴，阿里嘎多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;故事的起因来源于我在优化他人c++源码的时候，想通过多线程的方式提升程序的运算效率，主要存在以下需求和难点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多个线程并行跑模型，看哪个模型跑的快，跑出来后结束其他线程，线程间独立运行无通信过程&lt;/li&gt;
&lt;li&gt;源码模型很复杂，函数调用较多，不好改动，因此不太适合通过信号或标志进行通信终止&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="C++" scheme="https://dlc1994.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://dlc1994.github.io/tags/C/"/>
    
      <category term="多线程" scheme="https://dlc1994.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dlc1994.github.io/2021/06/22/cl0zeby7r001ap45c08npg5jk/"/>
    <id>https://dlc1994.github.io/2021/06/22/cl0zeby7r001ap45c08npg5jk/</id>
    <published>2021-06-22T14:03:11.811Z</published>
    <updated>2021-06-22T14:57:12.181Z</updated>
    
    <content type="html"><![CDATA[<p>在primal simplex算法中，每轮迭代都需要选择most candidate的方向并移动到邻近的顶点上，那么，用什么来评估方向的好坏呢？我们知道，选择一个方向走下去对目标值的改善程度是由方向和步长决定的，对于标准型的线性规划问题而言，使目标值下降的方向是reduced cost $d_j &lt;= 0$的那些非基变量，理论上来说，任意一个满足$d_j &lt;= 0$条件的非基变量都可以作为入基，但是我们不是那么随便的人，肯定不会随便选，那要如何选择呢？</p><p>用一高一矮两个人来比喻，同样是走100步，你觉得是高的人走的远还是矮的人走得远呢（莫杠，正常场景）？同理，我这里当然是选择单位步长下能走更远的非基变量，当然，步长也是决定你能走多远的重要因素，这里暂且不论，就考虑最基本的dantzig的选基算法，即</p><script type="math/tex; mode=display">q\in \underset{j\in N}{\argmin} \bar{z}_j</script><p>选入基的法则非常简单对不对，那么假设你处在某一次迭代中，想要计算所有非基变量的reduced cost $d_j, j\in N$，难道需要用reduced cost的计算公式每次计算？</p><script type="math/tex; mode=display">\bar{z}_N = c_N - N^TB^{-T}c_B</script><p>显然大家不会那么傻，就跟revised simplex的$B^{-1}$更新一样，两次迭代间的reduced cost也是有关联关系的，接下来就给大家推导一下，不感兴趣的可以直接跳到结论了哈。</p><p>对于一个genenal形式的LP问题：</p><script type="math/tex; mode=display">\begin{aligned} \min:& \quad c^T x \\ s.t.:& \quad a \le Ax \le b, \\      & \quad l \le x \le u\end{aligned}</script><p>通过增加结构变量的形式可以转成一般形式的LP问题：</p><script type="math/tex; mode=display">\begin{aligned} \min:& \quad c^T x \\ s.t.:& \quad Ax = b, \\      & \quad l \le x \le u\end{aligned}</script><p>注意到当前的$x$包含原始变量和结构变量，记为$x_c$和$x_r$。</p><p>假设primal feasible，由对偶问题性质$Ay+s=c$，那么对于任意迭代时刻，都有如下条件满足</p><script type="math/tex; mode=display">\begin{cases}B x_B + s_B = c_B \\N x_N + s_N = c_N \\s_B = 0\end{cases}</script><p>其中$s_B, s_N$分别为对应基矩阵和非基矩阵的reduced costs。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在primal simplex算法中，每轮迭代都需要选择most candidate的方向并移动到邻近的顶点上，那么，用什么来评估方向的好坏呢？我们知道，选择一个方向走下去对目标值的改善程度是由方向和步长决定的，对于标准型的线性规划问题而言，使目标值下降的方向是reduce
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>智能优化算法（9）：其他类型的优化算法</title>
    <link href="https://dlc1994.github.io/2020/07/17/cl0zeby7q0018p45ciy33zp4h/"/>
    <id>https://dlc1994.github.io/2020/07/17/cl0zeby7q0018p45ciy33zp4h/</id>
    <published>2020-07-17T10:11:40.000Z</published>
    <updated>2020-07-17T10:14:44.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-3-其他类型的优化算法"><a href="#3-3-其他类型的优化算法" class="headerlink" title="3.3 其他类型的优化算法"></a>3.3 其他类型的优化算法</h2><h3 id="3-3-1-和声搜索算法"><a href="#3-3-1-和声搜索算法" class="headerlink" title="3.3.1 和声搜索算法"></a>3.3.1 和声搜索算法</h3><p>和声搜索（Harmony search, HS）算法从和声记忆库按照考虑概率选择一个音调，再按照音调调整概率确定是否对选择的音调进行调整，若需调整利用步长微调，在现有和声记忆库外产生一个音调，称为随机化。用最好的新和声替换最差的和声，不断重复。<br><a id="more"></a><br>算法流程图：<br><img src="/2020/07/17/cl0zeby7q0018p45ciy33zp4h/HS.jpg" alt="HS"></p><p>应用案例：<br>管道优化设计、土坡稳定性分析、电力系统经济导读和模糊控制器设计</p><h3 id="3-3-2-大洪水算法"><a href="#3-3-2-大洪水算法" class="headerlink" title="3.3.2 大洪水算法"></a>3.3.2 大洪水算法</h3><p>大洪水算法（Great Deluge Algorithm, GDA）类似于模拟退火算法，属于单点搜索，区别在于新解的接受方式，模拟退火通过Metropolis准则判断是否接受新解，而GDA通过新解函数值和水平面值的比较进行判断。</p><p>算法流程图：<br><img src="/2020/07/17/cl0zeby7q0018p45ciy33zp4h/GDA.jpg" alt="GDA"></p><p>应用案例:<br>电力调度问题、复杂系统可靠度问题、排课表问题和二次分配问题（集成电路布线、打字机键盘设计、作业调度、物流运输）</p><h3 id="3-3-3-正弦余弦算法"><a href="#3-3-3-正弦余弦算法" class="headerlink" title="3.3.3 正弦余弦算法"></a>3.3.3 正弦余弦算法</h3><p>正弦余弦算法（Sine Cosine Algorithm, SCA）2016年才提出，是一种基于数学规律的元启发方法，基于正弦函数和余弦函数值的变化实现优化搜索，不同于现有任何一种优化算法。</p><p>应用案例：电力系统安全性问题、经济负荷分配问题、结构损伤测试问题和太阳能光伏电池充电问题</p><h3 id="3-3-4-竞争决策算法"><a href="#3-3-4-竞争决策算法" class="headerlink" title="3.3.4 竞争决策算法"></a>3.3.4 竞争决策算法</h3><p>竞争决策算法（Competitive Decision Algorithm, CDA）是中国学者2006年在分析大自然生物界特别是人类各种竞争机制和决策原理基础上，利用竞争造就优化和决策左右结果的特性得出的一种寻优算法，主要用于求解NP-hard问题。</p><p>应用案例：设施选址、最小比率生成树、多目标最小生成树、最小顶点覆盖、TSP、瓶颈TSP、车辆路径和背包问题等</p><h3 id="3-3-3-文化算法"><a href="#3-3-3-文化算法" class="headerlink" title="3.3.3 文化算法"></a>3.3.3 文化算法</h3><p>文化算法（Cultureal Algorithm, CA）模拟人类社会的文化进化过程，在现有智能优化算法基础上，提取隐含在进化过程中的各种信息，以知识的形式加以存储，指导算法的优化过程。</p><p>应用案例：数据挖掘、欺骗检测、服务器集群自适应负载均衡、电路板布局设计</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;3-3-其他类型的优化算法&quot;&gt;&lt;a href=&quot;#3-3-其他类型的优化算法&quot; class=&quot;headerlink&quot; title=&quot;3.3 其他类型的优化算法&quot;&gt;&lt;/a&gt;3.3 其他类型的优化算法&lt;/h2&gt;&lt;h3 id=&quot;3-3-1-和声搜索算法&quot;&gt;&lt;a href=&quot;#3-3-1-和声搜索算法&quot; class=&quot;headerlink&quot; title=&quot;3.3.1 和声搜索算法&quot;&gt;&lt;/a&gt;3.3.1 和声搜索算法&lt;/h3&gt;&lt;p&gt;和声搜索（Harmony search, HS）算法从和声记忆库按照考虑概率选择一个音调，再按照音调调整概率确定是否对选择的音调进行调整，若需调整利用步长微调，在现有和声记忆库外产生一个音调，称为随机化。用最好的新和声替换最差的和声，不断重复。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Optimization Algorithms" scheme="https://dlc1994.github.io/categories/Optimization-Algorithms/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>智能优化算法（8）：差分进化算法</title>
    <link href="https://dlc1994.github.io/2020/07/17/cl0zeby700007p45cbie4mz3o/"/>
    <id>https://dlc1994.github.io/2020/07/17/cl0zeby700007p45cbie4mz3o/</id>
    <published>2020-07-17T10:09:30.000Z</published>
    <updated>2020-07-17T10:11:24.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-2-差分进化算法"><a href="#3-2-差分进化算法" class="headerlink" title="3.2 差分进化算法"></a>3.2 差分进化算法</h2><p>差分进化（Differential Evolution, DE）算法是在求解Chebyshev多项式拟合问题时提出的，算法主要通过基于差分形式的变异操作和基于概率选择的交叉操作进行优化搜索。DE算法最初的设计方法源于遗传退火算法，主要操作包括变异、交叉和选择，但具体实现方法与遗传算法有本质区别。<br><a id="more"></a></p><h3 id="3-2-1-算法原理"><a href="#3-2-1-算法原理" class="headerlink" title="3.2.1 算法原理"></a>3.2.1 算法原理</h3><p>算法首先对搜索群体进行初始化。假设$NP$表示群体规模，$D$表示变量维数，$G$表示迭代次数，令$X_{i,G}$表示第$G$代的寻优个体$i$，并可以表示为：</p><script type="math/tex; mode=display">X_{i,G} = [X_{i,G}^1, X_{i,G}^2,...,X_{i,G}^D] \tag{1}</script><p>对每个搜索个体的解采用随机初始化方法，例如个体$i$的第$j$个解的分量可以通过如下方法产生：</p><script type="math/tex; mode=display">X_{i,0}^j = X_{\min}^j + r(X_{\max}^j-X_{\min}^j) \tag{2}</script><p>其中$X_{\max}^j$和$X_{\min}^j$分别表示第$j$个分量的上下界；$r$表示在[0,1]间服从均匀分布的随机数。完成初始化后，进入循环</p><p><strong>1. 变异操作</strong></p><p>在DE算法中，经典的变异操作是在目标向量的基础上，利用两个向量的差分进行解的更新，比如：</p><script type="math/tex; mode=display">V_{i,G} = X_{r_1, G}+F(X_{r_2, G}-X_{r_3, G}) \tag{3}</script><p>其中$r_1,r_2,r_3$是从当前搜索群体中随机选择的三个个体编号，要求$r_1\ne r_2 \ne r_3$；$X_{i,G}$称为目标向量；$V_{i,G}$表示个体$X_{i,G}$变异后的解向量，称为个体i的合成向量；$X_{r_1,G}$表示被选择的进行变异的向量，$X_{r_2,G}$和$X_{r_3,G}$是被选择进行差分操作的两个向量；系数$F$称为缩放因子，用于控制差分向量对变异公式的影响。</p><p><strong>2. 交叉操作</strong></p><p>在DE算法中，交叉操作是利用合成向量$V_{i,G}$和目标向量$X_{i,G}$的分量进行重新组合产生试验向量$U_{i,G}$，以提高解的多样性。目前，二项式交叉和指数交叉是DE算法主要的交叉方法，<strong>二项式交叉</strong>对应定义如下：</p><script type="math/tex; mode=display">U_{i,G}^j=\left\{\begin{aligned}&V_{i,G}^j, if\; rand \le \; Cr \;or \; j=j_{rand} \\&X_{i,G}^j, otherwise\end{aligned}\right.\tag{4}</script><p>其中，rand表示[0,1]之间服从均匀分布的随机数；Cr表示交叉概率，且取值与[0,1]；$j_{rand}$表示在区间[1,D]上随机产生的整数。</p><p><strong>指数交叉</strong>实现方法如下：</p><script type="math/tex; mode=display">U_{i,G}^j=\left\{\begin{aligned}&V_{i,G}^j, j=<n>_D,<n+1>_D,...,<n+L+1>_D \\&X_{i,G}^j, otherwise\end{aligned}\right.\tag{5}</script><p>其中,$n$和$L$是在[1,D]上随机产生的整数；$&lt;&gt;_D$表示对D进行取模运算。</p><p><strong>3. 选择操作</strong><br>选择操作是基于贪婪策略，比较试验向量$U_{i,G}$和目标向量$X_{i,G}$的优劣，挑选更优的值作为下一代的目标向量。</p><p>DE算法的流程如下图所示：<br><img src="/2020/07/17/cl0zeby700007p45cbie4mz3o/DE.jpg" alt="DE"></p><p>上述算法是差分优化算法的基本形式，目前还有其他版本的算法，可以用DE$/x/y/z$表示，其中$x$表示被变异的向量选择方法；$y$表示变异种采用的差分向量的个数；$z$表示交叉操作的方法，上bin表示二项式交叉，exp表示指数交叉，因此前面的DE算法可以表示为DE$/rand/1/bin$，此外，其他DE算法的形式有：</p><ul><li>DE$/rand/2/bin$</li><li>DE$/best/1/bin$</li><li>DE$/best/2/bin$</li><li>DE$/target-to-best/1/bin$</li><li>DE$/rand/1/exp$</li></ul><h3 id="3-2-2-应用案例"><a href="#3-2-2-应用案例" class="headerlink" title="3.2.2 应用案例"></a>3.2.2 应用案例</h3><p>瓶颈TSP问题（不追求总巡回路线最短，希望在巡回路线中单次行程尽可能短）、Chebyshev多项式拟合问题</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;3-2-差分进化算法&quot;&gt;&lt;a href=&quot;#3-2-差分进化算法&quot; class=&quot;headerlink&quot; title=&quot;3.2 差分进化算法&quot;&gt;&lt;/a&gt;3.2 差分进化算法&lt;/h2&gt;&lt;p&gt;差分进化（Differential Evolution, DE）算法是在求解Chebyshev多项式拟合问题时提出的，算法主要通过基于差分形式的变异操作和基于概率选择的交叉操作进行优化搜索。DE算法最初的设计方法源于遗传退火算法，主要操作包括变异、交叉和选择，但具体实现方法与遗传算法有本质区别。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Optimization Algorithms" scheme="https://dlc1994.github.io/categories/Optimization-Algorithms/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
  </entry>
  
</feed>
