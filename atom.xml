<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LC-Garden</title>
  
  <subtitle>博客没维护好，丢失源文件了，之后慢慢加回来吧</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dlc1994.github.io/"/>
  <updated>2021-06-28T15:29:32.589Z</updated>
  <id>https://dlc1994.github.io/</id>
  
  <author>
    <name>Lingcheng Dai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何编写高效、优雅、可信代码系列（3）——类成员初始化的三种方式</title>
    <link href="https://dlc1994.github.io/2021/06/28/ckqgs2ccc000mucvexeqvjpup/"/>
    <id>https://dlc1994.github.io/2021/06/28/ckqgs2ccc000mucvexeqvjpup/</id>
    <published>2021-06-28T03:11:53.000Z</published>
    <updated>2021-06-28T15:29:32.589Z</updated>
    
    <content type="html"><![CDATA[<p>首先，先得了解一下C++支持哪几种类成员初始化的方式，你常用的又是哪一种。</p><ul><li><p>初始化方式一：初始化列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int a; // 初始化列表</span><br><span class="line">    A(int a_):a(a_)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>初始化方式二：构造函数初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int a; // 初始化列表</span><br><span class="line">    A(int a_, bool b) &#123; a = a_; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>初始化方式三：声明时初始化（也称就地初始化，c++11后支持）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int a = 1; // 声明时初始化</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>在C++98中，支持了在类声明中使用等号“=”加初始值的方式，来初始化类中静态成员常量。这种声明方式我们也称之为“就地”声明。就地声明在代码编写时非常便利，不过C++98对类中就地声明的要求却非常高。如果静态成员不满足常量性，则不可以就地声明，而且即使常量的静态成员也只能是整型或者枚举型才能就地初始化。而非静态成员变量的初始化则必须在构造函数中进行。比如，如下代码在c++98中编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Init</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Init(): a(0) []</span><br><span class="line">    Init(int d): a(d) &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    int a;</span><br><span class="line">    const static int b = 0;</span><br><span class="line"></span><br><span class="line">    int c = 1;           // member, cannot pass build</span><br><span class="line">    static int d = 0;    // member, cannot pass build</span><br><span class="line"></span><br><span class="line">    static const double e = 1.3;      // not int or enum type, cannot pass build</span><br><span class="line">    stati const char* const f = &quot;e&quot;;  // not int or enum type, cannot pass build</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这非常不方便，所以在C++11中，标准允许非静态成员变量的初始化有多种形式。具体而言，除了初始化列表外，在C++11中，标准还允许使用<strong>等号=</strong> 或者 <strong>花括号{}</strong> 进行就地的非静态成员变量初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct init &#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    double b &#123;1.2&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>大家知道，有几种情况下推荐优先使用列表初始化</p><ul><li><strong>const成员变量只能用成员初始化列表来完成初始化，而不能在构造函数内赋值</strong></li><li><strong>初始化的数据成员是对象</strong></li><li><strong>需要初始化引用成员数据</strong></li></ul><p>具体的原因这里不细述，大家可以去看一下《C++ Primer》。</p><p>构造函数初始化的本质是赋值操作（”=”），这个方法存在两个问题，一个是比起初始化列表和就地初始化，此方式的效率偏低；第二个是可能存在错误隐患。</p><p>先说第一个，赋值过程中会产生临时对象，临时对象的构造析构会造成效率损耗，初始化列表的方式就避免了产生临时对象缩带来的问题。</p><p>第二个是，如果你没有重写或者禁止赋值构造函数，c++会悄悄的加上默认的赋值构造函数，这个时候也有可能带来问题。</p><p>从C++11之后，这三种初始化的方法都可以使用，并不会存在冲突，但是，他们之间是有优先级顺序的，这个优先级来源于他们在初始化的时间顺序，后面初始化的会把前面的覆盖掉，成员变量的初始化顺序是</p><p><strong>声明时初始化-&gt;初始化列表-&gt;构造函数初始化</strong></p><p>因此假如三种初始化方式同时存在的话，那么最后保留的成员变量值肯定是构造函数中初始化的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int a = 1;</span><br><span class="line">    A(int a_) :a(2) &#123; a = 3; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    A a;</span><br><span class="line">    cout &lt;&lt; &quot;a.a=&quot; &lt;&lt; a.a &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// a.a=3</span><br></pre></td></tr></table></figure></p><p>既然初始化方式这么多，那么什么时候适用哪种呢？</p><p><strong>1. 声明时初始化的使用场景</strong></p><ul><li>一个优点是直观，你在声明的时候顺便给一个初始值，bravo，别人在看你代码的时候，点一下调到声明也能看到你赋予的初始值，不用再去看构造函数那里给的什么值</li><li>第二个优点更有用了，比如你要定义多个构造函数，每个构造函数都用列表初始化的方法初始化，多麻烦呀，请看下面的例子，妈妈看了再也不用担心我想用其他初始化方法了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Group &#123;</span><br><span class="line">public:</span><br><span class="line">    Group() &#123;&#125;</span><br><span class="line">    Group(int a): data(a) &#123;&#125;</span><br><span class="line">    Group(Mem m): mem(m) &#123;&#125;</span><br><span class="line">    Group(int a, Mem m, string n): data(a), mem(m), name(n) &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    int data = 1;</span><br><span class="line">    Mem mem&#123;0&#125;;</span><br><span class="line">    string name&#123;&quot;Group&quot;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>2. 列表初始化的使用场景</strong><br>前面说过了三个场景，这里赘述一下</p><ul><li>const成员变量只能用成员初始化列表来完成初始化，而不能在构造函数内赋值</li><li>初始化的数据成员是对象</li><li>需要初始化引用成员数据</li></ul><p>但是，需要注意列表初始化的顺序，不过IDE会提示你的</p><p><strong>3. 构造函数初始化的使用场景</strong></p><ul><li>第一个就是拷贝和赋值构造函数里（不然怎么叫赋值构造函数呢）</li><li>第二个就是比较无聊的情况了，比如你想把几个成员函数都初始化成一个值，请看下面例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Group &#123;</span><br><span class="line">public:</span><br><span class="line">    Group() &#123;data1 = data2 = data3 = 0;&#125;</span><br><span class="line">private:</span><br><span class="line">    int data1;</span><br><span class="line">    int data2;</span><br><span class="line">    int data3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>一言以蔽之，优先就地初始化和列表初始化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，先得了解一下C++支持哪几种类成员初始化的方式，你常用的又是哪一种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;初始化方式一：初始化列表&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
      <category term="C++" scheme="https://dlc1994.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://dlc1994.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dlc1994.github.io/2021/06/22/ckqgs2ccr000yucveclndy1p1/"/>
    <id>https://dlc1994.github.io/2021/06/22/ckqgs2ccr000yucveclndy1p1/</id>
    <published>2021-06-22T14:03:11.811Z</published>
    <updated>2021-06-22T14:57:12.181Z</updated>
    
    <content type="html"><![CDATA[<p>在primal simplex算法中，每轮迭代都需要选择most candidate的方向并移动到邻近的顶点上，那么，用什么来评估方向的好坏呢？我们知道，选择一个方向走下去对目标值的改善程度是由方向和步长决定的，对于标准型的线性规划问题而言，使目标值下降的方向是reduced cost $d_j &lt;= 0$的那些非基变量，理论上来说，任意一个满足$d_j &lt;= 0$条件的非基变量都可以作为入基，但是我们不是那么随便的人，肯定不会随便选，那要如何选择呢？</p><p>用一高一矮两个人来比喻，同样是走100步，你觉得是高的人走的远还是矮的人走得远呢（莫杠，正常场景）？同理，我这里当然是选择单位步长下能走更远的非基变量，当然，步长也是决定你能走多远的重要因素，这里暂且不论，就考虑最基本的dantzig的选基算法，即</p><script type="math/tex; mode=display">q\in \underset{j\in N}{\argmin} \bar{z}_j</script><p>选入基的法则非常简单对不对，那么假设你处在某一次迭代中，想要计算所有非基变量的reduced cost $d_j, j\in N$，难道需要用reduced cost的计算公式每次计算？</p><script type="math/tex; mode=display">\bar{z}_N = c_N - N^TB^{-T}c_B</script><p>显然大家不会那么傻，就跟revised simplex的$B^{-1}$更新一样，两次迭代间的reduced cost也是有关联关系的，接下来就给大家推导一下，不感兴趣的可以直接跳到结论了哈。</p><p>对于一个genenal形式的LP问题：</p><script type="math/tex; mode=display">\begin{aligned} \min:& \quad c^T x \\ s.t.:& \quad a \le Ax \le b, \\      & \quad l \le x \le u\end{aligned}</script><p>通过增加结构变量的形式可以转成一般形式的LP问题：</p><script type="math/tex; mode=display">\begin{aligned} \min:& \quad c^T x \\ s.t.:& \quad Ax = b, \\      & \quad l \le x \le u\end{aligned}</script><p>注意到当前的$x$包含原始变量和结构变量，记为$x_c$和$x_r$。</p><p>假设primal feasible，由对偶问题性质$Ay+s=c$，那么对于任意迭代时刻，都有如下条件满足</p><script type="math/tex; mode=display">\begin{cases}B x_B + s_B = c_B \\N x_N + s_N = c_N \\s_B = 0\end{cases}</script><p>其中$s_B, s_N$分别为对应基矩阵和非基矩阵的reduced costs。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在primal simplex算法中，每轮迭代都需要选择most candidate的方向并移动到邻近的顶点上，那么，用什么来评估方向的好坏呢？我们知道，选择一个方向走下去对目标值的改善程度是由方向和步长决定的，对于标准型的线性规划问题而言，使目标值下降的方向是reduce
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>智能优化算法（9）：其他类型的优化算法</title>
    <link href="https://dlc1994.github.io/2020/07/17/ckqgs2ccr000vucveegtqkw1x/"/>
    <id>https://dlc1994.github.io/2020/07/17/ckqgs2ccr000vucveegtqkw1x/</id>
    <published>2020-07-17T10:11:40.000Z</published>
    <updated>2020-07-17T10:14:44.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-3-其他类型的优化算法"><a href="#3-3-其他类型的优化算法" class="headerlink" title="3.3 其他类型的优化算法"></a>3.3 其他类型的优化算法</h2><h3 id="3-3-1-和声搜索算法"><a href="#3-3-1-和声搜索算法" class="headerlink" title="3.3.1 和声搜索算法"></a>3.3.1 和声搜索算法</h3><p>和声搜索（Harmony search, HS）算法从和声记忆库按照考虑概率选择一个音调，再按照音调调整概率确定是否对选择的音调进行调整，若需调整利用步长微调，在现有和声记忆库外产生一个音调，称为随机化。用最好的新和声替换最差的和声，不断重复。<br><a id="more"></a><br>算法流程图：<br><img src="/2020/07/17/ckqgs2ccr000vucveegtqkw1x/HS.jpg" alt="HS"></p><p>应用案例：<br>管道优化设计、土坡稳定性分析、电力系统经济导读和模糊控制器设计</p><h3 id="3-3-2-大洪水算法"><a href="#3-3-2-大洪水算法" class="headerlink" title="3.3.2 大洪水算法"></a>3.3.2 大洪水算法</h3><p>大洪水算法（Great Deluge Algorithm, GDA）类似于模拟退火算法，属于单点搜索，区别在于新解的接受方式，模拟退火通过Metropolis准则判断是否接受新解，而GDA通过新解函数值和水平面值的比较进行判断。</p><p>算法流程图：<br><img src="/2020/07/17/ckqgs2ccr000vucveegtqkw1x/GDA.jpg" alt="GDA"></p><p>应用案例:<br>电力调度问题、复杂系统可靠度问题、排课表问题和二次分配问题（集成电路布线、打字机键盘设计、作业调度、物流运输）</p><h3 id="3-3-3-正弦余弦算法"><a href="#3-3-3-正弦余弦算法" class="headerlink" title="3.3.3 正弦余弦算法"></a>3.3.3 正弦余弦算法</h3><p>正弦余弦算法（Sine Cosine Algorithm, SCA）2016年才提出，是一种基于数学规律的元启发方法，基于正弦函数和余弦函数值的变化实现优化搜索，不同于现有任何一种优化算法。</p><p>应用案例：电力系统安全性问题、经济负荷分配问题、结构损伤测试问题和太阳能光伏电池充电问题</p><h3 id="3-3-4-竞争决策算法"><a href="#3-3-4-竞争决策算法" class="headerlink" title="3.3.4 竞争决策算法"></a>3.3.4 竞争决策算法</h3><p>竞争决策算法（Competitive Decision Algorithm, CDA）是中国学者2006年在分析大自然生物界特别是人类各种竞争机制和决策原理基础上，利用竞争造就优化和决策左右结果的特性得出的一种寻优算法，主要用于求解NP-hard问题。</p><p>应用案例：设施选址、最小比率生成树、多目标最小生成树、最小顶点覆盖、TSP、瓶颈TSP、车辆路径和背包问题等</p><h3 id="3-3-3-文化算法"><a href="#3-3-3-文化算法" class="headerlink" title="3.3.3 文化算法"></a>3.3.3 文化算法</h3><p>文化算法（Cultureal Algorithm, CA）模拟人类社会的文化进化过程，在现有智能优化算法基础上，提取隐含在进化过程中的各种信息，以知识的形式加以存储，指导算法的优化过程。</p><p>应用案例：数据挖掘、欺骗检测、服务器集群自适应负载均衡、电路板布局设计</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;3-3-其他类型的优化算法&quot;&gt;&lt;a href=&quot;#3-3-其他类型的优化算法&quot; class=&quot;headerlink&quot; title=&quot;3.3 其他类型的优化算法&quot;&gt;&lt;/a&gt;3.3 其他类型的优化算法&lt;/h2&gt;&lt;h3 id=&quot;3-3-1-和声搜索算法&quot;&gt;&lt;a href=&quot;#3-3-1-和声搜索算法&quot; class=&quot;headerlink&quot; title=&quot;3.3.1 和声搜索算法&quot;&gt;&lt;/a&gt;3.3.1 和声搜索算法&lt;/h3&gt;&lt;p&gt;和声搜索（Harmony search, HS）算法从和声记忆库按照考虑概率选择一个音调，再按照音调调整概率确定是否对选择的音调进行调整，若需调整利用步长微调，在现有和声记忆库外产生一个音调，称为随机化。用最好的新和声替换最差的和声，不断重复。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Optimization Algorithms" scheme="https://dlc1994.github.io/categories/Optimization-Algorithms/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>智能优化算法（8）：差分进化算法</title>
    <link href="https://dlc1994.github.io/2020/07/17/ckqgs2ccc000bucve8gj5k12w/"/>
    <id>https://dlc1994.github.io/2020/07/17/ckqgs2ccc000bucve8gj5k12w/</id>
    <published>2020-07-17T10:09:30.000Z</published>
    <updated>2020-07-17T10:11:24.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-2-差分进化算法"><a href="#3-2-差分进化算法" class="headerlink" title="3.2 差分进化算法"></a>3.2 差分进化算法</h2><p>差分进化（Differential Evolution, DE）算法是在求解Chebyshev多项式拟合问题时提出的，算法主要通过基于差分形式的变异操作和基于概率选择的交叉操作进行优化搜索。DE算法最初的设计方法源于遗传退火算法，主要操作包括变异、交叉和选择，但具体实现方法与遗传算法有本质区别。<br><a id="more"></a></p><h3 id="3-2-1-算法原理"><a href="#3-2-1-算法原理" class="headerlink" title="3.2.1 算法原理"></a>3.2.1 算法原理</h3><p>算法首先对搜索群体进行初始化。假设$NP$表示群体规模，$D$表示变量维数，$G$表示迭代次数，令$X_{i,G}$表示第$G$代的寻优个体$i$，并可以表示为：</p><script type="math/tex; mode=display">X_{i,G} = [X_{i,G}^1, X_{i,G}^2,...,X_{i,G}^D] \tag{1}</script><p>对每个搜索个体的解采用随机初始化方法，例如个体$i$的第$j$个解的分量可以通过如下方法产生：</p><script type="math/tex; mode=display">X_{i,0}^j = X_{\min}^j + r(X_{\max}^j-X_{\min}^j) \tag{2}</script><p>其中$X_{\max}^j$和$X_{\min}^j$分别表示第$j$个分量的上下界；$r$表示在[0,1]间服从均匀分布的随机数。完成初始化后，进入循环</p><p><strong>1. 变异操作</strong></p><p>在DE算法中，经典的变异操作是在目标向量的基础上，利用两个向量的差分进行解的更新，比如：</p><script type="math/tex; mode=display">V_{i,G} = X_{r_1, G}+F(X_{r_2, G}-X_{r_3, G}) \tag{3}</script><p>其中$r_1,r_2,r_3$是从当前搜索群体中随机选择的三个个体编号，要求$r_1\ne r_2 \ne r_3$；$X_{i,G}$称为目标向量；$V_{i,G}$表示个体$X_{i,G}$变异后的解向量，称为个体i的合成向量；$X_{r_1,G}$表示被选择的进行变异的向量，$X_{r_2,G}$和$X_{r_3,G}$是被选择进行差分操作的两个向量；系数$F$称为缩放因子，用于控制差分向量对变异公式的影响。</p><p><strong>2. 交叉操作</strong></p><p>在DE算法中，交叉操作是利用合成向量$V_{i,G}$和目标向量$X_{i,G}$的分量进行重新组合产生试验向量$U_{i,G}$，以提高解的多样性。目前，二项式交叉和指数交叉是DE算法主要的交叉方法，<strong>二项式交叉</strong>对应定义如下：</p><script type="math/tex; mode=display">U_{i,G}^j=\left\{\begin{aligned}&V_{i,G}^j, if\; rand \le \; Cr \;or \; j=j_{rand} \\&X_{i,G}^j, otherwise\end{aligned}\right.\tag{4}</script><p>其中，rand表示[0,1]之间服从均匀分布的随机数；Cr表示交叉概率，且取值与[0,1]；$j_{rand}$表示在区间[1,D]上随机产生的整数。</p><p><strong>指数交叉</strong>实现方法如下：</p><script type="math/tex; mode=display">U_{i,G}^j=\left\{\begin{aligned}&V_{i,G}^j, j=<n>_D,<n+1>_D,...,<n+L+1>_D \\&X_{i,G}^j, otherwise\end{aligned}\right.\tag{5}</script><p>其中,$n$和$L$是在[1,D]上随机产生的整数；$&lt;&gt;_D$表示对D进行取模运算。</p><p><strong>3. 选择操作</strong><br>选择操作是基于贪婪策略，比较试验向量$U_{i,G}$和目标向量$X_{i,G}$的优劣，挑选更优的值作为下一代的目标向量。</p><p>DE算法的流程如下图所示：<br><img src="/2020/07/17/ckqgs2ccc000bucve8gj5k12w/DE.jpg" alt="DE"></p><p>上述算法是差分优化算法的基本形式，目前还有其他版本的算法，可以用DE$/x/y/z$表示，其中$x$表示被变异的向量选择方法；$y$表示变异种采用的差分向量的个数；$z$表示交叉操作的方法，上bin表示二项式交叉，exp表示指数交叉，因此前面的DE算法可以表示为DE$/rand/1/bin$，此外，其他DE算法的形式有：</p><ul><li>DE$/rand/2/bin$</li><li>DE$/best/1/bin$</li><li>DE$/best/2/bin$</li><li>DE$/target-to-best/1/bin$</li><li>DE$/rand/1/exp$</li></ul><h3 id="3-2-2-应用案例"><a href="#3-2-2-应用案例" class="headerlink" title="3.2.2 应用案例"></a>3.2.2 应用案例</h3><p>瓶颈TSP问题（不追求总巡回路线最短，希望在巡回路线中单次行程尽可能短）、Chebyshev多项式拟合问题</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;3-2-差分进化算法&quot;&gt;&lt;a href=&quot;#3-2-差分进化算法&quot; class=&quot;headerlink&quot; title=&quot;3.2 差分进化算法&quot;&gt;&lt;/a&gt;3.2 差分进化算法&lt;/h2&gt;&lt;p&gt;差分进化（Differential Evolution, DE）算法是在求解Chebyshev多项式拟合问题时提出的，算法主要通过基于差分形式的变异操作和基于概率选择的交叉操作进行优化搜索。DE算法最初的设计方法源于遗传退火算法，主要操作包括变异、交叉和选择，但具体实现方法与遗传算法有本质区别。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Optimization Algorithms" scheme="https://dlc1994.github.io/categories/Optimization-Algorithms/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>智能优化算法（7）：禁忌搜索算法</title>
    <link href="https://dlc1994.github.io/2020/07/17/ckqgs2ccc000kucvesjvdlavg/"/>
    <id>https://dlc1994.github.io/2020/07/17/ckqgs2ccc000kucvesjvdlavg/</id>
    <published>2020-07-17T10:07:01.000Z</published>
    <updated>2020-07-17T10:13:54.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-1-禁忌搜索算法"><a href="#3-1-禁忌搜索算法" class="headerlink" title="3.1 禁忌搜索算法"></a>3.1 禁忌搜索算法</h2><p>禁忌搜索（Tabu Search, TS）算法是局部搜索算法的拓展，采用禁忌表来记录已经到达过的局部最优点，使得在以后一段时期内的搜索中，不再重复搜索这些解，以此跳出局部极值点。<br><a id="more"></a></p><h3 id="3-1-1-算法原理"><a href="#3-1-1-算法原理" class="headerlink" title="3.1.1 算法原理"></a>3.1.1 算法原理</h3><p>区别于模拟退火算法通过温度调整算法从搜索空间的一个点移动到另一个点的概率来避免局部极值，在禁忌搜索算法中，是通过禁忌表驱动算法探索搜索空间的位置区域来避免早熟收敛。</p><p><strong>局部最优解</strong>：给定一个最优化问题实例$(F, f)$的一个邻域$N$，一个可行解$x\in F$，若$\forall g \in N(x)$ 有 $f(x)\le f(g)$，称$x$为关于$N$的局部最优解。</p><p><strong>邻域</strong>：对于组合优化问题$(D,F,f)$，其中$D$为所有解构成的状态空间，$F$为$D$上的可行域，$f$为目标函数，则一个邻域函数可定义为一种映射，即：</p><script type="math/tex; mode=display">N:x\in D -> N(x) \in 2^D</script><p>其中，$2^D$表示所有子集的集合,$N(x)$为$x$的邻域。</p><p>局部搜索算法本质上说是基于贪婪策略的搜索算法，容易实现，但是算法往往会陷入局部极值，无法保证获得全局最优解，为避免早熟收敛，禁忌搜索算法通过禁忌策略扩大寻优范围，提高算法全局优化能力。</p><h3 id="3-1-2-算法模型"><a href="#3-1-2-算法模型" class="headerlink" title="3.1.2 算法模型"></a>3.1.2 算法模型</h3><p>禁忌搜索算法第一次在优化过程中使用了记忆功能，使用禁忌表来避免重复搜索，扩大搜索区域。</p><p><strong>1. 禁忌表</strong></p><p>禁忌表由禁忌对象和禁忌长度组成，禁忌对象是产生解变化的因素，而禁忌长度是禁忌对象被禁次数。</p><p>禁忌对象分为解的简单变化、解向量分量变化、目标值变化</p><ul><li>解的简单变化。从解空间中的$x$到$y$</li><li>解向量分量的变化。解向量有$n$维，其中一维或者某几维发生变化</li><li>目标值变化。具有相同目标值的解认为是同一状态，</li></ul><p><strong>2. 禁忌长度</strong></p><p>禁忌长度就是被禁对象不允许被选择的迭代次数。</p><p>设置禁忌长度$t$的方法主要有两种：</p><ul><li>$t$为常数。</li><li>$t$随迭代次数调整</li></ul><p>研究表明，禁忌长度较大时，算法可以在更多的位置区域进行优化搜索，全局探索性能较好；禁忌长度较小时，算法可以进行精细搜索，局部开发能力较强。动态调整的禁忌长度比固定不变的禁忌长度能够让算法具有更好的性能。</p><p><strong>3. 特设准则</strong></p><p>优化过程中，可能会出现邻域解全是被禁对象，或者解禁某个对象后最优值发生改进。因此，可以将某个被禁对象解禁。</p><p>设置常用方法主要有以下几种：</p><ul><li>基于评价值准则：如果邻域解的评价值优于历史当前最优值</li><li>基于最小错误原则：如果邻域解全是被禁对象，而且不满足评价值准则，那么可以从所有邻域解中选一个最优的</li><li>基于影响力准则：有些对象的变化对目标值影响较大</li></ul><p>TS的流程图：<br><img src="/2020/07/17/ckqgs2ccc000kucvesjvdlavg/TS.jpg" alt="TS"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;3-1-禁忌搜索算法&quot;&gt;&lt;a href=&quot;#3-1-禁忌搜索算法&quot; class=&quot;headerlink&quot; title=&quot;3.1 禁忌搜索算法&quot;&gt;&lt;/a&gt;3.1 禁忌搜索算法&lt;/h2&gt;&lt;p&gt;禁忌搜索（Tabu Search, TS）算法是局部搜索算法的拓展，采用禁忌表来记录已经到达过的局部最优点，使得在以后一段时期内的搜索中，不再重复搜索这些解，以此跳出局部极值点。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Optimization Algorithms" scheme="https://dlc1994.github.io/categories/Optimization-Algorithms/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>智能优化算法（6）：其他基于物理学原理的优化算法</title>
    <link href="https://dlc1994.github.io/2020/07/17/ckqgs2ccr000wucveye8fed91/"/>
    <id>https://dlc1994.github.io/2020/07/17/ckqgs2ccr000wucveye8fed91/</id>
    <published>2020-07-17T10:03:37.000Z</published>
    <updated>2020-07-17T10:06:48.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-2-其他基于物理学原理的优化算法"><a href="#2-2-其他基于物理学原理的优化算法" class="headerlink" title="2.2 其他基于物理学原理的优化算法"></a>2.2 其他基于物理学原理的优化算法</h2><h3 id="2-2-1-引力搜索算法"><a href="#2-2-1-引力搜索算法" class="headerlink" title="2.2.1 引力搜索算法"></a>2.2.1 引力搜索算法</h3><p>受万有引力定律启发，学着提出了一种新型的群体智能优化算法——引力搜索算法（Gravitational Search Algorithm, GSA）。<br><a id="more"></a></p><p>万有引力定律：自然界中任何两个物体都是相互吸引的，引力的大小跟这两个物体的质量的乘积成正比，跟它们的距离的二次方成反比，数学表达式为：</p><script type="math/tex; mode=display">F=G\frac{m_1 m_2}{r^2}</script><p>其中，$F$表示两个物体间的引力，$G$表示万有引力常数，$m_1$和$m_2$分别表示物体1和物体2的质量，$r$表示两个物体间的距离。</p><p>引力搜索算法在求解优化问题时，搜索个体的位置和问题的解相对应，个体质量用于评价个体的优劣，位置越好，质量越大。由于引力作用，个体之间相互吸引并且朝着质量较大的个体方向移动，个体运动遵循牛顿第二定律，随着运动不断进行，最终这个群体都会聚集在质量最大个体的周围，从而找到质量最大的个体，而质量最大的个体占据最优位置，因此算法可以获得问题的最优解。</p><p>算法流程如下图所示：<br><img src="/2020/07/17/ckqgs2ccr000wucveye8fed91/GSA.jpg" alt="GSA"></p><p>应用案例：<br>投资者偏好条件下概率准则投资组合问题</p><p><strong>智能优化算法一般不要求目标函数连续性和可微性，甚至有时连有没有解析表达式都不要求，并且对计算中数据的不确定性也有很强的适应能力。</strong></p><h2 id="2-2-2-混沌优化算法"><a href="#2-2-2-混沌优化算法" class="headerlink" title="2.2.2 混沌优化算法"></a>2.2.2 混沌优化算法</h2><p>基于混沌现象（貌似无规律的复杂运动形态）的独特性质——遍历性、随机性以及规律性，我国学者李兵提出混沌优化算法，通过载波方法将混沌状态和决策变量相对应，然后将混沌运动的遍历范围映射到决策变量的的取值范围，最后利用混沌变量进行优化搜索。</p><p>混沌优化算法的几种特征：</p><ol><li>初值敏感性</li><li>遍历性</li><li>规律性</li><li>随机性</li></ol><p>算法基本步骤：</p><ol><li>算法初始化。</li><li>第一次载波。</li><li>用混沌变量进行迭代搜索。</li><li>经过若干次搜索后优化目标函数值没有发生改变，进行第二次搜索。</li><li>运用二次载波后的混沌变量进行迭代搜搜。</li><li>满足终止条件，终止搜索；否则返回步骤5。</li></ol><p>应用案例：<br>求解天体力学Kepler方程</p><h2 id="2-2-3-随机分形搜索算法"><a href="#2-2-3-随机分形搜索算法" class="headerlink" title="2.2.3 随机分形搜索算法"></a>2.2.3 随机分形搜索算法</h2><p>随机分形搜索算法（Stochastic Fractal Search Algorithm, SFS）采用高斯随机游走模型，基于个体当前位置进行扩散，并根据适应度函数对个体位置做进一步更新。</p><p>分形：自相似性，部分与整体具有相似性，图案之中递归的套着图案。</p><p>随机分形搜索算法将微粒类比为寻优个体，扩散过程类比为优化过程，寻优个体的位置和待优化问题的解相对应，且个体位置的优劣将通过目标函数值的大小进行评价。</p><p>主要步骤：</p><ol><li>设置算法参数，进行种群初始化</li><li>计算个体适应度函数值，找到当前最佳点BP</li><li>执行扩散过程，对于每一个扩散的个体，根据选择的高斯游走模型生成新个体的新位置</li><li>进行群体第一次更新</li><li>进行群体第二次更新</li><li>判断终止条件，不满足则执行步骤2</li></ol><p>应用案例：<br>CEC2010测试函数库</p><h2 id="2-2-4-光学优化算法"><a href="#2-2-4-光学优化算法" class="headerlink" title="2.2.4 光学优化算法"></a>2.2.4 光学优化算法</h2><p>光学优化算法（Optics Inspired Optimization, OIO）2015年才提出，假设初始解为一系列初始光源点，经球面镜函数反射，得到相应的像点，这一系列像点，作为下一次搜索的光源点，不断反射搜索，即可找到最优解。</p><p>应用案例：<br>城市排水工程——暴雨强度公式参数优化</p><h2 id="2-2-5-量子优化算法"><a href="#2-2-5-量子优化算法" class="headerlink" title="2.2.5 量子优化算法"></a>2.2.5 量子优化算法</h2><p>量子计算（Quantum computing, QC），遇事不决，量子力学。</p><p>量子优化算法可以和很多优化算法结合，比如量子神经计算、量子遗传算法、量子退火算法等，与其他优化算法相比建模方式有所区别，编码方式也不同</p><p>应用案例：<br>VRP问题</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2-2-其他基于物理学原理的优化算法&quot;&gt;&lt;a href=&quot;#2-2-其他基于物理学原理的优化算法&quot; class=&quot;headerlink&quot; title=&quot;2.2 其他基于物理学原理的优化算法&quot;&gt;&lt;/a&gt;2.2 其他基于物理学原理的优化算法&lt;/h2&gt;&lt;h3 id=&quot;2-2-1-引力搜索算法&quot;&gt;&lt;a href=&quot;#2-2-1-引力搜索算法&quot; class=&quot;headerlink&quot; title=&quot;2.2.1 引力搜索算法&quot;&gt;&lt;/a&gt;2.2.1 引力搜索算法&lt;/h3&gt;&lt;p&gt;受万有引力定律启发，学着提出了一种新型的群体智能优化算法——引力搜索算法（Gravitational Search Algorithm, GSA）。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Optimization Algorithms" scheme="https://dlc1994.github.io/categories/Optimization-Algorithms/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>智能优化算法（5）：模拟退火算法</title>
    <link href="https://dlc1994.github.io/2020/07/17/ckqgs2ccc000lucvetilqto32/"/>
    <id>https://dlc1994.github.io/2020/07/17/ckqgs2ccc000lucvetilqto32/</id>
    <published>2020-07-17T10:00:38.000Z</published>
    <updated>2020-07-17T10:03:06.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-1-模拟退火算法"><a href="#2-1-模拟退火算法" class="headerlink" title="2.1 模拟退火算法"></a>2.1 模拟退火算法</h2><p>模拟退火（Simlated Annealing, SA）算法是一种全局搜索算法，是局部搜索算法的拓展。区别于其他算法，模拟退火算法不要求每次产生的新解质量都有提高。<br><a id="more"></a></p><h3 id="2-1-1-算法原理"><a href="#2-1-1-算法原理" class="headerlink" title="2.1.1 算法原理"></a>2.1.1 算法原理</h3><p>SA源于物理退火过程的模拟，在热力学和物理学中，将固体加温至融化状态，待其徐徐冷却之后使其凝固成规整晶体的过程称为物理退火，可以分为升温过程、降温过程和等温过程三个部分：</p><ul><li>升温过程：加热过程中，温度不断升高，固体粒子热运动增强，能量也在增加；到熔点后固定融化为液态。粒子自由运动增加，从有序的结晶态转变为无序的液态，有助于消除固体内的非均匀态，使得随后的降温过程以某一平衡态为起点。</li><li>降温过程：在冷却时，温度慢慢降低，分子的热运动减弱，逐渐趋向有序。当温度到达结晶温度时，液体凝固，系统熵减小。在冷却时如果温度急剧降低物体只会冷凝为非均匀的亚稳态，系统能量也不会达到最小值。</li><li>等温过程：在物理退火中，系统在每一个温度下面达到平衡态的过程可以用封闭系统的等温过程来描述，即热力学系统在恒定温度下发生的各种物理或者化学过程。该过程可以保证每个温度下系统都能达到平衡态，最终达到固体的基态。</li></ul><h3 id="2-1-2-算法模型"><a href="#2-1-2-算法模型" class="headerlink" title="2.1.2 算法模型"></a>2.1.2 算法模型</h3><p>在SA求解优化问题时，解和目标函数类似于退火过程中物体的状态和能量函数，而最优解就是物体达到能量最低的状态。<br>物理退火过程和模拟退火算法的对应关系<br>|  物理退火过程   | 模拟退火算法  |<br>|  ——  | ——  |<br>| 系统状态  | 解 |<br>| 系统能量  | 目标函数 |<br>| 系统最低能量状态（基态）| 全局最优解|<br>| 加温过程 | 设置初始高温 |<br>| 降温过程 | 温度下降|<br>| 等温过程 | 基于Metropolis准则搜索 |</p><p>算法流程：</p><ol><li>设置初始高温和终止温度，选择任意初始解$x$</li><li>内循环，在当前温度下随机产生一个邻域解$y\in N(x)$($N(x)$表示$x$的邻域)，根据Metropolis准则，判断是否选择新解$y$。如此反复进行直到达到满足内循环停止条件。</li><li>外循环，若满足外循环终止条件算法停止</li></ol><p>为达到每个温度下的平衡态，内循环次数要足够多，但在实际应用中无法达到理论上的平衡态，通常将内循环的次数设为常数值，在外循环中，通过调整温度来控制算法的搜索过程。</p><h3 id="2-1-3-Metropolis准则"><a href="#2-1-3-Metropolis准则" class="headerlink" title="2.1.3 Metropolis准则"></a>2.1.3 Metropolis准则</h3><p>假设在温度$T$下，由当前状态$i$产生新的状态$j$，两种状态对应的能量分布为$E_i$和$E_j$，如果$E_i&gt;E_j$，那么就接受新状态$j$。如果$E_i&lt;E_j$，那么要根据系统处于新状态$j$的概率判断该状态是否为<strong>重要</strong>状态。上述概率用$r$表示，且</p><script type="math/tex; mode=display">r=\exp(-(E_j-E_i)/K_BT)</script><p>其中，$K_B$为Boltzman常数。</p><p>在[0,1]之间产生随机数$\xi$，如果$r&gt;\xi$，那么新状态$j$为重要桩体，接受该状态，否则仍然保留状态$i$。</p><h3 id="2-1-4-应用案例"><a href="#2-1-4-应用案例" class="headerlink" title="2.1.4 应用案例"></a>2.1.4 应用案例</h3><p>平面选址问题，欧氏距离选址，绝对值选址</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2-1-模拟退火算法&quot;&gt;&lt;a href=&quot;#2-1-模拟退火算法&quot; class=&quot;headerlink&quot; title=&quot;2.1 模拟退火算法&quot;&gt;&lt;/a&gt;2.1 模拟退火算法&lt;/h2&gt;&lt;p&gt;模拟退火（Simlated Annealing, SA）算法是一种全局搜索算法，是局部搜索算法的拓展。区别于其他算法，模拟退火算法不要求每次产生的新解质量都有提高。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Optimization Algorithms" scheme="https://dlc1994.github.io/categories/Optimization-Algorithms/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>智能优化算法（4）：人工蜂群优化算法与其他基于生物学原理的优化算法</title>
    <link href="https://dlc1994.github.io/2020/07/17/ckqgs2cbw0002ucvebpy0td5g/"/>
    <id>https://dlc1994.github.io/2020/07/17/ckqgs2cbw0002ucvebpy0td5g/</id>
    <published>2020-07-17T09:57:20.000Z</published>
    <updated>2020-07-17T10:00:14.271Z</updated>
    
    <content type="html"><![CDATA[<p>人工蜂群算法（Artificial Bee Colony Algorithm, ABC），是模拟工蜂的觅食行为提出的，由三个基本部分组成，包括蜜源、雇佣蜂和未雇佣蜂；定义两种行为，包括招募蜜蜂到蜜源和放弃蜜源。<br><a id="more"></a></p><p>蜜源：由含蜜量的多少、距离蜂巢的远近以及采集花蜜的难易程度决定。在人工蜂群算法中对应适应度值，蜜源的质量直接决定了目标函数的优劣。</p><p>雇佣蜂：（Employed Bees），也称为引领蜂，主要任务是勘探蜜源，数量与发现的蜜源数量相同，任务是将每一个蜜源信息传递到蜂巢的其他蜜蜂。</p><p>非雇佣蜂：分为跟随蜂（Onlooker Bees）和侦察蜂（Scout Bees）。初始时刻，跟随蜂的数量和雇佣蜂相同，在蜂巢中等待雇佣蜂传递回信息后按照一定的策略选择蜜源，并进行开采；侦查蜂在蜂巢附近探索新的蜜源，如果探索到的蜜源优于已选择蜜源则对其进行替换。</p><h3 id="1-4-1-算法模型"><a href="#1-4-1-算法模型" class="headerlink" title="1.4.1 算法模型"></a>1.4.1 算法模型</h3><p>对各引领蜂的位置进行初始化，随机产生$2N$个位置，并取较为优异的$N$个位置作为蜜源位置，引领蜂根据采蜜经验，在领域范围内利用下式产生一个新位置，评估新位置的蜜源质量，即当前位置的适应度值。若蜜源质量高于原蜜源质量，则新位置替换原位置。</p><script type="math/tex; mode=display">v_{ij}=x_{ij}+\phi (x_{ij}-x_{kj}) \tag{1}</script><p>其中$v_{ij}$是新位置，$x_{ij}$是原位置，$x_{kj}$是随机选取的邻居蜜源位置；$\phi$是在$[-1,1]$上服从均匀分布的随机数；$k=1,2,…,BN$(BN为种群规模)；$j={1,2,…,n}$（$n$为维数）。</p><p>引领蜂通过跳摇摆舞将蜜源信息分享给跟随蜂，跟随蜂利用下式通过轮盘赌机制来选择一个蜜源，在利用式(1)在此蜜源附近随机产生新蜜源新位置，比较新位置和原位置的蜜源质量，若新位置的蜜源质量更好，则保存新位置。</p><script type="math/tex; mode=display">p_i = fit_i/\sum_{n=1}^BN fit_n</script><script type="math/tex; mode=display">fit_i=\left\{\begin{aligned}\frac{1}{1+f_i}, f_i\ge 0 \\1+|f_i|,fi<0\end{aligned}\right.\tag{2}</script><p>其中，$fit_i$指当前蜜源位置的适应度值。</p><p>如果一个蜜源经过limit代后，其适应度都没有任何改变，则当前蜜源放弃。此外，当前蜜源处的引领蜂变成侦查蜂，侦查蜂利用式（3）进行随机搜索新蜜源：</p><script type="math/tex; mode=display">x_{ij}=x_j^{\min}+rand[0,1](x_j^{\max}-x_j^{min})</script><p>反复进行上述搜索过程，直到算法迭代次数$t$达到预定的最大迭代次数，或者最好解达到预定误差精度时算法结束。流程如下图所示：<br><img src="/2020/07/17/ckqgs2cbw0002ucvebpy0td5g/ABC.jpg" alt="ABC"></p><h3 id="1-4-2-应用案例"><a href="#1-4-2-应用案例" class="headerlink" title="1.4.2 应用案例"></a>1.4.2 应用案例</h3><p>电子商务自动谈判研究-多Agent自动谈判模型</p><h2 id="其他基于生物学原理的优化算法"><a href="#其他基于生物学原理的优化算法" class="headerlink" title="其他基于生物学原理的优化算法"></a>其他基于生物学原理的优化算法</h2><ul><li><strong>蝙蝠算法</strong>：多目标多选择背包问题</li><li><strong>萤火虫群优化算法</strong>：平面选址问题</li><li><strong>布谷鸟优化算法</strong>：函数优化和多维背包问题，测试函数整体比PSO好很多</li><li><strong>人工鱼群算法</strong>：电力系统无功优化、波浪发电系统最优负载、出租车智能调度、大规模多背包问题、机器人路径规划</li><li><strong>细菌觅食优化算法</strong>：城市轨道交通调度优化、永磁同步电机、贝叶斯网络结构学习、柔性作业车间调度问题、投资组合、输电网规划</li><li><strong>生物地理学优化算法</strong>：</li><li><strong>模拟植物生长算法</strong>：多目标旅行商问题</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人工蜂群算法（Artificial Bee Colony Algorithm, ABC），是模拟工蜂的觅食行为提出的，由三个基本部分组成，包括蜜源、雇佣蜂和未雇佣蜂；定义两种行为，包括招募蜜蜂到蜜源和放弃蜜源。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Optimization Algorithms" scheme="https://dlc1994.github.io/categories/Optimization-Algorithms/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>智能优化算法（3）：微粒群优化算法</title>
    <link href="https://dlc1994.github.io/2020/07/17/ckqgs2ccc000nucveujdyzulh/"/>
    <id>https://dlc1994.github.io/2020/07/17/ckqgs2ccc000nucveujdyzulh/</id>
    <published>2020-07-17T09:50:11.000Z</published>
    <updated>2020-07-17T09:56:37.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-3-微粒群优化算法"><a href="#1-3-微粒群优化算法" class="headerlink" title="1.3 微粒群优化算法"></a>1.3 微粒群优化算法</h2><p>微粒群优化（Particle Swarm Optimization, PSO）算法，或称为粒子群优化算法，是一种基于鸟群觅食行为规律提出的群体智能优化算法。算法概念简明，易于实现。<br><a id="more"></a></p><p>在群体觅食过程中，群体中的每一个个体都会受益于所有成员在这个过程中发现和积累的经验。而基于信息交流和共享的个体检的协作正式微粒群优化算法进行优化搜索的基础。</p><p>微粒群算法模拟鸟类觅食模型，将优化问题的搜搜空间类比作鸟类的飞行空间，所需要找到的最优解相当于食物，算法将每只鸟抽象为没有质量的微粒，每个微粒有位置和速度两个特征向量，位置代表候选解，解的优劣通过适应度函数大小进行评价；微粒速度决定飞行方向和速率。</p><p>优化过程中，微粒和位置和其他算法一样需要随机初始化，通过迭代进行更新，每次迭代需要通过两个<strong>极值</strong>进行更新，第一个是每个微粒当前所找到的最好的解，称为<strong>个体极值</strong>；第二个极值是整个群体找到的最好的解，称为<strong>全局极值</strong>。每个微粒根据自身经验和群体经验进行更新。</p><h3 id="1-3-1-算法模型"><a href="#1-3-1-算法模型" class="headerlink" title="1.3.1 算法模型"></a>1.3.1 算法模型</h3><p>设待求解的优化问题维度为$N$，微粒群体规模为$M$，在微粒群优化算法中，$x_i = (x_{i1}, x_{i2}, x_{i3}, …, x_{iN})$表示第$i$个微粒的位置；$v_i=(v_{i1},v_{i2},…,v_{iN})$表示第$i$个微粒的速度；$p_i=(p_{i1},p_{i2},…,p_{iN})$表示第$i$个微粒所搜寻到的最好的位置；$g_i=(g_{1},g_{2},…,g_{N})$表示整个群体所搜寻到的最好的位置。</p><p>Eberhart和Kennedy最初提出的基本微粒群优化算法采用如下迭代方程进行速度和位置的更新：</p><script type="math/tex; mode=display">v_{id}(t+1) = v_{id}(t)+c_1r_1(p_{id}(t)-x_{id}(t))+c_2r_2(g_{d}(t)-x_{d}(t))</script><script type="math/tex; mode=display">x_{id}(t+1) = x_{id}(t)+v_{id}(t+1)</script><p>其中，$i=1,2,…,M;d=1,2,…,N;c_1$和$c_2$是学习因子;$t$表示迭代次数；$r_1$和$r_2$是在$[0,1]$上服从均匀分布的随机数。</p><p>在速度更新方程中，第一项表示微粒根据自身的速度进行惯性运动；第二项表示微粒根据自身经验进行调整，称为<strong>认知</strong>部分；第三项表示微粒根据其他微粒的经验进行调整，称为<strong>社会</strong>部分。需要指出的是，为了防止微粒的速度过大或者过小，需要限定速度的范围：</p><script type="math/tex; mode=display">v_{id}(t+1) > v_{\max} \rightarrow v_{id}(t+1) = v_{\max}</script><script type="math/tex; mode=display">v_{id}(t+1) < -v_{\max} \rightarrow v_{id}(t+1) = -v_{\max}</script><p>在求解边界约束问题上，如果更新后位置越界，常见的修正方法是将其限定在边界上。在公式1中，$g$是整个群体的最好位置。上述算法称为微粒群优化算法的全局版本；此外，也可以将微粒领域内的最好位置设为$g$，则称为局部版本；全局版本算法优化速度快，但是容易陷入局部最优；而局部版本算法优化速度慢，但容易找到更优解。</p><p>算法基本流程：<br><img src="/2020/07/17/ckqgs2ccc000nucveujdyzulh/PSO.jpg" alt="PSO"></p><h3 id="1-3-2-算法分析"><a href="#1-3-2-算法分析" class="headerlink" title="1.3.2 算法分析"></a>1.3.2 算法分析</h3><h4 id="学习因子"><a href="#学习因子" class="headerlink" title="学习因子"></a>学习因子</h4><p>学习因子$c_1_$和$c_2$是微粒根据自身经验和社会经验对其运动进行更新的权重。如果令$c_1$为0，那么微粒缺乏自身经验，这是算法的优化速度可能比较快，但容易陷入局部极值；如果令$c_2$为0，那么优化信息无法在群体内传播，微粒搜索到最优解的概率非常低；如果同时为0，那么算法优化性能会急剧下降。</p><h4 id="领域拓扑结构"><a href="#领域拓扑结构" class="headerlink" title="领域拓扑结构"></a>领域拓扑结构</h4><p>微粒群间的信息交流是算法的重要组成部分，通过为止共享，每个微粒能够向比自身位置更好的方向运动，而领域拓扑就决定了信息交流的方向。拓扑类型有：</p><ul><li>环型（每个微粒受近邻影响，只向最好近邻位置运动）</li><li>星型（全局领域拓扑，完全图，计算复杂度较高）</li><li>齿型（发散的，中心向最好微粒逼近，再把经验传递给其他微粒，其他微粒两两不相连）</li></ul><p>研究发现，环型拓扑收敛速度慢，容易找到全局最优解；星型拓扑收敛速度快，容易陷入局部极值；齿型拓扑优化效果差。这三种属于静态拓扑，还有动态拓扑——优化最小距离、逐步增长、重新组合。</p><p>在基本微粒群优化算法的基础上，有人提出了带惯性权重和收缩因子的两种算法版本：</p><p><strong>惯性权重</strong></p><script type="math/tex; mode=display">v_{id}(t+1) = wv_{id}(t)+c_1r_1(p_{id}(t)-x_{id}(t))+c_2r_2(g_{d}(t)-x_{d}(t))</script><p>其中$w$是惯性权重，用于对速度的控制；较大的惯性权重保证算法具有较强的全局探索能力，较小的惯性权重能保证算法具有较强的局部开发能力。目前，使惯性权重随迭代次数线性递减是最基本的策略，带惯性权重的优化算法是目前主流的算法版本。</p><p><strong>收缩因子</strong></p><script type="math/tex; mode=display">v_{id}(t+1) = \chi (v_{id}(t)+c_1r_1(p_{id}(t)-x_{id}(t))+c_2r_2(g_{d}(t)-x_{d}(t)))</script><p>其中收缩因子$\chi$是$c_1$和$c_2$的函数，函数表达式为：</p><script type="math/tex; mode=display">\chi = \frac{2}{|2-\mu -\sqrt{\mu^2-4\mu}|}</script><p>其中$\mu = c_1+c_2&gt;4$</p><h3 id="1-3-3-应用案例"><a href="#1-3-3-应用案例" class="headerlink" title="1.3.3 应用案例"></a>1.3.3 应用案例</h3><p>多目标优化</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-3-微粒群优化算法&quot;&gt;&lt;a href=&quot;#1-3-微粒群优化算法&quot; class=&quot;headerlink&quot; title=&quot;1.3 微粒群优化算法&quot;&gt;&lt;/a&gt;1.3 微粒群优化算法&lt;/h2&gt;&lt;p&gt;微粒群优化（Particle Swarm Optimization, PSO）算法，或称为粒子群优化算法，是一种基于鸟群觅食行为规律提出的群体智能优化算法。算法概念简明，易于实现。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Optimization Algorithms" scheme="https://dlc1994.github.io/categories/Optimization-Algorithms/"/>
    
    
      <category term="Algorithms" scheme="https://dlc1994.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>智能优化算法（2）：蚁群算法</title>
    <link href="https://dlc1994.github.io/2020/07/03/ckqgs2ccc000pucves7logbxq/"/>
    <id>https://dlc1994.github.io/2020/07/03/ckqgs2ccc000pucves7logbxq/</id>
    <published>2020-07-03T03:23:00.000Z</published>
    <updated>2020-07-03T03:26:42.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-2-蚁群优化算法"><a href="#1-2-蚁群优化算法" class="headerlink" title="1.2 蚁群优化算法"></a>1.2 蚁群优化算法</h2><p>蚁群优化（Ant Colony Optimization, ACO）算法是源自大自然生物界的仿真类算法，其思想吸收了蚁群觅食过程中的行为特性。蚁群算法在TSP问题、二次分配问题、图着色问题、车辆调度问题、通信网络中的负载均衡问题等表现出良好的优化性能。<br><a id="more"></a></p><p>大自然中的蚂蚁没有视觉，依赖于同类散发在环境中的信息素决定自己何去何从，孤立的蚂蚁沿着同伴的信息素轨迹移动，同时释放自己的信息素，从而增强了该路线上的信息素数量，随着越来越多的蚂蚁通过该路线，一条较佳的路线就形成了（这条路径不一定最短，但对于NP-hard问题而言足够了）。</p><h3 id="1-2-1-算法模型"><a href="#1-2-1-算法模型" class="headerlink" title="1.2.1 算法模型"></a>1.2.1 算法模型</h3><p>以旅行商问题（Traveling Salesman Problem, TSP）为例，在图论中称为最小Hamilton问题。</p><p>记$G = (V,E)$为赋权图，$V=(1,2,3,…,N)$为顶点集，$E$为边集，各顶点间的距离$d_{ij}$已知$(d_{ij}&gt;0,d_{ii}=\infty,i,j\in V)$，设</p><script type="math/tex; mode=display">x_{ij} = 1, 若(i,j)在最优回路上；否则为0</script><p>则经典的TSP问题可以表示如下：</p><script type="math/tex; mode=display">\min Z = \sum_{i=1}^{n}\sum_{j=1}^{n}d_{ij}x_{ij}</script><p>服从如下几个约束：</p><ul><li>约束1：$\sum_{j=1}^{n}x_{ij}=1, i\in V$</li><li>约束2：$\sum_{i=1}^{n}x_{ij}=1, j\in V$</li><li>约束3：$\sum_{i\in S}\sum_{j\in S}x_{ij} \le |S|-1, \forall S \subset V$</li><li>约束4：$x_{ij}\in \{0, 1\}$</li></ul><p>其中$|S|$为集合中所含图的顶点数；约束1和2对于每个点来说只有一条边进一条边出，也就是任意两个点间只有一条最优路线；约束3保证了没有任何子回路的产生。</p><p>当$d_{ij} = d_{ji}$时，问题被称为对称型TSP；当对于所有$1\le i, j,k \le n$时，有不等式$d_{ij}+d_{jk}\ge d_{ik}$成立，问题被称为是满足三角形不等式的，记为$\Delta$TSP。三角形不等式在很多情况下是满足的，即使不满足也可以转换为闭包形式求等价TSP最优解。</p><p>蚁群优化算法基本模型：</p><ol><li>蚂蚁群体总是寻找最小费用可行解</li><li>蚂蚁具有记忆性，存储当前路径的信息，构造可行解、评价解的质量、路径反向追踪</li><li>当前状态的蚂蚁可以移动到可行领域任意一点</li><li>每个蚂蚁赋予一个初始状态和若干个终止条件</li><li>蚂蚁从初始状态到可行领域状态，以递推方式构造解，当有一个蚂蚁满足至少一个终止条件时构造过程结束</li><li>蚂蚁按某种概率决策规则移动至领域结点</li><li>移动后信息素轨迹被更新，过程称为“单步在线信息素更新”</li><li>一旦构造出一个解，蚂蚁沿原路方向追踪，更新信息素轨迹，称为“在线延迟信息素更新”</li></ol><h3 id="1-2-2-算法分析"><a href="#1-2-2-算法分析" class="headerlink" title="1.2.2 算法分析"></a>1.2.2 算法分析</h3><p>算法复杂度是$O(nc\cdot n^2\cdot m)$，m为蚂蚁个数，nc为迭代次数或者搜索次数，n为顶点数。算法运行效果受到$\alpha, \beta$等参数影响，其中$\beta$的影响在于体现信息素轨迹的持久性，数值过小意味着信息消失过快；数值过大容易落入局部最优点，因此其数值通常取0.7左右。</p><p>在基本的蚁群优化算法上，可以与其他启发式算法相结合，最典型的就是嵌入局部搜索算法，在各个蚂蚁形成自己的路线后，用局部调整方法（2-opt, 3-opt）加以改进，此外，与遗传算法、模拟退火和禁忌搜索等结合也有一定的成效。</p><p>混合蚁群优化算法主要步骤：</p><ol><li><strong>Begin</strong></li><li>蚂蚁初始化；</li><li>LOOP：</li><li>$\quad$蚂蚁路径构造；</li><li>$\quad$对某个蚂蚁实施局部搜索算法</li><li>$\quad$蚂蚁轨迹更新</li><li>$\quad$若迭代次数未到，转LOOP；</li><li>输出当前最好解</li><li><strong>End</strong></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-2-蚁群优化算法&quot;&gt;&lt;a href=&quot;#1-2-蚁群优化算法&quot; class=&quot;headerlink&quot; title=&quot;1.2 蚁群优化算法&quot;&gt;&lt;/a&gt;1.2 蚁群优化算法&lt;/h2&gt;&lt;p&gt;蚁群优化（Ant Colony Optimization, ACO）算法是源自大自然生物界的仿真类算法，其思想吸收了蚁群觅食过程中的行为特性。蚁群算法在TSP问题、二次分配问题、图着色问题、车辆调度问题、通信网络中的负载均衡问题等表现出良好的优化性能。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Optimization Algorithms" scheme="https://dlc1994.github.io/categories/Optimization-Algorithms/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>智能优化算法（1）：遗传算法</title>
    <link href="https://dlc1994.github.io/2020/07/03/ckqgs2ccc0008ucveqt22ik4o/"/>
    <id>https://dlc1994.github.io/2020/07/03/ckqgs2ccc0008ucveqt22ik4o/</id>
    <published>2020-07-03T03:11:53.000Z</published>
    <updated>2020-07-03T03:41:35.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-遗传算法"><a href="#1-1-遗传算法" class="headerlink" title="1.1 遗传算法"></a>1.1 遗传算法</h2><p>遗传算法（Genetic algorithm, GA），模拟生物在自然环境中遗传和进化的<strong>自适应</strong>（对遗传参数的自适应调整）<strong>全局优化</strong>（随机变异不断寻找全局最优解）算法，基本思想是“优胜劣汰”，是应用最广泛和效果最显著的智能优化算法。<br><a id="more"></a></p><h3 id="1-1-1-编码方法"><a href="#1-1-1-编码方法" class="headerlink" title="1.1.1 编码方法"></a>1.1.1 编码方法</h3><p>算法模型通过对个体（individual，也即solution）进行二进制编码（01编码）、自然数编码、实数编码和树型编码。在对个体进行适应度计算时需要进行解码，实现问题的解空间与算法搜索空间的相互转换。</p><h3 id="1-1-2-适应度函数"><a href="#1-1-2-适应度函数" class="headerlink" title="1.1.2 适应度函数"></a>1.1.2 适应度函数</h3><p>每个个体都有一个适应度函数（Fitness），对这个个体的优劣进行定量评价，适应度函数是算法执行“适者生存、优胜劣汰”的依据。适应度函数需要根据目标函数进行设置，令$g(x)$表示目标函数，令$G(x)$表示适应度函数，从目标函数$g(x)$映射到适应度函数$G(x)$的过程称为<strong>标定</strong>。</p><p>对于最大值优化问题，可直接将$g(x)$设定为适应度函数$G(x)$，即$G(x)=g(x)$；对于最小值优化问题，$G(x)=-\min g(x)$；在遗传算法规定中，适应度函数为正值，但上述二式无法保证，因此需要加上最小值或者最大值以及分段函数。</p><h3 id="1-1-3-选择操作"><a href="#1-1-3-选择操作" class="headerlink" title="1.1.3 选择操作"></a>1.1.3 选择操作</h3><p>选择（Selection）是从当前群体中选择适应度函数值大的个体，这些优良个体有可能作为父代繁殖下一代，<strong>个体适应度函数越大，被选择作为父代的概率越大</strong>（有可能！）</p><p>选择算法有很多，最基本的是轮盘赌算法：</p><script type="math/tex; mode=display">P_i = \frac{F_i}{\sum_{i=1}^{N}F_i}</script><p>其中，$P_i$表示个体被选择的概率；$F_i$表示个体的适应度函数值；$N$表示种群规模。</p><p>根据选择概率$P_i$将圆盘形赌轮分为$N$份，第$i$个扇形的中心角为$2\pi P_i$。随机产生0到1之间服从均匀分布的数$r$，落在第$i$个扇形的累计概率为$Q_i = \sum_{j=1}^i P_j$，则选择个体$i$，重复$N$次，就可以选择$N$个个体。</p><h3 id="1-1-4-交叉操作"><a href="#1-1-4-交叉操作" class="headerlink" title="1.1.4 交叉操作"></a>1.1.4 交叉操作</h3><p>两个个体通过交叉（Crossover）互换染色体部分基因而重组产生新的个体，也就是产生新解。交叉前需要进行随机配对。</p><p>一般情况下，对二进制编码的个体采用点交叉的方法，也就是在两个配对字符串随机选择一个或者多个交叉点，互换部分子串从而产生新的字符串</p><p><img src="/2020/07/03/ckqgs2ccc0008ucveqt22ik4o/crossover.jpg" alt="crossover"></p><p>两个个体是否进行交叉操作由交叉概率决定，<strong>较大的交叉概率可以使遗传算法产生更多新解，保持群体多样性，并能防止算法过早成熟，但是交叉概率过大会使算法过多搜索不必要的解区域，消耗过多的计算时间</strong>，一般取值在0.9左右。</p><h3 id="1-1-5-变异操作"><a href="#1-1-5-变异操作" class="headerlink" title="1.1.5 变异操作"></a>1.1.5 变异操作</h3><p>生物进化中，某些染色体可能会发生基因突变（Mutation），从而产生新的染色体，这也是产生新解的另外一种重要方式。<strong>交叉操作相当于进行全局探索，变异操作相当于进行局部开发，这也是智能优化算法必备的两种搜索能力</strong>。</p><p>个体能否变异取决于变异概率，过低会使得部分有用基因无法进入染色体，不能提高解的质量；过大会使子代丧失父代优良基因，导致算法失去从过去搜索经验的学习能力，一般情况下，变异概率取值为0.005左右。</p><p>值得注意的是，<strong>Rudolph通过马尔科夫链相关理论证明仅采用选择、交叉和变异三个操作的遗传算法不能收敛到全局最优解，而采用精英保留策略的遗传算法是全局收敛的</strong>。</p><p>算法的整体流程如下图所示：</p><p><img src="/2020/07/03/ckqgs2ccc0008ucveqt22ik4o/GA.jpg" alt="GA"></p><h3 id="1-1-6-算法分析"><a href="#1-1-6-算法分析" class="headerlink" title="1.1.6 算法分析"></a>1.1.6 算法分析</h3><p>一个好的智能算法，关键在于全局探索和局部开发能力的平衡。全局探索的目的是对解空间进行更全面的探索，局部开发主要目的是对已知区域进行更精细的搜索，希望获得质量更好的新解。</p><p>遗传算法可以通过设置选择压力实现全局探索和局部开发的平衡。在算法运行初始阶段，设置较小的选择压力可以使算法具有较好的全局探索能力，进行广域搜索；算法运行后期，设置较大的选择压力可以使算法进行比较精细的局部搜索。</p><p>选择压力的设置可以从适应度函数标定和选择策略。</p><p>适应度函数标定，在算法早期，应当缩小个体适应度差距，减少淘汰率；算法运行最后阶段，扩大个体适应度差距，保证算法能在高适应度个体对应解区域进行集中搜索，加快算法收敛速度。常用方法有：</p><ul><li>线性尺度变换 $H = aF+b$</li><li>$\sigma$截断法 $H = F+(\hat F - c\sigma)$</li><li>幂律尺度变换 $H = F^\alpha$</li></ul><p>选择策略，低选择压力可选择多种类型的个体，加强对未知解区域的搜索，避免算法陷入局部极值，但算法优化速度会变得缓慢；高选择压力可选择优良个体，加快优化速度但群体多样性会下降，减少搜索到全局最优值的概率。除了轮盘赌算法外，选择策略还有：</p><ul><li>分级选择法</li><li>锦标赛选择法</li><li>Boltzmann选择法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-1-遗传算法&quot;&gt;&lt;a href=&quot;#1-1-遗传算法&quot; class=&quot;headerlink&quot; title=&quot;1.1 遗传算法&quot;&gt;&lt;/a&gt;1.1 遗传算法&lt;/h2&gt;&lt;p&gt;遗传算法（Genetic algorithm, GA），模拟生物在自然环境中遗传和进化的&lt;strong&gt;自适应&lt;/strong&gt;（对遗传参数的自适应调整）&lt;strong&gt;全局优化&lt;/strong&gt;（随机变异不断寻找全局最优解）算法，基本思想是“优胜劣汰”，是应用最广泛和效果最显著的智能优化算法。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Optimization Algorithms" scheme="https://dlc1994.github.io/categories/Optimization-Algorithms/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【转载】Manacher&#39;s algorithm (马拉车算法)</title>
    <link href="https://dlc1994.github.io/2020/04/05/ckqgs2ccr000tucve0rc929bf/"/>
    <id>https://dlc1994.github.io/2020/04/05/ckqgs2ccr000tucve0rc929bf/</id>
    <published>2020-04-05T07:24:30.000Z</published>
    <updated>2020-04-05T08:48:45.276Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ethsonliu.com/2018/04/kmp.html">Manacher’s算法(C++代码实现)</a><br><a id="more"></a></p><blockquote><p> 文章作者：刘毅 (Ethson Liu)</p><p>发布日期：2018-04-03</p><p>原文链接：<a href="https://ethsonliu.com/2018/04/manacher.html">https://ethsonliu.com/2018/04/manacher.html</a></p></blockquote><h2 id="一：背景"><a href="#一：背景" class="headerlink" title="一：背景"></a>一：背景</h2><p>给定一个字符串，求出其最长回文子串。例如：</p><ol><li>s=”abcd”，最长回文长度为 1；</li><li>s=”ababa”，最长回文长度为 5；</li><li>s=”abccb”，最长回文长度为 4，即 bccb。</li></ol><p>以上问题的传统思路大概是，遍历每一个字符，以该字符为中心向两边查找。其时间复杂度为 $O(n^2)$，效率很差。</p><p>1975 年，一个叫 Manacher 的人发明了一个算法，Manacher 算法（中文名：马拉车算法），该算法可以把时间复杂度提升到 $O(n)$。下面来看看马拉车算法是如何工作的。</p><h2 id="二：算法过程分析"><a href="#二：算法过程分析" class="headerlink" title="二：算法过程分析"></a>二：算法过程分析</h2><p>由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：在字符串首尾，及各字符间各插入一个字符（前提这个字符未出现在串里）。</p><p>举个例子：<code>s=&quot;abbahopxpo&quot;</code>，转换为<code>s_new=&quot;$#a#b#b#a#h#o#p#x#p#o#&quot;</code>（这里的字符 $ 只是为了防止越界，下面代码会有说明），如此，s 里起初有一个偶回文<code>abba</code>和一个奇回文<code>opxpo</code>，被转换为<code>#a#b#b#a#</code>和<code>#o#p#x#p#o#</code>，长度都转换成了<strong>奇数</strong>。</p><p>定义一个辅助数组<code>int p[]</code>，其中<code>p[i]</code>表示以 i 为中心的最长回文的半径，例如：</p><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th></tr></thead><tbody><tr><td style="text-align:center">s_new[i]</td><td style="text-align:center">$</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">h</td><td style="text-align:center">#</td><td style="text-align:center">o</td><td style="text-align:center">#</td><td style="text-align:center">p</td><td style="text-align:center">#</td><td style="text-align:center">x</td><td style="text-align:center">#</td><td style="text-align:center">p</td><td style="text-align:center">#</td></tr><tr><td style="text-align:center">p[i]</td><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">4</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr></tbody></table></div><p>可以看出，<code>p[i] - 1</code>正好是原字符串中最长回文串的长度。</p><p>接下来的重点就是求解 p 数组，如下图：<br><img src="https://resource.ethsonliu.com/image/20180403_02.png" alt=""><br>设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是<code>mx = id + p[id]</code>。</p><p>假设我们现在求<code>p[i]</code>，也就是以 i 为中心的最长回文半径，如果<code>i &lt; mx</code>，如上图，那么：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &lt; mx)  </span><br><span class="line">    p[i] = min(p[<span class="number">2</span> * id - i], mx - i);</span><br></pre></td></tr></table></figure><p><code>2 * id - i</code>为 i 关于 id 的对称点，即上图的 j 点，而<strong><code>p[j]</code>表示以 j 为中心的最长回文半径</strong>，因此我们可以利用<code>p[j]</code>来加快查找。</p><h2 id="三：代码"><a href="#三：代码" class="headerlink" title="三：代码"></a>三：代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">char</span> s_new[<span class="number">2000</span>];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">2000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">s_new[<span class="number">0</span>] = <span class="string">'$'</span>;</span><br><span class="line">s_new[<span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">s_new[j++] = s[i];</span><br><span class="line">s_new[j++] = <span class="string">'#'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s_new[j] = <span class="string">'\0'</span>;  <span class="comment">// 别忘了哦</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> j;  <span class="comment">// 返回 s_new 的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = Init();  <span class="comment">// 取得新字符串长度并完成向 s_new 的转换</span></span><br><span class="line"><span class="keyword">int</span> max_len = <span class="number">-1</span>;  <span class="comment">// 最长回文长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; mx)</span><br><span class="line">p[i] = min(p[<span class="number">2</span> * id - i], mx - i);  <span class="comment">// 需搞清楚上面那张图含义, mx 和 2*id-i 的含义</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (s_new[i - p[i]] == s_new[i + p[i]])  <span class="comment">// 不需边界判断，因为左有'$',右有'\0'</span></span><br><span class="line">p[i]++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们每走一步 i，都要和 mx 比较，我们希望 mx 尽可能的远，这样才能更有机会执行 if (i &lt; mx)这句代码，从而提高效率</span></span><br><span class="line"><span class="keyword">if</span> (mx &lt; i + p[i])</span><br><span class="line">&#123;</span><br><span class="line">id = i;</span><br><span class="line">mx = i + p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">max_len = max(max_len, p[i] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">printf</span>(<span class="string">"请输入字符串：\n"</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"最长回文长度为 %d\n\n"</span>, Manacher());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四：算法复杂度分析"><a href="#四：算法复杂度分析" class="headerlink" title="四：算法复杂度分析"></a>四：算法复杂度分析</h2><p>文章开头已经提及，Manacher 算法为线性算法，即使最差情况下其时间复杂度亦为 $O(n)$，在进行证明之前，我们还需要更加深入地理解上述算法过程。</p><p>根据回文的性质，<code>p[i]</code>的值基于以下三种情况得出：</p><p>（1）：<strong>j 的回文串有一部分在 id 的之外</strong>，如下图：<br><img src="https://resource.ethsonliu.com/image/20180403_03.png" alt=""><br>上图中，黑线为 id 的回文，i 与 j 关于 id 对称，红线为 j 的回文。那么根据代码此时<code>p[i] = mx - i</code>，即紫线。那么<code>p[i]</code>还可以更大么？答案是不可能！见下图：<br><img src="https://resource.ethsonliu.com/image/20180403_04.png" alt=""><br>假设右侧新增的紫色部分是<code>p[i]</code>可以增加的部分，那么根据回文的性质，a 等于 d ，也就是说 id 的回文不仅仅是黑线，而是黑线+两条紫线，矛盾，所以假设不成立，故<code>p[i] = mx - i</code>，不可以再增加一分。</p><p>（2）：<strong>j 回文串全部在 id 的内部</strong>，如下图：<br><img src="https://resource.ethsonliu.com/image/20180403_05.png" alt=""><br>根据代码，此时<code>p[i] = p[j]</code>，那么<code>p[i]</code>还可以更大么？答案亦是不可能！见下图：<br><img src="https://resource.ethsonliu.com/image/20180403_06.png" alt=""><br>假设右侧新增的红色部分是<code>p[i]</code>可以增加的部分，那么根据回文的性质，a 等于 b ，也就是说 j 的回文应该再加上 a 和 b ，矛盾，所以假设不成立，故<code>p[i] = p[j]</code>，也不可以再增加一分。</p><p>（3）：<strong>j 回文串左端正好与 id 的回文串左端重合</strong>，见下图：<br><img src="https://resource.ethsonliu.com/image/20180403_07.png" alt=""><br>根据代码，此时<code>p[i] = p[j]</code>或<code>p[i] = mx - i</code>，并且<code>p[i]</code>还可以继续增加，所以需要</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (s_new[i - p[i]] == s_new[i + p[i]]) </span><br><span class="line">    p[i]++;</span><br></pre></td></tr></table></figure><p>根据（1）（2）（3），很容易推出 Manacher 算法的最坏情况，即为字符串内全是相同字符的时候。在这里我们重点研究 Manacher() 中的 for 语句，推算发现 for 语句内平均访问每个字符 5 次，即时间复杂度为：$T_{worst}(n)=O(n)$。</p><p>同理，我们也很容易知道最佳情况下的时间复杂度，即字符串内字符各不相同的时候。推算得平均访问每个字符 4 次，即时间复杂度为：$T_{best}(n)=O(n)$。</p><p>综上，<strong>Manacher 算法的时间复杂度为 $O(n)$</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ethsonliu.com/2018/04/kmp.html&quot;&gt;Manacher’s算法(C++代码实现)&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Data Structure" scheme="https://dlc1994.github.io/categories/Algorithm-and-Data-Structure/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
      <category term="C/C++" scheme="https://dlc1994.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔记</title>
    <link href="https://dlc1994.github.io/2020/03/30/ckqgs2ccr000uucve6xd9hd29/"/>
    <id>https://dlc1994.github.io/2020/03/30/ckqgs2ccr000uucve6xd9hd29/</id>
    <published>2020-03-30T08:06:27.000Z</published>
    <updated>2020-07-17T09:55:27.106Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习笔记精编版，秋招时的学习笔记<br>  <a id="more"></a></p><h1 id="传统机器学习"><a href="#传统机器学习" class="headerlink" title="传统机器学习"></a>传统机器学习</h1><h2 id="Logistic-Regression和percetron的异同"><a href="#Logistic-Regression和percetron的异同" class="headerlink" title="Logistic Regression和percetron的异同"></a>Logistic Regression和percetron的异同</h2><ol><li>二者都是线性分类器</li><li>损失函数不同，LR是极大似然（交叉熵，对数似然函数，logistic损失（误差平方和损失）目标函数非凸），感知机使用的是均方损失函数（即最小化错误点到分离平面的距离）</li><li>逻辑斯蒂比感知机的优点在于对于激活函数的改进。LR为sigmoid函数，连续可导，概率解释能力，分类更好<br>感知机为阶跃函数，分段函数，分类粗糙，线性分类器参数学习，错误驱动的在线学习算法<br>损失函数L(w;x,y)=max(0, -ywx),如果训练集线性可分，算法必定收敛<br>不足：1.泛化能力不能保证；2.样本顺序敏感；3.不线性可分不收敛<br>改进：参数平均：投票感知机、平均感知机<br>拓展到多分类：构建输入输出联合空间特征函数，将样本(x,y)映射到特征向量空间<br>C分类问题，特征函数φ(x,y)=vec(yx),y为类别的one-hot向量表示</li><li>LR的最大损失函数推导<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/lr.png" alt="lr"><h2 id="最大似然概率"><a href="#最大似然概率" class="headerlink" title="最大似然概率"></a>最大似然概率</h2>p(x|θ) 是条件概率的表示方法，θ 是前置条件，理解为在 θ 的前提下，事件 x 发生的概率，相对应的似然为L(θ|x)可以理解为已知结果为 x ，参数为 θ对应的概率，即：L(θ|x)=P(x|θ)<br>需要说明的是两者在数值上相等，但是意义并不相同，L 是关于 θ 的函数，而 P 则是关于 x 的函数<br>机器学习领域，我们更关注的是似然函数的最大值，我们需要根据已知事件来找出产生这种结果最有可能的条件，目的当然是根据这个最有可能的条件去推测未知事件的概率<br>对数函数不改变原函数的单调性和极值位置，而且根据对数函数的性质可以将乘积转换为加减式，这可以大大简化求导的过程：</li></ol><h2 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h2><ol><li>线性可分支持向量机（硬间隔）<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/svm-hard.png" alt="lr"></li><li>线性支持向量机（软间隔）<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/svm-soft.png" alt="lr"><br>线性可分支持向量机的解W唯一但b不唯一<br>线性支持向量机学习等价于最小化二阶范数正则化的合页函数<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/heye.png" alt="lr"><br>合页损失函数（正确分类且函数间隔大于1，损失为0，max(z,0)）<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/heye2.png" alt="lr"></li><li>非线性支持向量机<br>通过非线性变换转化为高维特征空间中的线性分类问题，即核函数</li><li>序列最小化优化（SMO）算法<br>支持向量机的学习快速算法，固定αi之外的所有参数，然后求αi上的极值；不断重复直至收敛。</li><li><strong>和LR的异同</strong>（<a href="https://www.cnblogs.com/zhizhan/p/5038747.html）">https://www.cnblogs.com/zhizhan/p/5038747.html）</a></li></ol><ul><li>不考虑核函数，LR和SVM都是线性分类算法，分类决策面是线性的</li><li>本质是损失函数不同，LR是对数似然函数（基于概率），SVM是合页损失函数（基于几何间隔）</li><li>SVM只考虑边界点，LR考虑全局，所以LR一般不用核函数</li><li>SVM依赖数据距离测度，需要先做normalization，LR不受影响</li><li>SVM损失函数自带正则（结构风险最小化），LR需要添加</li></ul><h2 id="One-Hot-Encoding-（dummy-variables"><a href="#One-Hot-Encoding-（dummy-variables" class="headerlink" title="One-Hot Encoding （dummy variables)"></a>One-Hot Encoding （dummy variables)</h2><ol><li>一组编码[0 0 1 0]，一个为1其他为0，处理离散分类特征</li><li>许多算法基于向量空间计算，取值拓展到欧氏空间，扩充特征</li><li>特征空间大时，可结合PCA</li><li>树模型不太需要one-hot编码，对DT来说是增加树的深度</li></ol><h2 id="生成模型"><a href="#生成模型" class="headerlink" title="生成模型"></a>生成模型</h2><ol><li>监督生成模型<br>朴素贝叶斯、隐马尔科夫、条件随机场</li><li>非监督生成模型<br>受限玻尔兹曼机、GAN、自回归、变分自编码器、深度信念网络<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/struc.png" alt="lr"><br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/class.png" alt="lr"></li></ol><h2 id="模型融合：Stacking-和-Blending"><a href="#模型融合：Stacking-和-Blending" class="headerlink" title="模型融合：Stacking 和 Blending"></a>模型融合：Stacking 和 Blending</h2><ol><li>Stacking stacking是一种分层模型集成框架。以两层为例，第一层由多个基学习器组成，其输入为原始训练集，第二层的模型则是以第一层基学习器的输出作为特征加入训练集进行再训练，从而得到完整的stacking模型。</li></ol><ul><li>样例：假设我们有Training data（有label）和Testing data（无label），我们需要建立起模型对Testing data的label进行预测，我们利用两个基模型KNN和SVM进行stacking，首先我们需要训练好两个基模型</li><li>一、KNN（Base model 1） 5-fold Cross-Validation + Grid Search确定K的大小</li><li>二、SVM（Base model 2） 5-fold Cross-Validation + Grid Search确定参数 type 和 cost</li><li>三、Stacking（Meta Ensembling）<br>将training data划分成5个testing folds<br>为training data和testing中的每一个样本添加空属性M1、M2（model 1、2的输出），记为train_meta 和 test_meta<br>对于每一个test fold:<br>3.1)将其他4个folds作为一个traing fold，将此training fold作为model 1的输入，对test fold进行预测，将结果存放进train_meta的M1中，类似model 2 的结果存在M2中<br>3.2)将整个training data作为base model的输入，对testing data进行预测，model 1、2的结果分别存在test_meta的M1、M2中<br>将train_meta作为一个新模型S（也就是stacking model）的输入，对test_meta进行预测</li><li>stacking方法从一开始就得确定一个Kfold，这个Kfold将伴随对基模型的调参、生成元特征以及对元模型的调参，贯穿整个stacking流程<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/blending.png" alt="lr"></li></ul><ol><li>Blending Blending与Stacking大致相同，只是Blending的主要区别在于训练集不是通过K-Fold的CV策略来获得预测值从而生成第二阶段模型的特征，而是建立一个Holdout集，例如10%的训练数据，第二阶段的stacker模型就基于第一阶段模型对这10%训练数据的预测值进行拟合。说白了，就是把Stacking流程中的K-Fold CV 改成 HoldOut CV。</li></ol><h2 id="Adaboost-XGBoost-Bagging-LightBoost"><a href="#Adaboost-XGBoost-Bagging-LightBoost" class="headerlink" title="Adaboost,XGBoost,Bagging,LightBoost"></a>Adaboost,XGBoost,Bagging,LightBoost</h2><ol><li>Boost算法 初始样本权重，每次训练得到模型赋予错分样本更大的权重，N次迭代后对N个模型进行加权叠加或投票，得到预测结果；串行过程，不好并行化，计算复杂度高，不适合高维稀疏特征</li><li>XGBoost </li></ol><ul><li>GBDT以CART作为基分类器，XGBoost支持线性分类器（L1，L2的逻辑回归或线性回归）</li><li>GBDT优化使用一阶导数，XGBoost对代价函数进行二阶泰勒展开，支持自定义代价函数</li><li>XGBoost加入正则项，包括树的叶子节点个数、叶子节点上score值（正则化是从bias-variance考虑，可以降低模型variance，降低模型复杂度，防止过拟合，传统GBDT没有?）</li><li>列采样（每个模型随机选取一些列），借鉴随机森林，目的是降低过拟合</li><li>Shrinkage（缩减），相当于学习速率（xgboost中的eta）。xgboost在进行完一次迭代后，会将叶子节点的权重乘上该系数，主要是为了削弱每棵树的影响，让后面有更大的学习空间</li><li>并行化。不是像bagging，仍然是boost方式，并行是在特征排序上，</li><li>xgboost在训练之前，预先对数据进行排序，然后保存成block结构，后面的迭代中重复的使用这个结构，大大的减少了计算量。在进行节点分裂时，计算每个特征的信息增益，各个特征的增益计算就可以开多线程计算。</li><li>分裂节点公式：<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/split.png" alt="lr"></li></ul><ol><li>lightGBM </li></ol><ul><li>训练速度更快，效率更高。</li><li>降低内存使用率。</li><li>更好的准确性。</li><li>支持并行和GPU学习。</li><li>能够处理大规模数据。</li><li>与XGBoost GBDT区别：<br>xgboost采用预排序算法进行特征分割，比较简单；LightGBM用的是histogram（直方图），将连续特征（属性）值存储到离散的bin中，加快训练速度和减少内存使用量<br>稀疏特征优化<br>xgboost是level-wise，多线程同时分类同一层叶子，但不加区分，开销大；lightGBM是leaf-wise的，每次找分类增益最大进行分裂，限制最大深度，防止过拟合<br>并行优化（feature parallel, data parallel, voting parallel）</li></ul><ol><li>GBDT</li></ol><ul><li>GBDT用的回归树</li><li>GBDT 是以决策树为基学习器、采用 Boosting 策略的一种集成学习模型</li><li>与提升树的区别：残差的计算不同，提升树使用的是真正的残差，梯度提升树用当前模型的负梯度来拟合残差。</li><li>核心是每棵树学习的是之前所有树结论和的残差，所有树累加起来做最终结论</li><li>本质上，Shrinkage为每棵树设置了一个weight，累加时要乘以这个weight，但和Gradient并没有关系。<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/gbdt.png" alt="lr"></li></ul><ol><li>随机森林 Bagging的典型应用；随机采样（行、列），防止过拟合；剪枝、限制树深度<br>优点</li></ol><ul><li>在当前的很多数据集上，相对其他算法有着很大的优势，表现良好</li><li>它能够处理很高维度（feature很多）的数据，并且不用做特征选择 PS：特征子集是随机选择的</li><li>在训练完后，它能够给出哪些feature比较重要 PS：<a href="http://blog.csdn.net/keepreder/article/details/47277517">http://blog.csdn.net/keepreder/article/details/47277517</a></li><li>在创建随机森林的时候，对generlization error使用的是无偏估计，模型泛化能力强</li><li>训练速度快，容易做成并行化方法 PS：训练时树与树之间是相互独立的</li><li>在训练过程中，能够检测到feature间的互相影响</li><li>实现比较简单</li><li>对于不平衡的数据集来说，它可以平衡误差。</li><li>如果有很大一部分的特征遗失，仍可以维持准确度。<br>缺点：<br>1、随机森林已经被证明在某些噪音较大的分类或回归问题上会过拟合<br>2、对于有不同取值的属性的数据，取值划分较多的属性会对随机森林产生更大的影响，所以随机森林在这种数据上产出的属性权值是不可信的。</li></ul><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><ol><li>决策树学习算法：特征选择、决策树的生成、剪枝（条件概率分布）</li><li>ID3算法：信息增益；C4.5：信息增益比</li><li>CART分类：基尼系数；CART回归：平方损失函数，用平方误差最小的准则（最小二乘法）求解每个单元上的最优输出值（每个叶子节点上的预测值为所有样本的平均值）。</li><li>决策树的生成通常使用 信息增益最大、信息增益比最大或基尼指数最小作为特征选择的准则。</li></ol><h2 id="过拟合和欠拟合"><a href="#过拟合和欠拟合" class="headerlink" title="过拟合和欠拟合"></a>过拟合和欠拟合</h2><ul><li>正则化 L1（L=∑|w|）和L2(L=||w||^2)；L1的稀疏性，指的就是在加了L1正则项后，模型的解w，有很多分量都是0。引入L2正则时，代价函数在0处的导数仍是d0，无变化。而引入L1正则后，代价函数在0处的导数有一个突变。从d0+λ到d0−λ，若d0+λ和d0−λ异号，则在0处会是一个极小值点。代价函数求导。因此，优化时，很可能优化到该极小值点上，即w=0处。</li><li>提前停止 当测试集误差不再下降时停止可以避免过拟合</li><li>dropout</li><li>偏差-方差分解 在模型能力和复杂度之间取得一个较好的平衡</li><li><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/bias.png" alt="lr"></li><li>偏差高，模型拟合能力不够：增加数据特征、提高模型复杂度、减少正则化系数</li><li>方差高，模型过拟合（训练集错误低，验证集错误高）：降低模型复杂度，加大正则化系数，引入先验、集成模型</li><li><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/bias2.png" alt="lr"></li></ul><h2 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h2><ol><li>经验风险最小化 真实标签与预测标签的差异；最小二乘估计（最小均方误差）；XX^T必须满秩，即rank(XX^T)=d+1，X中每行特征之间线性不相关；样本数小于特征数也不可逆，存在多组解；当XX^T不可逆时，可用PCA消除相关性</li></ol><ul><li><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/estimate.png" alt="lr"></li></ul><ol><li>结构风险最小化 正则化；岭回归（w=(XX^T+λI）^(-1)Xy，使其秩不为0，可看出结构风险最小化准则的LSE；</li></ol><ul><li><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/xx.png" alt="lr"></li></ul><ol><li>最大似然估计 MLE是指找到一组参数w使得似然函数p(y|X,w, σ) 最大，等价于对数似然函数log p(y|X,w, σ) 最大。</li><li>最大后验估计 贝叶斯估计；MAP是指最优参数为后验分布p(w|X, y, ν, σ) 中概率密度最高的参数w。当ν → ∞时，先验分布p(w|ν) 退化为均匀分布，称为无信息先验（non-informative prior），最大后验估计退化为最大似然估计。</li></ol><ul><li><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/back-estimate.png" alt="lr"></li></ul><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>交叉熵（cross entropy) <a href="https://blog.csdn.net/mieleizhi0522/article/details/80200126">https://blog.csdn.net/mieleizhi0522/article/details/80200126</a></p><ul><li><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/loss1.png" alt="lr"></li><li><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/loss2.png" alt="lr"></li><li><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/loss3.png" alt="lr"></li></ul><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><ul><li>特征选择和特征抽取的优点是可以用较少的特征来表示原始特征中的大部分相关信息，去掉噪声信息，并进而提高计算效率和减小维度灾难</li><li>特征选择 选取原始特征集合的一个有效子集，使得基于这个特征子集训练出来的模型准确率最高；子集搜索—前向搜索，反向搜索、L1正则化</li><li>特征抽取 构造一个新的特征空间，并将原始特征投影在新的空间中。线性判断分析（LDA，监督）、PCA（无监督）</li></ul><h2 id="评价标准"><a href="#评价标准" class="headerlink" title="评价标准"></a>评价标准</h2><p>分类问题，常见的评价标准有正确率、准确率、召回率和F值，AUC,ROC,PR曲线</p><ul><li>混淆矩阵</li><li><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/evaluate1.png" alt="lr"></li><li><p><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/evaluate2.png" alt="lr"></p></li><li><p>ROC(Receiver operating characteristic) AUC(Area under the curve)<br><a href="https://tracholar.github.io/machine-learning/2018/01/26/auc.html">https://tracholar.github.io/machine-learning/2018/01/26/auc.html</a><br>准确率、召回率、F1值等依赖于判决阈值的评估指标，AUC没有</p></li><li>AUC可以看做随机从正负样本中选取一对正负样本，其中正样本的得分大于负样本的概率！<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/evaluate3.png" alt="lr"></li></ul><h2 id="超参优化"><a href="#超参优化" class="headerlink" title="超参优化"></a>超参优化</h2><ol><li>超参优化</li></ol><ul><li>网络结构，包括神经元之间的连接关系、层数、每层的神经元数量、激活函数的类型等；</li><li>优化参数，包括优化方法、学习率、小批量的样本数量等；</li><li>正则化系数。</li></ul><ol><li>超参设置方法：人工搜索、网格搜索和随机搜索。<br>网格搜索和随机搜索都没有利用不同超参数组合之间的相关性，即如果模型的超参数组合比较类似，其模型性能也是比较接近的。因此这两种搜索方式一般都比较低效。</li><li>自适应的超参数优化方法：贝叶斯优化和动态资源分配</li><li>贝叶斯优化的一个缺点是高斯过程建模需要计算协方差矩阵的逆，时间复杂度是O(n3)，因此不能很好地处理高维情况。深层神经网络的超参数一般比较多，为了使用贝叶斯优化来搜索神经网络的超参数，需要一些更高效的高斯过程建模</li><li>动态资源分配通过一组超参数的学习曲线来预估这组超参数配置是否有希望得到比较好的结果。逐次减半，将超参数优化看作是一种非随机的最优臂问题</li><li>神经架构搜索</li></ol><h2 id="网络正则化"><a href="#网络正则化" class="headerlink" title="网络正则化"></a>网络正则化</h2><p>传统的机器学习中，提高泛化能力的方法主要是限制模型复杂度，比如采用ℓ1 和ℓ2 正则化等方式。在训练深层神经网络时，特别是在过度参数（Over-Parameterized）（过度参数是指模型参数的数量远远大于训练数据的数量）时，ℓ1 和ℓ2 正则化的效果往往不如浅层机器学习模型中显著。因此训练深度学习模型时，往往还会使用其它的正则化方法，比如数据增强、提前停止、丢弃法、集成法等。<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/nomal1.png" alt="lr"></p><ul><li>权重衰减<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/nomal2.png" alt="lr"></li><li>提前停止</li><li>丢弃法（dropout) 随机丢弃一部分神经元（对应连接边）</li></ul><ol><li>集成学习的解释（每做一次丢弃，相当于从原始的网络中采样得到一个子网络）、贝叶斯学习的解释</li><li>循环神经网络上的dropout 当在循环神经网络上应用丢弃法，不能直接对每个时刻的隐状态进行随机丢弃，这样会损害循环网络在时间维度上记忆能力。一种简单的方法是对非时间维度的连接（即非循环连接）进行随机丢失</li></ol><ul><li>数据增强</li></ul><ol><li>通过数据增强（Data Augmentation）来增加数据量，提高模型鲁棒性，避免过拟合</li><li>旋转（Rotation）：将图像按顺时针或逆时针方向随机旋转一定角度；</li><li>翻转（Flip）：将图像沿水平或垂直方法随机翻转一定角度；</li><li>缩放（Zoom In/Out）：将图像放大或缩小一定比例；</li><li>平移（Shift）：将图像沿水平或垂直方法平移一定步长；</li><li>加噪声（Noise）：加入随机噪声。</li><li>标签平滑</li></ol><ul><li>注意力机制<br>一个和注意力有关的例子是鸡尾酒会效应。当一个人在吵闹的鸡尾酒会上和朋友聊天时，尽管周围噪音干扰很多，他还是可以听到朋友的谈话内容，而忽略其他人的声音（聚焦式注意力）。同时，如果未注意到的背景声中有重要的词（比如他的名字），他会马上注意到（显著性注意力）。</li></ul><ol><li>可以将最大汇聚（max pooling）、门控（gating）机制来近似地看作是自下而上的基于显著性的注意力机制</li><li>注意力机制的计算可以分为两步：一是在所有输入信息上计算注意力分布，二是根据注意力分布来计算输入信息的加权平均</li></ol><h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><p>深层神经网络是一个高度非线性的模型，其风险函数是一个非凸函数，因此风险最小化是一个非凸优化问题，会存在很多局部最优点。</p><ul><li>低维空间的非凸优化问题主要是存在一些局部最优点。</li><li>在高维空间中，非凸优化的难点并不在于如何逃离局部最优点，而是如何逃离鞍点。鞍点的梯度是0，但是在一些维度上是最高点，在另一些维度上是最低点</li><li>深层神经网络的参数非常多，并且有一定的冗余性，这导致每单个参数对最终损失的影响都比较小，这导致了损失函数在局部最优点附近是一个平坦的区域，称为平坦最小值</li></ul><ol><li>梯度下降法及其变种优缺点【An overview of gradient descent optimization algorithms】</li></ol><ul><li>发展历程——SGD -&gt; SGDM -&gt; NAG -&gt;AdaGrad -&gt; AdaDelta -&gt; Adam -&gt; Nadam</li><li>BGD的时间复杂度是O(mn)<br>其中m是一次迭代计算的样本数（所有样本），n是样本特征数。</li><li>SGB的时间复杂度是O(n)好吧？</li><li>SGD一次迭代计算的样本数为1，n为样本特征数</li><li>BatchGD 全数据集用于训练，有大量冗余计算；很慢且消耗内存；可以保证到达局部最优（非凸）或全局最优（凸）</li><li>StochasticGD 一次用一个样本，取消冗余计算；更快、可在线；以高variance更新导致目标函数严重震荡，可能跳出局部最优点找到更好的，也可能不收敛（慢慢减少学习率）</li><li>Mini-batchGD 一次用一部分，结合两者优势；减少参数更新variance，稳定收敛；利用矩阵优势，计算梯度效率更高？<br>挑战：学习率的选择策略——预定义、动态调整；不同特征的学习率（低频特征步长更大）；鞍点</li><li>Momentum 加速相关方向抑制震荡；更新公式与前一次更新值有关；下降像放球一样，在同一个方向上会越来越快，在不同梯度方向会减少更新；更快收敛和更少震荡<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/gd1.png" alt="lr"></li><li>NesterovAcceleratedGreadient 动量法盲目跟随斜坡；NAG上升前先减速，对梯度下降方向有粗略预测；用到了二阶信息，上一个下降点的二阶导（黄色部分）<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/gd2.png" alt="lr"></li><li><p>Adagrad 调整学习率（低频更新大，高频更新小，词嵌入）；适合处理稀疏数据；鲁棒性提升；参数更新率不同per-parameter update;Gt,ii为对角矩阵，对角元素为过去梯度的平方和，可向量化；不需要人为调整学习率；缺陷在于平方梯度在分母，随着训练学习率会变很小，后面不再更新<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/gd3.png" alt="lr"><br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/gd4.png" alt="lr"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Adagrad update</span><br><span class="line">cache += dx*82</span><br><span class="line">x += - learning_rate * dx / (np.sqrt(cache) + 1e-7)</span><br></pre></td></tr></table></figure></li><li><p>Adagrad update<br>cache += dx<em>82<br>x += - learning_rate </em> dx / (np.sqrt(cache) + 1e-7) </p></li><li><p>Adadelta Adagrad的拓展，旨在减少它单调递减的学习率；不收集过去所有梯度，而是收集过去固定值w大小的梯度量；</p></li><li>RMSprop 也是Adagrad的改进，是Adadelta的第一步推导；一种泄露机制</li><li><p><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/gd5.png" alt="lr"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># RMSPorp</span><br><span class="line">cache = decay_rate * cache + (1 - decay_reate) * dx**2</span><br><span class="line">x += - learning_rate * dx / (np.sqrt(cache) + 1e-7)</span><br></pre></td></tr></table></figure></li><li><p>Adaptive Moment Estimation (Adam) Adagrad和RMSprop的结合：<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/gd6.png" alt="lr"><br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/gd7.png" alt="lr"></p></li></ul><p>m与v分别是梯度的一阶矩（带权平均）和二阶矩（带权有偏方差），初始为0向量。Adam的作者发现它们(接近于0向量)，特别是在衰减因子(衰减率)β1,β2接近于1时。为了改进这个问题，对m与v进行偏差修正(bias-corrected)，偏差修正取决于时间步长t</p><ul><li><p>Adam (bias-corrected)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m = beta1 * m + (1-beta1) * dx</span><br><span class="line">v  = beta2 * v  + (1-beta2) * (dx**2)</span><br><span class="line">m /= 1-beta1**t</span><br><span class="line">v /= 1-beta2**t</span><br><span class="line">x += - learning_rate * m / (np.sqrt(v)) + le-7)</span><br></pre></td></tr></table></figure></li><li><p>Nadam Adam和NAG的结合（既调整学习率和粗略预测未来方向）</p></li><li><p>优化器的选择 稀疏数据用自适应学习率方法（ada系列）；RMSprop,Adadelta和Adam比较相似；SGD用的很多？SGD优化时间长，依赖于初始化和退火调度，可能陷于鞍点</p></li></ul><ol><li>用什么优化根本不重要，因为paper的contribution不在优化问题上面。</li><li>控制变量法，如果baseline是用SGD的，自然也用SGD去对比，不然怎么知道是model的差异还是optimization的差异？</li><li>选择Adam还是SGD是工程问题不是科学问题。Adam比SGD好，是通过cross validation得出的不是通过数学推导得出的。</li><li>SGD和Adam没有本质区别，顶多是自行车和变速山地车的区别，多了一些trick罢了。</li><li>SGD在一些场景下效果比其他的好。</li></ol><ul><li>一些tricks </li></ul><ol><li>随机化 防止样本顺序带来的影响或偏差，更好的学习</li><li>Batch normalization（批归一化）在深度神经网络训练过程中使得每一层神经网络的输入保持相同分布，为解决“Internal Covariate Shift”问题——因为深层神经网络在做非线性变换前的<strong>激活输入值（就是那个x=WU+B，U是输入）随着网络深度加深或者在训练过程中，其分布逐渐发生偏移或者变动，之所以训练收敛慢，一般是整体分布逐渐往非线性函数的取值区间的上下限两端靠近</strong>（对于Sigmoid函数来说，意味着激活输入值WU+B是大的负值或正值），所以这导致反向传播时低层神经网络的梯度消失对于每个隐层神经元，把逐渐向非线性函数映射后向取值区间极限饱和区靠拢的输入分布强制拉回到均值为0方差为1的比较标准的正态分布，使得非线性变换函数的输入值落入对输入比较敏感的区域，以此避免<strong>梯度消失</strong>问题。<br>位于X=WU+B激活值获得之后，非线性函数变换</li></ol><ul><li>Scale and shift: 对净输入z(l) 的标准归一化会使得其取值集中的0 附近，如果使用sigmoid型激活函数时，这个取值区间刚好是接近线性变换的区间，减弱了神经网络的非线性性质。因此，为了使得归一化不对网络的表示能力造成负面影响，通过一个附加的缩放和平移变换改变取值区间。</li><li>mini-batch期望和方差：目前主要的训练方法是基于小批量的随机梯度下降方法，z(l) 的期望和方差通常用当前小批量样本集的均值和方差近似估计。</li><li>局限性：批量归一化是对一个中间层的单个神经元进行归一化操作，因此要求小批量样本的数量不能太小，否则难以计算单个神经元的统计信息。此外，如果一个神经元的净输入的分布在神经网络中是动态变化的，比如循环神经网络，那么就无法应用批量归一化操作。</li><li>层归一化LN：层归一化是对一个中间层的所有神经元进行归一化。<br>对于K 个样本的一个小批量集合Z(l) = [z(1,l); · · · ; z(K,l)]，层归一化是对矩阵Z(l) 对每一列进行归一化，而批量归一化是对每一行进行归一化</li><li>权重归一化：对神经网络的连接权重进行归一化，通过再参数化（Reparameterization）方法，将<br>连接权重分解为长度和方向两种参数</li><li>局部响应归一化：基于卷积的图像处理中。局部响应归一化和层归一化都是对同层的神经元进行归一化。不同的是局部响应归一化应用在激活函数之后，只是对邻近的神经元进行局部归一化，并且不减去均值。<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/ln.png" alt="lr"></li></ul><ol><li>提前停止</li><li>梯度噪声 使网络对于糟糕初始化更鲁棒，对训练复杂很深的网络有用<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/ln2.png" alt="lr"></li></ol><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/activation.png" alt="lr"></p><ul><li>Sigmoid S曲线；值域0-1；求导；两端饱和函数；非零中心化的输出会使得其后一层的神经元的输入发生偏置偏移（Bias Shift），并进一步使得梯度下降的收敛速度变慢。</li><li>Logistic函数 σ(x)=(1+exp(-x))^-1</li><li>Tanh函数 放大平移的Logistic函数；值域为（-1,1）；tanh(x)=2σ(2x)-1</li><li>Logistic 函数和Tanh 函数都是Sigmoid 型函数，具有饱和性，但是计算开销较大。因为这两个函数都是在中间（0 附近）近似线性，两端饱和<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/activation2.png" alt="lr"></li><li>ReLU修正线性单元 </li></ul><ol><li>原始ReLU ReLU(x)=max(0,x)；<br>优点：1.神经元运算简单，计算上更高效；2.单侧抑制、宽兴奋边界；3.Sigmoid会导致非稀疏网络，ReLU稀疏性好；4.ReLU左饱和，右导数为1，缓解梯度消失，加速梯度收敛；<br>缺点：1.输出非0中心化，给后层网络引入偏置偏移，影响梯度下降效率；2.死亡ReLU问题</li><li>LeakyReLU LeakyReLU(x)=max(0,x)+γmin(0,x)</li><li>PReLU PReLU=max(0, x) + γ_i min(0, x),可学习参数</li><li>ELU ELU=max(0, x) + min(0, γ(exp(x) − 1))</li><li>Softplus函数 Softplus(x) = log(1 + exp(x)).单侧抑制、宽兴奋边界，没有稀疏激活性<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/activation3.png" alt="lr"></li></ol><ul><li>Swish函数 自门控激活函数 swish(x) = xσ(βx)</li><li>Maxout单元  maxout单元的输入是上一层神经元的全部原始输入，是一个向量x = [x1; x2; · · · , xd]；</li></ul><h2 id="梯度消失和梯度爆炸"><a href="#梯度消失和梯度爆炸" class="headerlink" title="梯度消失和梯度爆炸"></a>梯度消失和梯度爆炸</h2><p>原因：深度神经网络和反向传播，根据损失函数计算的误差通过梯度反向传播的方式，指导深度网络权值的更新优化。</p><ol><li>梯度消失</li></ol><ul><li>网络太深层</li><li>采用了不合适的损失函数</li></ul><ol><li>梯度爆炸</li></ol><ul><li>网络太深</li><li>权值初始化值太大<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/gradient.png" alt="lr"></li></ul><ol><li>解决方案：</li></ol><ul><li>预训练加微调</li><li>梯度剪切，权重正则（针对梯度爆炸）</li><li>使用不同的激活函数</li><li>Batch normalization</li><li>残差结构</li><li>使用LSTM或GRU （有点像残差网络）</li><li>梯度截断  当梯度的模大于一定阈值时，就对梯度进行截断；分为按值截断、按模截断</li></ul><h2 id="卷积神经网络作用及发展"><a href="#卷积神经网络作用及发展" class="headerlink" title="卷积神经网络作用及发展"></a>卷积神经网络作用及发展</h2><h3 id="CNN与DNN区别：卷积、池化"><a href="#CNN与DNN区别：卷积、池化" class="headerlink" title="CNN与DNN区别：卷积、池化"></a>CNN与DNN区别：卷积、池化</h3><ul><li>卷积作用：局部感受野（提升表达能力和泛化能力），参数共享（减少运算量）</li><li>1*1卷积核作用：不影响输入输出维度，增加网络非线性表达能力，降低参数量</li><li>池化（下采样）：最大，平均；减少参数</li><li>激活函数：提升表达能力和泛化能力</li><li>Dropout:随机舍弃某些权重，降低模型复杂度，预防过拟合</li><li>LeNet(传统CNN)-&gt;AlexNet（数据增广，dropout,relu,局部响应归一化LRN）-&gt;VGG(深)-&gt;GoogLeNet(inception增加网络宽度和深度)-&gt;ResNet(shortcut，残差网络，防止梯度消失)-&gt;DenseNet(密集连接，任何两层都有直接的连接，内存占用大)</li></ul><h3 id="卷积神经网络计算"><a href="#卷积神经网络计算" class="headerlink" title="卷积神经网络计算"></a>卷积神经网络计算</h3><ul><li>卷积：n<em>m的图像，k</em>k的滤波器，卷积后为(n-k+1)<em>(m-k+1)，参数量k</em>k+1</li><li>Padding：卷积得到原图像size，加入层数为p=(k-1)/2</li><li>步长stride：(n+2p-k)/s+1，s为步长</li><li>单卷积核：三通道的过滤器与图像卷积，对k<em>k</em>3个数去加权计算和，不是分层计算</li><li>多卷积核：j个k<em>k</em>3的滤波器，得到(n-k+1)<em>(m-k+1)</em>j层输出，参数量k<em>k</em>3*j+j</li><li>池化：改变输入输出，不会有参数，n<em>m的图像，k</em>k的滤波器,s为步长，输出(n+2p-k)/s+1</li><li>全连接层：FC1 * FC2</li></ul><h3 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h3><ul><li>任务模式：序列到类别（分类）、同步序列到序列（词性标注）、异步序列到序列（编码器解码器、机器翻译）</li><li><p>参数学习：随时间反向传播（BPTT），实时循环学习算法（RTRL、前向传播）</p></li><li><p>两种算法比较：RTRL算法和BPTT算法都是基于梯度下降的算法，分别通过前<br>向模式和反向模式应用链式法则来计算梯度。在循环神经网络中，一般网络输<br>出维度远低于输入维度，因此BPTT算法的计算量会更小，但是BPTT算法需<br>要保存所有时刻的中间梯度，空间复杂度较高。RTRL算法不需要梯度回传，因<br>此非常适合用于需要在线学习或无限序列的任务中。</p></li><li>长期依赖问题：如果t时刻的输出yt 依赖于t−k 时刻的输入xt−k，当间隔k 比较大时，简单神经网络很难建模这种长距离的依赖关系，称为长期依赖问题</li><li>梯度爆炸：权重衰减（通过给参数增加ℓ1 或ℓ2 范数的正则化项来限制参数的取值范<br>围，从而使得γ ≤ 1）、梯度截断（当梯度的模大于一定阈值时，就将它截断成为一个较小的数）</li><li>梯度消失（RNN主要问题）：改变模型，ht = ht−1 + g(xt, ht−1; θ), (6.50)<br>这样ht 和ht−1 之间为既有线性关系，也有非线性关系，但有记忆容量问题—增加额外存储，选择性遗忘</li><li>LSTM和GRU：基于门控的循环神经网络</li><li>LSTM:LSTM网络引入一个新的内部状态（internal state）ct 专门进行<br>线性的循环信息传递，同时（非线性）输出信息给隐藏层的外部状态ht。<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/lstm1.png" alt="lr"><br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/lstm2.png" alt="lr"></li><li>LSTM网络中的“门”是一种“软”门，取值在(0, 1) 之间，表示以一定的比例运行信息通过。</li><li>输入门：输入门it 控制当前时刻的候选状态˜ct 有多少信息需要保存</li><li>遗忘门：遗忘门ft 控制上一个时刻的内部状态ct−1 需要遗忘多少信息</li><li>输出门：输出门ot 控制当前时刻的内部状态ct 有多少信息需要输出给外部状态ht。<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/lstm3.png" alt="lr"><br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/lstm4.png" alt="lr"></li></ul><p>LSTM网络中，记忆单元c 可以在某个时刻捕捉到某个关键信息，并有能力将此关键信息保存一定的时间间隔。记忆单元c 中保存信息的生命周期要长于短期记忆h，但又远远短于长期记忆，因此称为长的短期记忆（long short-term memory）。</p><h3 id="LSTM变体："><a href="#LSTM变体：" class="headerlink" title="LSTM变体："></a>LSTM变体：</h3><ul><li>无遗忘门的LSTM Schmidhuber最早提出，ct会不断累加</li><li>peephole连接 三个门不但依赖于输入xt 和上一时刻的隐状态ht−1，也依赖于上一个时刻的记忆单元ct−1。</li><li><p>耦合输入门和遗忘门 LSTM网络中的输入门和遗忘门有些互补关系，同时用两个门比较冗余。</p></li><li><p>门控循环单元（GRU)   GRU将输入门与和遗忘门合并成一个门：更新门。同时，GRU也不引入额外的记忆单元，直接在当前状态ht 和历史状态ht−1 之间引入线性依赖关系。</p></li></ul><p>深层循环神经网络  增加循环神经网络的深度主要是增加同一时刻网络输入到输出之间的路径xt →yt，比如增加隐状态到输出ht → yt，以及输入到隐状态xt → ht 之间的路径的深度。</p><ul><li>堆叠循环神经网络<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/lstm5.png" alt="lr"><br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/lstm6.png" alt="lr"></li><li>双向循环神经网络  一个时刻的输出不但和过去时刻的信息有关，也和后续时刻的信息有关。比如给定一个句子，其中一个词的词性由它的上下文决定<br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/lstm7.png" alt="lr"><br><img src="/2020/03/30/ckqgs2ccr000uucve6xd9hd29/lstm8.png" alt="lr"></li></ul><h3 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h3><p>参数初始化</p><ul><li>在感知器和logistic 回归的训练中，我们一般将参数全部初始化为0</li><li>对称权重：神经网络训练，前向计算时所有隐层神经元激活值相同，导致深层无区分性</li><li>参数初始化过小：多层传递信号慢慢消失；使sigmoid丢失非线性（0附近近似线性）</li><li>参数初始化过大：sigmoid后激活值变得饱和，导致梯度接近于0</li><li>常用初始化方法：Gassian分布初始化、均匀分布初始化（Xavier 初始化）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习笔记精编版，秋招时的学习笔记&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="https://dlc1994.github.io/categories/Machine-Learning/"/>
    
    
      <category term="Gradient Decent Methods" scheme="https://dlc1994.github.io/tags/Gradient-Decent-Methods/"/>
    
  </entry>
  
  <entry>
    <title>clion连接postgresql</title>
    <link href="https://dlc1994.github.io/2020/03/21/ckqgs2ccr000qucved0ebknc4/"/>
    <id>https://dlc1994.github.io/2020/03/21/ckqgs2ccr000qucved0ebknc4/</id>
    <published>2020-03-21T04:12:20.000Z</published>
    <updated>2020-03-21T04:23:54.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Clion连接postgresql"><a href="#Clion连接postgresql" class="headerlink" title="Clion连接postgresql"></a>Clion连接postgresql</h1><p><a href="https://www.jetbrains.com/clion/">Clion</a>是<code>Jetbrains</code>家的面向跨平台开发的<code>C/C++</code>集成开发环境. 有时候开发需要连接到数据库进行<code>query</code>查询.<br><a id="more"></a></p><h2 id="安装postgresql"><a href="#安装postgresql" class="headerlink" title="安装postgresql"></a>安装postgresql</h2><p><a href="https://www.runoob.com/postgresql/windows-install-postgresql.html">教程</a><br>可用菜单栏上的<code>pgAdmin</code>查询自己的数据库名、端口</p><h2 id="安装Clion"><a href="#安装Clion" class="headerlink" title="安装Clion"></a>安装Clion</h2><p>参考详细文档<a href="https://www.jetbrains.com/clion">Clion使用</a></p><h2 id="设置database连接"><a href="#设置database连接" class="headerlink" title="设置database连接"></a>设置database连接</h2><ol><li><p>clion界面右侧-&gt;<code>+</code>号-&gt;<code>Data Source</code>-&gt;<code>PostgreSQL</code></p></li><li><p>检查数据库信息，用户名和密码是否正确，点击<code>Test Connection</code>，成功可返回；不成功查看下一步。</p></li><li><p>若无法连接外网，点击下方的<code>Download</code>，无法下载，但要把网址上的<code>.jar</code>包下载下来，后面用到；点击左侧<code>drivers</code>-&gt;<code>PostgreSQL</code>，在<code>Dirver files</code>下点击<code>+</code>号，加载刚下载的<code>jar</code>包，然后左侧的<code>Data source</code>，点击<code>Test Connection</code>可以看到数据库具体信息。</p></li></ol><ul><li>有时候<code>clion</code>首页会重新让输入数据库用户名和密码，输入即可</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Clion连接postgresql&quot;&gt;&lt;a href=&quot;#Clion连接postgresql&quot; class=&quot;headerlink&quot; title=&quot;Clion连接postgresql&quot;&gt;&lt;/a&gt;Clion连接postgresql&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.jetbrains.com/clion/&quot;&gt;Clion&lt;/a&gt;是&lt;code&gt;Jetbrains&lt;/code&gt;家的面向跨平台开发的&lt;code&gt;C/C++&lt;/code&gt;集成开发环境. 有时候开发需要连接到数据库进行&lt;code&gt;query&lt;/code&gt;查询.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Development" scheme="https://dlc1994.github.io/categories/Development/"/>
    
    
      <category term="Clion" scheme="https://dlc1994.github.io/tags/Clion/"/>
    
      <category term="Database" scheme="https://dlc1994.github.io/tags/Database/"/>
    
      <category term="Postgresql" scheme="https://dlc1994.github.io/tags/Postgresql/"/>
    
  </entry>
  
  <entry>
    <title>【转载】Knuth–Morris–Pratt algorithm (KMP算法)</title>
    <link href="https://dlc1994.github.io/2020/03/19/ckqgs2ccc000gucvex4zxus36/"/>
    <id>https://dlc1994.github.io/2020/03/19/ckqgs2ccc000gucvex4zxus36/</id>
    <published>2020-03-19T07:24:30.000Z</published>
    <updated>2020-04-05T08:38:26.498Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ethsonliu.com/2018/04/kmp.html">KMP算法(C++代码实现)</a><br><a id="more"></a></p><blockquote><p> 文章作者：刘毅 (Ethson Liu)</p><p>发布日期：2018-04-04</p><p>原文链接：<a href="https://ethsonliu.com/2018/04/kmp.html">https://ethsonliu.com/2018/04/kmp.html</a></p></blockquote><h2 id="一：背景"><a href="#一：背景" class="headerlink" title="一：背景"></a>一：背景</h2><p>给定一个字符串，求出其最长回文子串。例如：</p><ol><li>s=”abcd”，最长回文长度为 1；</li><li>s=”ababa”，最长回文长度为 5；</li><li>s=”abccb”，最长回文长度为 4，即 bccb。</li></ol><p>以上问题的传统思路大概是，遍历每一个字符，以该字符为中心向两边查找。其时间复杂度为 $O(n^2)$，效率很差。</p><p>1975 年，一个叫 Manacher 的人发明了一个算法，Manacher 算法（中文名：马拉车算法），该算法可以把时间复杂度提升到 $O(n)$。下面来看看马拉车算法是如何工作的。</p><h2 id="二：算法过程分析"><a href="#二：算法过程分析" class="headerlink" title="二：算法过程分析"></a>二：算法过程分析</h2><p>由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：在字符串首尾，及各字符间各插入一个字符（前提这个字符未出现在串里）。</p><p>举个例子：<code>s=&quot;abbahopxpo&quot;</code>，转换为<code>s_new=&quot;$#a#b#b#a#h#o#p#x#p#o#&quot;</code>（这里的字符 $ 只是为了防止越界，下面代码会有说明），如此，s 里起初有一个偶回文<code>abba</code>和一个奇回文<code>opxpo</code>，被转换为<code>#a#b#b#a#</code>和<code>#o#p#x#p#o#</code>，长度都转换成了<strong>奇数</strong>。</p><p>定义一个辅助数组<code>int p[]</code>，其中<code>p[i]</code>表示以 i 为中心的最长回文的半径，例如：</p><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th></tr></thead><tbody><tr><td style="text-align:center">s_new[i]</td><td style="text-align:center">$</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">h</td><td style="text-align:center">#</td><td style="text-align:center">o</td><td style="text-align:center">#</td><td style="text-align:center">p</td><td style="text-align:center">#</td><td style="text-align:center">x</td><td style="text-align:center">#</td><td style="text-align:center">p</td><td style="text-align:center">#</td></tr><tr><td style="text-align:center">p[i]</td><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">4</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr></tbody></table></div><p>可以看出，<code>p[i] - 1</code>正好是原字符串中最长回文串的长度。</p><p>接下来的重点就是求解 p 数组，如下图：<br><img src="https://resource.ethsonliu.com/image/20180403_02.png" alt=""><br>设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是<code>mx = id + p[id]</code>。</p><p>假设我们现在求<code>p[i]</code>，也就是以 i 为中心的最长回文半径，如果<code>i &lt; mx</code>，如上图，那么：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &lt; mx)  </span><br><span class="line">    p[i] = min(p[<span class="number">2</span> * id - i], mx - i);</span><br></pre></td></tr></table></figure><p><code>2 * id - i</code>为 i 关于 id 的对称点，即上图的 j 点，而<strong><code>p[j]</code>表示以 j 为中心的最长回文半径</strong>，因此我们可以利用<code>p[j]</code>来加快查找。</p><h2 id="三：代码"><a href="#三：代码" class="headerlink" title="三：代码"></a>三：代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">char</span> s_new[<span class="number">2000</span>];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">2000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">s_new[<span class="number">0</span>] = <span class="string">'$'</span>;</span><br><span class="line">s_new[<span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">s_new[j++] = s[i];</span><br><span class="line">s_new[j++] = <span class="string">'#'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s_new[j] = <span class="string">'\0'</span>;  <span class="comment">// 别忘了哦</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> j;  <span class="comment">// 返回 s_new 的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = Init();  <span class="comment">// 取得新字符串长度并完成向 s_new 的转换</span></span><br><span class="line"><span class="keyword">int</span> max_len = <span class="number">-1</span>;  <span class="comment">// 最长回文长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; mx)</span><br><span class="line">p[i] = min(p[<span class="number">2</span> * id - i], mx - i);  <span class="comment">// 需搞清楚上面那张图含义, mx 和 2*id-i 的含义</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (s_new[i - p[i]] == s_new[i + p[i]])  <span class="comment">// 不需边界判断，因为左有'$',右有'\0'</span></span><br><span class="line">p[i]++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们每走一步 i，都要和 mx 比较，我们希望 mx 尽可能的远，这样才能更有机会执行 if (i &lt; mx)这句代码，从而提高效率</span></span><br><span class="line"><span class="keyword">if</span> (mx &lt; i + p[i])</span><br><span class="line">&#123;</span><br><span class="line">id = i;</span><br><span class="line">mx = i + p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">max_len = max(max_len, p[i] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">printf</span>(<span class="string">"请输入字符串：\n"</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"最长回文长度为 %d\n\n"</span>, Manacher());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四：算法复杂度分析"><a href="#四：算法复杂度分析" class="headerlink" title="四：算法复杂度分析"></a>四：算法复杂度分析</h2><p>文章开头已经提及，Manacher 算法为线性算法，即使最差情况下其时间复杂度亦为 $O(n)$，在进行证明之前，我们还需要更加深入地理解上述算法过程。</p><p>根据回文的性质，<code>p[i]</code>的值基于以下三种情况得出：</p><p>（1）：<strong>j 的回文串有一部分在 id 的之外</strong>，如下图：<br><img src="https://resource.ethsonliu.com/image/20180403_03.png" alt=""><br>上图中，黑线为 id 的回文，i 与 j 关于 id 对称，红线为 j 的回文。那么根据代码此时<code>p[i] = mx - i</code>，即紫线。那么<code>p[i]</code>还可以更大么？答案是不可能！见下图：<br><img src="https://resource.ethsonliu.com/image/20180403_04.png" alt=""><br>假设右侧新增的紫色部分是<code>p[i]</code>可以增加的部分，那么根据回文的性质，a 等于 d ，也就是说 id 的回文不仅仅是黑线，而是黑线+两条紫线，矛盾，所以假设不成立，故<code>p[i] = mx - i</code>，不可以再增加一分。</p><p>（2）：<strong>j 回文串全部在 id 的内部</strong>，如下图：<br><img src="https://resource.ethsonliu.com/image/20180403_05.png" alt=""><br>根据代码，此时<code>p[i] = p[j]</code>，那么<code>p[i]</code>还可以更大么？答案亦是不可能！见下图：<br><img src="https://resource.ethsonliu.com/image/20180403_06.png" alt=""><br>假设右侧新增的红色部分是<code>p[i]</code>可以增加的部分，那么根据回文的性质，a 等于 b ，也就是说 j 的回文应该再加上 a 和 b ，矛盾，所以假设不成立，故<code>p[i] = p[j]</code>，也不可以再增加一分。</p><p>（3）：<strong>j 回文串左端正好与 id 的回文串左端重合</strong>，见下图：<br><img src="https://resource.ethsonliu.com/image/20180403_07.png" alt=""><br>根据代码，此时<code>p[i] = p[j]</code>或<code>p[i] = mx - i</code>，并且<code>p[i]</code>还可以继续增加，所以需要</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (s_new[i - p[i]] == s_new[i + p[i]]) </span><br><span class="line">    p[i]++;</span><br></pre></td></tr></table></figure><p>根据（1）（2）（3），很容易推出 Manacher 算法的最坏情况，即为字符串内全是相同字符的时候。在这里我们重点研究 Manacher() 中的 for 语句，推算发现 for 语句内平均访问每个字符 5 次，即时间复杂度为：$T_{worst}(n)=O(n)$。</p><p>同理，我们也很容易知道最佳情况下的时间复杂度，即字符串内字符各不相同的时候。推算得平均访问每个字符 4 次，即时间复杂度为：$T_{best}(n)=O(n)$。</p><p>综上，<strong>Manacher 算法的时间复杂度为 $O(n)$</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ethsonliu.com/2018/04/kmp.html&quot;&gt;KMP算法(C++代码实现)&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Data Structure" scheme="https://dlc1994.github.io/categories/Algorithm-and-Data-Structure/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
      <category term="C/C++" scheme="https://dlc1994.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>中国第二届高性能云计算大赛（MAXP)——京东云数据算法赛</title>
    <link href="https://dlc1994.github.io/2020/03/19/ckqgs2ccc000jucveym4ldc97/"/>
    <id>https://dlc1994.github.io/2020/03/19/ckqgs2ccc000jucveym4ldc97/</id>
    <published>2020-03-19T07:20:45.000Z</published>
    <updated>2020-03-21T03:57:32.078Z</updated>
    
    <content type="html"><![CDATA[<p>中国第二届高性能云计算大赛（MAXP)——京东云数据算法赛<br><a id="more"></a></p><p><img src="/2020/03/19/ckqgs2ccc000jucveym4ldc97/0001.jpg" alt="1"></p><p><img src="/2020/03/19/ckqgs2ccc000jucveym4ldc97/0002.jpg" alt="2"></p><p><img src="/2020/03/19/ckqgs2ccc000jucveym4ldc97/0003.jpg" alt="3"></p><p><img src="/2020/03/19/ckqgs2ccc000jucveym4ldc97/0004.jpg" alt="4"></p><p><img src="/2020/03/19/ckqgs2ccc000jucveym4ldc97/0005.jpg" alt="5"></p><p><img src="/2020/03/19/ckqgs2ccc000jucveym4ldc97/0006.jpg" alt="6"></p><p><img src="/2020/03/19/ckqgs2ccc000jucveym4ldc97/0007.jpg" alt="7"></p><p><img src="/2020/03/19/ckqgs2ccc000jucveym4ldc97/0008.jpg" alt="8"></p><p><img src="/2020/03/19/ckqgs2ccc000jucveym4ldc97/0009.jpg" alt="9"></p><p><img src="/2020/03/19/ckqgs2ccc000jucveym4ldc97/0009.jpg" alt="10"></p><p><img src="/2020/03/19/ckqgs2ccc000jucveym4ldc97/0011.jpg" alt="11"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中国第二届高性能云计算大赛（MAXP)——京东云数据算法赛&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Competition" scheme="https://dlc1994.github.io/categories/Competition/"/>
    
    
      <category term="Python" scheme="https://dlc1994.github.io/tags/Python/"/>
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Postgresql+postgis地图开发说明</title>
    <link href="https://dlc1994.github.io/2020/03/19/ckqgs2ccr000zucvep4md44kt/"/>
    <id>https://dlc1994.github.io/2020/03/19/ckqgs2ccr000zucvep4md44kt/</id>
    <published>2020-03-19T07:20:45.000Z</published>
    <updated>2020-03-19T11:32:15.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Postgresql-postgis地图开发说明"><a href="#Postgresql-postgis地图开发说明" class="headerlink" title="Postgresql+postgis地图开发说明"></a><code>Postgresql+postgis</code>地图开发说明</h1><p>实习期间需要部署路网数据库查询服务，<code>windows</code>和<code>ubuntu</code>下的安装部署大同小异，现以postgresql 10+postgis 2.5.0为例<br><a id="more"></a></p><h2 id="1-安装postgresql-postgis部署地图数据查询服务"><a href="#1-安装postgresql-postgis部署地图数据查询服务" class="headerlink" title="1. 安装postgresql+postgis部署地图数据查询服务"></a>1. 安装<code>postgresql+postgis</code>部署地图数据查询服务</h2><p><code>ubuntu: sudo apt install libpq-dev postgresql-server-dev-10 postgresql-server-dev-all</code></p><p><code>windows</code>:参考博客<a href="https://blog.csdn.net/antma/article/details/83579920">csdn blog</a></p><h2 id="2-下载openstreetmap地图osm数据"><a href="#2-下载openstreetmap地图osm数据" class="headerlink" title="2. 下载openstreetmap地图osm数据"></a>2. 下载<code>openstreetmap</code>地图<code>osm</code>数据</h2><ul><li><p>下载国家地图数据，在<code>www.openstreetmap.org</code>，无法具体到省份城市</p></li><li><p>下载具体省份城市地图下载可参考<a href="https://blog.csdn.net/xxzj_zz2017/article/details/79524627">省市地图</a></p></li><li><p>更小区域地图下载，可使用<code>www.openstreetmap.org</code>限定经纬度直接导出</p></li></ul><h2 id="3-创建数据库，并支持postgis和pgrouting"><a href="#3-创建数据库，并支持postgis和pgrouting" class="headerlink" title="3. 创建数据库，并支持postgis和pgrouting"></a>3. 创建数据库，并支持<code>postgis</code>和<code>pgrouting</code></h2><ul><li>方式一，命令行</li></ul><p><code>createdb -U postgres XXX</code>（数据库名称，后续都用XXX代替）</p><p>进入数据库<code>\c XXX</code>,输入以下语句使数据库支持空间分析和空间查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE EXTENSION postgis; </span><br><span class="line">CREATE EXTENSION pgrouting;</span><br><span class="line">CREATE EXTENSION postgis_topology; </span><br><span class="line">CREATE EXTENSION fuzzystrmatch; </span><br><span class="line">CREATE EXTENSION postgis_tiger_geocoder; </span><br><span class="line">CREATE EXTENSION address_standardizer;</span><br></pre></td></tr></table></figure><ul><li>方式二：在<code>pgAdmin</code>中打开，直接以<code>postgis</code>数据库为模版创建数据库，这样创建的数据库直接支持空间查询和空间分析。</li></ul><h2 id="4-将osm数据导入数据库blog"><a href="#4-将osm数据导入数据库blog" class="headerlink" title="4. 将osm数据导入数据库blog"></a>4. 将<code>osm</code>数据导入数据库<a href="https://blog.csdn.net/cao812755156/article/details/80919521">blog</a></h2><h3 id="4-1-安装OSM数据导入工具osm2pgsql"><a href="#4-1-安装OSM数据导入工具osm2pgsql" class="headerlink" title="4.1    安装OSM数据导入工具osm2pgsql"></a>4.1    安装<code>OSM</code>数据导入工具<code>osm2pgsql</code></h3><p>(<code>Ubuntu</code>操作)：</p><p><code>sudo apt install osm2pgsql</code></p><p>(<code>windows</code>操作)：</p><ul><li><p><code>osm2pgsql</code>下载地址：<code>http://customdebug.com/osm/osm2pgsql.zip</code></p></li><li><p><code>default.style</code>文件:<code>https://github.com/openstreetmap/osm2pgsql/blob/master/default.style</code></p></li><li><p><code>osm2pgsql</code>下载好之后解压，解压完成之后，将下载的<code>default.style</code>放入到<code>.\osm2pgsql\x64</code>文件夹下</p></li></ul><h3 id="4-2-进入数据库"><a href="#4-2-进入数据库" class="headerlink" title="4.2    进入数据库"></a>4.2    进入数据库</h3><p><code>windows</code>: <code>cmd</code>输入<code>psql -U postgres -d XXX</code>进入数据库</p><p><code>ubuntu</code>: <code>psql -U user_name -d database_name -h localhost</code></p><h3 id="4-3-为了避免后面出现要输入密码或者出现Error-Connection-to-database-failed-fe-sendauth-no-password-supplied错误，将文件pg-hba-conf（文件路径：-PostgreSQL-10-data）里面的md5，下图所示的两个md5改为trust"><a href="#4-3-为了避免后面出现要输入密码或者出现Error-Connection-to-database-failed-fe-sendauth-no-password-supplied错误，将文件pg-hba-conf（文件路径：-PostgreSQL-10-data）里面的md5，下图所示的两个md5改为trust" class="headerlink" title="4.3    为了避免后面出现要输入密码或者出现Error: Connection to database failed: fe_sendauth: no password supplied错误，将文件pg_hba.conf（文件路径：...\PostgreSQL\10\data）里面的md5，下图所示的两个md5改为trust"></a>4.3    为了避免后面出现要输入密码或者出现<code>Error: Connection to database failed: fe_sendauth: no password supplied</code>错误，将文件<code>pg_hba.conf</code>（文件路径：<code>...\PostgreSQL\10\data</code>）里面的<code>md5</code>，下图所示的两个<code>md5</code>改为<code>trust</code></h3><h3 id="4-4-windwos-加载postgis对象和函数定义（postgis-sql）"><a href="#4-4-windwos-加载postgis对象和函数定义（postgis-sql）" class="headerlink" title="4.4    (windwos)加载postgis对象和函数定义（postgis.sql）"></a>4.4    (<code>windwos</code>)加载<code>postgis</code>对象和函数定义（<code>postgis.sql</code>）</h3><ul><li><p>在数据库安装位置<code>bin</code>文件夹下打开<code>dos</code>窗口，输入命令<code>psql -U postgres -d osm -f</code> “此处为postgis.sql文件的路径”。</p></li><li><p><code>postgis.sql</code>文件在<code>...PostgreSQL\10\share\contrib\postgis-2.5</code>文件夹下</p></li></ul><h3 id="4-5-windows-加载EPSG坐标系统定义（spatial-ref-sys-sql）"><a href="#4-5-windows-加载EPSG坐标系统定义（spatial-ref-sys-sql）" class="headerlink" title="4.5    (windows)加载EPSG坐标系统定义（spatial_ref_sys.sql）"></a>4.5    (<code>windows</code>)加载<code>EPSG</code>坐标系统定义（spatial_ref_sys.sql）</h3><ul><li><p>在<code>dos</code>窗口下输入命令<code>psql -U postgres -d osm -f</code> 此处为<code>postgis.sql</code>文件的路径</p></li><li><p><code>postgis.sql</code>文件在<code>...PostgreSQL\10\share\contrib\postgis-2.4</code>文件夹下</p></li></ul><h3 id="4-6-导入OSM数据"><a href="#4-6-导入OSM数据" class="headerlink" title="4.6    导入OSM数据"></a>4.6    导入<code>OSM</code>数据</h3><ul><li><p><code>ubuntu</code></p><p><code>osm2pgsql -d XXX –U username -P portID -C 12000 -S /home/china-latest.osm.pbf -H localhost -W</code></p></li><li><p><code>windows</code></p><p>在下载的<code>osm2pgsql</code>的<code>.\osm2pgsql\x64</code>文件夹下打开<code>dos</code>窗口，输入命令<code>osm2pgsql -d XXX –U username -P portID -C 12000 -S &quot;C:\develop\postsql-gis\osm2pgsql\x64\default.style&quot; china-latest.osm.pbf</code></p></li></ul><h3 id="4-7-验证数据是否成功"><a href="#4-7-验证数据是否成功" class="headerlink" title="4.7    验证数据是否成功"></a>4.7    验证数据是否成功</h3><ul><li><p>(<code>linux</code>) <code>\d</code>发现多了几张<code>table</code>和<code>view</code>说明导入成功</p></li><li><p>(<code>windows</code>) 从菜单栏的<code>postgressql</code>打开<code>pgAdmin</code>，发现<code>XXX</code>库中多了4张表，说明导入成功</p></li></ul><h2 id="5-创建路网拓扑图和查询数据表"><a href="#5-创建路网拓扑图和查询数据表" class="headerlink" title="5. 创建路网拓扑图和查询数据表"></a>5. <a href="http://www.itboth.com/d/NNzYfq/postgis-postgresql-dijkstra-pgrouting-opengis">创建路网拓扑图和查询数据表</a></h2><h3 id="5-1-创建数据表，选择指定列，并重新排序gid"><a href="#5-1-创建数据表，选择指定列，并重新排序gid" class="headerlink" title="5.1    创建数据表，选择指定列，并重新排序gid"></a>5.1    创建数据表，选择指定列，并重新排序gid</h3><ul><li><p>选择指定列：<code>CREATE TABLE XXX AS (SELECT osm_id,name,ref,highway,oneway,bridge,way FROM planet_osm_roads);</code></p></li><li><p>添加起点id：<code>ALTER TABLE XXX ADD COLUMN source integer;</code></p></li><li><p>添加终点id：<code>ALTER TABLE XXX ADD COLUMN target integer;</code></p></li><li><p>添加道路权重值: <code>ALTER TABLE XXX ADD COLUMN length double precision;</code></p></li><li><p>创建序列：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE SEQUENCE test_id_seq</span><br><span class="line">START WITH 1</span><br><span class="line">INCREMENT BY 1</span><br><span class="line">NO MINVALUE</span><br><span class="line">NO MAXVALUE</span><br><span class="line">CACHE 1;</span><br></pre></td></tr></table></figure><ul><li>更新自增ID：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table XXX add column gid int;</span><br><span class="line">alter table XXX alter column gid set default nextval(&apos;test_id_seq&apos;);</span><br><span class="line">update XXX set gid=nextval(&apos;test_id_seq&apos;);</span><br></pre></td></tr></table></figure><ul><li>修改数据表中列名way为geom: <code>alter table XXX rename way to geom</code></li></ul><h3 id="5-2-创建路网拓扑-SELECT-pgr-createTopology-39-XXX-39-0-00001-39-geom-39-39-gid-39"><a href="#5-2-创建路网拓扑-SELECT-pgr-createTopology-39-XXX-39-0-00001-39-geom-39-39-gid-39" class="headerlink" title="5.2    创建路网拓扑 SELECT pgr_createTopology(&#39;XXX&#39;,0.00001, &#39;geom&#39;, &#39;gid&#39;);"></a>5.2    创建路网拓扑 <code>SELECT pgr_createTopology(&#39;XXX&#39;,0.00001, &#39;geom&#39;, &#39;gid&#39;);</code></h3><h3 id="5-3-为length赋值-update-XXX-set-length-st-length-geom"><a href="#5-3-为length赋值-update-XXX-set-length-st-length-geom" class="headerlink" title="5.3    为length赋值 update XXX set length =st_length(geom);"></a>5.3    为length赋值 update XXX set length =st_length(geom);</h3><h2 id="6-使用QGIS加载数据表和在线地图"><a href="#6-使用QGIS加载数据表和在线地图" class="headerlink" title="6. 使用QGIS加载数据表和在线地图"></a>6. 使用QGIS加载数据表和在线地图</h2><h3 id="6-1-QGIS连接postgressql"><a href="#6-1-QGIS连接postgressql" class="headerlink" title="6.1    QGIS连接postgressql"></a>6.1    <a href="https://www.jianshu.com/p/1f213e67b066">QGIS连接postgressql</a></h3><ul><li><p>连接PostGIS数据源——数据库管理器——导入数据——加载数据</p></li><li><p>输入数据库名称 端口 用户名和密码</p></li><li><p>双击数据表即可显示图层</p></li></ul><h3 id="6-2-安装在线地图插件显示地图图层"><a href="#6-2-安装在线地图插件显示地图图层" class="headerlink" title="6.2    安装在线地图插件显示地图图层"></a>6.2    <a href="https://blog.csdn.net/hetongde/article/details/79087010">安装在线地图插件显示地图图层</a></h3><ul><li>打开QGIS，在插件下搜QGIS cloud插件，选择 add background layer 即可添加google map，bing map，openstreet map 作为底图</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Postgresql-postgis地图开发说明&quot;&gt;&lt;a href=&quot;#Postgresql-postgis地图开发说明&quot; class=&quot;headerlink&quot; title=&quot;Postgresql+postgis地图开发说明&quot;&gt;&lt;/a&gt;&lt;code&gt;Postgresql+postgis&lt;/code&gt;地图开发说明&lt;/h1&gt;&lt;p&gt;实习期间需要部署路网数据库查询服务，&lt;code&gt;windows&lt;/code&gt;和&lt;code&gt;ubuntu&lt;/code&gt;下的安装部署大同小异，现以postgresql 10+postgis 2.5.0为例&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Development" scheme="https://dlc1994.github.io/categories/Development/"/>
    
    
      <category term="Database" scheme="https://dlc1994.github.io/tags/Database/"/>
    
      <category term="Postgresql" scheme="https://dlc1994.github.io/tags/Postgresql/"/>
    
      <category term="Map" scheme="https://dlc1994.github.io/tags/Map/"/>
    
      <category term="Postgis" scheme="https://dlc1994.github.io/tags/Postgis/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解(C++)</title>
    <link href="https://dlc1994.github.io/2020/03/06/ckqgs2cei0038ucves0rkf0qi/"/>
    <id>https://dlc1994.github.io/2020/03/06/ckqgs2cei0038ucves0rkf0qi/</id>
    <published>2020-03-06T13:27:23.000Z</published>
    <updated>2020-03-06T11:33:35.374Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer各题目的C++解法<br><a id="more"></a><br><!-- TOC --></p><ul><li><a href="#剑指offer-1-二维数组查找">剑指offer 1 二维数组查找</a></li><li><a href="#剑指offer-2-替换空格">剑指offer 2 替换空格</a></li><li><a href="#剑指offer-3-从尾到头打印链表">剑指offer 3 从尾到头打印链表</a></li><li><a href="#剑指offer-4-重建二叉树">剑指offer 4 重建二叉树</a></li><li><a href="#剑指offer-5-用两个栈实现队列">剑指offer 5 用两个栈实现队列</a></li><li><a href="#剑指offer-6-旋转数组的最小值">剑指offer 6 旋转数组的最小值</a></li><li><a href="#剑指offer-7-斐波那契数列">剑指offer 7 斐波那契数列</a></li><li><a href="#剑指offer-8-跳台阶">剑指offer 8 跳台阶</a></li><li><a href="#剑指offer-9-变态跳台阶">剑指offer 9 变态跳台阶</a></li><li><a href="#剑指offer-10-矩形覆盖">剑指offer 10 矩形覆盖</a></li><li><a href="#剑指offer-11-二进制中1的个数">剑指offer 11 二进制中1的个数**</a></li><li><a href="#剑指offer-12-求base的exponent次方">剑指offer 12 求base的exponent次方</a></li><li><a href="#剑指offer-13-调整数组奇偶顺序">剑指offer 13 调整数组奇偶顺序</a></li><li><a href="#剑指offer-14-链表倒数第k个结点">剑指offer 14 链表倒数第k个结点</a></li><li><a href="#剑指offer-15-反转链表">剑指offer 15 反转链表</a></li><li><a href="#剑指offer-16-合并两个排序的链表">剑指offer 16 合并两个排序的链表</a></li><li><a href="#剑指offer-17-树的子结构">剑指offer 17 树的子结构</a></li><li><a href="#剑指offer-18-二叉树的镜像">剑指offer 18 二叉树的镜像</a></li><li><a href="#剑指offer-19-顺时针打印矩阵">剑指offer 19 顺时针打印矩阵</a></li><li><a href="#剑指offer-20-包含min函数的栈">剑指offer 20 包含Min函数的栈</a></li><li><a href="#剑指offer-21-栈的压入弹出序列">剑指offer 21 栈的压入、弹出序列</a></li><li><a href="#剑指offer-22-从上往下打印二叉树">剑指offer 22 从上往下打印二叉树</a></li><li><a href="#剑指offer-23-二叉搜索树的后序遍历序列">剑指offer 23 二叉搜索树的后序遍历序列</a></li><li><a href="#剑指offer-24-二叉树中和为某一值的所有路径">剑指offer 24 二叉树中和为某一值的所有路径</a></li><li><a href="#剑指offer-25-复杂链表的复制">剑指offer 25 复杂链表的复制</a></li><li><a href="#剑指offer-26-二叉搜索树转双端链表">剑指offer 26 二叉搜索树转双端链表**</a></li><li><a href="#剑指offer-27-字符串的排列">剑指offer 27 字符串的排列</a></li><li><a href="#剑指offer-28-数组中出现超过一半的数">剑指offer 28 数组中出现超过一半的数</a></li><li><a href="#剑指offer-29-最小的k个数">剑指offer 29 最小的k个数**</a></li><li><a href="#剑指offer-30-连续子数组最大和">剑指offer 30 连续子数组最大和</a></li><li><a href="#剑指offer-31-整数中1的个数">剑指offer 31 整数中1的个数</a></li><li><a href="#剑指offer-32-把数组排成最小的数">剑指offer 32 把数组排成最小的数**</a></li><li><a href="#剑指offer-33-丑数">剑指offer 33 丑数</a></li><li><a href="#剑指offer-34-第一次出现的字符">剑指offer 34 第一次出现的字符</a></li><li><a href="#剑指offer-35-数组中的逆序对">剑指offer 35 数组中的逆序对**</a></li><li><a href="#剑指offer-36-两个链表的第一个公共结点">剑指offer 36 两个链表的第一个公共结点</a></li><li><a href="#剑指offer-37-数组在排序数组出现的次数">剑指offer 37 数组在排序数组出现的次数</a></li><li><a href="#剑指offer-38-二叉树深度">剑指offer 38 二叉树深度</a></li><li><a href="#剑指offer-39-判断平衡二叉树">剑指offer 39 判断平衡二叉树</a></li><li><a href="#剑指offer-40-数组中只出现一次的数字">剑指offer 40 数组中只出现一次的数字</a></li><li><a href="#剑指offer-41-和为s的连续正数序列">剑指offer 41 和为S的连续正数序列</a></li><li><a href="#剑指offer-42-和为s的两个数">剑指offer 42 和为S的两个数</a></li><li><a href="#剑指offer-43-左旋转字符串">剑指offer 43 左旋转字符串</a></li><li><a href="#剑指offer-44-翻转单词顺序列">剑指offer 44 翻转单词顺序列</a></li><li><a href="#剑指offer-45-扑克牌顺子">剑指offer 45 扑克牌顺子</a></li><li><a href="#剑指offer-46-孩子们的游戏圆圈里最后剩下的数">剑指offer 46 孩子们的游戏（圆圈里最后剩下的数）</a></li><li><a href="#剑指offer-47-求12n">剑指offer 47 求1+2+…+n</a></li><li><a href="#剑指offer-48-不用加减乘除做加法">剑指offer 48 不用加减乘除做加法</a></li><li><a href="#剑指offer-49-把字符串转换为整数">剑指offer 49 把字符串转换为整数</a></li><li><a href="#剑指offer-50-数组中重复的数字">剑指offer 50 数组中重复的数字</a></li><li><a href="#剑指offer-51-构建乘积数组">剑指offer 51 构建乘积数组</a></li><li><a href="#剑指offer-52-正则表达式匹配">剑指offer 52 正则表达式匹配</a></li><li><a href="#剑指offer-53-表示数值的字符串">剑指offer 53 表示数值的字符串</a></li><li><a href="#剑指offer-54-字符流中第一个不重复的字符">剑指offer 54 字符流中第一个不重复的字符</a></li><li><a href="#剑指offer-55-链表中环的入口节点">剑指offer 55 链表中环的入口节点</a></li><li><a href="#剑指offer-56-删除链表中重复的节点">剑指offer 56 删除链表中重复的节点</a></li><li><a href="#剑指offer-57-二叉树的下一个节点">剑指offer 57 二叉树的下一个节点</a></li><li><a href="#剑指offer-58-对称的二叉树">剑指offer 58 对称的二叉树</a></li><li><a href="#剑指offer-59-之字形打印二叉树">剑指offer 59 之字形打印二叉树</a></li><li><a href="#剑指offer-60-把二叉树打印成多行层序遍历">剑指offer 60 把二叉树打印成多行（层序遍历）</a></li><li><a href="#剑指offer-61-序列化二叉树">剑指offer 61 序列化二叉树</a></li><li><a href="#剑指offer-62-二叉搜索树的第k个结点">剑指offer 62 二叉搜索树的第k个结点</a></li><li><a href="#剑指offer-63-数据流中的中位数">剑指offer 63 数据流中的中位数</a></li><li><a href="#剑指offer-64-滑动窗口的最大值">剑指offer 64 滑动窗口的最大值</a></li><li><a href="#剑指offer-65-矩阵中的路径">剑指offer 65 矩阵中的路径</a></li><li><a href="#剑指offer-66-机器人的动作范围">剑指offer 66 机器人的动作范围</a></li><li><a href="#剑指offer-67-剪绳子">剑指offer 67 剪绳子</a></li></ul><!-- /TOC --><div style="page-break-after: always;"></div><h1 id="剑指offer-1-二维数组查找"><a href="#剑指offer-1-二维数组查找" class="headerlink" title="剑指offer 1 二维数组查找"></a>剑指offer 1 二维数组查找</h1><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 左下往右上查找，快速定位地图经纬度 O(n+m)</span><br><span class="line">bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</span><br><span class="line">    int rows = array.size(), cols = array[0].size();</span><br><span class="line">    int row=rows-1,col=0;</span><br><span class="line">    while(row&gt;=0 &amp;&amp; col&lt;cols)&#123;</span><br><span class="line">            if(array[row][col]==target) return true;</span><br><span class="line">            else if(array[row][col]&gt;target) row--;</span><br><span class="line">            else col++;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 二分法 O(nlogm) O(n+m)</span><br><span class="line">bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</span><br><span class="line">    if(array.size()==0) return false;</span><br><span class="line">        int nrows = array.size(), ncols= array[0].size();</span><br><span class="line">        for(int i=0;i&lt;nrows;i++)&#123;</span><br><span class="line">            int low=0;</span><br><span class="line">            int high=ncols-1;</span><br><span class="line">            while(low&lt;=high)&#123;</span><br><span class="line">                int mid=(low+high)/2;</span><br><span class="line">                if(target&gt;array[i][mid])</span><br><span class="line">                    low=mid+1;</span><br><span class="line">                else if(target&lt;array[i][mid])</span><br><span class="line">                    high=mid-1;</span><br><span class="line">                else</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-2-替换空格"><a href="#剑指offer-2-替换空格" class="headerlink" title="剑指offer 2 替换空格"></a>剑指offer 2 替换空格</h1><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// O(n)</span><br><span class="line">void replaceSpace(char *str,int length) &#123;</span><br><span class="line">    int count=0;</span><br><span class="line">    for(int i=0;i&lt;length;i++)&#123;</span><br><span class="line">        if(str[i]==&apos; &apos;)</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=length-1;i&gt;=0;i--)&#123;</span><br><span class="line">        if(str[i]!=&apos; &apos;)&#123;</span><br><span class="line">            str[i+2*count]=str[i]; //非空格在新数组的位置 </span><br><span class="line">            //0 1 2 3 4 5 6 7 8  </span><br><span class="line">            //0 # 3 # 4     </span><br><span class="line">            //0 % 2 0 3 % 2 0 4</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            count--;</span><br><span class="line">            str[i+2*count]=&apos;%&apos;;</span><br><span class="line">            str[i+2*count+1]=&apos;2&apos;;</span><br><span class="line">            str[i+2*count+2]=&apos;0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-3-从尾到头打印链表"><a href="#剑指offer-3-从尾到头打印链表" class="headerlink" title="剑指offer 3 从尾到头打印链表"></a>剑指offer 3 从尾到头打印链表</h1><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//递归</span><br><span class="line">vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    if(head!=NULL)&#123;</span><br><span class="line">        if(head-&gt;next!=NULL)&#123;</span><br><span class="line">            res = printListFromTailToHead(head-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(head-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">//栈</span><br><span class="line">vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    stack&lt;int&gt; sta;</span><br><span class="line">    while(head!=NULL)&#123;</span><br><span class="line">        sta.push(head-&gt;val);</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!sta.empty())&#123;</span><br><span class="line">        res.push_back(sta.top());</span><br><span class="line">        sta.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">// **链表原地反转**</span><br><span class="line">vector&lt;int&gt; printListFromTailToHead(struct ListNode* head) &#123;</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    ListNode *buf=head;</span><br><span class="line">    ListNode *pre=buf;</span><br><span class="line">    if(head==NULL)</span><br><span class="line">        return vec;</span><br><span class="line">    while(head-&gt;next!=NULL)&#123;</span><br><span class="line">        buf=head-&gt;next;</span><br><span class="line">        head-&gt;next=buf-&gt;next;</span><br><span class="line">        buf-&gt;next=pre;</span><br><span class="line">        pre=buf;</span><br><span class="line">    &#125;</span><br><span class="line">    while(buf)&#123;</span><br><span class="line">        vec.push_back(buf-&gt;val);</span><br><span class="line">        buf=buf-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-4-重建二叉树"><a href="#剑指offer-4-重建二叉树" class="headerlink" title="剑指offer 4 重建二叉树"></a>剑指offer 4 重建二叉树</h1><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">    TreeNode* root = helper(pre, 0, pre.size()-1, vin, 0, vin.size()-1);</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* helper(vector&lt;int&gt; pre, int startpre, int endpre, vector&lt;int&gt; vin, int startvin, int endvin)&#123;</span><br><span class="line">    if(startpre&gt;endpre||startvin&gt;endvin)</span><br><span class="line">        return NULL;</span><br><span class="line">    TreeNode* root=new TreeNode(pre[startpre]);</span><br><span class="line">    for(int i=startvin;i&lt;=endvin;i++)&#123;</span><br><span class="line">        if(vin[i]==pre[startpre])&#123;</span><br><span class="line">            root-&gt;left = helper(pre, startpre+1, startpre+i-startvin, vin, startvin, i-1);</span><br><span class="line">            root-&gt;right = helper(pre, startpre+i-startvin+1, endpre, vin, i+1, endvin);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-5-用两个栈实现队列"><a href="#剑指offer-5-用两个栈实现队列" class="headerlink" title="剑指offer 5 用两个栈实现队列"></a>剑指offer 5 用两个栈实现队列</h1><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int&gt; stack1;</span><br><span class="line">stack&lt;int&gt; stack2;</span><br><span class="line">void push(int node) &#123;</span><br><span class="line">    stack1.push(node);</span><br><span class="line">&#125;</span><br><span class="line">//栈1不空，全部压入栈2，栈2的top则可以输出；</span><br><span class="line">//然后把栈2再压回栈1</span><br><span class="line">int pop() &#123;</span><br><span class="line">    while(!stack1.empty())&#123;</span><br><span class="line">        int a = stack1.top();</span><br><span class="line">        stack1.pop();</span><br><span class="line">        stack2.push(a);</span><br><span class="line">    &#125;</span><br><span class="line">    int res = stack2.top();</span><br><span class="line">    stack2.pop();</span><br><span class="line">    while(!stack2.empty())&#123;</span><br><span class="line">        stack1.push(stack2.top());</span><br><span class="line">        stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果栈2不空，栈2的top即为输出，否则把栈1全部压入栈2</span><br><span class="line">int pop() &#123;</span><br><span class="line">    if(stack2.empty())&#123;</span><br><span class="line">        while(!stack1.empty())&#123;</span><br><span class="line">            int a = stack1.top();</span><br><span class="line">            stack1.pop();</span><br><span class="line">            stack2.push(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int res = stack2.top();</span><br><span class="line">    stack2.pop();</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-6-旋转数组的最小值"><a href="#剑指offer-6-旋转数组的最小值" class="headerlink" title="剑指offer 6 旋转数组的最小值"></a>剑指offer 6 旋转数组的最小值</h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//O(N)</span><br><span class="line">int minNumberInRotateArray(int[] array) &#123;</span><br><span class="line">  if (array.length == 0)</span><br><span class="line">      return 0;</span><br><span class="line">  for (int i = 0; i &lt; array.length - 1; i++) &#123;</span><br><span class="line">      if (array[i] &gt; array[i + 1])</span><br><span class="line">          return array[i + 1];</span><br><span class="line">  &#125;</span><br><span class="line">  return array[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// O(logn) 二分法</span><br><span class="line">int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">    if(rotateArray.size()==0) return 0;</span><br><span class="line">    int low=0, high=rotateArray.size()-1;</span><br><span class="line">    while(low&lt;high)&#123;</span><br><span class="line">        int mid=(low+high)/2;</span><br><span class="line">        if(rotateArray[mid]&gt;rotateArray[high]) low=mid+1;</span><br><span class="line">        else if(rotateArray[mid]==rotateArray[high]) high--;</span><br><span class="line">        else high=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return rotateArray[high];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-7-斐波那契数列"><a href="#剑指offer-7-斐波那契数列" class="headerlink" title="剑指offer 7 斐波那契数列"></a>剑指offer 7 斐波那契数列</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//斐波那契数列</span><br><span class="line">0 1 2 3 4 ...</span><br><span class="line">0 1 1 2 3 ...</span><br><span class="line">//递归</span><br><span class="line">int Fibonacci(int n) &#123;</span><br><span class="line">    if(n==0) return 0;</span><br><span class="line">    if(n==1) return 1;</span><br><span class="line">    return Fibonacci(n-1)+Fibonacci(n-2);</span><br><span class="line">&#125;</span><br><span class="line">//循环 时间复杂度O(N) 空间复杂度O(1)</span><br><span class="line">int Fibonacci(int n) &#123;</span><br><span class="line">    if(n==0) return 0;</span><br><span class="line">    if(n==1) return 1;</span><br><span class="line">    int pre=0, now=1;</span><br><span class="line">    while(n&gt;1)&#123;</span><br><span class="line">        int tmp = pre+now;</span><br><span class="line">        pre = now;</span><br><span class="line">        now = tmp;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    return now;</span><br><span class="line">&#125;</span><br><span class="line">//动态规划 时间复杂度O(N) 空间复杂度O(N)</span><br><span class="line">int Fibonacci(int n) &#123;</span><br><span class="line">    if(n==0) return 0;</span><br><span class="line">    if(n==1) return 1;</span><br><span class="line">    vector&lt;int&gt; dp(n+1,0);</span><br><span class="line">    dp[0]=0;</span><br><span class="line">    dp[1]=1;</span><br><span class="line">    for(int i=2;i&lt;=n;++i)&#123;</span><br><span class="line">        dp[i]=dp[i-1]+dp[i-2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after: always;"></div><h1 id="剑指offer-8-跳台阶"><a href="#剑指offer-8-跳台阶" class="headerlink" title="剑指offer 8 跳台阶"></a>剑指offer 8 跳台阶</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//斐波那契数列 DP O(N)</span><br><span class="line">int jumpFloor(int number) &#123;</span><br><span class="line">    if(number&lt;2) return number;</span><br><span class="line">    int pre=1, now=2;</span><br><span class="line">    for(int i=3;i&lt;=number;i++)&#123;</span><br><span class="line">        int tmp = pre+now;</span><br><span class="line">        pre = now;</span><br><span class="line">        now=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-9-变态跳台阶"><a href="#剑指offer-9-变态跳台阶" class="headerlink" title="剑指offer 9 变态跳台阶"></a>剑指offer 9 变态跳台阶</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int jumpFloorII(int number) &#123;</span><br><span class="line">    if(number==0) return 0;</span><br><span class="line">    int res=1;</span><br><span class="line">    while(number--&gt;1)&#123;</span><br><span class="line">        res*=2;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">//移位 左移一位*2，左移n-1位即 2^(n-1)</span><br><span class="line">int res = 1&lt;&lt;(number-1)</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-10-矩形覆盖"><a href="#剑指offer-10-矩形覆盖" class="headerlink" title="剑指offer 10 矩形覆盖"></a>剑指offer 10 矩形覆盖</h1><p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，有多少种方法？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//还是斐波那契数列</span><br><span class="line"> f(n) = f(n-1) + f(n-2)， (n &gt; 2)。</span><br></pre></td></tr></table></figure></p><p>更一般的结论，如果用1*m的方块覆盖m*n区域，递推关系式为f(n) = f(n-1) + f(n-m)，(n &gt; m)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 循环</span><br><span class="line">int rectCover(int number) &#123;</span><br><span class="line">    if(number&lt;=2) return number;</span><br><span class="line">    int pre=1, now=2;</span><br><span class="line">    for(int i=3;i&lt;=number;++i)&#123;</span><br><span class="line">        int tmp=pre+now;</span><br><span class="line">        pre=now;</span><br><span class="line">        now=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return now;</span><br><span class="line">&#125;</span><br><span class="line">// 递归</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public int RectCover(int target) &#123;</span><br><span class="line">        if (target &lt; 1) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else if (target == 1 || target == 2) &#123;</span><br><span class="line">            return target;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return RectCover(target-1) + RectCover(target-2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// dp</span><br><span class="line">int rectCover(int number) &#123;</span><br><span class="line">    if ( number &lt; 1 ) return 0;</span><br><span class="line">    int g = 1, f = 2;</span><br><span class="line">    while ( --number ) &#123;</span><br><span class="line">        f = f + g;</span><br><span class="line">        g = f - g;</span><br><span class="line">    &#125;</span><br><span class="line">    return g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-11-二进制中1的个数"><a href="#剑指offer-11-二进制中1的个数" class="headerlink" title="剑指offer 11 二进制中1的个数**"></a>剑指offer 11 二进制中1的个数**</h1><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</span><br><span class="line">int NumberOf1(int n) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while (n != 0) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        n = (n - 1) &amp; n;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-12-求base的exponent次方"><a href="#剑指offer-12-求base的exponent次方" class="headerlink" title="剑指offer 12 求base的exponent次方"></a>剑指offer 12 求base的exponent次方</h1><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 简单快速幂</span><br><span class="line">double Power(double base, int exponent) &#123;</span><br><span class="line">    long long p = abs((long long)exponent);</span><br><span class="line">    double r = 1.0;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        if(p &amp; 1) r *= base;</span><br><span class="line">        base *= base;</span><br><span class="line">        p &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return exponent &lt; 0 ? 1/ r : r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一种方法：使用递归，时间复杂度O(logn)<br>当n为偶数，a^n =（a^n/2）*（a^n/2）</p><p>当n为奇数，a^n = a ^ [( n - 1) / 2] <em> a ^ [(n-1)/2] </em> a</p><p>举例：</p><p>2^11 = 2^1 <em> 2^2 </em> 2^8</p><p>2^1011 = 2^0001 <em> 2^0010 </em> 2^1000</p><p>第二种方法：累乘，时间复杂度为O(n)</p><div style="page-break-after: always;"></div><h1 id="剑指offer-13-调整数组奇偶顺序"><a href="#剑指offer-13-调整数组奇偶顺序" class="headerlink" title="剑指offer 13 调整数组奇偶顺序"></a>剑指offer 13 调整数组奇偶顺序</h1><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// O(2n) O(n) </span><br><span class="line">void reOrderArray(vector&lt;int&gt; &amp;array) &#123;</span><br><span class="line">  if(array.size()==0) return;</span><br><span class="line">  vector&lt;int&gt; res(array.size(),0);</span><br><span class="line">  int s=0,e=array.size()-1;</span><br><span class="line">  for(int i=0;i&lt;array.size();++i)&#123;</span><br><span class="line">    if(array[i]%2==1)&#123;</span><br><span class="line">      res[s++]=array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=array.size()-1;i&gt;=0;--i)&#123;</span><br><span class="line">    if(array[i]%2==0)&#123;</span><br><span class="line">      res[e--]=array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  array=res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// O(n*n) O(1) 插排想法</span><br><span class="line">void reOrderArray1(vector&lt;int&gt; &amp;array)&#123;</span><br><span class="line">  if(array.size()&lt;=1) return;</span><br><span class="line">  for(int i=0;i&lt;array.size();i++)&#123;</span><br><span class="line">    if(array[i]%2==1)&#123;</span><br><span class="line">      int tmp=array[i];</span><br><span class="line">      int j=i-1;</span><br><span class="line">      while(j&gt;=0 &amp;&amp; array[j]%2==0)&#123;</span><br><span class="line">        array[j+1]=array[j];</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">      array[j+1]  =tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 开辟2个数组分别存奇数和偶数 O(n) O(2n)</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-14-链表倒数第k个结点"><a href="#剑指offer-14-链表倒数第k个结点" class="headerlink" title="剑指offer 14 链表倒数第k个结点"></a>剑指offer 14 链表倒数第k个结点</h1><p>输入一个链表，输出该链表中倒数第k个结点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// 遍历再数 O(2n-k)</span><br><span class="line">ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123;</span><br><span class="line">    if(k&lt;=0) return NULL;</span><br><span class="line">    int cnt=0, start=0;</span><br><span class="line">    ListNode* root=pListHead;</span><br><span class="line">    while(pListHead!=NULL)&#123;</span><br><span class="line">        pListHead=pListHead-&gt;next;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(k&gt;cnt) return NULL;</span><br><span class="line">    while(start!=cnt-k)&#123;</span><br><span class="line">        root=root-&gt;next;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历再数 O(n)</span><br><span class="line">ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123;</span><br><span class="line">    if(k&lt;=0 || pListHead==NULL) return NULL;</span><br><span class="line">    ListNode *fast=pListHead;</span><br><span class="line">    ListNode *slow=pListHead;</span><br><span class="line">    while(k--&gt;0)&#123;</span><br><span class="line">if(fast==nullptr) return nullptr;</span><br><span class="line">        fast=fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">while(fast!=NULL)&#123;</span><br><span class="line">fast=fast-&gt;next;</span><br><span class="line">slow=slow-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归</span><br><span class="line">ListNode* FindKthToTail2(ListNode* pListHead, unsigned int k) &#123;</span><br><span class="line">if(pListHead==NULL) return NULL;</span><br><span class="line">ListNode* node=FindKthToTail(pListHead-&gt;next,k);</span><br><span class="line">if(node!=NULL) return node;</span><br><span class="line">cnt++;</span><br><span class="line">if(cnt==k) return pListHead;</span><br><span class="line">else return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-15-反转链表"><a href="#剑指offer-15-反转链表" class="headerlink" title="剑指offer 15 反转链表"></a>剑指offer 15 反转链表</h1><p>输入一个链表，反转链表后，输出新链表的表头。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public ListNode ReverseList(ListNode head) &#123;</span><br><span class="line">    if(head==null)</span><br><span class="line">        return null;</span><br><span class="line">    //head为当前节点，如果当前节点为空的话，那就什么也不做，直接返回null；</span><br><span class="line">    ListNode pre = null;</span><br><span class="line">    ListNode next = null;</span><br><span class="line">    //当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点</span><br><span class="line">    //需要pre和next的目的是让当前节点从pre-&gt;head-&gt;next1-&gt;next2变成pre&lt;-head next1-&gt;next2</span><br><span class="line">    //即pre让节点可以反转所指方向，但反转之后如果不用next节点保存next1节点的话，此单链表就此断开了</span><br><span class="line">    //所以需要用到pre和next两个节点</span><br><span class="line">    //1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line">    //1&lt;-2&lt;-3 4-&gt;5</span><br><span class="line">    while(head!=null)&#123;</span><br><span class="line">        //做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre</span><br><span class="line">        //如此就可以做到反转链表的效果</span><br><span class="line">        //先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂</span><br><span class="line">        next = head.next;</span><br><span class="line">        //保存完next，就可以让head从指向next变成指向pre了，代码如下</span><br><span class="line">        head.next = pre;</span><br><span class="line">        //head指向pre后，就继续依次反转下一个节点</span><br><span class="line">        //让pre，head，next依次向后移动一个节点，继续下一次的指针反转</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果head为null的时候，pre就为最后一个节点了，但是链表已经反转完毕，pre就是反转后链表的第一个节点</span><br><span class="line">    //直接输出pre就是我们想要得到的反转后的链表</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-16-合并两个排序的链表"><a href="#剑指offer-16-合并两个排序的链表" class="headerlink" title="剑指offer 16 合并两个排序的链表"></a>剑指offer 16 合并两个排序的链表</h1><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//递归</span><br><span class="line">ListNode* Merge(ListNode* pHead1, ListNode* pHead2)&#123;</span><br><span class="line">  if(pHead1==NULL) return pHead2;</span><br><span class="line">  if(pHead2==nullptr) return pHead1;</span><br><span class="line">      if(pHead1-&gt;val&gt;pHead2-&gt;val) &#123;</span><br><span class="line">    pHead2-&gt;next=Merge(pHead1, pHead2-&gt;next);</span><br><span class="line">    return pHead2;</span><br><span class="line">  &#125;</span><br><span class="line">  if(pHead1-&gt;val&lt;pHead2-&gt;val) &#123;</span><br><span class="line">    pHead1-&gt;next=Merge(pHead1-&gt;next, pHead2);</span><br><span class="line">    return pHead1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 循环</span><br><span class="line">if(list1 == null) return list2;</span><br><span class="line">if(list2 == null) return list1;</span><br><span class="line">ListNode mergeHead = null;</span><br><span class="line">ListNode current = null;</span><br><span class="line">while(list1!=null &amp;&amp; list2!=null)&#123;</span><br><span class="line">    if(list1.val &lt;= list2.val)&#123;</span><br><span class="line">        if(mergeHead == null)&#123;</span><br><span class="line">           mergeHead = current = list1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">           current.next = list1;</span><br><span class="line">           current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        list1 = list1.next;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        if(mergeHead == null)&#123;</span><br><span class="line">           mergeHead = current = list2;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">           current.next = list2;</span><br><span class="line">           current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        list2 = list2.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if(list1 == null) current.next = list2;</span><br><span class="line">else current.next = list1;</span><br><span class="line">return mergeHead;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-17-树的子结构"><a href="#剑指offer-17-树的子结构" class="headerlink" title="剑指offer 17 树的子结构"></a>剑指offer 17 树的子结构</h1><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)</span><br><span class="line">&#123;</span><br><span class="line">    bool result=false;</span><br><span class="line">    if(pRoot1!=NULL &amp;&amp; pRoot2!=NULL)&#123;</span><br><span class="line">        if(pRoot1-&gt;val==pRoot2-&gt;val) result=Tree1HaveTree2(pRoot1, pRoot2);</span><br><span class="line">        if(!result) &#123;</span><br><span class="line">            result=Tree1HaveTree2(pRoot1-&gt;left, pRoot2) || Tree1HaveTree2(pRoot1-&gt;right, pRoot2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">bool Tree1HaveTree2(TreeNode* pRoot1, TreeNode* pRoot2)&#123;</span><br><span class="line">    if(pRoot2==NULL) return true;</span><br><span class="line">    if(pRoot1==NULL) return false;</span><br><span class="line">    if(pRoot1-&gt;val!=pRoot2-&gt;val) return false;</span><br><span class="line">    return Tree1HaveTree2(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; Tree1HaveTree2(pRoot1-&gt;right,pRoot2-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-18-二叉树的镜像"><a href="#剑指offer-18-二叉树的镜像" class="headerlink" title="剑指offer 18 二叉树的镜像"></a>剑指offer 18 二叉树的镜像</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void Mirror(TreeNode *pRoot) &#123;</span><br><span class="line">    if (pRoot==NULL) return;</span><br><span class="line">    else &#123;</span><br><span class="line">        TreeNode *tmp=pRoot-&gt;left;</span><br><span class="line">        pRoot-&gt;left = pRoot-&gt;right;</span><br><span class="line">        pRoot-&gt;right = tmp;</span><br><span class="line">        Mirror(pRoot-&gt;left);</span><br><span class="line">        Mirror(pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after: always;"></div><h1 id="剑指offer-19-顺时针打印矩阵"><a href="#剑指offer-19-顺时针打印矩阵" class="headerlink" title="剑指offer 19 顺时针打印矩阵"></a>剑指offer 19 顺时针打印矩阵</h1><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123;</span><br><span class="line">    int row = matrix.size();</span><br><span class="line">    int col = matrix[0].size();</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">        </span><br><span class="line">    // 输入的二维数组非法，返回空的数组</span><br><span class="line">    if (row == 0 || col == 0)  return res;</span><br><span class="line">        </span><br><span class="line">    // 定义四个关键变量，表示左上和右下的打印范围</span><br><span class="line">    int left = 0, top = 0, right = col - 1, bottom = row - 1;</span><br><span class="line">    while (left &lt;= right &amp;&amp; top &lt;= bottom)</span><br><span class="line">    &#123;</span><br><span class="line">        // left to right</span><br><span class="line">        for (int i = left; i &lt;= right; ++i)  res.push_back(matrix[top][i]);</span><br><span class="line">        // top to bottom</span><br><span class="line">        for (int i = top + 1; i &lt;= bottom; ++i)  res.push_back(matrix[i][right]);</span><br><span class="line">        // right to left</span><br><span class="line">        if (top != bottom)</span><br><span class="line">        for (int i = right - 1; i &gt;= left; --i)  res.push_back(matrix[bottom][i]);</span><br><span class="line">        // bottom to top</span><br><span class="line">        if (left != right)</span><br><span class="line">        for (int i = bottom - 1; i &gt; top; --i)  res.push_back(matrix[i][left]);</span><br><span class="line">        left++,top++,right--,bottom--;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-20-包含Min函数的栈"><a href="#剑指offer-20-包含Min函数的栈" class="headerlink" title="剑指offer 20 包含Min函数的栈"></a>剑指offer 20 包含Min函数的栈</h1><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int&gt; stack1, stack2;</span><br><span class="line">void push(int value) &#123;</span><br><span class="line">    stack1.push(value);</span><br><span class="line">    if(stack2.empty()) stack2.push(value);</span><br><span class="line">    else&#123;</span><br><span class="line">        if(value&lt;stack2.top()) stack2.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void pop() &#123;</span><br><span class="line">    if(stack1.top()==stack2.top()) stack2.pop();</span><br><span class="line">    stack1.pop();</span><br><span class="line">&#125;</span><br><span class="line">int top() &#123;</span><br><span class="line">    return stack1.top();</span><br><span class="line">&#125;</span><br><span class="line">int min() &#123;</span><br><span class="line">    return stack2.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-21-栈的压入、弹出序列"><a href="#剑指offer-21-栈的压入、弹出序列" class="headerlink" title="剑指offer 21 栈的压入、弹出序列"></a>剑指offer 21 栈的压入、弹出序列</h1><p>//输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123;</span><br><span class="line">      if(pushV.empty()||popV.empty()) return false;</span><br><span class="line">  stack&lt;int&gt; Stack;</span><br><span class="line">  int popIndex=0;</span><br><span class="line">  for(int i=0;i&lt;pushV.size();++i)&#123;</span><br><span class="line">    Stack.push(pushV[i]);</span><br><span class="line">    while(!Stack.empty() &amp;&amp; Stack.top()==popV[popIndex])&#123;</span><br><span class="line">      Stack.pop();</span><br><span class="line">      popIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return Stack.empty();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-22-从上往下打印二叉树"><a href="#剑指offer-22-从上往下打印二叉树" class="headerlink" title="剑指offer 22 从上往下打印二叉树"></a>剑指offer 22 从上往下打印二叉树</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//双端队列</span><br><span class="line">vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">vector&lt;int&gt; res;</span><br><span class="line">if(root==NULL) return NULL;</span><br><span class="line">deque&lt;TreeNode*&gt; d;</span><br><span class="line">d.push_back(root);</span><br><span class="line">while(!d.empty())&#123;</span><br><span class="line">root=d.front();</span><br><span class="line">if(root!=NULL)&#123;</span><br><span class="line">res.push_back(root-&gt;val);</span><br><span class="line">d.push_back(root-&gt;left);</span><br><span class="line">d.push_back(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">d.pop_front();</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">//队列</span><br><span class="line">vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    if(root==NULL)</span><br><span class="line">        return res;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        res.push_back(q.front()-&gt;val);</span><br><span class="line">        if(q.front()-&gt;left!=NULL)</span><br><span class="line">            q.push(q.front()-&gt;left);</span><br><span class="line">        if(q.front()-&gt;right!=NULL)</span><br><span class="line">            q.push(q.front()-&gt;right);</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after: always;"></div><h1 id="剑指offer-23-二叉搜索树的后序遍历序列"><a href="#剑指offer-23-二叉搜索树的后序遍历序列" class="headerlink" title="剑指offer 23 二叉搜索树的后序遍历序列"></a>剑指offer 23 二叉搜索树的后序遍历序列</h1><p>//输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。<br>//如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123;</span><br><span class="line">  if (sequence.empty()) &#123;</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br><span class="line">  return helper(sequence, 0, sequence.size() - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool helper(vector&lt;int&gt; &amp;sequence, int first, int last) &#123; // first和last表示树序列的开始和结束的位置</span><br><span class="line">  if(first &gt;= last)&#123;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line">  int curIdx = first;</span><br><span class="line">  int rootVal = sequence[last]; //后序遍历，根节点一定在最后，找到根节点后，就可以将树分为左右两棵子树，其中左子树中的元素都小于根节点，右子树中的元素都大于根节点</span><br><span class="line">  while(curIdx &lt; last &amp;&amp; sequence[curIdx] &lt; rootVal)&#123;</span><br><span class="line">      ++curIdx;</span><br><span class="line">  &#125;</span><br><span class="line">  int midIdx = curIdx; // 到curIdx的值大于根节点时，我们认为开始进入到右子树部分，用一个midIdx记录下当前的右子树开始的位置</span><br><span class="line">  while (curIdx &lt; last)&#123;</span><br><span class="line">      if(sequence[curIdx] &lt; rootVal)&#123;</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">      ++curIdx;</span><br><span class="line">  &#125;</span><br><span class="line">  return helper(sequence, first, midIdx - 1) &amp;&amp; helper(sequence, midIdx, last - 1); // 再分别对左子树和右子树做同样的操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-24-二叉树中和为某一值的所有路径"><a href="#剑指offer-24-二叉树中和为某一值的所有路径" class="headerlink" title="剑指offer 24 二叉树中和为某一值的所有路径"></a>剑指offer 24 二叉树中和为某一值的所有路径</h1><p>//输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。<br>//路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。<br>//(注意: 在返回值的list中，数组长度大的数组靠前)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">vector&lt;int&gt; path;</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123;</span><br><span class="line">if(root==NULL || expectNumber&lt;=0) return res;</span><br><span class="line">findHelper(root, expectNumber); </span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">void findHelper(TreeNode* root, int sum)&#123;</span><br><span class="line">if(root==NULL) return;</span><br><span class="line">path.push_back(root-&gt;val);</span><br><span class="line">if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL &amp;&amp; root-&gt;val==sum)&#123;</span><br><span class="line">res.push_back(path);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">if(root-&gt;left!=NULL)&#123;</span><br><span class="line">findHelper(root-&gt;left, sum-root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line">if(root-&gt;right!=NULL)&#123;</span><br><span class="line">findHelper(root-&gt;right, sum-root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">path.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-25-复杂链表的复制"><a href="#剑指offer-25-复杂链表的复制" class="headerlink" title="剑指offer 25 复杂链表的复制"></a>剑指offer 25 复杂链表的复制</h1><p>//输入一个复杂链表（每个节点中有节点值，以及两个指针，<br>//一个指向下一个节点，另一个特殊指针指向任意一个节点），<br>//返回结果为复制后复杂链表的head。<br>//（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct RandomListNode &#123;</span><br><span class="line">int label;</span><br><span class="line">struct RandomListNode *next, *random;</span><br><span class="line">RandomListNode(int x) :</span><br><span class="line">label(x), next(NULL), random(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    RandomListNode* Clone(RandomListNode* pHead)&#123;</span><br><span class="line">    if(pHead==NULL) return NULL;</span><br><span class="line">    RandomListNode* currentNode=pHead;</span><br><span class="line">    //复制每个结点，将其插入结点后面</span><br><span class="line">    while(currentNode!=NULL)&#123;</span><br><span class="line">    RandomListNode* cloneNode = new RandomListNode(currentNode-&gt;label);</span><br><span class="line">    RandomListNode* nextNode = currentNode-&gt;next;</span><br><span class="line">    currentNode-&gt;next=cloneNode;</span><br><span class="line">    cloneNode-&gt;next=nextNode;</span><br><span class="line">    currentNode=nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode=pHead;</span><br><span class="line">    //复制老结点的随机指针给新结点</span><br><span class="line">    while(currentNode!=NULL)&#123;</span><br><span class="line">    currentNode-&gt;next-&gt;random = currentNode-&gt;random==NULL?NULL:currentNode-&gt;random-&gt;next;</span><br><span class="line">    currentNode=currentNode-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    //拆分链表</span><br><span class="line">    currentNode=pHead;</span><br><span class="line">    RandomListNode* pCloneHead=pHead-&gt;next;</span><br><span class="line">    while(currentNode!=NULL)&#123;</span><br><span class="line">    RandomListNode* cloneNode=currentNode-&gt;next;</span><br><span class="line">    currentNode-&gt;next=cloneNode-&gt;next;</span><br><span class="line">    cloneNode-&gt;next=cloneNode-&gt;next==NULL?NULL:cloneNode-&gt;next-&gt;next;</span><br><span class="line">    currentNode=currentNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-26-二叉搜索树转双端链表"><a href="#剑指offer-26-二叉搜索树转双端链表" class="headerlink" title="剑指offer 26 二叉搜索树转双端链表**"></a>剑指offer 26 二叉搜索树转双端链表**</h1><p>//题目描述<br>//输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。<br>//要求不能创建任何新的结点，只能调整树中结点指针的指向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">TreeNode* Convert(TreeNode* pRootOfTree)&#123;</span><br><span class="line">if(pRootOfTree==NULL) return NULL;</span><br><span class="line">TreeNode* pre=NULL;</span><br><span class="line">convertHelper(pRootOfTree, pre);</span><br><span class="line">TreeNode* res=pRootOfTree;</span><br><span class="line">while(res-&gt;left)&#123;</span><br><span class="line">res=res-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">void convertHelper(TreeNode* cur, TreeNode*&amp; pre)&#123;</span><br><span class="line">if(cur==NULL) return;</span><br><span class="line">convertHelper(cur-&gt;left, pre);</span><br><span class="line">cur-&gt;left=pre;</span><br><span class="line">if(pre) pre-&gt;right=cur;</span><br><span class="line">pre=cur;</span><br><span class="line">convertHelper(cur-&gt;right, pre);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-27-字符串的排列"><a href="#剑指offer-27-字符串的排列" class="headerlink" title="剑指offer 27 字符串的排列"></a>剑指offer 27 字符串的排列</h1><p>题目描述<br>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<br>输入描述:<br>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 1、递归算法</span><br><span class="line">     *</span><br><span class="line">     * 解析：http://www.cnblogs.com/cxjchen/p/3932949.html  (感谢该文作者！)</span><br><span class="line">     *</span><br><span class="line">     * 对于无重复值的情况</span><br><span class="line">     *</span><br><span class="line">     * 固定第一个字符，递归取得首位后面的各种字符串组合；</span><br><span class="line">     * 再把第一个字符与后面每一个字符交换，并同样递归获得首位后面的字符串组合； *递归的出口，就是只剩一个字符的时候，递归的循环过程，就是从每个子串的第二个字符开始依次与第一个字符交换，然后继续处理子串。</span><br><span class="line">     *</span><br><span class="line">     * 假如有重复值呢？</span><br><span class="line">     * *由于全排列就是从第一个数字起，每个数分别与它后面的数字交换，我们先尝试加个这样的判断——如果一个数与后面的数字相同那么这两个数就不交换了。</span><br><span class="line">     * 例如abb，第一个数与后面两个数交换得bab，bba。然后abb中第二个数和第三个数相同，就不用交换了。</span><br><span class="line">     * 但是对bab，第二个数和第三个数不 同，则需要交换，得到bba。</span><br><span class="line">     * 由于这里的bba和开始第一个数与第三个数交换的结果相同了，因此这个方法不行。</span><br><span class="line">     *</span><br><span class="line">     * 换种思维，对abb，第一个数a与第二个数b交换得到bab，然后考虑第一个数与第三个数交换，此时由于第三个数等于第二个数，</span><br><span class="line">     * 所以第一个数就不再用与第三个数交换了。再考虑bab，它的第二个数与第三个数交换可以解决bba。此时全排列生成完毕！</span><br><span class="line">     *</span><br><span class="line">     *</span><br><span class="line">     * @param str</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">vector&lt;string&gt; Permutation(string str) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        if(str.empty()) return res;</span><br><span class="line">        permutationHelper(str, res, 0, str.size()-1);</span><br><span class="line">        sort(res.begin(),res.end());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">void permutationHelper(string str, vector&lt;string&gt; &amp;res, int start, int end)&#123;</span><br><span class="line">    if(start==end) &#123;</span><br><span class="line">        res.push_back(str);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=start;i&lt;=end;i++)&#123;   //从str的头到尾都换一次</span><br><span class="line">        if(is_swap(str, start, i))&#123;</span><br><span class="line">            swap(str, start, i);</span><br><span class="line">            permutationHelper(str, res, start+1, end);</span><br><span class="line">            swap(str, start, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool is_swap(string str, int l, int r)&#123;</span><br><span class="line">    bool flag=true;</span><br><span class="line">    for(int i=l;i&lt;r;i++)&#123;  //l==r则跳过循环，比如aa可以加入res</span><br><span class="line">        if(str[i]==str[r])&#123;</span><br><span class="line">            flag=false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line">void swap(string &amp;str, int l, int r)&#123;</span><br><span class="line">    char tmp=str[l];</span><br><span class="line">    str[l]=str[r];</span><br><span class="line">    str[r]=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap(char* str,int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    char tmp = str[a];</span><br><span class="line">    str[a] = str[b];</span><br><span class="line">    str[b] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">     * 2、字典序排列算法</span><br><span class="line">     *</span><br><span class="line">     * 可参考解析： http://www.cnblogs.com/pmars/archive/2013/12/04/3458289.html  （感谢作者）</span><br><span class="line">     *</span><br><span class="line">     * 一个全排列可看做一个字符串，字符串可有前缀、后缀。</span><br><span class="line">     * 生成给定全排列的下一个排列.所谓一个的下一个就是这一个与下一个之间没有其他的。</span><br><span class="line">     * 这就要求这一个与下一个有尽可能长的共同前缀，也即变化限制在尽可能短的后缀上。</span><br><span class="line">     *</span><br><span class="line">     * [例]839647521是1--9的排列。1—9的排列最前面的是123456789，最后面的987654321，</span><br><span class="line">     * 从右向左扫描若都是增的，就到了987654321，也就没有下一个了。否则找出第一次出现下降的位置。</span><br><span class="line">     *</span><br><span class="line">     * 【例】 如何得到346987521的下一个</span><br><span class="line">     * 1，从尾部往前找第一个P(i-1) &lt; P(i)的位置</span><br><span class="line">     * 3 4 6 &lt;- 9 &lt;- 8 &lt;- 7 &lt;- 5 &lt;- 2 &lt;- 1</span><br><span class="line">     * 最终找到6是第一个变小的数字，记录下6的位置i-1</span><br><span class="line">     *</span><br><span class="line">     * 2，从i位置往后找到最后一个大于6的数</span><br><span class="line">     * 3 4 6 -&gt; 9 -&gt; 8 -&gt; 7 5 2 1</span><br><span class="line">     * 最终找到7的位置，记录位置为m</span><br><span class="line">     *</span><br><span class="line">     * 3，交换位置i-1和m的值</span><br><span class="line">     * 3 4 7 9 8 6 5 2 1</span><br><span class="line">     * 4，倒序i位置后的所有数据</span><br><span class="line">     * 3 4 7 1 2 5 6 8 9</span><br><span class="line">     * 则347125689为346987521的下一个排列</span><br><span class="line">     *</span><br><span class="line">     * @param str</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line"> </span><br><span class="line">public ArrayList&lt;String&gt; Permutation2(String str)&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">        if(str==null || str.length()==0)&#123;</span><br><span class="line">            return list;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] chars = str.toCharArray();</span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">        list.add(String.valueOf(chars));</span><br><span class="line">        int len = chars.length;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            int lIndex = len-1;</span><br><span class="line">            int rIndex;</span><br><span class="line">            while(lIndex&gt;=1 &amp;&amp; chars[lIndex-1]&gt;=chars[lIndex])&#123;</span><br><span class="line">                lIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            if(lIndex == 0)</span><br><span class="line">                break;</span><br><span class="line">            rIndex = lIndex;</span><br><span class="line">            while(rIndex&lt;len &amp;&amp; chars[rIndex]&gt;chars[lIndex-1])&#123;</span><br><span class="line">                rIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(chars,lIndex-1,rIndex-1);</span><br><span class="line">            reverse(chars,lIndex);</span><br><span class="line"> </span><br><span class="line">            list.add(String.valueOf(chars));</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private void reverse(char[] chars,int k)&#123;</span><br><span class="line">    if(chars==null || chars.length&lt;=k)</span><br><span class="line">        return;</span><br><span class="line">    int len = chars.length;</span><br><span class="line">    for(int i=0;i&lt;(len-k)/2;i++)&#123;</span><br><span class="line">        int m = k+i;</span><br><span class="line">        int n = len-1-i;</span><br><span class="line">        if(m&lt;=n)&#123;</span><br><span class="line">            swap(chars,m,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-28-数组中出现超过一半的数"><a href="#剑指offer-28-数组中出现超过一半的数" class="headerlink" title="剑指offer 28 数组中出现超过一半的数"></a>剑指offer 28 数组中出现超过一半的数</h1><p>//数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">// O(n) 空间O(n) 不追求元素排序，不用map或者hashmap</span><br><span class="line">int MoreThanHalfNum_Solution2(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">int n = numbers.size();</span><br><span class="line">//map 记录出现次数</span><br><span class="line">unordered_map&lt;int, int&gt; m;</span><br><span class="line">int count;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">count = ++m[numbers[i]];</span><br><span class="line">if (count &gt; n/2) return numbers[i];</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">// O(n) O(1)</span><br><span class="line">int MoreThanHalfNum_Solution1(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">if(numbers.empty()) return 0;</span><br><span class="line">int n = numbers.size(), num=numbers[0],count=1;</span><br><span class="line">for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">if(numbers[i]==num) count++;</span><br><span class="line">else count--;</span><br><span class="line">if(count==0)&#123;</span><br><span class="line">num=numbers[i];</span><br><span class="line">count=1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">count=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">if(numbers[i]==num) count++;</span><br><span class="line">&#125;</span><br><span class="line">return (count&gt;n/2)?num:0;</span><br><span class="line">&#125;</span><br><span class="line">//快排思想 O(n)?O(logn)?</span><br><span class="line">int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">if(numbers.empty()) return 0;</span><br><span class="line">int n = numbers.size(), mid=n/2,count=1;</span><br><span class="line">int start=0,end=n-1;</span><br><span class="line">int k=partition(numbers, 0, n-1);</span><br><span class="line">while(k!=mid)&#123;</span><br><span class="line">if(k&gt;mid)&#123;</span><br><span class="line">end=k-1;</span><br><span class="line">k=partition(numbers, start, end);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">start=k+1;</span><br><span class="line">k=partition(numbers, start, end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int num=numbers[mid];</span><br><span class="line">count=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">if(numbers[i]==num) count++;</span><br><span class="line">&#125;</span><br><span class="line">return (count&gt;n/2)?num:0;</span><br><span class="line">&#125;</span><br><span class="line">int partition(vector&lt;int&gt; &amp;numbers, int s, int e)&#123;</span><br><span class="line">int pivot=numbers[s];</span><br><span class="line">int leftmark=s+1, rightmark=e;</span><br><span class="line">bool done=false;</span><br><span class="line">while(!done)&#123;</span><br><span class="line">while(leftmark&lt;=rightmark &amp;&amp; pivot&gt;=numbers[leftmark]) leftmark++;</span><br><span class="line">while(leftmark&lt;=rightmark &amp;&amp; pivot&lt;=numbers[rightmark]) rightmark--;</span><br><span class="line">if(leftmark&gt;rightmark) done=true;</span><br><span class="line">else&#123;</span><br><span class="line">swap(numbers, leftmark, rightmark);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(numbers, s, rightmark);</span><br><span class="line">return rightmark;</span><br><span class="line">&#125;</span><br><span class="line">void swap(vector&lt;int&gt; &amp;v, int s, int e)&#123;</span><br><span class="line">int tmp=v[s];</span><br><span class="line">v[s]=v[e];</span><br><span class="line">v[e]=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//拓展：输出数组中两个数量超过1/3的数 //投票法，讲道理partition应该也行1/3,2/3的位置</span><br><span class="line">vector&lt;int&gt; MoreThanOneThirdNum_Solution(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    if(numbers.empty()) return res;</span><br><span class="line">    int num1=0, num2=0, cnt1=0, cnt2=0, len = numbers.size();</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        if(numbers[i]==num1) cnt1++;</span><br><span class="line">        else if (numbers[i]==num2) cnt2++;</span><br><span class="line">        else if (cnt1==0) num1=numbers[i], cnt1=1;</span><br><span class="line">        else if (cnt2==0) num2=numbers[i], cnt2=1;</span><br><span class="line">        else cnt1--, cnt2--;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt1=0, cnt2=0;</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        if(numbers[i]==num1) cnt1++;</span><br><span class="line">        if(numbers[i]==num2) cnt2++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(cnt1&gt;len/3) res.push_back(num1);</span><br><span class="line">    if(cnt2&gt;len/3) res.push_back(num2);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-29-最小的k个数"><a href="#剑指offer-29-最小的k个数" class="headerlink" title="剑指offer 29 最小的k个数**"></a>剑指offer 29 最小的k个数**</h1><p>//输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。partition O(n)-O(n^2）?牛客超时？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">vector&lt;int&gt; res;</span><br><span class="line">if(input.empty() || k&gt;input.size()) return res;</span><br><span class="line">int len=input.size(), pos, s=0, e=len-1;</span><br><span class="line">pos=par(input, 0, len-1);</span><br><span class="line">while (pos!=k)&#123;</span><br><span class="line">if (pos&gt;k) e=pos-1,pos=par(input, s, e);</span><br><span class="line">else s=pos+1,pos=par(input, s, e);</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">res.push_back(input[i]);</span><br><span class="line">&#125;</span><br><span class="line">sort(res.begin(),res.end());</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">int par(vector&lt;int&gt; &amp;arr, int s, int e)&#123;</span><br><span class="line">int pivot=arr[s];</span><br><span class="line">int l=s+1, r=e;</span><br><span class="line">bool done=false;</span><br><span class="line">while(!done)&#123;</span><br><span class="line">while(l&lt;=r &amp;&amp; arr[l]&lt;=pivot) </span><br><span class="line">l++;</span><br><span class="line">while(l&lt;=r &amp;&amp; arr[r]&gt;=pivot) </span><br><span class="line">r--;</span><br><span class="line">if(l&gt;r) done=true;</span><br><span class="line">else swap(arr, l, r); </span><br><span class="line">&#125;</span><br><span class="line">swap(arr, s, r);</span><br><span class="line">return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//最大堆，待写</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-30-连续子数组最大和"><a href="#剑指offer-30-连续子数组最大和" class="headerlink" title="剑指offer 30 连续子数组最大和"></a>剑指offer 30 连续子数组最大和</h1><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//DP O(n) O(1)</span><br><span class="line">int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</span><br><span class="line">if(array.empty()) return 0;</span><br><span class="line">int len=array.size();</span><br><span class="line">int res=array[0], pre=array[0];</span><br><span class="line">for(int i=1;i&lt;len;i++)&#123;</span><br><span class="line">pre=max(array[i], pre+array[i]);</span><br><span class="line">if(res&lt;pre) res=pre;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-31-整数中1的个数"><a href="#剑指offer-31-整数中1的个数" class="headerlink" title="剑指offer 31 整数中1的个数"></a>剑指offer 31 整数中1的个数</h1><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数?为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int NumberOf1Between1AndN_Solution(int n)&#123;</span><br><span class="line">    if(n&lt;0) return 0;</span><br><span class="line">    int count=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i*=10)&#123;</span><br><span class="line">        int k=i*10;</span><br><span class="line">        count+=(n/k)*i+min(max(n%k-i+1, 0), i);</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p> <div style="page-break-after: always;"></div><h1 id="剑指offer-32-把数组排成最小的数"><a href="#剑指offer-32-把数组排成最小的数" class="headerlink" title="剑指offer 32 把数组排成最小的数**"></a>剑指offer 32 把数组排成最小的数**</h1><p>//输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">static bool cmp(int a, int b)&#123;</span><br><span class="line">string A=&quot;&quot;;</span><br><span class="line">string B=&quot;&quot;;</span><br><span class="line">A += to_string(a);</span><br><span class="line">A += to_string(b);</span><br><span class="line">B += to_string(b);</span><br><span class="line">B += to_string(a);</span><br><span class="line">return A&lt;B;</span><br><span class="line">&#125;</span><br><span class="line">string PrintMinNumber(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">string res=&quot;&quot;;</span><br><span class="line">if(numbers.empty()) return res;</span><br><span class="line">sort(numbers.begin(), numbers.end(), cmp);</span><br><span class="line">for(int i=0;i&lt;numbers.size();i++)&#123;</span><br><span class="line">res+=to_string(numbers[i]);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-33-丑数"><a href="#剑指offer-33-丑数" class="headerlink" title="剑指offer 33 丑数"></a>剑指offer 33 丑数</h1><p>//把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">int GetUglyNumber_Solution(int index) &#123;</span><br><span class="line">if(index&lt;1) return 0;</span><br><span class="line">vector&lt;int&gt; ugly(index, 1);</span><br><span class="line">int pointer2=0, pointer3=0, pointer5=0;</span><br><span class="line">for(int i=1;i&lt;index;i++)&#123;</span><br><span class="line">ugly[i] = findmin(ugly[pointer2]*2, ugly[pointer3]*3, ugly[pointer5]*5);</span><br><span class="line">if(ugly[pointer2]*2==ugly[i]) pointer2++;</span><br><span class="line">if(ugly[pointer3]*3==ugly[i]) pointer3++;</span><br><span class="line">if(ugly[pointer5]*5==ugly[i]) pointer5++;</span><br><span class="line">&#125;</span><br><span class="line">return ugly[index-1];</span><br><span class="line">    &#125;</span><br><span class="line">int findmin(int a, int b, int c)&#123;</span><br><span class="line">int tmp = a&gt;b?b:a;</span><br><span class="line">int tmp2 = tmp&gt;c?c:tmp;</span><br><span class="line">return tmp2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-34-第一次出现的字符"><a href="#剑指offer-34-第一次出现的字符" class="headerlink" title="剑指offer 34 第一次出现的字符"></a>剑指offer 34 第一次出现的字符</h1><p>//在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int FirstNotRepeatingChar(string str) &#123;</span><br><span class="line">  int res=-1;</span><br><span class="line">  if(str.empty()) return res;</span><br><span class="line">  int len=str.size();</span><br><span class="line">  unordered_map&lt;char, int&gt; mp;</span><br><span class="line">  for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">    mp[str[i]]++;</span><br><span class="line">    // cout&lt;&lt;mp[str[i]]&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">    cout&lt;&lt;mp[str[i]]&lt;&lt;endl;</span><br><span class="line">    if(mp[str[i]]==1)&#123;</span><br><span class="line">       res=i;break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-35-数组中的逆序对"><a href="#剑指offer-35-数组中的逆序对" class="headerlink" title="剑指offer 35 数组中的逆序对**"></a>剑指offer 35 数组中的逆序对**</h1><p>//在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007。例子：输入 1,2,3,4,5,6,7,0 输出 7<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//暴力求解 O(N*N)</span><br><span class="line">int InversePairs2(vector&lt;int&gt; data) &#123;</span><br><span class="line">    int res=0;</span><br><span class="line">    if(data.empty()) return res;</span><br><span class="line">    int len=data.size();</span><br><span class="line">    for(int i=len-1;i&gt;=0;i--)&#123;</span><br><span class="line">        for(int j=i-1;j&gt;=0;j--)&#123;</span><br><span class="line">            if(data[j]&gt;data[i]) res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">//归并排序 O(nlogn)</span><br><span class="line">int InversePairs(vector&lt;int&gt; data) &#123;</span><br><span class="line">int res=0;</span><br><span class="line">if(data.empty()) return res;</span><br><span class="line">int len=data.size();</span><br><span class="line">vector&lt;int&gt; cp(len, 0);</span><br><span class="line">for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">cp[i]=data[i];</span><br><span class="line">&#125;</span><br><span class="line">res = mergeCount(data, cp, 0, len-1);</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">int mergeCount(vector&lt;int&gt; &amp;arr, vector&lt;int&gt; &amp;cp, int s, int e)&#123;</span><br><span class="line">if(s==e) return 0;</span><br><span class="line">int mid=(s+e)&gt;&gt;1;</span><br><span class="line">int leftCount=mergeCount(arr, cp, s, mid)%1000000007;</span><br><span class="line">int rightCount=mergeCount(arr, cp, mid+1, e)%1000000007;</span><br><span class="line">int count=0,i=mid,j=e,locCopy=e;</span><br><span class="line">while(i&gt;=s &amp;&amp; j&gt;mid)&#123;</span><br><span class="line">if(arr[i]&gt;arr[j])&#123;</span><br><span class="line">count += j-mid;</span><br><span class="line">cp[locCopy--] = arr[i--];</span><br><span class="line">if(count&gt;=1000000007) count%=1000000007;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">cp[locCopy--] = arr[j--];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(;i&gt;=s;i--)&#123;</span><br><span class="line">cp[locCopy--]=arr[i];</span><br><span class="line">&#125;</span><br><span class="line">for(;j&gt;mid;j--)&#123;</span><br><span class="line">cp[locCopy--]=arr[j];</span><br><span class="line">&#125;</span><br><span class="line">for(int ss=s;ss&lt;=e;ss++)&#123;</span><br><span class="line">arr[ss]=cp[ss];</span><br><span class="line">&#125;</span><br><span class="line">return (leftCount+rightCount+count)%1000000007;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-36-两个链表的第一个公共结点"><a href="#剑指offer-36-两个链表的第一个公共结点" class="headerlink" title="剑指offer 36 两个链表的第一个公共结点"></a>剑指offer 36 两个链表的第一个公共结点</h1><p>输入两个链表，找出它们的第一个公共结点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 若有公共结点，让最长的链表先走len1-len2步，再一起走，必会相交</span><br><span class="line">ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) &#123;</span><br><span class="line">    if(pHead1==NULL || pHead2==NULL) return NULL;</span><br><span class="line">int len1 = findLinkedListLength(pHead1);</span><br><span class="line">int len2 = findLinkedListLength(pHead2);</span><br><span class="line">if(len1&gt;len2)&#123;</span><br><span class="line">pHead1=walkK(pHead1, len1-len2);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">pHead2 = walkK(pHead2, len2-len1);</span><br><span class="line">&#125;</span><br><span class="line">while(pHead1!=NULL &amp;&amp; pHead2!=NULL)&#123;</span><br><span class="line">if(pHead1==pHead2) return pHead1;</span><br><span class="line">pHead1=pHead1-&gt;next;</span><br><span class="line">pHead2=pHead2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int findLinkedListLength(ListNode* pHead)&#123;</span><br><span class="line">int res=0;</span><br><span class="line">while(pHead!=NULL)&#123;</span><br><span class="line">pHead = pHead-&gt;next;</span><br><span class="line">res++;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">ListNode* walkK(ListNode* pHead, int k)&#123;</span><br><span class="line">while(k--)&#123;</span><br><span class="line">pHead=pHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-37-数组在排序数组出现的次数"><a href="#剑指offer-37-数组在排序数组出现的次数" class="headerlink" title="剑指offer 37 数组在排序数组出现的次数"></a>剑指offer 37 数组在排序数组出现的次数</h1><p>//统计一个数字在排序数组中出现的次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// O(n) O(1)</span><br><span class="line">int GetNumberOfK1(vector&lt;int&gt; data ,int k) &#123;</span><br><span class="line">      if(data.empty()) return 0;</span><br><span class="line">  int res=0;</span><br><span class="line">  for(int i=0;i&lt;data.size();i++)&#123;</span><br><span class="line">    if(data[i]==k) res++;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">  &#125;</span><br><span class="line">// O(logn) O(1)</span><br><span class="line">int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123;</span><br><span class="line">      if(data.empty()) return 0;</span><br><span class="line">  int start=0, end=data.size()-1, res=0;</span><br><span class="line">  while(start&lt;=end)&#123;</span><br><span class="line">    int mid=(start+end)&gt;&gt;1;</span><br><span class="line">    if(data[mid]&gt;k)&#123;</span><br><span class="line">      end=mid-1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(data[mid]&lt;k) &#123;</span><br><span class="line">      start=mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      int l=mid, r=mid;</span><br><span class="line">      res++;</span><br><span class="line">      while(data[--l]==k) res++;</span><br><span class="line">      while(data[++r]==k) res++;</span><br><span class="line">      cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-38-二叉树深度"><a href="#剑指offer-38-二叉树深度" class="headerlink" title="剑指offer 38 二叉树深度"></a>剑指offer 38 二叉树深度</h1><p>//输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//递归</span><br><span class="line">int TreeDepth(TreeNode* pRoot) &#123;</span><br><span class="line">  if(pRoot==NULL) return 0;</span><br><span class="line">  return max(TreeDepth(pRoot-&gt;left), TreeDepth(pRoot-&gt;right))+1;</span><br><span class="line">&#125;</span><br><span class="line">//非递归</span><br><span class="line">int TreeDepthNotLoop(TreeNode* pRoot) &#123;</span><br><span class="line">  int res=0;</span><br><span class="line">  if(pRoot==NULL) return res;</span><br><span class="line">  queue&lt;TreeNode *&gt; q;</span><br><span class="line">  q.push(pRoot);</span><br><span class="line">  while(!q.empty()) &#123;</span><br><span class="line">    int size=q.size();</span><br><span class="line">    res++;</span><br><span class="line">    for(int i=0;i&lt;size;i++)&#123;</span><br><span class="line">        TreeNode* top=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(top-&gt;left) q.push(top-&gt;left);</span><br><span class="line">        if(top-&gt;right) q.push(top-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res; &#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-39-判断平衡二叉树"><a href="#剑指offer-39-判断平衡二叉树" class="headerlink" title="剑指offer 39 判断平衡二叉树"></a>剑指offer 39 判断平衡二叉树</h1><p>//输入一棵二叉树，判断该二叉树是否是平衡二叉树。如果二叉树的每个节点的左子树和右子树的深度不大于1，它就是平衡二叉树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool IsBalanced_Solution(TreeNode* pRoot)&#123;</span><br><span class="line">  return pos_travel(pRoot)!=-1;</span><br><span class="line">  &#125;</span><br><span class="line">int pos_travel(TreeNode* pRoot)&#123;</span><br><span class="line">  if(pRoot==NULL) return 0;</span><br><span class="line">  int left=pos_travel(pRoot-&gt;left);</span><br><span class="line">  if(left==-1) return -1;</span><br><span class="line">  int right=pos_travel(pRoot-&gt;right);</span><br><span class="line">  if(right==-1) return -1;</span><br><span class="line">  return abs(left-right)&gt;1?-1:1+max(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-40-数组中只出现一次的数字"><a href="#剑指offer-40-数组中只出现一次的数字" class="headerlink" title="剑指offer 40 数组中只出现一次的数字"></a>剑指offer 40 数组中只出现一次的数字</h1><p>//一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//input vector&lt;int&gt; arr=&#123;1,4,4,5,5,7&#125;;</span><br><span class="line">void FindNumsAppearOnce(vector &lt;int&gt; data, int* num1, int *num2) &#123;</span><br><span class="line">    if(data.empty()) return;</span><br><span class="line">    int len=data.size();</span><br><span class="line">    unordered_map &lt;int, int&gt; mp;</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        mp[data[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        if(mp[data[i]]==1)&#123;</span><br><span class="line">            res.push_back(data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *num1 = res[0];</span><br><span class="line">    *num2 = res[1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int find1From2(int[] a)&#123;</span><br><span class="line">    int len = a.length, res = 0;</span><br><span class="line">    for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="line">        res = res ^ a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-41-和为S的连续正数序列"><a href="#剑指offer-41-和为S的连续正数序列" class="headerlink" title="剑指offer 41 和为S的连续正数序列"></a>剑指offer 41 和为S的连续正数序列</h1><p>//输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; vOut;</span><br><span class="line">    vector&lt;int&gt; vIn;</span><br><span class="line">    if(sum==1) &#123;</span><br><span class="line">        vIn.push_back(1);</span><br><span class="line">        vOut.push_back(vIn);</span><br><span class="line">        return vOut;</span><br><span class="line">    &#125;</span><br><span class="line">    int left=1, right=2;</span><br><span class="line">    while(left&lt;right)&#123;</span><br><span class="line">        int k=(left+right)*(right-left+1)/2;</span><br><span class="line">        if(sum==k) &#123;</span><br><span class="line">            vector&lt;int&gt; vTmp;</span><br><span class="line">            for(int i=left;i&lt;=right;i++)&#123;</span><br><span class="line">                vTmp.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            vOut.push_back(vTmp);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(sum&gt;k) &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return vOut;</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123;</span><br><span class="line">  vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">  if(sum&lt;=2) return res;</span><br><span class="line">  int up=sqrt(2*sum);</span><br><span class="line">  for(int i=up;i&gt;=2;i--)&#123;</span><br><span class="line">    int n = sum/i;</span><br><span class="line">    if(i%2==1 &amp;&amp; sum%i==0)&#123;</span><br><span class="line">      vector&lt;int&gt; tmp;</span><br><span class="line">      for(int j=n-(i-1)/2;j&lt;=n+(i-1)/2;j++)&#123;</span><br><span class="line">        tmp.push_back(j);</span><br><span class="line">      &#125;</span><br><span class="line">      res.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    if(i%2==0 &amp;&amp; sum%i*2==i)&#123;</span><br><span class="line">      vector&lt;int&gt; tmp;</span><br><span class="line">      for(int j=n-(i-2)/2;j&lt;=n+(i-2)/2+1;j++)&#123;</span><br><span class="line">        tmp.push_back(j);</span><br><span class="line">      &#125;</span><br><span class="line">      res.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-42-和为S的两个数"><a href="#剑指offer-42-和为S的两个数" class="headerlink" title="剑指offer 42 和为S的两个数"></a>剑指offer 42 和为S的两个数</h1><p>//输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123;</span><br><span class="line">  vector&lt;int&gt; res;</span><br><span class="line">  if(array.empty()) return res;</span><br><span class="line">  int low=0, high=array.size()-1, Min=INT32_MAX;</span><br><span class="line">  while(low&lt;high)&#123;</span><br><span class="line">    cout&lt;&lt;low&lt;&lt;&quot; &quot;&lt;&lt;high&lt;&lt;endl;</span><br><span class="line">    int add = array[low]+array[high], product= array[low]*array[high];</span><br><span class="line">    if(sum==add) &#123;</span><br><span class="line">      if(product&lt;Min)&#123;</span><br><span class="line">        Min = product;</span><br><span class="line">        while(!res.empty())&#123;</span><br><span class="line">          res.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(array[low]);</span><br><span class="line">        res.push_back(array[high]);</span><br><span class="line">      &#125;</span><br><span class="line">      low++;high--;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (sum&lt;add)&#123;</span><br><span class="line">      high--;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">      low++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-43-左旋转字符串"><a href="#剑指offer-43-左旋转字符串" class="headerlink" title="剑指offer 43 左旋转字符串"></a>剑指offer 43 左旋转字符串</h1><p>//汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">string LeftRotateStringCircle(string str, int n) &#123;</span><br><span class="line">if (str.empty()) return &quot;&quot;;</span><br><span class="line">deque&lt;char&gt; q;</span><br><span class="line">for (int i=0;i&lt;str.size();i++)&#123;</span><br><span class="line">q.push_back(str[i]);</span><br><span class="line">&#125;</span><br><span class="line">while(n!=0) &#123;</span><br><span class="line">char tmp = q.front();</span><br><span class="line">q.pop_front();</span><br><span class="line">q.push_back(tmp);</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line">string res=&quot;&quot;;</span><br><span class="line">for (int i=0;i&lt;q.size();i++)&#123;</span><br><span class="line">res = res+q[i];</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">string LeftRotateString(string str, int n) &#123;</span><br><span class="line">if (str.empty()) return &quot;&quot;;</span><br><span class="line">n = n % str.size();</span><br><span class="line">reverse(str.begin(), str.end());</span><br><span class="line">reverse(str.begin(), str.begin()+str.size()-n);</span><br><span class="line">reverse(str.begin()+str.size()-n, str.end());</span><br><span class="line">return str;</span><br><span class="line">&#125;</span><br><span class="line">//自写reverse函数</span><br><span class="line">void reverse1(string&amp; str, int s, int e)&#123;</span><br><span class="line">    while (s &lt; e) &#123;</span><br><span class="line">        char temp = str[s];</span><br><span class="line">        str[s] = str[e];</span><br><span class="line">        str[e] = temp;</span><br><span class="line">        s++;</span><br><span class="line">        e--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-44-翻转单词顺序列"><a href="#剑指offer-44-翻转单词顺序列" class="headerlink" title="剑指offer 44 翻转单词顺序列"></a>剑指offer 44 翻转单词顺序列</h1><p>// “student. a am I”-&gt;“I am a student.”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">string ReverseSentence1(string str) &#123;</span><br><span class="line">string res = &quot;&quot;;</span><br><span class="line">if(str.empty()) return res;</span><br><span class="line">vector &lt;string&gt; s;</span><br><span class="line">int index=0;</span><br><span class="line">string tmp=&quot;&quot;;</span><br><span class="line">while(index &lt; str.size())&#123;</span><br><span class="line">if (str[index]==&apos; &apos;) &#123;</span><br><span class="line">s.push_back(tmp);</span><br><span class="line">tmp=&quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">tmp+=str[index];</span><br><span class="line">&#125;</span><br><span class="line">if(index==str.size()-1) s.push_back(tmp);</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">for (int i=s.size()-1;i&gt;=0;i--) &#123;</span><br><span class="line">res += s[i];</span><br><span class="line">if(i!=0) res += &apos; &apos;;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">string ReverseSentence(string str) &#123;</span><br><span class="line">std::reverse(str.begin(),str.end());</span><br><span class="line">int front=0;</span><br><span class="line">int back=0;</span><br><span class="line">int size = str.size();</span><br><span class="line">while(front&lt;size)&#123;</span><br><span class="line">    while(front&lt;size&amp;&amp;str[front]==&apos; &apos;)++front; //跳过空格，找第一个非空字母位置</span><br><span class="line">    back = front;</span><br><span class="line">    while(back&lt;size&amp;&amp;str[back]!=&apos; &apos;)++back; //找单词最后一个字符的位置</span><br><span class="line">    std::reverse(str.begin()+front, str.begin()+back); //反转</span><br><span class="line">    front = back;</span><br><span class="line">&#125;</span><br><span class="line">return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-45-扑克牌顺子"><a href="#剑指offer-45-扑克牌顺子" class="headerlink" title="剑指offer 45 扑克牌顺子"></a>剑指offer 45 扑克牌顺子</h1><p>//一组数字，判断是否顺子。0为任意数，如果牌能组成顺子就输出true，否则就输出false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// O(n)</span><br><span class="line">bool IsContinuous( vector&lt;int&gt; numbers ) &#123;</span><br><span class="line">    if(numbers.empty()) return false;</span><br><span class="line">    vector&lt;int&gt; arr(14, 0);</span><br><span class="line">    arr[0]=-5;</span><br><span class="line">    int Min=14, Max=-1;</span><br><span class="line">    for (int i=0;i&lt;numbers.size();i++)&#123;</span><br><span class="line">        arr[numbers[i]]++;</span><br><span class="line">        if(numbers[i]==0) continue;</span><br><span class="line">        if(arr[numbers[i]]&gt;1) return false;</span><br><span class="line">        if (numbers[i]&lt;Min) &#123;</span><br><span class="line">            Min = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if (numbers[i]&gt;Max) &#123;</span><br><span class="line">            Max = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(Max-Min&gt;4) return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">// O(nlogn)</span><br><span class="line">bool IsContinuous( vector&lt;int&gt; numbers ) &#123;</span><br><span class="line">    sort(numbers.begin(), numbers.end());</span><br><span class="line">    int cnt0 = 0, cntNeed = 0;</span><br><span class="line">    for(int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        if(numbers[i] == 0) &#123;</span><br><span class="line">            ++cnt0;</span><br><span class="line">        &#125; else if(i + 1 &lt; 5 ) &#123;</span><br><span class="line">            if(numbers[i + 1] == numbers[i]) return false;</span><br><span class="line">            cntNeed += numbers[i + 1] - numbers[i] - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(cntNeed &gt; cnt0) return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-46-孩子们的游戏（圆圈里最后剩下的数）"><a href="#剑指offer-46-孩子们的游戏（圆圈里最后剩下的数）" class="headerlink" title="剑指offer 46 孩子们的游戏（圆圈里最后剩下的数）"></a>剑指offer 46 孩子们的游戏（圆圈里最后剩下的数）</h1><p>//约瑟夫圆环。一个数m,编号为0开始报数，m-1的出列，下一个继续从0开始，直至最后一个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">int LastRemaining_Solution(int n, int m) &#123;</span><br><span class="line">  if(n==0 || m&lt;=0) return -1;</span><br><span class="line">  if (n==1) return 0;</span><br><span class="line">  vector&lt;int&gt; v;</span><br><span class="line">  for (int i=0;i&lt;n;i++) &#123;</span><br><span class="line">    v.push_back(i);</span><br><span class="line">  &#125;</span><br><span class="line">  int p = 0;</span><br><span class="line">  while(v.size()&gt;1) &#123;</span><br><span class="line">    n = v.size();</span><br><span class="line">    p = (p+m) % n - 1;</span><br><span class="line">    if (p == -1) p = n-1;</span><br><span class="line">    v.erase(v.begin()+p);</span><br><span class="line">  &#125;</span><br><span class="line">  return v[0];</span><br><span class="line">  &#125;</span><br><span class="line">//公式dp</span><br><span class="line">  int LastRemaining_Solution1(unsigned int n, unsigned int m)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">      if(n &lt;= 0 &amp;&amp; m &lt;= 0) return -1; //蛋疼的特殊条件</span><br><span class="line">      int t = 0;</span><br><span class="line">      for(int i = 2; i &lt;= n; i++)</span><br><span class="line">          t = (t + m) % i;</span><br><span class="line">      return t;</span><br><span class="line">  &#125;</span><br><span class="line">//模拟循环链表</span><br><span class="line">int LastRemaining_Solution2(int n, int m)//n为人数</span><br><span class="line">&#123;</span><br><span class="line">  if(n&lt;1||m&lt;1)</span><br><span class="line">      return -1;</span><br><span class="line">  list&lt;int&gt; numbers;</span><br><span class="line">  for(int i=0;i&lt;n;i++)</span><br><span class="line">      numbers.push_back(i);</span><br><span class="line">  list&lt;int&gt;::iterator current=numbers.begin();</span><br><span class="line">  while(numbers.size()&gt;1)</span><br><span class="line">  &#123;</span><br><span class="line">      for(int i=1;i&lt;m;i++)//走m-1步到达第m个数处</span><br><span class="line">      &#123;</span><br><span class="line">          ++current;</span><br><span class="line">          if(current==numbers.end())</span><br><span class="line">              current=numbers.begin();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      list&lt;int&gt;::iterator next=++current;</span><br><span class="line">      if(next==numbers.end())</span><br><span class="line">          next=numbers.begin();</span><br><span class="line">      --current;</span><br><span class="line">      numbers.erase(current);</span><br><span class="line">      current=next;</span><br><span class="line">  &#125;</span><br><span class="line">  return *current;//对迭代器取值，等价于对指针取值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-47-求1-2-…-n"><a href="#剑指offer-47-求1-2-…-n" class="headerlink" title="剑指offer 47 求1+2+…+n"></a>剑指offer 47 求1+2+…+n</h1><p>//求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int Sum_Solution(int n) &#123;</span><br><span class="line">  if (n&lt;=0) return 0;</span><br><span class="line">  if (n==1) return 1;</span><br><span class="line">  return Sum_Solution(n-1)+n;</span><br><span class="line"> &#125;</span><br><span class="line">int Sum_Solution(int n) &#123;</span><br><span class="line">    int ans = n;</span><br><span class="line">//逻辑与有个短路特点，前面为假，后面不计算。</span><br><span class="line">    ans &amp;&amp; (ans += Sum_Solution(n - 1));</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-48-不用加减乘除做加法"><a href="#剑指offer-48-不用加减乘除做加法" class="headerlink" title="剑指offer 48 不用加减乘除做加法"></a>剑指offer 48 不用加减乘除做加法</h1><p>//求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。用三步走的方式计算二进制值相加：5-101，7-111,第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101 &amp; 111) \&lt;\&lt; 1。第三步重复上述两步， 各位相加 0 1 0 \^ 1 0 1 0 = 1 0 0 0，进位值为100 = (010 \&amp; 1010)\&lt;\&lt; 1。继续重复上述两步：1000\^100 = 1100，进位值为0，跳出循环，1100为最终结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int Add(int num1, int num2) &#123;</span><br><span class="line">    while(num2!=0)&#123;</span><br><span class="line">        int tmp = num1^num2;</span><br><span class="line">        num2 = (num1&amp;num2)&lt;&lt;1;</span><br><span class="line">        num1=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-49-把字符串转换为整数"><a href="#剑指offer-49-把字符串转换为整数" class="headerlink" title="剑指offer 49 把字符串转换为整数"></a>剑指offer 49 把字符串转换为整数</h1><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int StrToInt(string str) &#123;</span><br><span class="line">    if(str.empty()) return 0;</span><br><span class="line">    int res=0, symbol=1;</span><br><span class="line">    if(str[0]==&apos;+&apos;) &#123;</span><br><span class="line">        str[0]=&apos;0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(str[0]==&apos;-&apos;) &#123;</span><br><span class="line">        symbol=-1;</span><br><span class="line">        str[0] = &apos;0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;str.size();i++) &#123;</span><br><span class="line">        if(str[i]&lt;&apos;0&apos; || str[i]&gt;&apos;9&apos;) &#123;</span><br><span class="line">            res = 0;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        res = res*10 + str[i]-&apos;0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return symbol*res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-50-数组中重复的数字"><a href="#剑指offer-50-数组中重复的数字" class="headerlink" title="剑指offer 50 数组中重复的数字"></a>剑指offer 50 数组中重复的数字</h1><p>// 在一个长度为n的数组里的所有数字都在0到n-1的范围内.数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Parameters:</span><br><span class="line">//        numbers:     an array of integers</span><br><span class="line">//        length:      the length of array numbers</span><br><span class="line">//        duplication: (Output) the duplicated number in the array number</span><br><span class="line">bool duplicate1(int numbers[], int length, int* duplication) &#123;</span><br><span class="line">bool res=false;</span><br><span class="line">if(length==0) return res;</span><br><span class="line">unordered_map&lt;int, int&gt; mp;</span><br><span class="line">for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">if (mp.count(numbers[i])==0) &#123;</span><br><span class="line">mp[numbers[i]] ++;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">*duplication = numbers[i];</span><br><span class="line">res = true;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>//思路二：剑指offer中解法：因为数组中数字都在0~n - 1，所以若无重复数字排好序则数字i将出现在下标i的位置。<br>//解法：从头到尾扫描这个数组，当扫描到下标为i的数字m时，先比较这个数字是否等于i，是则扫描下一个数字，否则<br>//将该数字与下标为m的数字进行比较，若相等，则找到一个重复的数字，否则将两个数字交换，并继续对该位置<br>//（下标i）重复上面比较过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">bool duplicate(int numbers[], int length, int* duplication) &#123;</span><br><span class="line">bool res = false;</span><br><span class="line">if (length == 0) return res;</span><br><span class="line">int i = 0;</span><br><span class="line">while(i&lt;length) &#123;</span><br><span class="line">if (numbers[i] == i) &#123;</span><br><span class="line">i++;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if (numbers[numbers[i]] == numbers[i]) &#123;</span><br><span class="line">res = true;</span><br><span class="line">*duplication = numbers[i];</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">int tmp = numbers[i];</span><br><span class="line">numbers[i] = numbers[tmp];</span><br><span class="line">numbers[tmp] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-51-构建乘积数组"><a href="#剑指offer-51-构建乘积数组" class="headerlink" title="剑指offer 51 构建乘积数组"></a>剑指offer 51 构建乘积数组</h1><p>给定一个数组A[0, 1, …, n - 1], 请构建一个数组B[0, 1, …, n - 1],其中B中的元素B[i] = A[0] <em> A[1] </em> … <em> A[i - 1] </em> A[i + 1] <em> … </em> A[n - 1]。不能使用除法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// recurrent O(n\*n)</span><br><span class="line">vector&lt;int&gt; multiplyN2(const vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">  vector&lt;int&gt; B;</span><br><span class="line">  if (A.empty()) return B;</span><br><span class="line">  for (int i = 0; i &lt; A.size(); i++) &#123;</span><br><span class="line">    B.push_back(ABhelper(A, A.size()-1, i));</span><br><span class="line">  &#125;</span><br><span class="line">  return B;</span><br><span class="line">&#125;</span><br><span class="line">int ABhelper(vector&lt;int&gt; A, int n, int k) &#123;</span><br><span class="line">  if (n == k &amp;&amp; n == 0) return 1;</span><br><span class="line">  if (n == k &amp;&amp; n &gt; 0) return ABhelper(A, n - 1, k);</span><br><span class="line">  if (n == 0) return A[0];</span><br><span class="line">  return ABhelper(A, n - 1, k) * A[n];</span><br><span class="line">&#125;</span><br><span class="line">// 上下三角求解合并</span><br><span class="line">//链接：https://www.nowcoder.com/questionTerminal/94a4d381a68b47b7a8bed86f2975db46?f=discussion</span><br><span class="line">vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">  vector&lt;int&gt; B;</span><br><span class="line">  if (A.empty()) return B;</span><br><span class="line">  int len = A.size();</span><br><span class="line">  // cal up triangle</span><br><span class="line">  B.push_back(1);</span><br><span class="line">  for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">    B.push_back(B[i - 1] * A[i - 1]);</span><br><span class="line">  &#125;</span><br><span class="line">  // cal down triangle</span><br><span class="line">  int down =1;</span><br><span class="line">  for (int i = len - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">    down *= A[i + 1];</span><br><span class="line">    B[i] *= down;</span><br><span class="line">  &#125;</span><br><span class="line">  return B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-52-正则表达式匹配"><a href="#剑指offer-52-正则表达式匹配" class="headerlink" title="剑指offer 52 正则表达式匹配"></a>剑指offer 52 正则表达式匹配</h1><p>//请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">bool match(char* str, char* pattern)&#123;</span><br><span class="line">    if (str == NULL || pattern == NULL)  return false;</span><br><span class="line">    int strIndex = 0, patternIndex = 0;</span><br><span class="line">    return matchHelper(str, pattern);</span><br><span class="line">&#125;</span><br><span class="line">bool matchHelper(char* str, char* pattern) &#123;</span><br><span class="line">    // str到尾，pattern到尾，匹配成功</span><br><span class="line">    // 注意下指针和string字符串判断是否为空的区别</span><br><span class="line">    if (*str == &apos;\0&apos; &amp;&amp; *pattern == &apos;\0&apos;) return true;</span><br><span class="line">    // pattern为空，str不空，匹配必定失败</span><br><span class="line">    if (*pattern == &apos;\0&apos; &amp;&amp; *str != &apos;\0&apos;) return false;</span><br><span class="line"></span><br><span class="line">    // 如果pattern下一个字符不为&apos;*&apos;</span><br><span class="line">    if (*(pattern + 1) != &apos;*&apos;) &#123;</span><br><span class="line">        // 匹配成功情况：</span><br><span class="line">        // 1. 当前str字符==当前pattern字符</span><br><span class="line">        // 2. pattern为&apos;.&apos;且当前str不为空</span><br><span class="line">        if (*pattern == *str || (*pattern == &apos;.&apos; &amp;&amp; *str != &apos;\0&apos;))&#123;</span><br><span class="line">            return matchHelper(str+1, pattern+1);</span><br><span class="line">        &#125;</span><br><span class="line">        else return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果pattern下一个字符为&apos;*&apos;</span><br><span class="line">    else &#123;</span><br><span class="line">        // 继续匹配的情况：</span><br><span class="line">        // 1. 当‘*’匹配0个字符时，str当前字符不变，pattern当前字符后移两位，跳过这个‘*’符号；</span><br><span class="line">        // 2. 当‘*’匹配1个或多个时，str当前字符移向下一个，pattern当前字符不变。</span><br><span class="line">        if (*pattern == *str || (*pattern == &apos;.&apos; &amp;&amp; *str != &apos;\0&apos;)) &#123;</span><br><span class="line">            return matchHelper(str+1,pattern) || matchHelper(str, pattern+2);</span><br><span class="line">        &#125;</span><br><span class="line">        else return matchHelper(str, pattern+2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-53-表示数值的字符串"><a href="#剑指offer-53-表示数值的字符串" class="headerlink" title="剑指offer 53 表示数值的字符串"></a>剑指offer 53 表示数值的字符串</h1><p>// 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool isNumeric(char* string)</span><br><span class="line">&#123;</span><br><span class="line">    if (string == nullptr) return false;</span><br><span class="line">    // 标记符号、小数点、e是否出现过</span><br><span class="line">    bool sign = false, decimal = false, hasE = false;</span><br><span class="line">    for (int i = 0; i &lt; strlen(string); i++) &#123;</span><br><span class="line">        if (string[i] == &apos;+&apos; || string[i] == &apos;-&apos;) &#123;</span><br><span class="line">            // 第二次出现+-符号，必须紧接在e之后</span><br><span class="line">            if (sign &amp;&amp; string[i-1] != &apos;e&apos; &amp;&amp; string[i-1] != &apos;E&apos;) return false;</span><br><span class="line">            // 第一次出现+-符号，且不是在字符串开头，也必须紧接在e之后</span><br><span class="line">            if (!sign &amp;&amp; i&gt;0 &amp;&amp; string[i-1] != &apos;e&apos; &amp;&amp; string[i-1] != &apos;E&apos;) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (string[i] == &apos;e&apos; || string[i] == &apos;E&apos;) &#123;</span><br><span class="line">            // e后面一定要接数字 || 不能同时存在两个e</span><br><span class="line">            if (i == strlen(string) - 1 || hasE) return false;</span><br><span class="line">            hasE = true;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (string[i] == &apos;.&apos;) &#123;</span><br><span class="line">            // e后面不能接小数点，小数点不能出现两次</span><br><span class="line">            if (hasE || decimal) return false;</span><br><span class="line">            decimal = true;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (string[i] &lt; &apos;0&apos; || string[i] &gt; &apos;9&apos;) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-54-字符流中第一个不重复的字符"><a href="#剑指offer-54-字符流中第一个不重复的字符" class="headerlink" title="剑指offer 54 字符流中第一个不重复的字符"></a>剑指offer 54 字符流中第一个不重复的字符</h1><p>// 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。如果当前字符流没有存在出现一次的字符，返回#字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">char hash[256] = &#123;0&#125;;</span><br><span class="line">//Insert one char from stringstream</span><br><span class="line">void Insert(char ch)</span><br><span class="line">&#123;</span><br><span class="line">        s += ch;</span><br><span class="line">        hash[ch]++;</span><br><span class="line">&#125;</span><br><span class="line">//return the first appearence once char in current stringstream</span><br><span class="line">char FirstAppearingOnce()</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">        if (hash[s[i]] == 1) &#123;</span><br><span class="line">            return s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &apos;#&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-55-链表中环的入口节点"><a href="#剑指offer-55-链表中环的入口节点" class="headerlink" title="剑指offer 55 链表中环的入口节点"></a>剑指offer 55 链表中环的入口节点</h1><p>// 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ListNode* EntryNodeOfLoop(ListNode* pHead)</span><br><span class="line">&#123;</span><br><span class="line">    if (pHead == nullptr) return nullptr;</span><br><span class="line">    ListNode* fast = pHead;</span><br><span class="line">    ListNode* slow = pHead;</span><br><span class="line">    ListNode* meetingNode = nullptr;</span><br><span class="line">    while (fast-&gt;next &amp;&amp; slow) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        if (fast == slow) &#123;</span><br><span class="line">            meetingNode = fast;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (meetingNode) &#123;</span><br><span class="line">        ListNode* p1 = meetingNode;</span><br><span class="line">        ListNode* p2 = pHead;</span><br><span class="line">        while (p1 != p2) &#123;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return p1;</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-56-删除链表中重复的节点"><a href="#剑指offer-56-删除链表中重复的节点" class="headerlink" title="剑指offer 56 删除链表中重复的节点"></a>剑指offer 56 删除链表中重复的节点</h1><p>// 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ListNode* deleteDuplication(ListNode* pHead)</span><br><span class="line">&#123;</span><br><span class="line">    if (pHead == nullptr) return nullptr;</span><br><span class="line">    ListNode *root = pHead, *pre;</span><br><span class="line">    while (root != nullptr) &#123;</span><br><span class="line">        if (root-&gt;next-&gt;val != root-&gt;val) &#123;</span><br><span class="line">            pre = root;</span><br><span class="line">            root = root-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            while (root-&gt;next &amp;&amp; root-&gt;next-&gt;val == root-&gt;val) &#123;</span><br><span class="line">                root = root-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            if (root-&gt;next) &#123;</span><br><span class="line">                pre-&gt;next = root-&gt;next;</span><br><span class="line">                root = root-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                pre-&gt;next = nullptr;</span><br><span class="line">                return pHead;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-57-二叉树的下一个节点"><a href="#剑指offer-57-二叉树的下一个节点" class="headerlink" title="剑指offer 57 二叉树的下一个节点"></a>剑指offer 57 二叉树的下一个节点</h1><p>// 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TreeLinkNode* GetNext(TreeLinkNode* pNode)</span><br><span class="line">&#123;</span><br><span class="line">    if (pNode == nullptr) return pNode;</span><br><span class="line">    while (pNode-&gt;right) &#123;</span><br><span class="line">        pNode = pNode-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-58-对称的二叉树"><a href="#剑指offer-58-对称的二叉树" class="headerlink" title="剑指offer 58 对称的二叉树"></a>剑指offer 58 对称的二叉树</h1><p>// 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool isSymmetrical(TreeNode* pRoot)</span><br><span class="line">&#123;</span><br><span class="line">    if (pRoot == nullptr) return true;</span><br><span class="line">    return isSymmetricalHelper(pRoot-&gt;left, pRoot-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">bool isSymmetricalHelper(TreeNode* p1, TreeNode* p2) &#123;</span><br><span class="line">    if (p1 &amp;&amp; p2 == nullptr) return false;</span><br><span class="line">    else if (p2 &amp;&amp; p1 == nullptr) return false;</span><br><span class="line">    else if (p1 == nullptr &amp;&amp; p2 == nullptr) return true;</span><br><span class="line">    if (p1-&gt;val == p2-&gt;val) &#123;</span><br><span class="line">        return isSymmetricalHelper(p1-&gt;left, p2-&gt;right) &amp;&amp; isSymmetricalHelper(p2-&gt;left, p1-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    else return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-59-之字形打印二叉树"><a href="#剑指offer-59-之字形打印二叉树" class="headerlink" title="剑指offer 59 之字形打印二叉树"></a>剑指offer 59 之字形打印二叉树</h1><p>// 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; PrintZ(TreeNode* pRoot) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    if (pRoot == nullptr) return res;</span><br><span class="line">    vector&lt;TreeNode*&gt; d;</span><br><span class="line">    d.push_back(pRoot);</span><br><span class="line">    vector&lt;int&gt; init;</span><br><span class="line">    init.push_back(pRoot-&gt;val);</span><br><span class="line">    res.push_back(init);</span><br><span class="line">    int layer = 1;</span><br><span class="line">    while (!d.empty()) &#123;</span><br><span class="line">        layer++;</span><br><span class="line">        vector&lt;TreeNode*&gt; tmp;</span><br><span class="line">        for (int i = 0; i &lt; d.size(); i++) &#123;</span><br><span class="line">            if (d[i]-&gt;left) tmp.push_back(d[i]-&gt;left);</span><br><span class="line">            if (d[i]-&gt;right) tmp.push_back(d[i]-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; tmpInt;</span><br><span class="line">        for (int i = 0; i &lt; tmp.size(); i++) &#123;</span><br><span class="line">            tmpInt.push_back(tmp[i]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        if (layer % 2 == 1 &amp;&amp; !tmpInt.empty()) &#123;</span><br><span class="line">            res.push_back(tmpInt);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (layer % 2 == 0 &amp;&amp; !tmpInt.empty()) &#123;</span><br><span class="line">            reverse(tmpInt.begin(), tmpInt.end());</span><br><span class="line">            res.push_back(tmpInt);</span><br><span class="line">        &#125;</span><br><span class="line">        d = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-60-把二叉树打印成多行（层序遍历）"><a href="#剑指offer-60-把二叉树打印成多行（层序遍历）" class="headerlink" title="剑指offer 60 把二叉树打印成多行（层序遍历）"></a>剑指offer 60 把二叉树打印成多行（层序遍历）</h1><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; vec;</span><br><span class="line">    if(pRoot == NULL) return vec;</span><br><span class="line"></span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(pRoot);</span><br><span class="line"></span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int lo = 0, hi = q.size();</span><br><span class="line">        vector&lt;int&gt; c;</span><br><span class="line">        while(lo++ &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *t = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            c.push_back(t-&gt;val);</span><br><span class="line">            if(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">            if(t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        vec.push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">    return vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-61-序列化二叉树"><a href="#剑指offer-61-序列化二叉树" class="headerlink" title="剑指offer 61 序列化二叉树"></a>剑指offer 61 序列化二叉树</h1><p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p><p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">typedef TreeNode node;</span><br><span class="line">typedef TreeNode* pnode;</span><br><span class="line">typedef int* pint;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    vector&lt;int&gt; buf;</span><br><span class="line">    void dfs(pnode p)&#123;</span><br><span class="line">        if(!p) buf.push_back(0x23333);</span><br><span class="line">        else&#123;</span><br><span class="line">            buf.push_back(p -&gt; val);</span><br><span class="line">            dfs(p -&gt; left);</span><br><span class="line">            dfs(p -&gt; right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pnode dfs2(pint&amp; p)&#123;</span><br><span class="line">        if(*p == 0x23333)&#123;</span><br><span class="line">            ++p;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        pnode res = new node(*p);</span><br><span class="line">        ++p;</span><br><span class="line">        res -&gt; left = dfs2(p);</span><br><span class="line">        res -&gt; right = dfs2(p);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    char* Serialize(TreeNode *p) &#123;</span><br><span class="line">        buf.clear();</span><br><span class="line">        dfs(p);</span><br><span class="line">        int *res = new int[buf.size()];</span><br><span class="line">        for(unsigned int i = 0; i &lt; buf.size(); ++i) res[i] = buf[i];</span><br><span class="line">        return (char*)res;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* Deserialize(char *str) &#123;</span><br><span class="line">        int *p = (int*)str;</span><br><span class="line">        return dfs2(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-62-二叉搜索树的第k个结点"><a href="#剑指offer-62-二叉搜索树的第k个结点" class="headerlink" title="剑指offer 62 二叉搜索树的第k个结点"></a>剑指offer 62 二叉搜索树的第k个结点</h1><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如,(5，3，7，2，4，6，8)中，按结点数值大小顺序第三小结点的值为4。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 递归</span><br><span class="line">int cnt = 0;</span><br><span class="line">TreeNode* KthNode(TreeNode* pRoot, int k)</span><br><span class="line">&#123;</span><br><span class="line">    if (pRoot) &#123;</span><br><span class="line">        TreeNode* node = KthNode(pRoot-&gt;left, k);</span><br><span class="line">        if (node) return node;</span><br><span class="line">        cnt++;</span><br><span class="line">        if (cnt == k) return pRoot;</span><br><span class="line">        node = KthNode(pRoot-&gt;right, k);</span><br><span class="line">        if (node) return node;</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br><span class="line">// 非递归 中序遍历</span><br><span class="line">TreeNode* KthNode(TreeNode* pRoot, int k)</span><br><span class="line">&#123;</span><br><span class="line">    if (pRoot == nullptr || k &lt; 1) return nullptr;</span><br><span class="line">    stack&lt;TreeNode*&gt; S;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    TreeNode* node = pRoot;</span><br><span class="line">    while (!S.empty() || node) &#123;</span><br><span class="line">        while (node) &#123;</span><br><span class="line">            S.push(node);</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        node = S.top();</span><br><span class="line">        S.pop();</span><br><span class="line">        cnt++;</span><br><span class="line">        if (cnt == k) return node;</span><br><span class="line">        node = node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-63-数据流中的中位数"><a href="#剑指offer-63-数据流中的中位数" class="headerlink" title="剑指offer 63 数据流中的中位数"></a>剑指offer 63 数据流中的中位数</h1><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 法1：大顶堆+小顶堆 </span><br><span class="line">// 法2：AVL 平衡二叉搜索树</span><br><span class="line">// 法3：排序</span><br><span class="line">vector&lt;int&gt; dataStream;</span><br><span class="line">void Insert(int num)</span><br><span class="line">&#123;</span><br><span class="line">    dataStream.push_back(num);</span><br><span class="line">    sort(dataStream.begin(), dataStream.end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double GetMedian()</span><br><span class="line">&#123; </span><br><span class="line">    int sz = dataStream.size();</span><br><span class="line">    double res;</span><br><span class="line">    if (sz % 2 == 0) &#123;</span><br><span class="line">        res = (double) (dataStream[sz/2] + dataStream[sz/2-1]) / 2;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        res = (double) dataStream[sz/2];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-64-滑动窗口的最大值"><a href="#剑指offer-64-滑动窗口的最大值" class="headerlink" title="剑指offer 64 滑动窗口的最大值"></a>剑指offer 64 滑动窗口的最大值</h1><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 暴力法 O(n * size)</span><br><span class="line">int FindMaxVal(vector&lt;int&gt; num, int st, int ed) &#123;</span><br><span class="line">    int MaxVal = num[st];</span><br><span class="line">    for (int i = st; i &lt;= ed; i++) &#123;</span><br><span class="line">        if (num[i] &gt; MaxVal) MaxVal = num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return MaxVal;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; maxInWindows1(const vector&lt;int&gt;&amp; num, unsigned int size)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    if (num.size() == 0 || size &lt; 1) return res;</span><br><span class="line">    for (int i = 0; i &lt;= num.size()-size; i++) &#123;</span><br><span class="line">        int tmp = FindMaxVal(num, i, i+size-1);</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">// 双端队列 O(n)</span><br><span class="line">vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    if (num.size() == 0 || size &lt; 1) return res;</span><br><span class="line">    deque&lt;int&gt; d;</span><br><span class="line">    for (int i = 0; i &lt; num.size(); ++i) &#123;</span><br><span class="line">        // 从后面依次弹出队列汇总比当前num值小的元素，同时保证队首元素为当前窗口最大值下标</span><br><span class="line">        while (d.size() &amp;&amp; num[d.back()] &lt;= num[i]) &#123;</span><br><span class="line">            d.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        // 当当前窗口移出队首元素所在的位置，即队首元素坐标对应的num不在窗口中，需要弹出</span><br><span class="line">        if (d.size() &amp;&amp; i-d.front()+1 &gt; size) &#123;</span><br><span class="line">            d.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        d.push_back(i);</span><br><span class="line">        // 当滑动窗口首地址i大于等于size时才开始写入窗口最大值</span><br><span class="line">        if (i &gt;= size - 1) &#123;</span><br><span class="line">            res.push_back(num[d.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-65-矩阵中的路径"><a href="#剑指offer-65-矩阵中的路径" class="headerlink" title="剑指offer 65 矩阵中的路径"></a>剑指offer 65 矩阵中的路径</h1><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">bool dfs(char* matrix, int i, int j, int rows, int cols, char* str, vector&lt;vector&lt;bool&gt; &gt; path) &#123;</span><br><span class="line">    if (*str == &apos;\0&apos;) return true;</span><br><span class="line">    if (matrix[i * cols + j] != str[0]) return false;</span><br><span class="line"></span><br><span class="line">    bool hasPath = false;</span><br><span class="line">    if (j &gt;= 0 &amp;&amp; i &gt;=0 &amp;&amp; i &lt; rows &amp;&amp; j &lt; cols &amp;&amp; !path[i][j]</span><br><span class="line">        &amp;&amp; matrix[i * cols + j] == str[0]) &#123;</span><br><span class="line">            path[i][j] = true;</span><br><span class="line">            hasPath = dfs(matrix, i-1, j, rows, cols, str+1, path)</span><br><span class="line">                    || dfs(matrix, i+1, j, rows, cols, str+1, path)</span><br><span class="line">                    || dfs(matrix, i, j-1, rows, cols, str+1, path)</span><br><span class="line">                    || dfs(matrix, i, j+1, rows, cols, str+1, path);</span><br><span class="line">            if (!hasPath) path[i][j] = false;</span><br><span class="line">        &#125;</span><br><span class="line">    return hasPath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool hasPath(char* matrix, int rows, int cols, char* str)</span><br><span class="line">&#123;</span><br><span class="line">    if (matrix == nullptr || str == nullptr) return false;</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; path(rows, vector&lt;bool&gt;(cols, false));</span><br><span class="line">    bool res = false;</span><br><span class="line">    for (int row = 0; row &lt; rows; row++) &#123;</span><br><span class="line">        for (int col = 0; col &lt; cols; col++) &#123;</span><br><span class="line">            if (matrix[row * cols + col] == str[0]) &#123;</span><br><span class="line">                res = dfs(matrix, row, col, rows, cols, str, path);</span><br><span class="line">            &#125;</span><br><span class="line">            if (res) return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-66-机器人的动作范围"><a href="#剑指offer-66-机器人的动作范围" class="headerlink" title="剑指offer 66 机器人的动作范围"></a>剑指offer 66 机器人的动作范围</h1><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int movingCount(int threshold, int rows, int cols)</span><br><span class="line">&#123;</span><br><span class="line">    bool* flag=new bool[rows*cols];</span><br><span class="line">    for(int i=0;i&lt;rows*cols;i++)</span><br><span class="line">        flag[i]=false;</span><br><span class="line">    int count=moving(threshold,rows,cols,0,0,flag);//从（0,0）坐标开始访问;</span><br><span class="line">    delete[] flag;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">//计算最大移动位置</span><br><span class="line">int moving(int threshold,int rows,int cols,int i,int j,bool* flag) &#123;</span><br><span class="line">    int count=0;</span><br><span class="line">    if(check(threshold,rows,cols,i,j,flag)) &#123;</span><br><span class="line">        flag[i*cols+j]=true;</span><br><span class="line">        //标记访问过，这个标志flag不需要回溯，因为只要被访问过即可。</span><br><span class="line">       //因为如果能访问，访问过会加1.不能访问，也会标记下访问过。</span><br><span class="line">        count=1+moving(threshold,rows,cols,i-1,j,flag) + moving(threshold,rows,cols,i,j-1,flag)</span><br><span class="line">               +moving(threshold,rows,cols,i+1,j,flag) + moving(threshold,rows,cols,i,j+1,flag);</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">//检查当前位置是否可以访问</span><br><span class="line">bool check(int threshold,int rows,int cols,int i,int j,bool* flag) &#123;</span><br><span class="line">    if(i&gt;=0 &amp;&amp; i&lt;rows &amp;&amp; j&gt;=0 &amp;&amp; j&lt;cols</span><br><span class="line">        &amp;&amp; getSum(i)+getSum(j)&lt;=threshold</span><br><span class="line">        &amp;&amp; flag[i*cols+j]==false)</span><br><span class="line">       return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">//计算位置的数值</span><br><span class="line">int getSum(int number) &#123;</span><br><span class="line">    int sum=0;</span><br><span class="line">    while(number&gt;0) &#123;</span><br><span class="line">        sum+=number%10;</span><br><span class="line">        number/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-67-剪绳子"><a href="#剑指offer-67-剪绳子" class="headerlink" title="剑指offer 67 剪绳子"></a>剑指offer 67 剪绳子</h1><p>给你一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* 首先判断k[0]到k[m]可能有哪些数字，实际上只可能是2或者3。</span><br><span class="line"> * 5&lt;2*3,6&lt;3*3,比6更大的数字我们就更不用考虑了，肯定要继续分。</span><br><span class="line"> * 其次看2和3的数量，2的数量肯定小于3个，为什么呢？因为2*2*2&lt;3*3，那么题目就简单了。</span><br><span class="line"> * 直接用n除以3，根据得到的余数判断是一个2还是两个2还是没有2就行了。</span><br><span class="line"> * 由于题目规定m&gt;1，所以2只能是1*1，3只能是2*1，这两个特殊情况直接返回就行了。 */</span><br><span class="line">long long n_max_3(long long n) &#123;</span><br><span class="line">    if (n == 2) return 1;</span><br><span class="line">    if (n == 3) return 2;</span><br><span class="line">    long long x = n % 3;</span><br><span class="line">    long long y = n / 3;</span><br><span class="line">    if (x == 0) &#123;</span><br><span class="line">        return pow(3, y);</span><br><span class="line">    &#125; else if (x == 1) &#123;</span><br><span class="line">        return 2 * 2 * (long long) pow(3, y - 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 2 * (long long) pow(3, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer各题目的C++解法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Data Structure" scheme="https://dlc1994.github.io/categories/Algorithm-and-Data-Structure/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
      <category term="C++" scheme="https://dlc1994.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://dlc1994.github.io/2020/01/08/ckqgs2ccr000rucveum7gbcxu/"/>
    <id>https://dlc1994.github.io/2020/01/08/ckqgs2ccr000rucveum7gbcxu/</id>
    <published>2020-01-08T04:50:07.000Z</published>
    <updated>2020-03-19T11:06:14.801Z</updated>
    
    <content type="html"><![CDATA[<p>Git &amp; Linux operations<br><a id="more"></a></p><h1 id="python程序后台运行"><a href="#python程序后台运行" class="headerlink" title="python程序后台运行"></a>python程序后台运行</h1><p>程序后台运行，打印结果到out.log文件<br>nohup python -u test.py &gt; out.log 2&gt;&amp;1 &amp;<br>说明：</p><ol><li>末尾的“&amp;”：表示后台运行程序</li><li>“nohup” ：保证程序不被挂起</li><li>“python”：是执行python代码的命令</li><li>“-u”：表示不启用缓存，实时输出打印信息到日志文件（如果不加-u，则会导致日志文件不会实时刷新代码中的print函数的信息）</li><li>“Job.py”：是python的源代码文件</li><li>“log.log”：是输出的日志文件</li><li>“&gt;”：是指将打印信息指定到日志文件</li><li>“2&gt;&amp;1”：将标准错误输出转变化标准输出，可以将错误信息也输出到日志文件中（0-&gt; stdin, 1-&gt;stdout, 2-&gt;stderr）</li></ol><p>查询下进程 ，可查看pid<br>ps -ef | grep xxx</p><p>终止脚本进程<br>kill -9 pid</p><p>to be continue…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git &amp;amp; Linux operations&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Development" scheme="https://dlc1994.github.io/categories/Development/"/>
    
    
      <category term="git" scheme="https://dlc1994.github.io/tags/git/"/>
    
      <category term="linux" scheme="https://dlc1994.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>链表的算法合集整理</title>
    <link href="https://dlc1994.github.io/2019/08/21/ckqgs2ccr000sucve7f1nvpm2/"/>
    <id>https://dlc1994.github.io/2019/08/21/ckqgs2ccr000sucve7f1nvpm2/</id>
    <published>2019-08-21T15:26:34.000Z</published>
    <updated>2020-03-19T11:07:19.825Z</updated>
    
    <content type="html"><![CDATA[<p>链表的算法合集大全(C/C++)<br><a id="more"></a></p><!-- TOC --><ul><li><a href="#1-链表结构体定义">1. 链表结构体定义</a></li><li><a href="#2-链表初始化可以快速创建样例">2. 链表初始化，可以快速创建样例</a></li><li><a href="#3-链表遍历打印检验算法正确性">3. 链表遍历打印，检验算法正确性</a></li><li><a href="#4-输出单链表倒数第-k-个节点">4. 输出单链表倒数第 K 个节点</a></li><li><a href="#5-判断链表是否有环">5. 判断链表是否有环</a></li><li><a href="#6-定位环的入口">6. 定位环的入口</a></li><li><a href="#7-计算环的长度">7. 计算环的长度</a></li><li><a href="#8-链表实现大数加法">8. 链表实现大数加法</a></li><li><a href="#9-有序链表合并">9. 有序链表合并</a></li><li><a href="#10-k个有序链表合并">10. K个有序链表合并</a></li><li><a href="#11-o1复杂度删除链表中结点">11. O(1)复杂度删除链表中结点</a></li><li><a href="#12-从尾到头打印链表">12. 从尾到头打印链表</a></li><li><a href="#13-反转链表">13. 反转链表</a></li><li><a href="#14-复杂链表的复制">14. 复杂链表的复制</a></li><li><a href="#15-逆序构造单链表">15. 逆序构造单链表</a></li><li><a href="#16-链表升序排序">16. 链表升序排序</a></li><li><a href="#17-找出单链表的中间结点">17. 找出单链表的中间结点</a></li></ul><!-- /TOC --><h1 id="1-链表结构体定义"><a href="#1-链表结构体定义" class="headerlink" title="1. 链表结构体定义"></a>1. 链表结构体定义</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">            val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-链表初始化，可以快速创建样例"><a href="#2-链表初始化，可以快速创建样例" class="headerlink" title="2. 链表初始化，可以快速创建样例"></a>2. 链表初始化，可以快速创建样例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 链表初始化，创造样例</span><br><span class="line">ListNode* linkedListInit(vector&lt;int&gt; v) &#123;</span><br><span class="line">    if (v.empty()) return NULL;</span><br><span class="line">    ListNode* root = new ListNode(v[0]);</span><br><span class="line">    ListNode* node = root;</span><br><span class="line">    int i = 1;</span><br><span class="line">    while (i&lt;v.size()) &#123;</span><br><span class="line">        node-&gt;next = new ListNode(v[i]);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-链表遍历打印，检验算法正确性"><a href="#3-链表遍历打印，检验算法正确性" class="headerlink" title="3. 链表遍历打印，检验算法正确性"></a>3. 链表遍历打印，检验算法正确性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 打印链表元素值，检验算法</span><br><span class="line">void PrintLinkedList(ListNode* root) &#123;</span><br><span class="line">    if (root == NULL) return;</span><br><span class="line">    while (root != NULL) &#123;</span><br><span class="line">        cout&lt;&lt;root-&gt;val&lt;&lt;&quot; &quot;;</span><br><span class="line">        root = root-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-输出单链表倒数第-K-个节点"><a href="#4-输出单链表倒数第-K-个节点" class="headerlink" title="4. 输出单链表倒数第 K 个节点"></a>4. 输出单链表倒数第 K 个节点</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 输出单链表倒数第 K 个节点</span><br><span class="line">// 法一：两次遍历</span><br><span class="line">ListNode* findKthTail1(ListNode *pHead, int k) &#123;</span><br><span class="line">    if (pHead == NULL || k &lt;= 0) return NULL;</span><br><span class="line">    int len = 0;</span><br><span class="line">    ListNode* root = pHead;</span><br><span class="line">    while (pHead != NULL) &#123;</span><br><span class="line">        pHead = pHead-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (len&lt;k) return NULL;</span><br><span class="line">    int countdown = len-k;</span><br><span class="line">    while (countdown--&gt;0) &#123;</span><br><span class="line">        root = root-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line">// 法二：递归**</span><br><span class="line">int cnt = 0;</span><br><span class="line">ListNode* findKthTail2(ListNode* pHead, int k) &#123;</span><br><span class="line">    if (pHead == NULL) return NULL;</span><br><span class="line">    ListNode* node = findKthTail2(pHead-&gt;next, k);</span><br><span class="line">    // 没找到就返回NULL，找到一直返回结点</span><br><span class="line">    if (node == NULL) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        if (cnt == k) return pHead;</span><br><span class="line">        else return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 法三：快慢指针***</span><br><span class="line">ListNode* findKthTail3(ListNode* pHead, int k) &#123;</span><br><span class="line">    if (pHead == NULL || k &lt;= 0) return NULL;</span><br><span class="line">    ListNode* slow = pHead;</span><br><span class="line">    ListNode* fast = pHead;</span><br><span class="line">    for(int i=0;i&lt;k;i++) &#123;  //快指针先走k步</span><br><span class="line">        if(fast) fast = fast-&gt;next;</span><br><span class="line">        else return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    while(fast) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-判断链表是否有环"><a href="#5-判断链表是否有环" class="headerlink" title="5. 判断链表是否有环"></a>5. 判断链表是否有环</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 判断链表是否有环</span><br><span class="line">// 法一：穷举比较 O(n^2)</span><br><span class="line">// 法二：哈希缓存 O(n)</span><br><span class="line">// 法三：快慢指针 O(n)~O(n^2)环很大时</span><br><span class="line">bool isExistRing3(ListNode* pHead) &#123;</span><br><span class="line">    if (pHead == NULL) return false;</span><br><span class="line">    ListNode* fast = pHead;</span><br><span class="line">    ListNode* slow = pHead;</span><br><span class="line">    while (fast-&gt;next &amp;&amp; slow) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        if (fast == slow) return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-定位环的入口"><a href="#6-定位环的入口" class="headerlink" title="6. 定位环的入口"></a>6. 定位环的入口</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 定位环的入口***hard***</span><br><span class="line">ListNode* getEntryNodeOfRing(ListNode* pHead) &#123;</span><br><span class="line">    ListNode* meetingnode = getMeetingNode(pHead);</span><br><span class="line">    if (meetingnode == NULL) return NULL; // 没环则相遇尾结点</span><br><span class="line">    ListNode* p1 = meetingnode;</span><br><span class="line">    ListNode* p2 = pHead;</span><br><span class="line">    // p1和p2以相同的速度向前移动，当p2指向环的入口节点时</span><br><span class="line">    // p1已经围绕着环走了n圈又回到了入口节点。</span><br><span class="line">    while(p1 != p2) &#123;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return p1;</span><br><span class="line">&#125;</span><br><span class="line">ListNode* getMeetingNode(ListNode* pHead) &#123;</span><br><span class="line">    if (pHead == NULL) return NULL;</span><br><span class="line">    ListNode* fast = pHead;</span><br><span class="line">    ListNode* slow = pHead;</span><br><span class="line">    while (fast-&gt;next &amp;&amp; slow) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        if (fast == slow) return slow;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-计算环的长度"><a href="#7-计算环的长度" class="headerlink" title="7. 计算环的长度"></a>7. 计算环的长度</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 计算环的长度</span><br><span class="line">// 找到slow与fast的相遇节点，令slow与fast指针从相遇节点出发，</span><br><span class="line">// 按照之前的前进规则，当slow与fast再次相遇时，slow走过的长度正好为环的长度。</span><br><span class="line">int getLengthOfRing(ListNode* pHead) &#123;</span><br><span class="line">    if (pHead == NULL) return 0;</span><br><span class="line">    ListNode* meetingnode = getMeetingNode(pHead);</span><br><span class="line">    if (meetingnode == NULL) return 0; // 防止无环</span><br><span class="line">    ListNode* fast = meetingnode-&gt;next-&gt;next;</span><br><span class="line">    ListNode* slow = meetingnode-&gt;next;</span><br><span class="line">    int length = 1;</span><br><span class="line">    while (fast != slow) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-链表实现大数加法"><a href="#8-链表实现大数加法" class="headerlink" title="8. 链表实现大数加法"></a>8. 链表实现大数加法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 链表实现大数加法</span><br><span class="line">ListNode* numberAddAsList(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">    ListNode *ret = l1, *pre = l2;</span><br><span class="line">    int up = 0; // 进位</span><br><span class="line">    while (l1 != NULL &amp;&amp; l2 != NULL) &#123;</span><br><span class="line">        l1-&gt;val = l1-&gt;val + l2-&gt;val +up;</span><br><span class="line">        up = l1-&gt;val / 10;</span><br><span class="line">        l1-&gt;val %= 10;</span><br><span class="line">        pre = l1; //记录当前结点位置</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    // 若l1到达末尾，说明l1长度小于l2</span><br><span class="line">    if (l1 == NULL) &#123;</span><br><span class="line">        pre-&gt;next = l2; // pre-&gt;next指向l2当前位置</span><br><span class="line">    &#125;</span><br><span class="line">    l1 = pre-&gt;next; // l1指针指向l2结点当前位置,即把l2拼到l1上继续计算</span><br><span class="line">    // 继续计算剩余结点，防止9999999+1这种情况</span><br><span class="line">    while (l1 != NULL) &#123;</span><br><span class="line">        l1-&gt;val = l1-&gt;val + up;</span><br><span class="line">        up = l1-&gt;val / 10;</span><br><span class="line">        l1-&gt;val %= 10;</span><br><span class="line">        pre = l1;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    // 最高位有进位，新建一个结点保留最高位</span><br><span class="line">    if (up != 0) &#123;</span><br><span class="line">        ListNode* tmp = new ListNode(up);</span><br><span class="line">        pre-&gt;next = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-有序链表合并"><a href="#9-有序链表合并" class="headerlink" title="9. 有序链表合并"></a>9. 有序链表合并</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 有序链表合并</span><br><span class="line">// 递归</span><br><span class="line">ListNode* mergeTwoOrderedListsRec(ListNode* pHead1, ListNode* pHead2)&#123;</span><br><span class="line">    if(pHead1 == NULL) return pHead2;</span><br><span class="line">    if(pHead2 == NULL) return pHead1;</span><br><span class="line">    if(pHead1-&gt;val &gt; pHead2-&gt;val) &#123;</span><br><span class="line">        pHead2-&gt;next = mergeTwoOrderedListsRec(pHead1, pHead2-&gt;next);</span><br><span class="line">        return pHead2;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        pHead1-&gt;next = mergeTwoOrderedListsRec(pHead1-&gt;next, pHead2);</span><br><span class="line">        return pHead1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 非递归</span><br><span class="line">ListNode* mergeTwoOrderedListsNotRec(ListNode* pHead1, ListNode* pHead2) &#123;</span><br><span class="line">    if (pHead1 == NULL) return pHead2;</span><br><span class="line">    else if (pHead2 == NULL) return pHead1;</span><br><span class="line">    else &#123;</span><br><span class="line">        ListNode* pTail = NULL; // 新链表最后一个结点</span><br><span class="line">        ListNode* newHead = NULL; // 合并后链表第一个结点</span><br><span class="line">        if (pHead1-&gt;val &lt; pHead2-&gt;val) &#123;</span><br><span class="line">            newHead = pHead1;</span><br><span class="line">            pHead1 = pHead1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            newHead = pHead2;</span><br><span class="line">            pHead2 = pHead2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pTail = newHead; // 指向第一个结点</span><br><span class="line">        while (pHead1 &amp;&amp; pHead2) &#123;</span><br><span class="line">            if (pHead1-&gt;val &lt;= pHead2-&gt;val) &#123;</span><br><span class="line">                pTail-&gt;next = pHead1;</span><br><span class="line">                pHead1 = pHead1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                pTail-&gt;next = pHead2;</span><br><span class="line">                pHead2 = pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pTail = pTail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (pHead1 == NULL) pTail-&gt;next = pHead2;</span><br><span class="line">        else if (pHead2 == NULL) pTail-&gt;next = pHead1;</span><br><span class="line">        return newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-K个有序链表合并"><a href="#10-K个有序链表合并" class="headerlink" title="10. K个有序链表合并"></a>10. K个有序链表合并</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// K个有序链表合并</span><br><span class="line">// 归并排序，复杂度O(nlogk)</span><br><span class="line">ListNode* mergeKsortedLists(vector&lt;ListNode*&gt; lists) &#123;</span><br><span class="line">    int amount = lists.size();</span><br><span class="line">    int gap = 1;</span><br><span class="line">    while (gap &lt; amount) &#123;</span><br><span class="line">        for (int i=0; i&lt; amount-gap; i+=gap*2) &#123;</span><br><span class="line">            lists[i] = mergeTwoOrderedListsRec(lists[i], lists[i+gap]);</span><br><span class="line">        &#125;</span><br><span class="line">        gap *= 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return amount&gt;0?lists[0]:NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-O-1-复杂度删除链表中结点"><a href="#11-O-1-复杂度删除链表中结点" class="headerlink" title="11. O(1)复杂度删除链表中结点"></a>11. O(1)复杂度删除链表中结点</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void deleteNode(ListNode **pHead, ListNode* pDelNode) &#123;</span><br><span class="line">    if (pDelNode == NULL) return;</span><br><span class="line">    if (pDelNode-&gt;next != NULL) &#123;</span><br><span class="line">        ListNode* pNext = pDelNode-&gt;next;</span><br><span class="line">        // 下一个节点的值赋给删除节点</span><br><span class="line">        pDelNode-&gt;val = pNext-&gt;val;</span><br><span class="line">        pDelNode-&gt;next = pNext-&gt;next;</span><br><span class="line">        delete pNext; // delete是删除指针指向的内容</span><br><span class="line">        pNext = NULL; // 不指向NULL会成为野指针</span><br><span class="line">    &#125;</span><br><span class="line">    else if (*pHead == pDelNode) &#123; //头结点</span><br><span class="line">        delete pDelNode;</span><br><span class="line">        pDelNode = NULL;</span><br><span class="line">        *pHead = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123; //删除尾结点</span><br><span class="line">        ListNode *pNode = *pHead;</span><br><span class="line">        while (pNode-&gt;next != pDelNode) &#123;</span><br><span class="line">            pNode = pNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pNode-&gt;next = NULL;</span><br><span class="line">        delete pDelNode;</span><br><span class="line">        pDelNode = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-从尾到头打印链表"><a href="#12-从尾到头打印链表" class="headerlink" title="12. 从尾到头打印链表"></a>12. 从尾到头打印链表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 递归</span><br><span class="line">vector&lt;int&gt; printListFromTailToHead1(ListNode* head) &#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    if(head!=NULL)&#123;</span><br><span class="line">        if(head-&gt;next!=NULL)&#123;</span><br><span class="line">            res = printListFromTailToHead1(head-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(head-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">//栈</span><br><span class="line">vector&lt;int&gt; printListFromTailToHead2(ListNode* head) &#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    stack&lt;int&gt; sta;</span><br><span class="line">    while(head!=NULL)&#123;</span><br><span class="line">        sta.push(head-&gt;val);</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!sta.empty())&#123;</span><br><span class="line">        res.push_back(sta.top());</span><br><span class="line">        sta.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">// **链表原地反转**</span><br><span class="line">vector&lt;int&gt; printListFromTailToHead3(struct ListNode* head) &#123;</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    ListNode *buf=head;</span><br><span class="line">    ListNode *pre=buf;</span><br><span class="line">    if(head==NULL)</span><br><span class="line">        return vec;</span><br><span class="line">    while(head-&gt;next!=NULL)&#123;  /*这里还没看懂*/</span><br><span class="line">        buf=head-&gt;next;</span><br><span class="line">        head-&gt;next=buf-&gt;next;</span><br><span class="line">        buf-&gt;next=pre;</span><br><span class="line">        pre=buf;</span><br><span class="line">    &#125;</span><br><span class="line">    while(buf)&#123;</span><br><span class="line">        vec.push_back(buf-&gt;val);</span><br><span class="line">        buf=buf-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="13-反转链表"><a href="#13-反转链表" class="headerlink" title="13. 反转链表"></a>13. 反转链表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 迭代（链表的原地反转）</span><br><span class="line">ListNode* reverseList1(ListNode* head) &#123;</span><br><span class="line">    ListNode* pre = NULL;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    while (cur != NULL) &#123;</span><br><span class="line">        ListNode* next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br><span class="line">// 递归</span><br><span class="line">ListNode* reverseList2(ListNode* head) &#123;</span><br><span class="line">    if (head == NULL || head-&gt;next == NULL) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* rhead = reverseList2(head-&gt;next);</span><br><span class="line">    // head-&gt;next此刻指向head后面的链表的尾节点</span><br><span class="line">    // head-&gt;next-&gt;next = head把head节点放在了尾部</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = NULL;</span><br><span class="line">    return rhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="14-复杂链表的复制"><a href="#14-复杂链表的复制" class="headerlink" title="14. 复杂链表的复制"></a>14. 复杂链表的复制</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// （每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针</span><br><span class="line">// 指向任意一个节点），返回结果为复制后复杂链表的head。</span><br><span class="line">RandomListNode* Clone(RandomListNode* pHead)&#123;</span><br><span class="line">    if(pHead==NULL) return NULL;</span><br><span class="line">    RandomListNode* currentNode=pHead;</span><br><span class="line">    //复制每个结点，将其插入结点后面</span><br><span class="line">    while(currentNode!=NULL)&#123;</span><br><span class="line">        RandomListNode* cloneNode = new RandomListNode(currentNode-&gt;label);</span><br><span class="line">        RandomListNode* nextNode = currentNode-&gt;next;</span><br><span class="line">        currentNode-&gt;next=cloneNode;</span><br><span class="line">        cloneNode-&gt;next=nextNode;</span><br><span class="line">        currentNode=nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode=pHead;</span><br><span class="line">    //复制老结点的随机指针给新结点</span><br><span class="line">    while(currentNode!=NULL)&#123;</span><br><span class="line">        currentNode-&gt;next-&gt;random = currentNode-&gt;random==NULL?NULL:currentNode-&gt;random-&gt;next;</span><br><span class="line">        currentNode=currentNode-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    //拆分链表</span><br><span class="line">    currentNode=pHead;</span><br><span class="line">    RandomListNode* pCloneHead=pHead-&gt;next;</span><br><span class="line">    while(currentNode!=NULL)&#123;</span><br><span class="line">        RandomListNode* cloneNode=currentNode-&gt;next;</span><br><span class="line">        currentNode-&gt;next=cloneNode-&gt;next;</span><br><span class="line">        cloneNode-&gt;next=cloneNode-&gt;next==NULL?NULL:cloneNode-&gt;next-&gt;next;</span><br><span class="line">        currentNode=currentNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pCloneHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="15-逆序构造单链表"><a href="#15-逆序构造单链表" class="headerlink" title="15. 逆序构造单链表"></a>15. 逆序构造单链表</h1><p>输入数据：[1,2,3,4,5],构造单链表:5-&gt;4-&gt;3-&gt;2-&gt;1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 逆序构造单链表</span><br><span class="line">ListNode* desc_construct(vector&lt;int&gt; input) &#123;</span><br><span class="line">    if (input.empty()) return NULL;</span><br><span class="line">    ListNode* pre = NULL;</span><br><span class="line">    for (int i=0;i&lt;input.size();i++) &#123;</span><br><span class="line">        ListNode* cur = new ListNode(input[i]);</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="16-链表升序排序"><a href="#16-链表升序排序" class="headerlink" title="16. 链表升序排序"></a>16. 链表升序排序</h1><p>快排是需要一个指针指向头，一个指针指向尾，然后两个指针相向运动并按一定规律交换值，最后使得支点左边小于支点，支点右边大于支点，但是对于单链表而言，指向结尾的指针很好办，但是这个指针如何往前，我们只有一个 next（这并不是一个双向链表）。</p><p>我们只需要两个指针 i 和 j，这两个指针均往 next 方向移动，移动的过程中始终保持区间 [1, i] 的 data 都小于 base（位置 0 是主元），区间 [i+1, j) 的 data 都大于等于 base，那么当 j 走到末尾的时候便完成了一次支点的寻找。若以 swap 操作即 if 判断语句成立作为基本操作，其操作数和快速排序相同，故该方法的平均时间复杂度亦为$T(n) = O(nlogn)$。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 链表升序排序</span><br><span class="line">/**</span><br><span class="line">    * @param begin 链表的第一个结点，即header-&gt;next</span><br><span class="line">    * @param end   链表的最后一个结点的next</span><br><span class="line">    */</span><br><span class="line">void asc_sort(ListNode* begin, ListNode* end) &#123;</span><br><span class="line">    // 链表为空或只有一个结点</span><br><span class="line">    if (begin == end || begin-&gt;next == end) return;</span><br><span class="line">    int base = begin-&gt;val;</span><br><span class="line">    ListNode* i = begin;</span><br><span class="line">    ListNode* j = begin-&gt;next;</span><br><span class="line">    while (j != end) &#123;</span><br><span class="line">        if (j-&gt;val &lt; base) &#123;</span><br><span class="line">            i = i-&gt;next;</span><br><span class="line">            swap(i-&gt;val, j-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        j = j-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    swap (i-&gt;val, begin-&gt;val);</span><br><span class="line">    asc_sort(begin, i);</span><br><span class="line">    asc_sort(i-&gt;next, end);</span><br><span class="line">&#125;</span><br><span class="line">// usage: asc_sort(header-&gt;next, nullptr);</span><br></pre></td></tr></table></figure><h1 id="17-找出单链表的中间结点"><a href="#17-找出单链表的中间结点" class="headerlink" title="17. 找出单链表的中间结点"></a>17. 找出单链表的中间结点</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 找出单链表的中间结点（类似倒数第k个结点）</span><br><span class="line">// 法一：遍历一次，再遍历到n/2,复杂度为O(n+n/2)</span><br><span class="line">// 法二：快慢指针</span><br><span class="line">ListNode* find_middle(ListNode* head) &#123;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链表的算法合集大全(C/C++)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Data Structure" scheme="https://dlc1994.github.io/categories/Algorithm-and-Data-Structure/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
      <category term="C/C++" scheme="https://dlc1994.github.io/tags/C-C/"/>
    
      <category term="LinkedList" scheme="https://dlc1994.github.io/tags/LinkedList/"/>
    
  </entry>
  
</feed>
