<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LC-Garden</title>
  
  <subtitle>Lingcheng&#39;s personal blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dlc1994.github.io/"/>
  <updated>2019-05-24T15:20:45.122Z</updated>
  <id>https://dlc1994.github.io/</id>
  
  <author>
    <name>Lingcheng Dai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019中兴捧月算法大赛——无线信道估计</title>
    <link href="https://dlc1994.github.io/zte2019.html"/>
    <id>https://dlc1994.github.io/zte2019.html</id>
    <published>2019-05-24T15:02:50.000Z</published>
    <updated>2019-05-24T15:20:45.122Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/dlc1994/2019ZTE-Algorithm-Competition" target="_blank" rel="noopener">Github项目：https://github.com/dlc1994/2019ZTE-Algorithm-Competition</a></p><p>本来想参加深度学习题目的，但看到用caffe，还要现学就作罢了<br><a id="more"></a></p><p>傅里叶门派有三个题目，一开始想做了智能调度，但是看了半天题目也没理解，随便提交了一个上去（最后发现一共才50多份提交，悔不当初）</p><p>看到这个有点像曲线拟合，题目就是用最少的导频数，估计带噪声的其余一共250个频点的信道值</p><p>看上去有点像曲线拟合，所以我就往曲线拟合方向做了</p><p>1 导频数用62，此时导频和误差百分比大致在50%</p><p>2 导频分开实部和虚部分开进行拟合，拟合函数使用SmoothingSpline</p><p>3 拟合出来函数是带噪声的，接下来去噪</p><p>4 用小波变换，小波基为coif5,分解层数为10层 </p><p>5 输出最终结果，感觉有点过拟合了</p><p>最后一天做了半天，只能提高到36名了，看到进决赛拿蓝剑的那些大神还是很羡慕的，应该多花些时间的，从原理上改进而不是简单的去噪拟合</p><p>大佬的思路：</p><p>1 多种组合构成个闭环优化，中兴专家做的，好像用20个导频左右拿了第一</p><p>2 用CNN，这个可能是从autoencoder方向想，但是数据集够用？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/dlc1994/2019ZTE-Algorithm-Competition&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github项目：https://github.com/dlc1994/2019ZTE-Algorithm-Competition&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本来想参加深度学习题目的，但看到用caffe，还要现学就作罢了&lt;br&gt;
    
    </summary>
    
      <category term="Competition" scheme="https://dlc1994.github.io/categories/Competition/"/>
    
    
      <category term="Matlab" scheme="https://dlc1994.github.io/tags/Matlab/"/>
    
      <category term="Wireless communications" scheme="https://dlc1994.github.io/tags/Wireless-communications/"/>
    
  </entry>
  
  <entry>
    <title>常用数据结构——栈</title>
    <link href="https://dlc1994.github.io/stack.html"/>
    <id>https://dlc1994.github.io/stack.html</id>
    <published>2019-04-29T13:27:23.000Z</published>
    <updated>2019-05-24T15:34:54.557Z</updated>
    
    <content type="html"><![CDATA[<p>本科学过c++的数据结构了，但研究生转无线通信后就忘的差不多了，现在重新复习下栈。<br><a id="more"></a><br>  栈（stack）、队列（queues）、双端队列（deques）和列表都是有序数据容器，元素添加后在容器内的位置跟其他元素添加和删除的顺序有关，像这样的容器被称作线性数据结构（linear data structure）。<br>  栈可以想象为只有一端开口的瓶子，假设每放一个东西进去都会把前面放的完全盖住，那么这时你想取出最里面的东西显然是不可能的，所以你只能把上面的一个个拿出来才能取到你想要的，这就叫做后进先出（LIFO, last-in first-out）。</p><h1 id="1-栈的主要方法及实现"><a href="#1-栈的主要方法及实现" class="headerlink" title="1. 栈的主要方法及实现"></a>1. 栈的主要方法及实现</h1><p>  栈的方法主要有下面几种：</p><ul><li><code>Stack()</code> creates a new stack that is empty. It needs no parameters and returns an empty stack.</li><li><code>push(item)</code> adds a new item to the top of the stack. It needs the item and returns nothing.</li><li><code>pop()</code> removes the top item from the stack. It needs no parameters and returns the item. The stack is modified.</li><li><code>peek()</code> returns the top item from the stack but does not remove it. It needs no parameters. The stack is not modified.</li><li><code>isEmpty()</code> tests to see whether the stack is empty. It needs no parameters and returns a boolean value.</li><li><code>size()</code> returns the number of items on the stack. It needs no parameters and returns an integer.<br>在python中是没有栈的实现的，所以栈需要自己实现，简单点可以用个list充当下，更一般的要实现上面各种方法还是面向对象创造一个类比较好，实现代码如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Stack:</span><br><span class="line">     def __init__(self):</span><br><span class="line">         self.items = []</span><br><span class="line"></span><br><span class="line">     def isEmpty(self):</span><br><span class="line">         return self.items == []</span><br><span class="line"></span><br><span class="line">     def push(self, item):</span><br><span class="line">         self.items.append(item)</span><br><span class="line"></span><br><span class="line">     def pop(self):</span><br><span class="line">         return self.items.pop()</span><br><span class="line"></span><br><span class="line">     def peek(self):</span><br><span class="line">         return self.items[len(self.items)-1]</span><br><span class="line"></span><br><span class="line">     def size(self):</span><br><span class="line">         return len(self.items)</span><br></pre></td></tr></table></figure></li></ul><h1 id="2-栈的主要应用"><a href="#2-栈的主要应用" class="headerlink" title="2. 栈的主要应用"></a>2. 栈的主要应用</h1><h2 id="2-1-字符串反转"><a href="#2-1-字符串反转" class="headerlink" title="2.1 字符串反转"></a>2.1 字符串反转</h2><p>  那么，费尽心机创造一个栈有啥用呢？首先可以用来翻转字符串，当然python有超级多方式可以反转字符串，最简单的自然是string[::-1]。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def stringReverse(self, stringstring):</span><br><span class="line">s = Stack()</span><br><span class="line">output = &quot;&quot;</span><br><span class="line">for ss in stringstring:</span><br><span class="line">s.push(ss)</span><br><span class="line">while not s.isEmpty():</span><br><span class="line">output = output + s.pop()</span><br><span class="line">return output</span><br></pre></td></tr></table></figure></p><h2 id="2-2-简单括号匹配"><a href="#2-2-简单括号匹配" class="headerlink" title="2.2 简单括号匹配"></a>2.2 简单括号匹配</h2><p>  除此之外，还有简单的括号匹配问题，也可以利用栈的特性来解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def parChecker(symbolString):</span><br><span class="line">    s = Stack()</span><br><span class="line">    balanced = True</span><br><span class="line">    index = 0</span><br><span class="line">    while index &lt; len(symbolString) and balanced:</span><br><span class="line">        symbol = symbolString[index]</span><br><span class="line">        if symbol == &quot;(&quot;:</span><br><span class="line">            s.push(symbol)</span><br><span class="line">        else:</span><br><span class="line">            if s.isEmpty():</span><br><span class="line">                balanced = False</span><br><span class="line">            else:</span><br><span class="line">                s.pop()</span><br><span class="line"></span><br><span class="line">        index = index + 1</span><br><span class="line"></span><br><span class="line">    if balanced and s.isEmpty():</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure></p><p>  其实吧，也可以不用栈解决呀（不是我杠，笔试时间也是很重要的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def parChecker(symbolString):</span><br><span class="line">    left = 0</span><br><span class="line">    right = 0</span><br><span class="line">    for s in symbolString:</span><br><span class="line">        if s == &apos;(&apos;:</span><br><span class="line">            left+=1</span><br><span class="line">        else:</span><br><span class="line">            right+=1</span><br><span class="line">    return left==right</span><br></pre></td></tr></table></figure></p><h2 id="2-3-多重括号匹配"><a href="#2-3-多重括号匹配" class="headerlink" title="2.3 多重括号匹配"></a>2.3 多重括号匹配</h2><p>  拓展到更复杂一点的括号匹配问题——多重括号匹配：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def parChecker(symbolString):</span><br><span class="line">    s = Stack()</span><br><span class="line">    balanced = True</span><br><span class="line">    index = 0</span><br><span class="line">    while index &lt; len(symbolString) and balanced:</span><br><span class="line">        symbol = symbolString[index]</span><br><span class="line">        if symbol in &quot;([&#123;&quot;:</span><br><span class="line">            s.push(symbol)</span><br><span class="line">        else:</span><br><span class="line">            if s.isEmpty():</span><br><span class="line">                balanced = False</span><br><span class="line">            else:</span><br><span class="line">                top = s.pop()</span><br><span class="line">                if not matches(top,symbol):</span><br><span class="line">                       balanced = False</span><br><span class="line">        index = index + 1</span><br><span class="line">    if balanced and s.isEmpty():</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">def matches(open,close):</span><br><span class="line">    opens = &quot;([&#123;&quot;</span><br><span class="line">    closers = &quot;)]&#125;&quot;</span><br><span class="line">    return opens.index(open) == closers.index(close)</span><br></pre></td></tr></table></figure></p><p>  当然，我又“杠”了，主要不想想这么复杂的结构2333：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def parChecker(symbolString):</span><br><span class="line">    l1,l2,l3,r1,r2,r3=0,0,0,0,0,0</span><br><span class="line">    for s in symbolString:</span><br><span class="line">        if s==&apos;&#123;&apos;:</span><br><span class="line">            l1+=1</span><br><span class="line">        elif s==&apos;&#125;&apos;:</span><br><span class="line">            r1+=1</span><br><span class="line">        elif s==&apos;(&apos;:</span><br><span class="line">            l2+=1</span><br><span class="line">        elif s==&apos;)&apos;:</span><br><span class="line">            r2+=1</span><br><span class="line">        elif s==&apos;[&apos;:</span><br><span class="line">            l3+=1</span><br><span class="line">        else:</span><br><span class="line">            r3+=1</span><br><span class="line">    return [l1,l2,l3]==[r1,r2,r3]</span><br></pre></td></tr></table></figure></p><h2 id="2-4-将十进制数转换为各种进制"><a href="#2-4-将十进制数转换为各种进制" class="headerlink" title="2.4 将十进制数转换为各种进制"></a>2.4 将十进制数转换为各种进制</h2><p>  想将10进制数（Decimal）转换为2进制（Binary）、8进制（Octal）或者16进制（Hexidecimal），就将这个数不断除进制数，然后将余数逆序输出，不想贴图了自己百度查下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def baseConverter(decNumber,base):</span><br><span class="line">    digits = &quot;0123456789ABCDEF&quot;</span><br><span class="line">    remstack = Stack()</span><br><span class="line"></span><br><span class="line">    while decNumber &gt; 0:</span><br><span class="line">        rem = decNumber % base</span><br><span class="line">        remstack.push(rem)</span><br><span class="line">        decNumber = decNumber // base</span><br><span class="line"></span><br><span class="line">    newString = &quot;&quot;</span><br><span class="line">    while not remstack.isEmpty():</span><br><span class="line">        newString = newString + digits[remstack.pop()]</span><br><span class="line"></span><br><span class="line">    return newString</span><br></pre></td></tr></table></figure></p><h2 id="2-5-中缀表达式、前后缀表达式"><a href="#2-5-中缀表达式、前后缀表达式" class="headerlink" title="2.5 中缀表达式、前后缀表达式"></a>2.5 <strong>中缀表达式、前后缀表达式</strong></h2><p>  接下来就是栈的重点操作了（就是比较复杂一点）。<br>  什么是中缀表达式呢？就是一般的表达式，比如A+B, C*D等。<br>  顾名思义，前缀表达式就是操作符在前面，后缀就是在后面，给几个例子体会一下：<br> <strong>Infix Expression</strong>        <strong>Prefix Expression</strong>    <strong>Postfix Expression</strong><br>  A + B <em> C + D        + + A </em> B C D            A B C <em> + D +<br>  (A + B) </em> (C + D)        <em> + A B + C D            A B + C D + </em><br>  A <em> B + C </em> D        + <em> A B </em> C D            A B <em> C D </em> +<br>  A + B + C + D        + + + A B C D            A B + C + D +</p><p>  将中缀表达式转换为后缀表达式，利用栈可以写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">def infixToPostfix(infixexpr):</span><br><span class="line">    prec = &#123;&#125;</span><br><span class="line">    prec[&quot;*&quot;] = 3</span><br><span class="line">    prec[&quot;/&quot;] = 3</span><br><span class="line">    prec[&quot;+&quot;] = 2</span><br><span class="line">    prec[&quot;-&quot;] = 2</span><br><span class="line">    prec[&quot;(&quot;] = 1</span><br><span class="line">    opStack = Stack()</span><br><span class="line">    postfixList = []</span><br><span class="line">    tokenList = infixexpr.split()</span><br><span class="line"></span><br><span class="line">    for token in tokenList:</span><br><span class="line">        if token in &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; or token in &quot;0123456789&quot;:</span><br><span class="line">            postfixList.append(token)</span><br><span class="line">        elif token == &apos;(&apos;:</span><br><span class="line">            opStack.push(token)</span><br><span class="line">        elif token == &apos;)&apos;:</span><br><span class="line">            topToken = opStack.pop()</span><br><span class="line">            while topToken != &apos;(&apos;:</span><br><span class="line">                postfixList.append(topToken)</span><br><span class="line">                topToken = opStack.pop()</span><br><span class="line">        else:</span><br><span class="line">            while (not opStack.isEmpty()) and \</span><br><span class="line">               (prec[opStack.peek()] &gt;= prec[token]):</span><br><span class="line">                  postfixList.append(opStack.pop())</span><br><span class="line">            opStack.push(token)</span><br><span class="line"></span><br><span class="line">    while not opStack.isEmpty():</span><br><span class="line">        postfixList.append(opStack.pop())</span><br><span class="line">    return &quot; &quot;.join(postfixList)</span><br></pre></td></tr></table></figure></p><p>  假如直接给你一个后缀表达式让你计算呢，这就是需要再写一个算法了，不过比较简单，贴上来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def postfixEval(postfixExpr):</span><br><span class="line">    operandStack = Stack()</span><br><span class="line">    tokenList = postfixExpr.split()</span><br><span class="line"></span><br><span class="line">    for token in tokenList:</span><br><span class="line">        if token in &quot;0123456789&quot;:</span><br><span class="line">            operandStack.push(int(token))</span><br><span class="line">        else:</span><br><span class="line">            operand2 = operandStack.pop()</span><br><span class="line">            operand1 = operandStack.pop()</span><br><span class="line">            result = doMath(token,operand1,operand2)</span><br><span class="line">            operandStack.push(result)</span><br><span class="line">    return operandStack.pop()</span><br><span class="line"></span><br><span class="line">def doMath(op, op1, op2):</span><br><span class="line">    if op == &quot;*&quot;:</span><br><span class="line">        return op1 * op2</span><br><span class="line">    elif op == &quot;/&quot;:</span><br><span class="line">        return op1 / op2</span><br><span class="line">    elif op == &quot;+&quot;:</span><br><span class="line">        return op1 + op2</span><br><span class="line">    else:</span><br><span class="line">        return op1 - op2</span><br></pre></td></tr></table></figure></p><p>  栈就目前学完了，后续有的话还会补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本科学过c++的数据结构了，但研究生转无线通信后就忘的差不多了，现在重新复习下栈。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://dlc1994.github.io/categories/Data-Structure/"/>
    
    
      <category term="Stack" scheme="https://dlc1994.github.io/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>常用排序算法（python）</title>
    <link href="https://dlc1994.github.io/sort.html"/>
    <id>https://dlc1994.github.io/sort.html</id>
    <published>2019-04-19T13:27:23.000Z</published>
    <updated>2019-04-29T13:36:31.957Z</updated>
    
    <content type="html"><![CDATA[<p>常用排序算法（python）<br><a id="more"></a></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def bubbleSort(alist):</span><br><span class="line">    for i in range(len(alist)):</span><br><span class="line">        for j in range(len(alist)-i-1):</span><br><span class="line">            if alist[j]&gt;alist[j+1]:</span><br><span class="line">                tmp = alist[j]</span><br><span class="line">                alist[j] = alist[j+1]</span><br><span class="line">                alist[j+1] = tmp</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def selectSort(alist):</span><br><span class="line">    for i in range(len(alist)):</span><br><span class="line">        minPos = i</span><br><span class="line">        for j in range(i+1, len(alist)):</span><br><span class="line">            if alist[i]&gt;alist[j]:</span><br><span class="line">                minPos = j</span><br><span class="line">        tmp = alist[i]</span><br><span class="line">        alist[i] = alist[minPos]</span><br><span class="line">        alist[minPos] = tmp</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def insertSort(alist):</span><br><span class="line">    for i in range(1, len(alist)):</span><br><span class="line">        current = alist[i]</span><br><span class="line">        pos = i</span><br><span class="line">        while pos&gt;0 and current&lt;alist[pos-1]:</span><br><span class="line">            alist[pos] = alist[pos-1]</span><br><span class="line">            pos-=1</span><br><span class="line">        alist[pos] = current</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def shellSort(alist):</span><br><span class="line">    gap = len(alist)//2</span><br><span class="line">    while gap&gt;0:</span><br><span class="line">        for i in range(gap, len(alist)):</span><br><span class="line">            j = i</span><br><span class="line">            current = alist[i]</span><br><span class="line">            while j-gap&gt;0 and current&lt;alist[j-gap]:</span><br><span class="line">                alist[j] = alist[j-gap]</span><br><span class="line">                j = j - gap</span><br><span class="line">            alist[j] = current</span><br><span class="line">        gap = gap // 2</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def mergeSort(alist):</span><br><span class="line">    if len(alist)&gt;1:</span><br><span class="line">        mid = len(alist) // 2</span><br><span class="line">        left = alist[:mid]</span><br><span class="line">        right = alist[mid:]</span><br><span class="line">        </span><br><span class="line">        mergeSort(left)</span><br><span class="line">        mergeSort(right)</span><br><span class="line">        </span><br><span class="line">        i,j,k = 0,0,0</span><br><span class="line">        while i&lt;len(left) and j&lt;len(right):</span><br><span class="line">            if left[i]&lt;right[j]:</span><br><span class="line">                alist[k] = left[i]</span><br><span class="line">                i+=1</span><br><span class="line">            else:</span><br><span class="line">                alist[k] = right[j]</span><br><span class="line">                j+=1</span><br><span class="line">            k+=1</span><br><span class="line">        while i&lt;len(left):</span><br><span class="line">            alist[k] = left[i]</span><br><span class="line">            k+=1</span><br><span class="line">            i+=1</span><br><span class="line">        while j&lt;len(right):</span><br><span class="line">            alist[k] = right[j]</span><br><span class="line">            k+=1</span><br><span class="line">            j+=1</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def quickSort(alist):</span><br><span class="line">    quickSortHelper(alist, 0, len(alist)-1)</span><br><span class="line"></span><br><span class="line">def quickSortHelper(alist, first, last):</span><br><span class="line">    if first&lt;last:</span><br><span class="line">        splitpoint = partition(alist, first, last)</span><br><span class="line">        quickSortHelper(alist, first, splitpoint-1)</span><br><span class="line">        quickSortHelper(alist, splitpoint + 1, last)</span><br><span class="line"></span><br><span class="line">def partition(alist, first, last):</span><br><span class="line">    pivot = alist[first]</span><br><span class="line">    leftmark = first + 1</span><br><span class="line">    rightmark = last</span><br><span class="line">    done = False</span><br><span class="line">    while not done:</span><br><span class="line">        while leftmark &lt;= rightmark and alist[leftmark] &lt;= pivot:</span><br><span class="line">            leftmark += 1</span><br><span class="line">        while rightmark &gt;= leftmark and alist[rightmark] &gt;= pivot:</span><br><span class="line">            rightmark -= 1</span><br><span class="line">        if rightmark &lt; leftmark:</span><br><span class="line">            done = True</span><br><span class="line">        else:</span><br><span class="line">            tmp = alist[leftmark]</span><br><span class="line">            alist[leftmark] = alist[rightmark]</span><br><span class="line">            alist[rightmark] = tmp</span><br><span class="line">    tmp = alist[first]</span><br><span class="line">    alist[first] = alist[rightmark]</span><br><span class="line">    alist[rightmark] = tmp</span><br><span class="line">    return rightmark</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常用排序算法（python）&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/categories/Algorithm/"/>
    
    
      <category term="Sorting" scheme="https://dlc1994.github.io/tags/Sorting/"/>
    
  </entry>
  
  <entry>
    <title>暑期实习招聘笔试题3月(更新ing)</title>
    <link href="https://dlc1994.github.io/toutiao.html"/>
    <id>https://dlc1994.github.io/toutiao.html</id>
    <published>2019-03-16T13:27:23.000Z</published>
    <updated>2019-05-24T15:35:06.289Z</updated>
    
    <content type="html"><![CDATA[<p>实习笔试试题，有些没投（准备好先），拿过来先看了看<br><a id="more"></a></p><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><h1 id="2-头条笔试题"><a href="#2-头条笔试题" class="headerlink" title="2 头条笔试题"></a>2 头条笔试题</h1><p><img src="toutiao/3.jpg" alt="3.jpg"><br><img src="toutiao/4.jpg" alt="4.jpg"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int N;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    for(int n=0;n&lt;N;++n)&#123;</span><br><span class="line">        int L, minVal, minPos;</span><br><span class="line">        minVal = 1000;</span><br><span class="line">        minPos = 0;</span><br><span class="line">        cin&gt;&gt;L;</span><br><span class="line">        vector&lt;int&gt; v(L, 0);</span><br><span class="line">        for(int l=0;l&lt;L;l++)&#123;</span><br><span class="line">            cin&gt;&gt;v[l];</span><br><span class="line">            if(v[l]&lt;minVal)&#123;</span><br><span class="line">                minVal = v[l];</span><br><span class="line">                minPos = l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; reward(v.size(), 0);</span><br><span class="line">        reward[minPos] = 1;</span><br><span class="line">        for(int k=0;k&lt;L;k++)&#123;</span><br><span class="line">            int pos = k+minPos;</span><br><span class="line">            if (pos&gt;=L)&#123;</span><br><span class="line">                pos = pos - L;</span><br><span class="line">            &#125;</span><br><span class="line">            if(pos==0)&#123;</span><br><span class="line">                if(v[pos]&gt;v[L-1]) reward[pos] = reward[L-1]+1;</span><br><span class="line">                else if(v[pos]==v[L-1]) reward[pos] = reward[L-1] - 1;</span><br><span class="line">                else reward[pos]=reward[pos];</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(v[pos]&gt;v[pos-1]) reward[pos] = reward[pos-1]+1;</span><br><span class="line">                else if(v[pos]==v[pos-1]) reward[pos] = reward[pos-1] - 1;</span><br><span class="line">                else reward[pos]=reward[pos];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;accumulate(reward.begin(),reward.end(),0)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3-头条笔试题"><a href="#3-头条笔试题" class="headerlink" title="3 头条笔试题"></a>3 头条笔试题</h1><p><img src="toutiao/5.jpg" alt="5.jpg"><br><img src="toutiao/6.jpg" alt="6.jpg"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; zhaoqian(int N)&#123;</span><br><span class="line">vector&lt;int&gt; v(4,0);</span><br><span class="line">    N = 1024 - N;</span><br><span class="line">int value[4] = &#123;64, 16, 4, 1&#125;;</span><br><span class="line">for(int i=0;i&lt;(sizeof(value)/sizeof(value[0]));i++)&#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">        int a = N/value[i];</span><br><span class="line">v[i] = a;</span><br><span class="line">N = N%value[i];</span><br><span class="line">&#125;</span><br><span class="line">return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int N;</span><br><span class="line">cin&gt;&gt;N;</span><br><span class="line">vector&lt;int&gt; vv;</span><br><span class="line">vv = zhaoqian(N);</span><br><span class="line">    cout&lt;&lt;accumulate(vv.begin(), vv.end(), 0)&lt;&lt;endl;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="4-招行笔试题"><a href="#4-招行笔试题" class="headerlink" title="4 招行笔试题"></a>4 招行笔试题</h1><p>题目描述：切不等高的蛋糕，蛋糕N份，每刀切平一部分，切下来的不得超过k份，整块蛋糕切平最少需要几刀，比如如下输入<br>5 6<br>1 2 3 4 5<br>提示：第一刀可以切到2，切下来刚好是6份，剩下蛋糕为1 2 2 2 2<br>第二刀全切到1，最少需要2刀<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int N,k;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;k;</span><br><span class="line">    vector&lt;int&gt; v(N, 0);</span><br><span class="line">    for(int l=0;l&lt;N;l++)&#123;</span><br><span class="line">        cin&gt;&gt;v[l];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(v.begin(),v.end());</span><br><span class="line">    int minVal = v.front();</span><br><span class="line">    int maxVal = v.back();</span><br><span class="line">    int dao = 0;</span><br><span class="line">    bool hello = false;</span><br><span class="line">    int i = 0;</span><br><span class="line">    while(i&lt;v.size())&#123;</span><br><span class="line">        if(hello) i=0;</span><br><span class="line">        if(minVal==maxVal) break;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        bool flag = true;</span><br><span class="line">        int minVal1=v[i];</span><br><span class="line">        for(int j=v.size()-1;j&gt;i;--j)&#123;</span><br><span class="line">            sum = sum+(v[j]-minVal1);</span><br><span class="line">            if(sum&gt;k)&#123;</span><br><span class="line">                flag = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            dao++;</span><br><span class="line">            hello = true;</span><br><span class="line">            for(int g=v.size()-1;g&gt;i;g--)&#123;</span><br><span class="line">                v[g] = v[g]-(v[g]-minVal1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxVal=v.back();</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dao;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实习笔试试题，有些没投（准备好先），拿过来先看了看&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://dlc1994.github.io/categories/LeetCode/"/>
    
    
      <category term="C++" scheme="https://dlc1994.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>二叉树常用操作的实现</title>
    <link href="https://dlc1994.github.io/BinaryTree.html"/>
    <id>https://dlc1994.github.io/BinaryTree.html</id>
    <published>2019-03-09T12:23:52.000Z</published>
    <updated>2019-04-29T13:52:47.776Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树的最全总结，常考题型，持续更新<br><strong>二叉树的递归思想很重要，还有递归的复杂度分析</strong><br><a id="more"></a></p><h1 id="1-1-二叉树的初始化"><a href="#1-1-二叉树的初始化" class="headerlink" title="1.1 二叉树的初始化"></a>1.1 二叉树的初始化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#initial of BinaryTree</span><br><span class="line">class BinaryTree:</span><br><span class="line">    def __init__(self,rootObj):</span><br><span class="line">        self.val = rootObj</span><br><span class="line">        self.left = None</span><br><span class="line">        self.right = None</span><br><span class="line"></span><br><span class="line">    def insertLeft(self,newNode):</span><br><span class="line">        if self.left == None:</span><br><span class="line">            self.left = BinaryTree(newNode)</span><br><span class="line">        else:</span><br><span class="line">            t = BinaryTree(newNode)</span><br><span class="line">            t.left = self.left</span><br><span class="line">            self.left = t</span><br><span class="line"></span><br><span class="line">    def insertRight(self,newNode):</span><br><span class="line">        if self.right == None:</span><br><span class="line">            self.right = BinaryTree(newNode)</span><br><span class="line">        else:</span><br><span class="line">            t = BinaryTree(newNode)</span><br><span class="line">            t.right = self.right</span><br><span class="line">            self.right = t</span><br></pre></td></tr></table></figure><h1 id="1-2-创建一个二叉树"><a href="#1-2-创建一个二叉树" class="headerlink" title="1.2 创建一个二叉树"></a>1.2 创建一个二叉树</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#create a BinaryTree [18,7,11,3,4,5,6,#,#,#,#,1,3,2,4]</span><br><span class="line">#  18</span><br><span class="line"># 7  11</span><br><span class="line">#3 4 5 6</span><br><span class="line">#   1 3 2 4</span><br><span class="line"></span><br><span class="line">root = BinaryTree(18)</span><br><span class="line">root.left = BinaryTree(7)</span><br><span class="line">root.right = BinaryTree(11)</span><br><span class="line">root.left.left = BinaryTree(3)</span><br><span class="line">root.left.right = BinaryTree(4)</span><br><span class="line">root.right.left = BinaryTree(5)</span><br><span class="line">root.right.right = BinaryTree(6)</span><br><span class="line">root.right.left.left = BinaryTree(1)</span><br><span class="line">root.right.left.right = BinaryTree(3)</span><br><span class="line">root.right.right.left = BinaryTree(2)</span><br><span class="line">root.right.right.right = BinaryTree(4)</span><br></pre></td></tr></table></figure><h1 id="1-3-前序遍历"><a href="#1-3-前序遍历" class="headerlink" title="1.3 前序遍历"></a>1.3 前序遍历</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#递归版本</span><br><span class="line">def PreOrder(self, node):</span><br><span class="line">    if node:</span><br><span class="line">        print(node.val)</span><br><span class="line">        self.PreOrder(node.left)</span><br><span class="line">        self.PreOrder(node.right)</span><br><span class="line">#循环版本</span><br><span class="line">def PreOrderLoop(self, node):</span><br><span class="line">    if node == None:</span><br><span class="line">        return</span><br><span class="line">    stack =[]</span><br><span class="line">    print(node.val)</span><br><span class="line">    stack.append(node)</span><br><span class="line">    node = node.left</span><br><span class="line">    while stack!=[] or node:</span><br><span class="line">        while node:</span><br><span class="line">            print(node.val)</span><br><span class="line">            stack.append(node)</span><br><span class="line">            node = node.left</span><br><span class="line">        node = stack[-1].right</span><br><span class="line">        stack.pop()</span><br><span class="line"></span><br><span class="line">#ouput: 18 7 3 4 11 5 1 3 6 2 4</span><br></pre></td></tr></table></figure><h1 id="1-4-中序遍历"><a href="#1-4-中序遍历" class="headerlink" title="1.4 中序遍历"></a>1.4 中序遍历</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#递归版本</span><br><span class="line">def InOrder(self, node):</span><br><span class="line">    if node:</span><br><span class="line">        self.InOrder(node.left)</span><br><span class="line">        print(node.val)</span><br><span class="line">        self.InOrder(node.right)</span><br><span class="line">#循环版本</span><br><span class="line">def InOrderLoop(self, node):</span><br><span class="line">    if node == None:</span><br><span class="line">        return None</span><br><span class="line">    stack = []</span><br><span class="line">    stack.append(node)</span><br><span class="line">    node = node.left</span><br><span class="line">    while stack!=[] or node:</span><br><span class="line">        while node:</span><br><span class="line">            stack.append(node)</span><br><span class="line">            node = node.left</span><br><span class="line">        print(stack[-1].val)</span><br><span class="line">        node = stack[-1].right</span><br><span class="line">        stack.pop()</span><br><span class="line">#output：3 7 4 18 1 5 3 11 2 6 4</span><br></pre></td></tr></table></figure><h1 id="1-5-后序遍历"><a href="#1-5-后序遍历" class="headerlink" title="1.5 后序遍历"></a>1.5 后序遍历</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#递归</span><br><span class="line">def PostOrder(self, node):</span><br><span class="line">    if node:</span><br><span class="line">        self.PostOrder(node.left)</span><br><span class="line">        self.PostOrder(node.right)</span><br><span class="line">        print(node.val)</span><br><span class="line">#非递归</span><br><span class="line">def PostOrderLoop(self, node):</span><br><span class="line">    if node == None:</span><br><span class="line">        return</span><br><span class="line">    stack =[]</span><br><span class="line">    stack.append(node)</span><br><span class="line">    pre = None</span><br><span class="line">    while stack!=[]:</span><br><span class="line">        node = stack[-1]</span><br><span class="line">        if ((node.left==None and node.right==None) or</span><br><span class="line">                (pre and (pre == node.left or pre ==node.right))):</span><br><span class="line">            print(node.val)</span><br><span class="line">            pre = node</span><br><span class="line">            stack.pop()</span><br><span class="line">        else:</span><br><span class="line">            if node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            if node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">#output:3 4 7 1 3 5 2 4 6 11 18</span><br></pre></td></tr></table></figure><h1 id="1-6-层序遍历"><a href="#1-6-层序遍历" class="headerlink" title="1.6 层序遍历"></a>1.6 层序遍历</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def LevelOrder(self, node):</span><br><span class="line">    if node == None:</span><br><span class="line">        return</span><br><span class="line">    stack = []</span><br><span class="line">    stack.append(node)</span><br><span class="line">    while stack!=[]:</span><br><span class="line">        node = stack[0]</span><br><span class="line">        if node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">        if node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        print(node.val)</span><br><span class="line">        stack.pop(0)</span><br><span class="line">output: 18 7 11 3 4 5 6 1 3 2 4</span><br></pre></td></tr></table></figure><h1 id="1-7-计算节点数"><a href="#1-7-计算节点数" class="headerlink" title="1.7 计算节点数"></a>1.7 计算节点数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#递归版本</span><br><span class="line">def CountNode(self, root):</span><br><span class="line">    if root == None:</span><br><span class="line">        return 0</span><br><span class="line">    return self.CountNode(root.left) + self.CountNode(root.right) + 1</span><br><span class="line">#非递归版本</span><br><span class="line">def CountNodeNotRev(self, root):</span><br><span class="line">    if root == None:</span><br><span class="line">        return 0</span><br><span class="line">    stack = []</span><br><span class="line">    stack.append(root)</span><br><span class="line">    index = 0</span><br><span class="line">    while index&lt;len(stack):</span><br><span class="line">        if stack[index].left:</span><br><span class="line">            stack.append(stack[index].left)</span><br><span class="line">        if stack[index].right:</span><br><span class="line">            stack.append(stack[index].right)</span><br><span class="line">        index += 1</span><br><span class="line">    print(len(stack))</span><br><span class="line">output: 11</span><br></pre></td></tr></table></figure><h1 id="1-8-计算树的深度"><a href="#1-8-计算树的深度" class="headerlink" title="1.8 计算树的深度"></a>1.8 计算树的深度</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def getTreeDepth(self, root):</span><br><span class="line">    if root == None:</span><br><span class="line">        return 0</span><br><span class="line">    left = self.getTreeDepth(root.left) + 1</span><br><span class="line">    right = self.getTreeDepth(root.right) + 1</span><br><span class="line">    return left if left&gt;right else right</span><br></pre></td></tr></table></figure><h1 id="1-9-计算树的叶子树"><a href="#1-9-计算树的叶子树" class="headerlink" title="1.9 计算树的叶子树"></a>1.9 计算树的叶子树</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def countLeaves(self, root):</span><br><span class="line">    if root == None:</span><br><span class="line">        return 0</span><br><span class="line">    if root.left==None and root.right==None:</span><br><span class="line">        return 1</span><br><span class="line">    return self.countLeaves(root.left)+self.countLeaves(root.right)</span><br></pre></td></tr></table></figure><h1 id="1-10-获取第K层节点数"><a href="#1-10-获取第K层节点数" class="headerlink" title="1.10 获取第K层节点数"></a>1.10 获取第K层节点数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def getKLevel(self, root, K):</span><br><span class="line">    if root == None: return 0</span><br><span class="line">    if K == 1: return 1</span><br><span class="line">    return self.getKLevel(root.left, K-1)+self.getKLevel(root.right, K-1)</span><br></pre></td></tr></table></figure><h1 id="1-11-判断两颗二叉树是否相同"><a href="#1-11-判断两颗二叉树是否相同" class="headerlink" title="1.11 判断两颗二叉树是否相同"></a>1.11 判断两颗二叉树是否相同</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def StrucCmp(self, root1, root2):</span><br><span class="line">    if root1 == None and root2 == None: return True</span><br><span class="line">    elif root1 ==None or root2 == None: return False</span><br><span class="line">    return self.StrucCmp(root1.left, root2.left) and self.StrucCmp(root1.right, root2.right)</span><br></pre></td></tr></table></figure><h1 id="1-12-二叉树的镜像"><a href="#1-12-二叉树的镜像" class="headerlink" title="1.12 二叉树的镜像"></a>1.12 二叉树的镜像</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def Mirror(self, root):</span><br><span class="line">    if root == None: return</span><br><span class="line">    tmp = root.left</span><br><span class="line">    root.left = root.right</span><br><span class="line">    root.right = tmp</span><br><span class="line">    self.Mirror(root.left)</span><br><span class="line">    self.Mirror(root.right)</span><br></pre></td></tr></table></figure><h1 id="1-13-找最低公共祖先节点"><a href="#1-13-找最低公共祖先节点" class="headerlink" title="1.13 找最低公共祖先节点"></a>1.13 找最低公共祖先节点</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def findLCA(self, root, node1, node2):</span><br><span class="line">    if root == None: return</span><br><span class="line">    if root == node1 or root == node2: return root</span><br><span class="line">    left = self.findLCA(root.left, node1, node2)</span><br><span class="line">    right = self.findLCA(root.right, node1, node2)</span><br><span class="line">    if left and right:</span><br><span class="line">        return root</span><br><span class="line">    return left if left else right</span><br></pre></td></tr></table></figure><h1 id="1-14-获取两个节点的距离"><a href="#1-14-获取两个节点的距离" class="headerlink" title="1.14 获取两个节点的距离"></a>1.14 获取两个节点的距离</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def getDist(self, root, node1, node2):</span><br><span class="line">    lca = self.findLCA(root, node1, node2) #找最低公共祖宗节点</span><br><span class="line">    level1 = self.FindLevel(lca, node1) #祖节点到两个节点的距离</span><br><span class="line">    level2 = self.FindLevel(lca, node2)</span><br><span class="line">    return level1+level2</span><br><span class="line">def FindLevel(self, node, target):</span><br><span class="line">    if node == None: return -1</span><br><span class="line">    if node == target: return 0</span><br><span class="line">    level = self.FindLevel(node.left, target)</span><br><span class="line">    if level == -1: level = self.FindLevel(node.right, target)</span><br><span class="line">    if level != -1: return level + 1</span><br><span class="line">    return -1</span><br></pre></td></tr></table></figure><h1 id="1-20-找一个节点的所有祖宗节点"><a href="#1-20-找一个节点的所有祖宗节点" class="headerlink" title="1.20 找一个节点的所有祖宗节点"></a>1.20 找一个节点的所有祖宗节点</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def findAllAncestor(self, root, target):</span><br><span class="line">    if root == None: return False</span><br><span class="line">    if root == target: return True</span><br><span class="line">    if self.findAllAncestor(root.left, target) or self.findAllAncestor(root.right, target):</span><br><span class="line">        print(root.val)</span><br><span class="line">        return True</span><br><span class="line">    return False</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树的最全总结，常考题型，持续更新&lt;br&gt;&lt;strong&gt;二叉树的递归思想很重要，还有递归的复杂度分析&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://dlc1994.github.io/categories/Data-Structure/"/>
    
    
      <category term="Python" scheme="https://dlc1994.github.io/tags/Python/"/>
    
      <category term="Binary Tree" scheme="https://dlc1994.github.io/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://dlc1994.github.io/hello-world.html"/>
    <id>https://dlc1994.github.io/hello-world.html</id>
    <published>2019-02-08T12:14:55.325Z</published>
    <updated>2019-04-29T13:35:34.973Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linear Regression</title>
    <link href="https://dlc1994.github.io/LinearRegression.html"/>
    <id>https://dlc1994.github.io/LinearRegression.html</id>
    <published>2018-11-28T12:23:52.000Z</published>
    <updated>2019-05-24T15:35:16.190Z</updated>
    
    <content type="html"><![CDATA[<p>  就从最简单的线性回归模型（Linear Regression model）开始学习吧。<br>  从这个模型的名字我们可以看出，因变量和变量之间的关系是线性的，预测值可以通过计算输入特征的权重给出：</p><script type="math/tex; mode=display">\hat{y} = \theta_0+\theta_1x_1+\theta_2x_2+...+\theta_nx_n</script><p>其中，$\hat{y}$是预测值，$n$是特征数量，$\theta_0$是bias，$x_i$是第$i$个特征值，$\theta_j$是第$j$个特征的模型参数。如果获取了模型的所有参数，给定一个样本我们就可以用上面这个公式模型得到预测值。<br>  为了表达更简洁，一般用向量表示：</p><script type="math/tex; mode=display">\hat{y} = h_{\mathbf{\theta}}(\mathbf{x}) = \mathbf{\theta}^T \mathbf{x}</script><p>其中$h_{\mathbf{\theta}}()$是hypothesis function是关于$\mathbf{\theta}$的假设函数，$\mathbf{\theta} = [\theta_0;\theta_1;…;\theta_n]$，$\mathbf{x} = [x_0, x_1, x_2, …, x_n]$并且$x_0=1$。<br>  我们的目标当然是想要所有预测值都跟实际值相等，因此，目标函数或者称代价函数建模为：</p><script type="math/tex; mode=display">\text{MSE}(\mathbf{X},h_{\mathbf{\theta}}) = \frac{1}{m}\sum_{i=1}^{m}\left(\mathbf{\theta}^T\cdot\mathbf{x}^{(i)}-y^{(i)}\right)^2</script><p>其中$\mathbf{X}$为所有样本的集合，数量为$m$。</p><h1 id="标准闭式解"><a href="#标准闭式解" class="headerlink" title="标准闭式解"></a>标准闭式解</h1><p>  基于均方误差最小化来进行模型求解的方法称为“最小二乘法”（least square method）。在线性回归中，最小二乘法就是试图找到一条直线，使所有样本到直线上的欧氏距离之和最小。<br>  一般地，我们利用最小二乘法对$\mathbf{\theta}$进行估计。数据集$\mathbf{X}$表示为：</p><script type="math/tex; mode=display">\mathbf{X}=\left(\begin{array}{ccc}       1 & x_{11} & x_{12} &  \cdots\  & x_{1d}\\      1 & x_{21} & x_{22} &  \cdots\  & x_{23} \\     \vdots & \vdots & \vdots & \ddots & \vdots\\    1 & x_{m1} & x_{m2} &  \cdots\  & x_{md}\\   \end{array}\right)=\left(\begin{array}{ccc}       1 & \mathbf{x}_1^T \\      1 & \mathbf{x}_2^T \\     \vdots & \vdots \\    1 & \mathbf{x}_m^T \\   \end{array}\right)</script><p>  然后把实际值也写成向量模式$\mathbf{y}=(y_1;y_2;…;y_m)$，因此优化问题为：</p><script type="math/tex; mode=display">\mathbf{\theta}^*=\underset{\mathbf{\theta}}{\text{arg}\min}(\mathbf{y}-\mathbf{\theta}^T\mathbf{X})^T(\mathbf{y}-\mathbf{\theta}^T\mathbf{X})</script><p>  令$E_{\mathbf{\theta}}=(\mathbf{y}-\mathbf{\theta}^T\mathbf{X})^T(\mathbf{y}-\mathbf{\theta}^T\mathbf{X})$，对$\mathbf{\theta}$求导可得：</p><script type="math/tex; mode=display">\frac{\partial E_{\mathbf{\theta}}}{\partial \mathbf{\theta}}=2\mathbf{X}^T(\mathbf{\theta}^T\mathbf{X}-\mathbf{y})</script><p>  令上式等于0可解得</p><script type="math/tex; mode=display">\mathbf{\theta}^*=(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{y}</script><p>  如果$\mathbf{X}^T\mathbf{X}$不可逆怎么办，这可能是由于矩阵中存在冗余特征，在线性代数里说明矩阵并非线性不相关，因此可以删除多余特征；也有可能是由于特征数大于等于样本数，也就是$m \le n$，可以通过删除一些特征或者使用正则化（regularization，后续介绍）。<br>  给出python一个实现例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line"></span><br><span class="line">X = 2 * np.random.rand(100, 1)</span><br><span class="line">y = 2 + 6 * X + np.random.randn(100, 1)</span><br><span class="line"></span><br><span class="line">X_b = np.c_[np.ones((100, 1)), X] # add x0 = 1 to each instance</span><br><span class="line">theta_best = np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(y)</span><br><span class="line">print(theta_best)</span><br><span class="line"># [[1.74568681] [6.27246194]]</span><br><span class="line"></span><br><span class="line">X_new = np.array([[0], [2]])</span><br><span class="line">X_new_b = np.c_[np.ones((2, 1)), X_new] # add x0 = 1 to each instance</span><br><span class="line">y_predict = X_new_b.dot(theta_best)</span><br><span class="line">print(y_predict) #[[ 1.74568681] [14.29061069]]</span><br><span class="line"></span><br><span class="line">plt.plot(X_new, y_predict, &quot;r-&quot;)</span><br><span class="line">plt.plot(X, y, &quot;b.&quot;)</span><br><span class="line">plt.axis([0, 2, 0, 15])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="/LinearRegression/1.png" title="Linear Regression"><p>  如果用sklearn实现的话，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.linear_model import LinearRegression</span><br><span class="line">&gt;&gt;&gt; lin_reg = LinearRegression()</span><br><span class="line">&gt;&gt;&gt; lin_reg.fit(X, y)</span><br><span class="line">&gt;&gt;&gt; lin_reg.intercept_, lin_reg.coef_</span><br><span class="line">(array([ 4.21509616]), array([[ 2.77011339]]))</span><br><span class="line">&gt;&gt;&gt; lin_reg.predict(X_new)</span><br><span class="line">array([[ 4.21509616],</span><br><span class="line">[ 9.75532293]])</span><br></pre></td></tr></table></figure></p><p>  这种方式实现的计算复杂度只要在矩阵求逆上，对于一个$n \times n$的矩阵，求逆复杂度大约是$O(n^{2.4})$到$O(n^{3})$，当特征数量很大时（比如100,000以上时），标准闭式解会变得很慢；另一方面，对于样本数量其复杂度是$O(m)$，也就是线性的；此外，模型训练完成后，预测的复杂度对于样本数量和特征数量复杂度都很快。</p><h1 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h1><p>  梯度下降法是十分常用的优化算法，目的是通过迭代过程不断更新参数进而最小化代价函数，每次优化的方向都是斜率绝对值最大的方向。<br><strong>Note：</strong></p><ul><li>需要谨慎选择步长（step size）或者叫做学习率（learning rate），太小的话，需要许多次迭代才能走到最优点，而步子太大，则有可能跨过最优点，然后陷入震荡。</li><li>凸优化问题找到最优点比较容易，而非凸问题则容易陷入局部最优点或者陷入平台（plateau)。线性回归问题是个凸优化问题。</li><li>最好在使用梯度下降法前对数据进行标准化处理，不然“碗”太长需要更多的迭代次数。</li><li>问题参数越多，维度越大，参数空间越大，搜索最优解也就越难。</li></ul><h2 id="Batch-Gradient-Descent"><a href="#Batch-Gradient-Descent" class="headerlink" title="Batch Gradient Descent"></a>Batch Gradient Descent</h2><p>  Batch是批的意思，批梯度下降就是在每次迭代过程中把所有数据都来计算代价函数的偏导，也就是梯度。代价函数对于参数$\theta_j$的偏导为：</p><script type="math/tex; mode=display">\frac{\partial \text{MSE}(\theta)}{\partial{\theta}_j}=\frac{2}{m}\sum_{i=1}^{m}\left(\theta^T \cdot \mathbf{x}^{(i)}-y^{(i)}\right)x_j^{(i)}</script><p>  用向量来表示梯度下降为：</p><script type="math/tex; mode=display">\nabla_{\theta}\text{MSE}(\theta)=\left(\begin{array}{ccc}\frac{\partial \text{MSE}(\theta)}{\partial \theta_0}\\\frac{\partial \text{MSE}(\theta)}{\partial \theta_1}\\\vdots\\\frac{\partial \text{MSE}(\theta)}{\partial \theta_0}\end{array}\right)=\frac{2}{m}\mathbf{X}^T\cdot(\mathbf{X}\cdot \theta-\mathbf{y})</script><p>  由此，我们可以得到梯度下降的步骤：</p><script type="math/tex; mode=display">\theta^{(n+1)} = \theta^{(n)}-\eta \nabla_{\theta}\text{MSE}(\theta)</script><p>  推导出这个公式之后就可以实现了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">eta = 0.1 # learning rate</span><br><span class="line">n_iterations = 1000</span><br><span class="line">m = 100</span><br><span class="line">theta = np.random.randn(2,1) # random initialization</span><br><span class="line">for iteration in range(n_iterations):</span><br><span class="line">gradients = 2/m * X_b.T.dot(X_b.dot(theta) - y)</span><br><span class="line">theta = theta - eta * gradients</span><br></pre></td></tr></table></figure></p><h2 id="Stochastic-Gradient-Descent"><a href="#Stochastic-Gradient-Descent" class="headerlink" title="Stochastic Gradient Descent"></a>Stochastic Gradient Descent</h2><p>  在前面讲过，BGD在每次迭代中是把所有数据都用于计算的，因此当数据量很大时，算法会变得难以忍受的慢，因此需要使用其他梯度下降算法。随机梯度下降法跟批梯度下降是两个极端，SGD在每次迭代中会随机从训练集中选择一个样本，然后只用这个样本计算并更新梯度。因此，这个算法计算比BGD快很多很多；但也由于其随机特性，优化曲线不会“直接”向着最优点前进，而是来回波动，但最终会抵达最优值附近。其算法如下图所示：<br><img src="/LinearRegression/2.jpg" title="SGD"><br>  Python实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n_epochs = 50</span><br><span class="line">t0, t1 = 5, 50 # learning schedule hyperparameters</span><br><span class="line">def learning_schedule(t):</span><br><span class="line">return t0 / (t + t1)</span><br><span class="line">theta = np.random.randn(2,1) # random initialization</span><br><span class="line">for epoch in range(n_epochs):</span><br><span class="line">for i in range(m):</span><br><span class="line">random_index = np.random.randint(m)</span><br><span class="line">xi = X_b[random_index:random_index+1]</span><br><span class="line">        yi = y[random_index:random_index+1]</span><br><span class="line">        gradients = 2 * xi.T.dot(xi.dot(theta) - yi)</span><br><span class="line">        eta = learning_schedule(epoch * m + i)</span><br><span class="line">        theta = theta - eta * gradients</span><br><span class="line">print(theta)</span><br></pre></td></tr></table></figure></p><p>  如果用sklearn来实现的话，代码就简单多了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.linear_model import SGDRegressor</span><br><span class="line">sgd_reg = SGDRegressor(n_iter=50, penalty=None, eta0=0.1)</span><br><span class="line">sgd_reg.fit(X, y.ravel())</span><br><span class="line">print(sgd_reg.intercept_, sgd_reg.coef_)</span><br></pre></td></tr></table></figure></p><p><strong>NOTE:</strong> epoch是指把所有数据样本都遍历一遍，iteration表示更新一次参数，batch则是指数据样本的大小，在SGD中，iteration=batch=1，epoch=num_X/batch</p><h2 id="Mini-batch-Gradient-Descent"><a href="#Mini-batch-Gradient-Descent" class="headerlink" title="Mini-batch Gradient Descent"></a>Mini-batch Gradient Descent</h2><p>  Mini-batch GD介于SGD和BGD之间，也就是每次用来更新参数的样本不是一也不是所有（吴恩达说在2-400之间，他倾向于用10），它吸收了BGD和SGD的优缺点的折中，收敛更快，随机性较小，但也难抵达最优值，其算法流程如下图所示：<br><img src="/LinearRegression/3.jpg" title="Mini-batch GD"></p><p>  这里介绍的标准闭式解只适用于线性回归问题，但梯度下降法可以用来训练许多模型，在深度学习中也有广泛应用，将他们比较如下：</p><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Large m</th><th>Out-of-core Support</th><th>Large n</th><th>Hyperparameters</th><th>Scaling Required</th><th>Sklearn</th></tr></thead><tbody><tr><td>Normal Equation</td><td>Fast</td><td>No</td><td>Slow</td><td>0</td><td>No</td><td>LinearRegression</td></tr><tr><td>Batch GD</td><td>Slow</td><td>No</td><td>Fast</td><td>2</td><td>Yes</td><td>n/a</td></tr><tr><td>Stochastic GD</td><td>Fast</td><td>Yes</td><td>Fast</td><td>$\ge$2</td><td>Yes</td><td>SGDRegressor</td></tr><tr><td>Mini-batch GD</td><td>Fast</td><td>Yes</td><td>Fast</td><td>$\ge $2</td><td>Yes</td><td>n/a</td></tr></tbody></table></div><h2 id="Polynomial-Regression"><a href="#Polynomial-Regression" class="headerlink" title="Polynomial Regression"></a>Polynomial Regression</h2><p>  如果数据并非一条直线呢，那么还可以用线性模型吗？实际上是可以的，主要方法就是把一个特征拓展成多维的，比如$x^2, x^3,…, x^k$，然后将其作为另一个维度的特征，比如$x_1 = x, x_2 = x^2$，那么就可以用线性模型按照上面的方法进行训练了，用sklearn实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from sklearn.preprocessing import PolynomialFeatures</span><br><span class="line">from sklearn.linear_model import LinearRegression</span><br><span class="line"></span><br><span class="line">m = 100</span><br><span class="line">X = 6 * np.random.rand(m, 1) - 3</span><br><span class="line">y = 1 * X**2 + X + 2 + np.random.randn(m, 1)</span><br><span class="line">plt.scatter(X, y)</span><br><span class="line"></span><br><span class="line">poly_features = PolynomialFeatures(degree=2, include_bias=False)</span><br><span class="line">X_poly = poly_features.fit_transform(X)</span><br><span class="line">lin_reg = LinearRegression()</span><br><span class="line">lin_reg.fit(X_poly, y)</span><br><span class="line">print(lin_reg.intercept_, lin_reg.coef_)</span><br><span class="line">xx = np.array((range(-3, 4)))</span><br><span class="line">print(xx)</span><br><span class="line">yy = xx*0.98134428+xx*xx*0.94365742+1.94555083</span><br><span class="line">plt.plot(xx, yy, c=&apos;r&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="/LinearRegression/4.png" title="Polynomial Regression"><p>  此外，需要注意，<code>PolynomialFeatures(degree=d)</code>会把一个包含n个特征的矩阵转化为包含$\frac{(n+d)!}{d!n!}$个特征的矩阵，即如果对于两个特征a和b，令degree=3，那么特征不仅有$a^2$，$a^3$，$b^2$，$b^3$，还会有$ab$，$a^2b$和$ab^2$.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  就从最简单的线性回归模型（Linear Regression model）开始学习吧。&lt;br&gt;  从这个模型的名字我们可以看出，因变量和变量之间的关系是线性的，预测值可以通过计算输入特征的权重给出：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=di
      
    
    </summary>
    
      <category term="Machine Learning" scheme="https://dlc1994.github.io/categories/Machine-Learning/"/>
    
    
      <category term="Python" scheme="https://dlc1994.github.io/tags/Python/"/>
    
      <category term="Linear Regression" scheme="https://dlc1994.github.io/tags/Linear-Regression/"/>
    
      <category term="Polynomial Regression" scheme="https://dlc1994.github.io/tags/Polynomial-Regression/"/>
    
      <category term="Gradient Decent Methods" scheme="https://dlc1994.github.io/tags/Gradient-Decent-Methods/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to Machine Learning</title>
    <link href="https://dlc1994.github.io/Introduction.html"/>
    <id>https://dlc1994.github.io/Introduction.html</id>
    <published>2018-11-28T12:13:53.000Z</published>
    <updated>2019-04-29T13:35:57.430Z</updated>
    
    <content type="html"><![CDATA[<p>  做了与机器学习相关的项目好久了，但对机器学习一直没有一个系统的认识，导致在切入一些新的领域时力有不逮，总感觉理解有偏差或者理解困难，因此想系统地、详细地学习机器学习，就从周志华的西瓜书和Andrew Ng的机器学习视频开始吧。<br><a id="more"></a><br>  众所周知， 机器学习是研究计算机怎样模拟或实现人类的学习行为，以获取新是研究计算机怎样模拟或实现人类的学习行为。<br>  来自卡内基梅隆大学的Tom Mitchell提出的关于机器学习的定义较为人所接受，他定义的机器学习是，一个程序被认为能从经验E中学习，解决任务T，达到性能度量值P，当且仅当，有了经验E后，经过P评判，程序在处理T时的性能有所提升。<br>  一般而言，我把机器学习分为<strong>监督学习</strong>、<strong>无监督学习</strong>和<strong>增强学习</strong>，而深度学习和大数据是拓展也是紧密的关联，如下图所示：<br><img src="/Introduction/1.jpg" title="classification"><br>  监督学习，顾名思义，就是有人指导你，告诉你这个学习正确与否。专业点来讲，就是数据集中每个样本都会带有一个正确答案，比如在西瓜分类里，“红瓤，有蒂”带有标签“甜”，“黄瓤，无蒂”带有标签“不甜”；在回归里，房价预测里每个样本都带有房价。<strong>分类和回归的区别在于预测的是一组离散的结果，而回归可以预测连续的输出。</strong><br><img src="/Introduction/2.jpg" title="Supervisedlearning and Unsupervisedlearning"><br>  无监督学习，从上图可以看出，我们事先不知道样本是哪一类或者是哪一个值，也就是没有任何的标签或“答案”。一个比较著名的例子就是鸡尾酒宴问题：许多人坐在一起参加鸡尾酒会，大家都在同一时间说话，声音此起彼伏，重重叠叠，要想分离出不同人说话的声音，就是一个聚类问题，也是无监督学习问题。这个例子可能比较难懂，再说一个就是在无线通信中，有时会根据用户的行为特征对用户进行分类，便于进行一些资源的调度和统一管理，而如何判断一堆用户里哪些用户是类似的，比如上班族、学生党、旅客等，这就是一个典型的聚类问题。<br>  增强学习则是要解决这样的问题，一个能感知环境的自治agent，怎样通过学习选择能达到其目标的最优动作。当agent（机器人，下棋，在无线领域则可以是用户、基站和operator）在环境中作出某个动作时，会产生不同的奖励值或者惩罚值，agent的任务就是从这个非直接的，有延迟的回报中学习，以便后续的动作产生最大的累积效应。<br><img src="/Introduction/3.jpg" title="Reinforcementlearning"><br>  在后续的文章中，我们会对各个算法有比较详细的学习过程，敬请期待啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  做了与机器学习相关的项目好久了，但对机器学习一直没有一个系统的认识，导致在切入一些新的领域时力有不逮，总感觉理解有偏差或者理解困难，因此想系统地、详细地学习机器学习，就从周志华的西瓜书和Andrew Ng的机器学习视频开始吧。&lt;br&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="https://dlc1994.github.io/categories/Machine-Learning/"/>
    
    
      <category term="Python" scheme="https://dlc1994.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Solutions</title>
    <link href="https://dlc1994.github.io/LeetCode%20Solutions.html"/>
    <id>https://dlc1994.github.io/LeetCode Solutions.html</id>
    <published>2018-07-30T04:50:07.000Z</published>
    <updated>2019-04-29T13:51:58.037Z</updated>
    
    <content type="html"><![CDATA[<p>Here are my solutions to the LeetCode problems, linking to my <a href="https://github.com/dlc1994" target="_blank" rel="noopener">Github</a> repository:<br><a id="more"></a></p><h1 id="EASY"><a href="#EASY" class="headerlink" title="EASY"></a>EASY</h1><ul><li><a href="https://github.com/dlc1994/LeetCode/blob/master/twoSums.py" target="_blank" rel="noopener">Leetcode 1   Two Sum</a> </li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/PalindromeNumber.py" target="_blank" rel="noopener">Leetcode 9   Palindrome Number</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/leetcode13%20roman2integer.py" target="_blank" rel="noopener">Leetcode 13  roman2integer</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/longestCommonPrefix.py" target="_blank" rel="noopener">Leetcode 14  longestcommonprefix</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/validParenthese.py" target="_blank" rel="noopener">Leetcode 20  valid parentheses</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/leetcode21%20merge2sortedlist.py" target="_blank" rel="noopener">Leetcode 21  merge2sortedlist</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/hamming.py" target="_blank" rel="noopener">Leetcode 461 Hamming Distance</a> </li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/lowerCase.py" target="_blank" rel="noopener">Leetcode 709 To Lower Case</a> </li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/JewerAndStones.py" target="_blank" rel="noopener">Leetcode 771 Jewels and Stones</a> </li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/MorseCode.py" target="_blank" rel="noopener">Leetcode 804 Unique Morse Code Words</a> </li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/circle.py" target="_blank" rel="noopener">Circle</a> </li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/flipping%20image.py" target="_blank" rel="noopener">Leetcode 832 Flipping an Image</a> </li></ul><h1 id="MEDIUM"><a href="#MEDIUM" class="headerlink" title="MEDIUM"></a>MEDIUM</h1><ul><li><a href="https://github.com/dlc1994/LeetCode/blob/master/leecode12%20int2roman.py" target="_blank" rel="noopener">Leetcode 12  int2roman</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/leetcode21%20merge2sortedlist.py" target="_blank" rel="noopener">Leetcode 21  merge2sortedlist</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/leetcode22%20generateParentheses.py" target="_blank" rel="noopener">Leetcode 22  generateParentheses</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/leetcode%2029%20%20DivideTwoIntegers.py" target="_blank" rel="noopener">Leetcode 29  DivideTwoIntegers</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/leetcode%2033%20%20SearchInRotatedSortedArray.py" target="_blank" rel="noopener">Leetcode 33  SearchInRotatedSortedArray</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/leetcode%2034%20%20FindFirstAndLastPositionInSortedArray.py" target="_blank" rel="noopener">Leetcode 34  FindFirstAndLastPositionInSortedArray</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/leetcode%2036%20%20ValidSudoku.py" target="_blank" rel="noopener">Leetcode 36  SearchInRotatedSortedArray</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/LongestPalindSubstring.py" target="_blank" rel="noopener">Leetcode 516 LongestPalindSubstring</a><h1 id="HARD"><a href="#HARD" class="headerlink" title="HARD"></a>HARD</h1></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/leetcode23%20mergeKsortedlist.py" target="_blank" rel="noopener">Leetcode 23  mergeKsortedlists</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Here are my solutions to the LeetCode problems, linking to my &lt;a href=&quot;https://github.com/dlc1994&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt; repository:&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://dlc1994.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://dlc1994.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://dlc1994.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Water Filling Algorithm and Matlab Simulation</title>
    <link href="https://dlc1994.github.io/Water-Filling-Algorithm-and-Matlab-simulation.html"/>
    <id>https://dlc1994.github.io/Water-Filling-Algorithm-and-Matlab-simulation.html</id>
    <published>2018-07-18T15:33:07.000Z</published>
    <updated>2019-04-29T13:36:59.220Z</updated>
    
    <content type="html"><![CDATA[<p><strong>注水算法</strong>是根据某种准则，并根据信道状况对发送功率进行自适应分配，通常是信道状况好的时刻，多分配功率，信道差的时候，少分配功率，从而最大化传输速率。</p><p>当接收端完全已知CSI（信道状态信息）而发送端未知CSI时，发送天线阵列中的功率平均分配是合理的。</p><p><strong>实现功率的“注水”分配，发送端必须知道CSI。</strong></p><p>直观而言，就如下图所示：</p><img src="/Water-Filling-Algorithm-and-Matlab-simulation/1.png" title="water filling"><p>图1 注水原理示意图（白色平台越高代表信道条件越差，注入的水就越少）</p><p>注水原理可以建模为下述优化问题：</p><script type="math/tex; mode=display">\begin{align}  & \underset{P_1,P_2,...,P_N}{\mathop{\max }}\,\text{          }{C_{sum}}=\sum_{n=1}^{N}{\log \left( 1+\frac{P_n{\left| {h_n} \right|}^2}{N_0} \right)}  \\ & \text{subject to      }\sum_{n=1}^{N}{P_n}={P}_{sum},n=1,2,...,N \\end{align}</script><p>其中${C}_{sum}$表示系统总信道容量，$N$为信道数，${P}_{n}$为第$n$个信道的功率，${h}_{n}$为第$n$个信道的信道增益，${N}_{0}$为噪声功率谱密度，${P}_{sum}$为传输总功率，也就是总水量。</p><p>该优化问题为凸优化问题，可以用拉格朗日乘数法求得全局最优解。</p><script type="math/tex; mode=display">\mathcal{L}(\lambda ,{P_1},{P_2},...,{P_N})=\sum_{n=1}^{N}{\log \left( 1+\frac{P_n{\left| {h_n} \right|}^2}{N_0} \right)}+\lambda (\sum_{n=1}^{N}{P_n}-P_{sum})</script><p>令$\frac{\partial \mathcal{L} }{\partial P_n}=\frac{\partial \mathcal{L} }{\partial \lambda }=0$，解得<strong>最优功率分配方案</strong>为：</p><script type="math/tex; mode=display">P_{n}^{*}={\left( \frac{1}{\lambda }-\frac{N_0}{\left| {h}_{n} \right|}^{2} \right)}^{+}</script><p>其中${(\centerdot )}^{+}$表示取值非负。</p><p><strong>MATLAB实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">clear all;</span><br><span class="line">channel_n=10;                         %channel number</span><br><span class="line">M=[5,10,20,50];                        %transmitted power</span><br><span class="line">N0=0.5;          </span><br><span class="line">h_1= random(&apos;rayleigh&apos;,1,1,channel_n);    %Rayleigh fading</span><br><span class="line">h_2=h_1.^2;                           %|h|.^2</span><br><span class="line">h_2_sorted=sort(h_2);                   %sort the channel gain</span><br><span class="line">h=h_2_sorted/N0;  </span><br><span class="line">syms lamda</span><br><span class="line">for m=1:length(M)</span><br><span class="line">    fprintf(&apos;transmitted power is %d watt&apos;,M(m));</span><br><span class="line">    for k=1:channel_n</span><br><span class="line">     p=zeros(1,channel_n);</span><br><span class="line">   sum=0;</span><br><span class="line">    for i=k:channel_n</span><br><span class="line">        sum=sum+(1/lamda-1/h(i));</span><br><span class="line">    end</span><br><span class="line">    f=sum-M(m);</span><br><span class="line">    x=solve(f,lamda);                    %find lamda</span><br><span class="line">    if k==1</span><br><span class="line">        if vpa(x)&gt;0 &amp;&amp; vpa(x)&lt;h(k)</span><br><span class="line">        for i=k:channel_n</span><br><span class="line">            p(i)=1/x-1/h(i);              %allocate power</span><br><span class="line">            capacity=capacity+log2(1+p(i)*h(i));%compute the capacity</span><br><span class="line">        end</span><br><span class="line">         p(i)=vpa(p(i),3)  </span><br><span class="line">         capacity=vpa(capacity,3)</span><br><span class="line">        end</span><br><span class="line">    else </span><br><span class="line">        if vpa(x)&gt;h(k-1) &amp;&amp; vpa(x)&lt;h(k)</span><br><span class="line">            capacity=0;</span><br><span class="line">        for i=k:channel_n</span><br><span class="line">            p(i)=1/x-1/h(i);               %allocate power</span><br><span class="line">            capacity=capacity+log2(1+p(i)*h(i)); %compute the capacity</span><br><span class="line">        end</span><br><span class="line">        p(i)=vpa(p(i),3)   </span><br><span class="line">        capacity=vpa(capacity,3)</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;注水算法&lt;/strong&gt;是根据某种准则，并根据信道状况对发送功率进行自适应分配，通常是信道状况好的时刻，多分配功率，信道差的时候，少分配功率，从而最大化传输速率。&lt;/p&gt;
&lt;p&gt;当接收端完全已知CSI（信道状态信息）而发送端未知CSI时，发送天线阵列中的功
      
    
    </summary>
    
      <category term="Wireless Communications" scheme="https://dlc1994.github.io/categories/Wireless-Communications/"/>
    
    
      <category term="Algorithms" scheme="https://dlc1994.github.io/tags/Algorithms/"/>
    
      <category term="Matlab" scheme="https://dlc1994.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>How to Make a Visual Mark Up and Revision of Significant Differences between Two Latex Files by Latexdiff</title>
    <link href="https://dlc1994.github.io/Latexdiff.html"/>
    <id>https://dlc1994.github.io/Latexdiff.html</id>
    <published>2018-06-19T15:34:10.000Z</published>
    <updated>2019-05-24T15:34:43.060Z</updated>
    
    <content type="html"><![CDATA[<p>Recently my survey was rejected and required minor revision, while I have to submit a revised article with the “editing mode” feature turned on. Because I use Miktex+Texstudio to edit my paper in windows 10, <code>Latexdiff</code> is considered of course.</p><blockquote><p><code>Latexdiff</code> is a Perl script for visual mark up and revision of significant differences between two LATEX files. Various options are available for visual mark up using standard LATEX packages such as <u>color</u>. Changes not di­rectly af­fect­ing vis­i­ble text, for ex­am­ple in for­mat­ting com­mands, are still marked in the LATEX source. A rudi­men­tary re­vi­sion fa­cilil­ity is pro­vided by an­other Perl script, la­texre­vise, which ac­cepts or re­jects all changes. Man­ual edit­ing of the dif­fer­ence file can be used to over­ride this de­fault be­haviour and ac­cept or re­ject se­lected changes only. </p></blockquote><h2 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1:"></a>Step 1:</h2><p>For a pure rookie, first of all, you need to install <a href="http://www.ctex.org/CTeXDownload/" target="_blank" rel="noopener">CTEX</a> (for Chinese users) or <a href="https://miktex.org/download" target="_blank" rel="noopener">Miktex</a>. </p><h2 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2:"></a>Step 2:</h2><p>Then, <code>win+R</code> and open <code>cmd</code>, input command <code>latexdiff</code>, if returns</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 and only 2 non-option arguments required. Write latexdiff -h to get help</span><br></pre></td></tr></table></figure><p>Congrats! You have successfully installed <code>latexdiff</code> and you can turn to <strong>Step 3.3</strong>.</p><h2 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3:"></a>Step 3:</h2><p>Otherwise, don’t worry, I encountered the same situation as you. Do as follows.</p><h3 id="3-1-Install-Latexdiff-Package"><a href="#3-1-Install-Latexdiff-Package" class="headerlink" title="3.1 Install Latexdiff Package"></a>3.1 Install <code>Latexdiff</code> Package</h3><p>After you install a Tex, open <code>Start Menu-&gt;Ctex or Miktex-&gt;Package Manager (Admin)</code>.</p><p>Search <code>Latexdiff</code> in column <code>Name:</code> as follows</p><img src="/Latexdiff/3.png" title="Install latexdiff"><p>Click the <code>+</code> button and install it.</p><h3 id="3-2-Install-Perl"><a href="#3-2-Install-Perl" class="headerlink" title="3.2 Install Perl"></a>3.2 Install <code>Perl</code></h3><p><code>Latexdiff</code> is a <code>Perl</code> script, so you can go to <a href="https://www.perl.org/get.html" target="_blank" rel="noopener">Perl</a> download corresponding version in your computer. Technically, <code>ActivePerl</code> and <code>StrawberryPerl</code> is both ok. </p><p>Same steps in <strong>Step 2</strong>, if you have problem as </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">latexdiff: The Perl script could not be found.  </span><br><span class="line">latexdiff: Data: scripts/latexdiff/perl/latexdiff.pl</span><br></pre></td></tr></table></figure><p>It’s  a common problem and you can find the answer in </p><p><a href="http://blog.sina.com.cn/s/blog_3ecd13560102vh95.html" target="_blank" rel="noopener">这里</a> or <a href="http://tex.stackexchange.com/questions/106785/installation-usage-of-latexdiff-on-windows-7" target="_blank" rel="noopener">Here</a>.</p><p>It is worth mentioning that if you have the following problem which confused me for a long time</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">latexmk: the script engine could not be found </span><br><span class="line">latexdiff: data: scriptengine=&quot;perl.exe&quot;</span><br></pre></td></tr></table></figure><p>Actually I have no idea how I successfully solve it. You may do the trials as what I have done.</p><ol><li>Check the System Path of <code>Perl</code> and <code>Tex</code>, especially according to <code>x86</code> or <code>x64</code></li><li>Reinstall <code>Perl</code>, if not work, change to <code>ActivePerl</code> or <code>StrawberryPerl</code></li><li>Restart your windows after you make some changes</li></ol><h3 id="3-3-Latexdiff"><a href="#3-3-Latexdiff" class="headerlink" title="3.3 Latexdiff"></a>3.3 <code>Latexdiff</code></h3><p>Put your origin tex version (e.g., <code>old.tex</code>) and your modified tex version (e.g., <code>new.tex</code>) in a same file. <code>cmd</code> to this path, and input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">latexdiff old.tex new.tex &gt;diff.tex</span><br></pre></td></tr></table></figure><p>where <code>diff.tex</code> is the editted version, add the required files to this path and compile it. Then you can have the results</p><img src="/Latexdiff/2.png" title="Final pdf"><p>If you encounter some errors in compiling, just google it because they are just some common LATEX errors. Enjoy.</p><p>!!!Tips: if you suffer any problem, first go to google or baidu it. </p><p><strong>Please discover the truth by yourself.</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Recently my survey was rejected and required minor revision, while I have to submit a revised article with the “editing mode” feature tur
      
    
    </summary>
    
      <category term="Paper Work" scheme="https://dlc1994.github.io/categories/Paper-Work/"/>
    
    
      <category term="Latex" scheme="https://dlc1994.github.io/tags/Latex/"/>
    
  </entry>
  
  <entry>
    <title>A Stupid Mistake I Made about Sorting in Python DataFrame</title>
    <link href="https://dlc1994.github.io/A-Stupid-Mistake-I-Made-about-Sorting-in-Python-DataFrame.html"/>
    <id>https://dlc1994.github.io/A-Stupid-Mistake-I-Made-about-Sorting-in-Python-DataFrame.html</id>
    <published>2018-06-12T02:47:31.000Z</published>
    <updated>2019-05-24T15:34:16.387Z</updated>
    
    <content type="html"><![CDATA[<p>One day when I try to sort a <code>DataFrame</code> by a column, an amazing mistake happens!</p><p>I will reproduce this stupid thing here. Firstly, make a dataframe example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   a  b  c</span><br><span class="line">0  9  4  6</span><br><span class="line">1  2  7  5</span><br><span class="line">2  5 -3  8</span><br><span class="line">3  1  2  3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(&#123;&quot;a&quot;:[9,2,5,1],&quot;b&quot;:[4,7,-3,2],&quot;c&quot;:[6,5,8,3]&#125;)</span><br><span class="line">frame.sort_values(&apos;a&apos;,inplace=True)</span><br><span class="line">print(frame)</span><br></pre></td></tr></table></figure><p>What do you think the result will be? What I expect it will get is like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   a  b  c</span><br><span class="line">3  1  2  3</span><br><span class="line">1  2  7  5</span><br><span class="line">2  5 -3  8</span><br><span class="line">0  9  4  6</span><br></pre></td></tr></table></figure><p>However, what I actually get is</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   a  b  c</span><br><span class="line">0  9  4  6</span><br><span class="line">1  2  7  5</span><br><span class="line">2  5 -3  8</span><br><span class="line">3  1  2  3</span><br></pre></td></tr></table></figure><p>I get really confused, so I try all the <em>arg</em> in function </p><blockquote><p>DataFrame.sort_values(by, axis=0, ascending=True, inplace=False, kind=’quicksort’, na_position=’last’)</p></blockquote><p>I find out that only if the <code>inplace=</code> is set to True, the result is as expected. But the usage of this function I searched in google, did not meantion this parameter.</p><p>Therefore, I look for an instruction of <code>inplace</code>， and I find that the <code>inplace</code> parameter is a generic term w.r.t pandas and not specific to <code>sort_values</code> alone. You can see it in several functions like <code>pd.fillna, pd.replace</code> etc. Whenever the <code>inplace</code> is set to True, it modifies the existing data frame and you need not assign it to a new data frame. </p><p>Ohhhh… Then I find out where the mistake really lies in. In my previous code, the DataFrame <code>frame</code> I sorted has not been modified only if the parameter <code>inplace</code> is set to True, so I modify the code as follow:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(&#123;&quot;a&quot;:[9,2,5,1],&quot;b&quot;:[4,7,-3,2],&quot;c&quot;:[6,5,8,3]&#125;)</span><br><span class="line">df = frame.sort_values(&apos;a&apos;,inplace=True)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p> The problem is solved! How stupid I was! </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;One day when I try to sort a &lt;code&gt;DataFrame&lt;/code&gt; by a column, an amazing mistake happens!&lt;/p&gt;
&lt;p&gt;I will reproduce this stupid thing he
      
    
    </summary>
    
      <category term="Data Processing" scheme="https://dlc1994.github.io/categories/Data-Processing/"/>
    
    
      <category term="Python" scheme="https://dlc1994.github.io/tags/Python/"/>
    
      <category term="DataFrame" scheme="https://dlc1994.github.io/tags/DataFrame/"/>
    
      <category term="Sorting" scheme="https://dlc1994.github.io/tags/Sorting/"/>
    
  </entry>
  
  <entry>
    <title>Hexo: setup a static blog</title>
    <link href="https://dlc1994.github.io/Hexo-setup-a-static-blog.html"/>
    <id>https://dlc1994.github.io/Hexo-setup-a-static-blog.html</id>
    <published>2018-06-12T01:46:53.000Z</published>
    <updated>2019-05-24T15:34:28.267Z</updated>
    
    <content type="html"><![CDATA[<p>​    Before we start, you have to know what is the difference between <strong>static</strong> site and <strong>dynamic</strong> site. Let’s take a look at the definition in Wiki:</p><blockquote><p>A <strong>static web page</strong> (sometimes called a <strong>flat page/stationary page</strong>) is a <a href="https://en.wikipedia.org/wiki/Web_page" target="_blank" rel="noopener">web page</a> that is delivered to the user exactly as stored, in contrast to <a href="https://en.wikipedia.org/wiki/Dynamic_web_page" target="_blank" rel="noopener">dynamic web pages</a> which are generated by a <a href="https://en.wikipedia.org/wiki/Web_application" target="_blank" rel="noopener">web application</a>. Consequently, a static web page displays the same information for all users, from all contexts, subject to modern capabilities of a web server to negotiate content-type or language of the document where such versions are available and the server is configured to do so. It’s pros and cons are listed as follows:</p><p> <strong>Advantages of a static website</strong></p><ul><li>Provide improved security over dynamic websites</li><li>Improved performance for end users compared to dynamic websites</li><li>Fewer or no dependencies on systems such as databases or other application servers</li></ul><p><strong>Disadvantages of a static website</strong></p><ul><li>Dynamic functionality has to be added separately</li></ul></blockquote><p>​    <strong>Dynamic site is not our topic here. I wil talk about how to deploy a hexo blog in Github repository under the environment of Window 10.</strong> </p><h1 id="1-Github-initialization"><a href="#1-Github-initialization" class="headerlink" title="1. Github initialization"></a>1. Github initialization</h1><p>​    From the very beginning, you have to create a <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> account and new a repository, note that the repository name need to be the same with your owner name (the alarm is appeared cause I have already newed a same one).</p><img src="/Hexo-setup-a-static-blog/2.jpg" title="Create a repository"><p><strong>REMEMBER</strong> the repository address (two kinds of address—- <code>SSH: git@github.com:dlc1994/dlc1994.github.io.git</code> and <code>HTTPS: https://github.com/dlc1994/dlc1994.github.io.git</code>). The configuration of SSH can be seen in <a href="https://www.cnblogs.com/superGG1990/p/6844952.html" target="_blank" rel="noopener">here</a>, and HTTPS has no need of extra operation.</p><p>Install <a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a> tool and the rest of operations is done through this tool.</p><h1 id="2-Install-the-necessary-components"><a href="#2-Install-the-necessary-components" class="headerlink" title="2. Install the necessary components"></a>2. Install the necessary components</h1><p>After that, install <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>, in case of the low speed, you can also download it in <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">here</a>.</p><p>Now it’s time to install Hexo in your machine, click right-hand button anywhere and open <code>Git Bash</code>, then input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install hexo-deployer-git  --save</span><br></pre></td></tr></table></figure><p>Wait a minute you can check if the component is installed successfully. Input directly in <code>Git Bash</code>, or <code>Win+R</code> and input <code>cmd</code>, then input codes as follow:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>If return the version number then you can go on, otherwise just google your mistake during your installation.</p><p>After Hexo is installed, go to the place where you want to save your blog and open <code>Git Bash</code>. Input <code>hexo init</code>, you can find that a lot of files are created. </p><h1 id="3-Create-your-first-blog"><a href="#3-Create-your-first-blog" class="headerlink" title="3. Create your first blog"></a>3. Create your first blog</h1><p>Use file editor like <a href="https://notepad-plus-plus.org/download/v7.5.6.html" target="_blank" rel="noopener">Notepad++</a>, open file <code>_config.yml</code>, find the codes and edit it as you want</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: DLC&apos;s Blog          #your blog name</span><br><span class="line">subtitle: Find myself in the darkest place #your blog subtitle</span><br><span class="line">description: Personal Blog#description of your blog</span><br><span class="line">keywords:</span><br><span class="line">author: </span><br><span class="line">language: </span><br><span class="line">timezone: Asia/Shanghai</span><br><span class="line"></span><br><span class="line">theme: landscape    #your blog theme, I will talk about how to change it to `Next`</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: </span><br><span class="line">  repository: git@github.com:dlc1994/dlc1994.github.io.git  #your repository address</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>In <code>Git Bash</code>, input <code>hexo g</code> and <code>hexo s</code>, it will return (perfectly)</p><p><code>Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</code></p><p>Open your browser and input <code>localhost:4000</code> in address bar, you can see that (Ok it is really ugly)</p><img src="/Hexo-setup-a-static-blog/4.png" title="Your First Blog"><p>Lastly, you have to deploy it to your github repository, continue to input <code>hexo d</code>. Luckily, there is no error and you can see it in your repository address like <code>git@github.com:dlc1994/dlc1994.github.io.git</code>. If not, go to google for help.</p><p>Create a new blog use <code>hexo new &quot;postname&quot;</code> or in your blog path <code>blogpath\source\_posts</code> new a <code>.md</code> file and edit it use Markdown (<a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a> is recommended here).</p><p>More commands can be found <a href="https://hexo.io/docs/commands.html" target="_blank" rel="noopener">here</a>. I will update the process of blog beautification in my next blogs.</p><p>!!!Tips: if you suffer any problem, first go to google or baidu it. </p><p><strong>Please discover the truth by yourself.</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    Before we start, you have to know what is the difference between &lt;strong&gt;static&lt;/strong&gt; site and &lt;strong&gt;dynamic&lt;/strong&gt; site. Let
      
    
    </summary>
    
      <category term="HEXO" scheme="https://dlc1994.github.io/categories/HEXO/"/>
    
    
      <category term="Hexo" scheme="https://dlc1994.github.io/tags/Hexo/"/>
    
      <category term="Markdown" scheme="https://dlc1994.github.io/tags/Markdown/"/>
    
  </entry>
  
</feed>
