<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LC-Garden</title>
  
  <subtitle>博客没维护好，丢失源文件了，之后慢慢加回来吧</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dlc1994.github.io/"/>
  <updated>2021-07-19T16:09:26.283Z</updated>
  <id>https://dlc1994.github.io/</id>
  
  <author>
    <name>Lingcheng Dai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何编写高效、优雅、可信代码系列（4）——今天教你学会用函数指针</title>
    <link href="https://dlc1994.github.io/2021/07/19/ckratpwl0000n04veb170faj2/"/>
    <id>https://dlc1994.github.io/2021/07/19/ckratpwl0000n04veb170faj2/</id>
    <published>2021-07-19T15:59:53.000Z</published>
    <updated>2021-07-19T16:09:26.283Z</updated>
    
    <content type="html"><![CDATA[<p>故事的起源来自于，没错，又是来自于业务。</p><p>事实是这样的，我在重构一段代码的时候，发现有两个函数的代码近乎80%都是相同的，区别在于根据不同的条件局部调用不同的两个函数，很难搞，因为一是抽个abstract class太麻烦，二是函数里是循环，在循环里判断又影响性能，不管吧，也影响代码重复率。这个时候我想到了函数指针！</p><h1 id="1-函数指针的定义和作用"><a href="#1-函数指针的定义和作用" class="headerlink" title="1. 函数指针的定义和作用"></a>1. 函数指针的定义和作用</h1><p>我们先来看看wiki的定义</p><blockquote><p>【from wiki】 A function pointer, also called a <code>subroutine pointer</code> or <code>procedure pointer</code>, is a pointer that points to a function. As opposed to referencing a data value, a function pointer points to executable code within memory. Dereferencing the function pointer yields the referenced function, which can be invoked and passed arguments just as in a normal function call. Such an invocation is also known as an “indirect” call, because the <strong>function is being invoked indirectly through a variable instead of directly through a fixed identifier or address</strong>.</p><p>Function pointers can be used to <strong>simplify code</strong> by providing a simple way to select a function to execute based on <strong>run-time</strong> values.  </p></blockquote><p>重点已经在上面标出来了，函数指针的作用之一是简化代码。</p><p>那么c++标准委员会仅仅是为了让我们写clean code吗？</p><p>Obviously not! Another use for function pointers is setting up <strong>“listener”</strong> or <strong>“callback”</strong> functions that are invoked when a particular event happens. </p><p>什么是回调函数呢？比如你为图形用户界面 (GUI) 编写代码时。大多数情况下，用户将与允许鼠标指针移动并重绘界面的循环进行交互。但是，有时用户会单击按钮或在字段中输入文本。这些操作是“事件”，可能需要您的程序需要处理的响应。你的代码怎么知道发生了什么？使用回调函数！用户的点击应该会导致界面调用您编写的用于处理事件的函数。</p><h1 id="2-函数指针的用法"><a href="#2-函数指针的用法" class="headerlink" title="2. 函数指针的用法"></a>2. 函数指针的用法</h1><p>说了这么多，你是不是已经跃跃欲试，恨不得马上重构自己的代码以降低重复率了，hold on! hold on!先看完用法再去操作，磨刀不误砍柴工。</p><h2 id="2-1-函数指针的声明"><a href="#2-1-函数指针的声明" class="headerlink" title="2.1 函数指针的声明"></a>2.1 函数指针的声明</h2><p>先来看看函数指针的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *(*foo)(int *);</span><br></pre></td></tr></table></figure><p>表达式的最里面的元素是 <code>*foo</code>，它应该指向一个返回 <code>void *</code> 并采用 <code>int *</code>作为参数的函数。因此，foo是指向这样一个函数的指针。</p><p>还可以用<code>typedef</code>简化函数指针的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int test(int a)</span><br><span class="line">&#123;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    typedef int (*foo)(int a);</span><br><span class="line">    foo f = test;</span><br><span class="line">    cout &lt;&lt; foo(2) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-函数指针的初始化"><a href="#2-2-函数指针的初始化" class="headerlink" title="2.2 函数指针的初始化"></a>2.2 函数指针的初始化</h2><p>为了初始化一个函数指针，需要给它一个程序内的函数地址，比如下面的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void MyFun(int x)</span><br><span class="line">&#123;</span><br><span class="line">    printf( &quot;我是%d颗大西瓜。\n&quot;, x );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // way 1</span><br><span class="line">    void (*foo)(int);</span><br><span class="line">    foo = &amp;MyFun;</span><br><span class="line">    // way 2</span><br><span class="line">    void (*foo)(int) = &amp;MyFun;</span><br><span class="line">    // way 3</span><br><span class="line">    auto foo = &amp;MyFun;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三种方式都是可以的。如果是指向类函数呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">        A(int aa = 0):a(aa)&#123;&#125;</span><br><span class="line">        ~A()&#123;&#125;</span><br><span class="line">        void SetA(int aa = 1)</span><br><span class="line">        &#123;</span><br><span class="line">            a = aa;</span><br><span class="line">        &#125;</span><br><span class="line">        virtual void Print()</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;A: &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    private:</span><br><span class="line">        int a;</span><br><span class="line">&#125;;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    A a;</span><br><span class="line">    void (A::*ptr)(int) = &amp;A::setA;</span><br><span class="line">    A* pa = &amp;a;</span><br><span class="line">    </span><br><span class="line">    //对于非虚函数，返回其在内存的真实地址</span><br><span class="line">    printf(&quot;A::Set(): %p\n&quot;, &amp;A::SetA);</span><br><span class="line">    //对于虚函数， 返回其在虚函数表的偏移位置</span><br><span class="line">    printf(&quot;A::Print(): %p\n&quot;, &amp;A::print);</span><br><span class="line"> </span><br><span class="line">    a.Print();</span><br><span class="line">    a.SetA(10);</span><br><span class="line">    //对于指向类成员函数的函数指针，引用时必须传入一个类对象的this指针，所以必须由类实体调用(如果是在类内调用就用*this)</span><br><span class="line">    (pa-&gt;*ptr)(1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-让我们来看看成果"><a href="#2-3-让我们来看看成果" class="headerlink" title="2.3 让我们来看看成果"></a>2.3 让我们来看看成果</h2><p>下面是用不同的order进行的选择排序代码，请看成片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;utility&gt; // for std::swap</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">// Note our user-defined comparison is the third parameter</span><br><span class="line">void selectionSort(int *array, int size, bool (*comparisonFcn)(int, int))</span><br><span class="line">&#123;</span><br><span class="line">    // Step through each element of the array</span><br><span class="line">    for (int startIndex &#123;0&#125;; startIndex &lt; (size - 1); ++startIndex) &#123;</span><br><span class="line">        // bestIndex is the index of the smallest/largest element we&apos;ve encountered so far.</span><br><span class="line">        int bestIndex &#123;startIndex&#125;;</span><br><span class="line">        // Look for smallest/largest element remaining in the array (starting at startIndex+1)</span><br><span class="line">        for (int currentIndex&#123; startIndex + 1 &#125;; currentIndex &lt; size; ++currentIndex) &#123;</span><br><span class="line">            // If the current element is smaller/larger than our previously found smallest</span><br><span class="line">            if (comparisonFcn(array[bestIndex], array[currentIndex])) &#123; // COMPARISON DONE HERE</span><br><span class="line">                // This is the new smallest/largest number for this iteration</span><br><span class="line">                bestIndex = currentIndex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // Swap our start element with our smallest/largest element</span><br><span class="line">        std::swap(array[startIndex], array[bestIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// Here is a comparison function that sorts in ascending order</span><br><span class="line">bool ascending(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    return x &gt; y; // swap if the first element is greater than the second</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// Here is a comparison function that sorts in descending order</span><br><span class="line">bool descending(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    return x &lt; y; // swap if the second element is greater than the first</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// This function prints out the values in the array</span><br><span class="line">void printArray(int *array, int size)</span><br><span class="line">&#123;</span><br><span class="line">    for (int index&#123; 0 &#125;; index &lt; size; ++index) &#123;</span><br><span class="line">        std::cout &lt;&lt; array[index] &lt;&lt; &apos; &apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; &apos;\n&apos;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int array[9] &#123; 3, 7, 9, 5, 6, 1, 8, 2, 4 &#125;;</span><br><span class="line"> </span><br><span class="line">    // Sort the array in descending order using the descending() function</span><br><span class="line">    selectionSort(array, 9, descending);</span><br><span class="line">    printArray(array, 9);</span><br><span class="line"> </span><br><span class="line">    // Sort the array in ascending order using the ascending() function</span><br><span class="line">    selectionSort(array, 9, ascending);</span><br><span class="line">    printArray(array, 9);</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-后记"><a href="#3-后记" class="headerlink" title="3. 后记"></a>3. 后记</h1><p>是不是看起来还挺优雅的，函数指针的好处可以总结如下</p><ul><li><strong>GOOD1: 函数指针提供了一种传递有关如何做某事的指令的方法</strong></li><li><strong>GOOD2: 可以编写灵活的函数和库，允许程序员通过将函数指针作为参数传递来选择行为（当然这种灵活性也可以通过使用具有虚函数的类来实现）</strong></li><li><strong>GOOD3: 可以简化代码</strong></li></ul><p>但是every coin has two sides，函数指针也不是百利而无一害，我也总结了一些，大家可以继续补充</p><ul><li><strong>BAD1: 性能开销。</strong> 让我们回到它的定义，正如一个指针变量保存的是变量的地址一样，只不过函数指针保存的是函数的地址，并且是运行时才能确定的变量。理论来说，直接函数调用开销更小，因为函数指针调用需要先访问数据区，再访问函数，增加指令开销，同时，数据取值与函数指令加载必须串行执行，影响CPU流水性能；普通的函数调用可以做内联优化。<em>不过幸好编译器可以将函数指针的调用开销优化到跟普通的函数调用相同（优化选项O1及以上，具体可参考<a href="https://zhuanlan.zhihu.com/p/84887035）">https://zhuanlan.zhihu.com/p/84887035）</a></em></li><li><strong>BAD2: 代码可读性。</strong> 区别于传统的函数调用，我们在进入到使用函数指针作为参数的函数中时，有时会很抓狂，比如上面的<code>selectionSort()</code>，我在阅读到<code>comparisonFcn()</code>的时候无法确认这个函数的行为，需要往外跳一层才能知道什么情况下这个函数是升序还是降序；更令人抓狂的是，更为复杂的函数中（假如作者不写任何注释），你会破口大骂谁写的函数指针，而且点跳转还无法跳转到相应的函数实现中（没错，我有时候是会骂自己的T.T）。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;故事的起源来自于，没错，又是来自于业务。&lt;/p&gt;
&lt;p&gt;事实是这样的，我在重构一段代码的时候，发现有两个函数的代码近乎80%都是相同的，区别在于根据不同的条件局部调用不同的两个函数，很难搞，因为一是抽个abstract class太麻烦，二是函数里是循环，在循环里判断又影响
      
    
    </summary>
    
      <category term="C++" scheme="https://dlc1994.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://dlc1994.github.io/tags/C/"/>
    
      <category term="函数指针" scheme="https://dlc1994.github.io/tags/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>如何编写高效、优雅、可信代码系列（3）——类成员初始化的三种方式</title>
    <link href="https://dlc1994.github.io/2021/06/28/ckratpwl0000o04vet0137vlp/"/>
    <id>https://dlc1994.github.io/2021/06/28/ckratpwl0000o04vet0137vlp/</id>
    <published>2021-06-28T03:11:53.000Z</published>
    <updated>2021-06-28T15:36:20.927Z</updated>
    
    <content type="html"><![CDATA[<p>首先，先得了解一下C++支持哪几种类成员初始化的方式，你常用的又是哪一种。<br><a id="more"></a></p><ul><li><p>初始化方式一：初始化列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int a; // 初始化列表</span><br><span class="line">    A(int a_):a(a_)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>初始化方式二：构造函数初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int a; // 初始化列表</span><br><span class="line">    A(int a_, bool b) &#123; a = a_; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>初始化方式三：声明时初始化（也称就地初始化，c++11后支持）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int a = 1; // 声明时初始化</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>在C++98中，支持了在类声明中使用等号“=”加初始值的方式，来初始化类中静态成员常量。这种声明方式我们也称之为“就地”声明。就地声明在代码编写时非常便利，不过C++98对类中就地声明的要求却非常高。如果静态成员不满足常量性，则不可以就地声明，而且即使常量的静态成员也只能是整型或者枚举型才能就地初始化。而非静态成员变量的初始化则必须在构造函数中进行。比如，如下代码在c++98中编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Init</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Init(): a(0) []</span><br><span class="line">    Init(int d): a(d) &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    int a;</span><br><span class="line">    const static int b = 0;</span><br><span class="line"></span><br><span class="line">    int c = 1;           // member, cannot pass build</span><br><span class="line">    static int d = 0;    // member, cannot pass build</span><br><span class="line"></span><br><span class="line">    static const double e = 1.3;      // not int or enum type, cannot pass build</span><br><span class="line">    stati const char* const f = &quot;e&quot;;  // not int or enum type, cannot pass build</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这非常不方便，所以在C++11中，标准允许非静态成员变量的初始化有多种形式。具体而言，除了初始化列表外，在C++11中，标准还允许使用<strong>等号=</strong> 或者 <strong>花括号{}</strong> 进行就地的非静态成员变量初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct init &#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    double b &#123;1.2&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>大家知道，有几种情况下推荐优先使用列表初始化</p><ul><li><strong>const成员变量只能用成员初始化列表来完成初始化，而不能在构造函数内赋值</strong></li><li><strong>初始化的数据成员是对象</strong></li><li><strong>需要初始化引用成员数据</strong></li></ul><p>具体的原因这里不细述，大家可以去看一下《C++ Primer》。</p><p>构造函数初始化的本质是赋值操作（”=”），这个方法存在两个问题，一个是比起初始化列表和就地初始化，此方式的效率偏低；第二个是可能存在错误隐患。</p><p>先说第一个，赋值过程中会产生临时对象，临时对象的构造析构会造成效率损耗，初始化列表的方式就避免了产生临时对象缩带来的问题。</p><p>第二个是，如果你没有重写或者禁止赋值构造函数，c++会悄悄的加上默认的赋值构造函数，这个时候也有可能带来问题。</p><p>从C++11之后，这三种初始化的方法都可以使用，并不会存在冲突，但是，他们之间是有优先级顺序的，这个优先级来源于他们在初始化的时间顺序，后面初始化的会把前面的覆盖掉，成员变量的初始化顺序是</p><p><strong>声明时初始化-&gt;初始化列表-&gt;构造函数初始化</strong></p><p>因此假如三种初始化方式同时存在的话，那么最后保留的成员变量值肯定是构造函数中初始化的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int a = 1;</span><br><span class="line">    A(int a_) :a(2) &#123; a = 3; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    A a;</span><br><span class="line">    cout &lt;&lt; &quot;a.a=&quot; &lt;&lt; a.a &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// a.a=3</span><br></pre></td></tr></table></figure></p><p>既然初始化方式这么多，那么什么时候适用哪种呢？</p><p><strong>1. 声明时初始化的使用场景</strong></p><ul><li>一个优点是直观，你在声明的时候顺便给一个初始值，bravo，别人在看你代码的时候，点一下调到声明也能看到你赋予的初始值，不用再去看构造函数那里给的什么值</li><li>第二个优点更有用了，比如你要定义多个构造函数，每个构造函数都用列表初始化的方法初始化，多麻烦呀，请看下面的例子，妈妈看了再也不用担心我想用其他初始化方法了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Group &#123;</span><br><span class="line">public:</span><br><span class="line">    Group() &#123;&#125;</span><br><span class="line">    Group(int a): data(a) &#123;&#125;</span><br><span class="line">    Group(Mem m): mem(m) &#123;&#125;</span><br><span class="line">    Group(int a, Mem m, string n): data(a), mem(m), name(n) &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    int data = 1;</span><br><span class="line">    Mem mem&#123;0&#125;;</span><br><span class="line">    string name&#123;&quot;Group&quot;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>2. 列表初始化的使用场景</strong><br>前面说过了三个场景，这里赘述一下</p><ul><li>const成员变量只能用成员初始化列表来完成初始化，而不能在构造函数内赋值</li><li>初始化的数据成员是对象</li><li>需要初始化引用成员数据</li></ul><p>但是，需要注意列表初始化的顺序，不过IDE会提示你的</p><p><strong>3. 构造函数初始化的使用场景</strong></p><ul><li>第一个就是拷贝和赋值构造函数里（不然怎么叫赋值构造函数呢）</li><li>第二个就是比较无聊的情况了，比如你想把几个成员函数都初始化成一个值，请看下面例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Group &#123;</span><br><span class="line">public:</span><br><span class="line">    Group() &#123;data1 = data2 = data3 = 0;&#125;</span><br><span class="line">private:</span><br><span class="line">    int data1;</span><br><span class="line">    int data2;</span><br><span class="line">    int data3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>一言以蔽之，优先就地初始化和列表初始化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，先得了解一下C++支持哪几种类成员初始化的方式，你常用的又是哪一种。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="https://dlc1994.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://dlc1994.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>如何编写高效、优雅、可信代码系列（1）——C++多线程强制终止</title>
    <link href="https://dlc1994.github.io/2021/06/28/ckratpwl0000r04ve6gj48jjg/"/>
    <id>https://dlc1994.github.io/2021/06/28/ckratpwl0000r04ve6gj48jjg/</id>
    <published>2021-06-28T03:11:53.000Z</published>
    <updated>2021-06-28T15:38:12.906Z</updated>
    
    <content type="html"><![CDATA[<p>故事的起因来源于我在优化他人c++源码的时候，想通过多线程的方式提升程序的运算效率，主要存在以下需求和难点：</p><ol><li>多个线程并行跑模型，看哪个模型跑的快，跑出来后结束其他线程，线程间独立运行无通信过程</li><li>源码模型很复杂，函数调用较多，不好改动，因此不太适合通过信号或标志进行通信终止<a id="more"></a></li></ol><p>网上搜索了一下线程结束的几种方式：</p><ol><li><strong>线程函数的return返回（建议）</strong>。这种退出线程的方式是最安全的，在线程函数return返回后, 会清理函数内申请的类对象, 即调用这些对象的析构函数.。然后会自动调用 _endthreadex()函数来清理 _beginthreadex()函数申请的资源(主要是创建的tiddata对象)。</li><li><strong>同一个进程或另一个进程中的线程调用TerminateThread函数（应避免使用该方法）</strong>。TerminateThread能够撤消任何线程，其中hThread参数用于标识被终止运行的线程的句柄。当线程终止运行时，它的退出代码成为你作为dwExitCode参数传递的值。同时，线程的内核对象的使用计数也被递减。注意TerminateThread函数是异步运行的函数，也就是说，它告诉系统你想要线程终止运行，但是，当函数返回时，不能保证线程被撤消。如果需要确切地知道该线程已经终止运行，必须调用WaitForSingleObject或者类似的函数，传递线程的句柄。</li><li><strong>通过调用ExitThread函数，线程将自行撤消（最好不使用该方法）</strong>。该函数将终止线程的运行，并导致操作系统清除该线程使用的所有操作系统资源。但是，C++资源（如C++类对象）将不被析构。</li><li><strong>ExitProcess和TerminateProcess函数也可以用来终止线程的运行（应避免使用该方法）</strong>。</li></ol><p>选项2和3可能会导致内存泄漏，实际上，没有任何语言或操作系统可以为你提供异步突然终止线程的便利，且不会警告你不要使用它们。所有这些执行环境都强烈建议开发人员，甚至要求在协作或同步线程终止的基础上构建多线程应用程序。</p><p>现有的线程结束函数，包括linux系统的<code>pthread.h</code>中的<code>pthread_exit()</code>和<code>pthread_cancel()</code>，windows系统的<code>win32.h</code>中的<code>ExitThread()</code>和<code>TerminateThread()</code>，也就是说，<strong>C++没有提供kill掉某个线程的能力，只能被动地等待某个线程的自然结束</strong>，析构函数<code>~thread()</code>也不能停止线程，析构函数只能在线程静止时终止线程<code>joinable</code>，对于连接/分离的线程，析构函数根本无法终止线程。</p><p>要终止与OS /编译器相关的函数的线程，我们需要知道如何从C++获取本机线程数据类型std::thread。幸运的是，在调用或之前<code>std::thread</code>提供了一个API <code>native_handle()</code>以获取线程的本机句柄类型。并且可以将此本地句柄传递给本地OS线程终止函数，例如<code>join() detach() pthread_cancel()</code>。</p><p>以下代码用于显示<code>std::thread::native_handle()</code>，<code>std::thread::get_id()</code>并<code>pthread_self()</code>返回相同的代码<code>pthread_t</code>来处理Linux / GCC的C++线程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"> </span><br><span class="line">std::mutex iomutex;</span><br><span class="line">void f(int num)</span><br><span class="line">&#123;</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::seconds(1));</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lk(iomutex);</span><br><span class="line">    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; num &lt;&lt; &quot; pthread_t &quot; &lt;&lt; pthread_self() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::thread t1(f, 1), t2(f, 2);</span><br><span class="line">    </span><br><span class="line">    //t1.join(); t2.join();  ----------------pos 1</span><br><span class="line">    //t1.detach(); t2.detach(); -------------pos 2</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Thread 1 thread id &quot; &lt;&lt; t1.get_id() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;Thread 2 thread id &quot; &lt;&lt; t2.get_id() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Thread 1 native handle &quot; &lt;&lt; t1.native_handle() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;Thread 2 native handle &quot; &lt;&lt; t2.native_handle() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    t1.join(); t2.join();</span><br><span class="line">    //t1.detach(); t2.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行后可以得到结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -Wall -std=c++11 cpp_thread_pthread.cc -o cpp_thread_pthread -pthread -lpthread</span><br><span class="line">$ ./cpp_thread_pthread </span><br><span class="line">Thread 1 thread id 140109390030592</span><br><span class="line">Thread 2 thread id 140109381637888</span><br><span class="line">Thread 1 native handle 140109390030592</span><br><span class="line">Thread 2 native handle 140109381637888</span><br><span class="line">Thread 1 pthread_t 140109390030592</span><br><span class="line">Thread 2 pthread_t 140109381637888</span><br></pre></td></tr></table></figure></p><p><code>uncomment</code>pos 1或者pos 2后，即调用join()或之后detach()，C++线程会丢失本机句柄类型的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./cpp_thread_pthread</span><br><span class="line">Thread 1 pthread_t 139811504355072</span><br><span class="line">Thread 2 pthread_t 139811495962368</span><br><span class="line">Thread 1 thread id thread::id of a non-executing thread</span><br><span class="line">Thread 2 thread id thread::id of a non-executing thread</span><br><span class="line">Thread 1 native handle 0</span><br><span class="line">Thread 2 native handle 0</span><br></pre></td></tr></table></figure></p><p>因此，要有效地调用本机线程终止函数（例如<code>pthread_cancel</code>），需要在调用<code>std::thread::join()</code>时或之前保存本机句柄<code>std::thread::detach()</code>。这样，始终可以使用有效的本机句柄终止线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">    void sleep_for(const std::string &amp;tname, int num)</span><br><span class="line">    &#123;</span><br><span class="line">        prctl(PR_SET_NAME,tname.c_str(),0,0,0);        </span><br><span class="line">        sleep(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void start_thread(const std::string &amp;tname)</span><br><span class="line">    &#123;</span><br><span class="line">        std::thread thrd = std::thread(&amp;Foo::sleep_for, this, tname, 3600);</span><br><span class="line">        tm_[tname] = thrd.native_handle();</span><br><span class="line">        thrd.detach();</span><br><span class="line">        std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; tname &lt;&lt; &quot; created:&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void stop_thread(const std::string &amp;tname)</span><br><span class="line">    &#123;</span><br><span class="line">        ThreadMap::const_iterator it = tm_.find(tname);</span><br><span class="line">        if (it != tm_.end()) &#123;</span><br><span class="line">            pthread_cancel(it-&gt;second);</span><br><span class="line">            tm_.erase(tname);</span><br><span class="line">            std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; tname &lt;&lt; &quot; killed:&quot; &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    typedef std::unordered_map&lt;std::string, pthread_t&gt; ThreadMap;</span><br><span class="line">    ThreadMap tm_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    std::string keyword(&quot;test_thread&quot;);</span><br><span class="line">    std::string tname1 = keyword + &quot;1&quot;;</span><br><span class="line">    std::string tname2 = keyword + &quot;2&quot;;</span><br><span class="line"></span><br><span class="line">    // create and kill thread 1</span><br><span class="line">    foo.start_thread(tname1);</span><br><span class="line">    foo.stop_thread(tname1);</span><br><span class="line"></span><br><span class="line">    // create and kill thread 2</span><br><span class="line">    foo.start_thread(tname2);</span><br><span class="line">    foo.stop_thread(tname2);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -Wall -std=c++11 kill_cpp_thread.cc -o kill_cpp_thread -pthread -lpthread</span><br><span class="line">$ ./kill_cpp_thread </span><br><span class="line">Thread test_thread1 created:</span><br><span class="line">30332 30333 pts/5    00:00:00 test_thread1</span><br><span class="line">Thread test_thread1 killed:</span><br><span class="line">Thread test_thread2 created:</span><br><span class="line">30332 30340 pts/5    00:00:00 test_thread2</span><br><span class="line">Thread test_thread2 killed:</span><br></pre></td></tr></table></figure></p><p>当然，条件允许的话最好还是使用返回或信号的方式终止线程，这样也符合安全可信的要求。</p><p>【转载声明】转载请附上原贴，阿里嘎多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;故事的起因来源于我在优化他人c++源码的时候，想通过多线程的方式提升程序的运算效率，主要存在以下需求和难点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多个线程并行跑模型，看哪个模型跑的快，跑出来后结束其他线程，线程间独立运行无通信过程&lt;/li&gt;
&lt;li&gt;源码模型很复杂，函数调用较多，不好改动，因此不太适合通过信号或标志进行通信终止&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="C++" scheme="https://dlc1994.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://dlc1994.github.io/tags/C/"/>
    
      <category term="多线程" scheme="https://dlc1994.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>如何编写高效、优雅、可信代码系列（2）——你真的会用new吗</title>
    <link href="https://dlc1994.github.io/2021/06/28/ckratpwl0000s04veqdquq8i6/"/>
    <id>https://dlc1994.github.io/2021/06/28/ckratpwl0000s04veqdquq8i6/</id>
    <published>2021-06-28T03:11:53.000Z</published>
    <updated>2021-06-28T15:39:31.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h1><h2 id="1-c-内存分配"><a href="#1-c-内存分配" class="headerlink" title="1. c++内存分配"></a>1. c++内存分配</h2><p>c++中的程序加载到内存后按照代码区、数据区、堆区、栈区进行布局，其中数据区又可以分为自由存储区、全局/静态存储区和常量存储区，各区所长如下：</p><ul><li>栈区<br>函数执行的时候，局部变量的存储单元都在栈上创建，函数执行结束后存储单元会自动释放。<strong>栈内存分配运算内置于处理器指令集中，效率高，但分配内存容量有限。</strong></li><li>堆区<br>堆就是new出来的内存块，编译器不管释放，由应用程序控制，<strong>new对应delete</strong>。如果没释放掉，程序结束后，操作系统会自动回收。</li><li>自由存储区<br>C中malloc分配的内存块。用free结束生命周期。</li><li>全局/静态存储区<br>全局变量和静态变量被分配到同一块内存中，<strong>定义的时候就会初始化</strong>。</li><li>常量存储区<br>比较特殊的存储区，存放常量，不允许修改。</li></ul><p>堆和栈的区别</p><ul><li>管理方式<br>栈由编译器自动管理，堆由程序员控制</li><li>空间大小<br>32位系统下，堆内存可以达到4GB，栈有一定的空间大小</li><li>碎片管理<br>对于堆，频繁的new/delete肯定造成内存空间的不连续，产生大量内存碎片降低程序效率；栈由于遵循先进后出的规则，不会产生空隙</li><li>生长方向<br>堆是向上生长的，即向着内存地址增加的方向增长；而栈是向着内存地址减小的方向增长的</li><li>分配方式<br>堆是动态分配的，栈有动态分配和静态分配之分：静态分配由编译器完成，动态分配由alloca函数完成，即使是动态分配，依然是编译器自动释放</li><li>分配效率<br>计算机底层提供了栈的支持，分配了专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这决定了栈的效率会比较高。堆则是由C/C++函数库提供的，机制比较复杂，比如为了分配某个大小的内存需要在堆内存中搜索可用足够大小的空间，效率比栈要低的多</li></ul><h2 id="2-new-delete和new-delete"><a href="#2-new-delete和new-delete" class="headerlink" title="2. new/delete和new []/delete []"></a>2. new/delete和new []/delete []</h2><ul><li>回收new分配的单个对象内存空间时用delete，回收用new[]分配的一组对象时用delete[]</li><li>对于内置类型(int/double/float/char/…)，由于new[]申请内存时，编译器还会悄悄在内存中保存整数，表示指针数组的个数，所以delete/delete[]都可以正确释放所申请的内存空间</li><li>建议在调用new时使用的[]，那么调用delete也使用[]</li></ul><h2 id="3-new的三种形态"><a href="#3-new的三种形态" class="headerlink" title="3. new的三种形态"></a>3. new的三种形态</h2><ul><li><strong>new operator</strong> 常用的new，语言函数内建，不能重载。调用过程中实际完成的有三件事：<ol><li>为类型对象分配内存；</li><li>调用构造函数初始化内存对象；</li><li>返回对象指针<br>如果是在堆上建立对象，直接使用new operator。</li></ol></li><li><strong>operator new</strong> 普通操作符，可以重载。如果仅仅是分配内存，那么应该调用operator new，但不负责初始化。系统默认提供的分配器在时间和空间两方面都存在一些问题：分配器速度较慢，分配小型对象时空间浪费严重，重载new/delete有三方面好处：<ol><li>改善效率</li><li>检测代码中的内存错误</li><li>获得内存使用的统计数据</li></ol><ul><li>C++标准规定，重载的operator new必须是类成员函数或全局函数，全局的operator new重载不应该改变原有签名，而是直接无缝替换原有版本。全局重载很有侵略性，别人使用你的库无法使用默认的new，而具体类的重载只会影响本class和其派生类，但是类的operator new函数重载必须声明为static，因为operator new是在类的具体对象被构建出来之前调用的。</li><li>为了获得2和3的优势，重载的operator new需要如下函数声明<code>void* operator new(size_t, const char* file, int line);</code></li><li></li></ul></li><li><strong>placement new</strong> 定义在库&lt;<new>&gt;中。如果想在一块已经获得内存里建立对象，那么应该调用placement new。通常情况不建议使用，但在<strong>某些对时间要求非常高的应用中</strong>可以考虑，因为选择合适的构造函数完成对象初始化是一个时间相对较长的过程。</new></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-内存管理&quot;&gt;&lt;a href=&quot;#C-内存管理&quot; class=&quot;headerlink&quot; title=&quot;C++内存管理&quot;&gt;&lt;/a&gt;C++内存管理&lt;/h1&gt;&lt;h2 id=&quot;1-c-内存分配&quot;&gt;&lt;a href=&quot;#1-c-内存分配&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="C++" scheme="https://dlc1994.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://dlc1994.github.io/tags/C/"/>
    
      <category term="内存管理" scheme="https://dlc1994.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dlc1994.github.io/2021/06/22/ckratpwl0000w04ve98fgk3gd/"/>
    <id>https://dlc1994.github.io/2021/06/22/ckratpwl0000w04ve98fgk3gd/</id>
    <published>2021-06-22T14:03:11.811Z</published>
    <updated>2021-06-22T14:57:12.181Z</updated>
    
    <content type="html"><![CDATA[<p>在primal simplex算法中，每轮迭代都需要选择most candidate的方向并移动到邻近的顶点上，那么，用什么来评估方向的好坏呢？我们知道，选择一个方向走下去对目标值的改善程度是由方向和步长决定的，对于标准型的线性规划问题而言，使目标值下降的方向是reduced cost $d_j &lt;= 0$的那些非基变量，理论上来说，任意一个满足$d_j &lt;= 0$条件的非基变量都可以作为入基，但是我们不是那么随便的人，肯定不会随便选，那要如何选择呢？</p><p>用一高一矮两个人来比喻，同样是走100步，你觉得是高的人走的远还是矮的人走得远呢（莫杠，正常场景）？同理，我这里当然是选择单位步长下能走更远的非基变量，当然，步长也是决定你能走多远的重要因素，这里暂且不论，就考虑最基本的dantzig的选基算法，即</p><script type="math/tex; mode=display">q\in \underset{j\in N}{\argmin} \bar{z}_j</script><p>选入基的法则非常简单对不对，那么假设你处在某一次迭代中，想要计算所有非基变量的reduced cost $d_j, j\in N$，难道需要用reduced cost的计算公式每次计算？</p><script type="math/tex; mode=display">\bar{z}_N = c_N - N^TB^{-T}c_B</script><p>显然大家不会那么傻，就跟revised simplex的$B^{-1}$更新一样，两次迭代间的reduced cost也是有关联关系的，接下来就给大家推导一下，不感兴趣的可以直接跳到结论了哈。</p><p>对于一个genenal形式的LP问题：</p><script type="math/tex; mode=display">\begin{aligned} \min:& \quad c^T x \\ s.t.:& \quad a \le Ax \le b, \\      & \quad l \le x \le u\end{aligned}</script><p>通过增加结构变量的形式可以转成一般形式的LP问题：</p><script type="math/tex; mode=display">\begin{aligned} \min:& \quad c^T x \\ s.t.:& \quad Ax = b, \\      & \quad l \le x \le u\end{aligned}</script><p>注意到当前的$x$包含原始变量和结构变量，记为$x_c$和$x_r$。</p><p>假设primal feasible，由对偶问题性质$Ay+s=c$，那么对于任意迭代时刻，都有如下条件满足</p><script type="math/tex; mode=display">\begin{cases}B x_B + s_B = c_B \\N x_N + s_N = c_N \\s_B = 0\end{cases}</script><p>其中$s_B, s_N$分别为对应基矩阵和非基矩阵的reduced costs。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在primal simplex算法中，每轮迭代都需要选择most candidate的方向并移动到邻近的顶点上，那么，用什么来评估方向的好坏呢？我们知道，选择一个方向走下去对目标值的改善程度是由方向和步长决定的，对于标准型的线性规划问题而言，使目标值下降的方向是reduce
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>智能优化算法（9）：其他类型的优化算法</title>
    <link href="https://dlc1994.github.io/2020/07/17/ckratpwl0000u04ve20b81zw3/"/>
    <id>https://dlc1994.github.io/2020/07/17/ckratpwl0000u04ve20b81zw3/</id>
    <published>2020-07-17T10:11:40.000Z</published>
    <updated>2020-07-17T10:14:44.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-3-其他类型的优化算法"><a href="#3-3-其他类型的优化算法" class="headerlink" title="3.3 其他类型的优化算法"></a>3.3 其他类型的优化算法</h2><h3 id="3-3-1-和声搜索算法"><a href="#3-3-1-和声搜索算法" class="headerlink" title="3.3.1 和声搜索算法"></a>3.3.1 和声搜索算法</h3><p>和声搜索（Harmony search, HS）算法从和声记忆库按照考虑概率选择一个音调，再按照音调调整概率确定是否对选择的音调进行调整，若需调整利用步长微调，在现有和声记忆库外产生一个音调，称为随机化。用最好的新和声替换最差的和声，不断重复。<br><a id="more"></a><br>算法流程图：<br><img src="/2020/07/17/ckratpwl0000u04ve20b81zw3/HS.jpg" alt="HS"></p><p>应用案例：<br>管道优化设计、土坡稳定性分析、电力系统经济导读和模糊控制器设计</p><h3 id="3-3-2-大洪水算法"><a href="#3-3-2-大洪水算法" class="headerlink" title="3.3.2 大洪水算法"></a>3.3.2 大洪水算法</h3><p>大洪水算法（Great Deluge Algorithm, GDA）类似于模拟退火算法，属于单点搜索，区别在于新解的接受方式，模拟退火通过Metropolis准则判断是否接受新解，而GDA通过新解函数值和水平面值的比较进行判断。</p><p>算法流程图：<br><img src="/2020/07/17/ckratpwl0000u04ve20b81zw3/GDA.jpg" alt="GDA"></p><p>应用案例:<br>电力调度问题、复杂系统可靠度问题、排课表问题和二次分配问题（集成电路布线、打字机键盘设计、作业调度、物流运输）</p><h3 id="3-3-3-正弦余弦算法"><a href="#3-3-3-正弦余弦算法" class="headerlink" title="3.3.3 正弦余弦算法"></a>3.3.3 正弦余弦算法</h3><p>正弦余弦算法（Sine Cosine Algorithm, SCA）2016年才提出，是一种基于数学规律的元启发方法，基于正弦函数和余弦函数值的变化实现优化搜索，不同于现有任何一种优化算法。</p><p>应用案例：电力系统安全性问题、经济负荷分配问题、结构损伤测试问题和太阳能光伏电池充电问题</p><h3 id="3-3-4-竞争决策算法"><a href="#3-3-4-竞争决策算法" class="headerlink" title="3.3.4 竞争决策算法"></a>3.3.4 竞争决策算法</h3><p>竞争决策算法（Competitive Decision Algorithm, CDA）是中国学者2006年在分析大自然生物界特别是人类各种竞争机制和决策原理基础上，利用竞争造就优化和决策左右结果的特性得出的一种寻优算法，主要用于求解NP-hard问题。</p><p>应用案例：设施选址、最小比率生成树、多目标最小生成树、最小顶点覆盖、TSP、瓶颈TSP、车辆路径和背包问题等</p><h3 id="3-3-3-文化算法"><a href="#3-3-3-文化算法" class="headerlink" title="3.3.3 文化算法"></a>3.3.3 文化算法</h3><p>文化算法（Cultureal Algorithm, CA）模拟人类社会的文化进化过程，在现有智能优化算法基础上，提取隐含在进化过程中的各种信息，以知识的形式加以存储，指导算法的优化过程。</p><p>应用案例：数据挖掘、欺骗检测、服务器集群自适应负载均衡、电路板布局设计</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;3-3-其他类型的优化算法&quot;&gt;&lt;a href=&quot;#3-3-其他类型的优化算法&quot; class=&quot;headerlink&quot; title=&quot;3.3 其他类型的优化算法&quot;&gt;&lt;/a&gt;3.3 其他类型的优化算法&lt;/h2&gt;&lt;h3 id=&quot;3-3-1-和声搜索算法&quot;&gt;&lt;a href=&quot;#3-3-1-和声搜索算法&quot; class=&quot;headerlink&quot; title=&quot;3.3.1 和声搜索算法&quot;&gt;&lt;/a&gt;3.3.1 和声搜索算法&lt;/h3&gt;&lt;p&gt;和声搜索（Harmony search, HS）算法从和声记忆库按照考虑概率选择一个音调，再按照音调调整概率确定是否对选择的音调进行调整，若需调整利用步长微调，在现有和声记忆库外产生一个音调，称为随机化。用最好的新和声替换最差的和声，不断重复。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Optimization Algorithms" scheme="https://dlc1994.github.io/categories/Optimization-Algorithms/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>智能优化算法（8）：差分进化算法</title>
    <link href="https://dlc1994.github.io/2020/07/17/ckratpwkk000504vey0g81hav/"/>
    <id>https://dlc1994.github.io/2020/07/17/ckratpwkk000504vey0g81hav/</id>
    <published>2020-07-17T10:09:30.000Z</published>
    <updated>2020-07-17T10:11:24.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-2-差分进化算法"><a href="#3-2-差分进化算法" class="headerlink" title="3.2 差分进化算法"></a>3.2 差分进化算法</h2><p>差分进化（Differential Evolution, DE）算法是在求解Chebyshev多项式拟合问题时提出的，算法主要通过基于差分形式的变异操作和基于概率选择的交叉操作进行优化搜索。DE算法最初的设计方法源于遗传退火算法，主要操作包括变异、交叉和选择，但具体实现方法与遗传算法有本质区别。<br><a id="more"></a></p><h3 id="3-2-1-算法原理"><a href="#3-2-1-算法原理" class="headerlink" title="3.2.1 算法原理"></a>3.2.1 算法原理</h3><p>算法首先对搜索群体进行初始化。假设$NP$表示群体规模，$D$表示变量维数，$G$表示迭代次数，令$X_{i,G}$表示第$G$代的寻优个体$i$，并可以表示为：</p><script type="math/tex; mode=display">X_{i,G} = [X_{i,G}^1, X_{i,G}^2,...,X_{i,G}^D] \tag{1}</script><p>对每个搜索个体的解采用随机初始化方法，例如个体$i$的第$j$个解的分量可以通过如下方法产生：</p><script type="math/tex; mode=display">X_{i,0}^j = X_{\min}^j + r(X_{\max}^j-X_{\min}^j) \tag{2}</script><p>其中$X_{\max}^j$和$X_{\min}^j$分别表示第$j$个分量的上下界；$r$表示在[0,1]间服从均匀分布的随机数。完成初始化后，进入循环</p><p><strong>1. 变异操作</strong></p><p>在DE算法中，经典的变异操作是在目标向量的基础上，利用两个向量的差分进行解的更新，比如：</p><script type="math/tex; mode=display">V_{i,G} = X_{r_1, G}+F(X_{r_2, G}-X_{r_3, G}) \tag{3}</script><p>其中$r_1,r_2,r_3$是从当前搜索群体中随机选择的三个个体编号，要求$r_1\ne r_2 \ne r_3$；$X_{i,G}$称为目标向量；$V_{i,G}$表示个体$X_{i,G}$变异后的解向量，称为个体i的合成向量；$X_{r_1,G}$表示被选择的进行变异的向量，$X_{r_2,G}$和$X_{r_3,G}$是被选择进行差分操作的两个向量；系数$F$称为缩放因子，用于控制差分向量对变异公式的影响。</p><p><strong>2. 交叉操作</strong></p><p>在DE算法中，交叉操作是利用合成向量$V_{i,G}$和目标向量$X_{i,G}$的分量进行重新组合产生试验向量$U_{i,G}$，以提高解的多样性。目前，二项式交叉和指数交叉是DE算法主要的交叉方法，<strong>二项式交叉</strong>对应定义如下：</p><script type="math/tex; mode=display">U_{i,G}^j=\left\{\begin{aligned}&V_{i,G}^j, if\; rand \le \; Cr \;or \; j=j_{rand} \\&X_{i,G}^j, otherwise\end{aligned}\right.\tag{4}</script><p>其中，rand表示[0,1]之间服从均匀分布的随机数；Cr表示交叉概率，且取值与[0,1]；$j_{rand}$表示在区间[1,D]上随机产生的整数。</p><p><strong>指数交叉</strong>实现方法如下：</p><script type="math/tex; mode=display">U_{i,G}^j=\left\{\begin{aligned}&V_{i,G}^j, j=<n>_D,<n+1>_D,...,<n+L+1>_D \\&X_{i,G}^j, otherwise\end{aligned}\right.\tag{5}</script><p>其中,$n$和$L$是在[1,D]上随机产生的整数；$&lt;&gt;_D$表示对D进行取模运算。</p><p><strong>3. 选择操作</strong><br>选择操作是基于贪婪策略，比较试验向量$U_{i,G}$和目标向量$X_{i,G}$的优劣，挑选更优的值作为下一代的目标向量。</p><p>DE算法的流程如下图所示：<br><img src="/2020/07/17/ckratpwkk000504vey0g81hav/DE.jpg" alt="DE"></p><p>上述算法是差分优化算法的基本形式，目前还有其他版本的算法，可以用DE$/x/y/z$表示，其中$x$表示被变异的向量选择方法；$y$表示变异种采用的差分向量的个数；$z$表示交叉操作的方法，上bin表示二项式交叉，exp表示指数交叉，因此前面的DE算法可以表示为DE$/rand/1/bin$，此外，其他DE算法的形式有：</p><ul><li>DE$/rand/2/bin$</li><li>DE$/best/1/bin$</li><li>DE$/best/2/bin$</li><li>DE$/target-to-best/1/bin$</li><li>DE$/rand/1/exp$</li></ul><h3 id="3-2-2-应用案例"><a href="#3-2-2-应用案例" class="headerlink" title="3.2.2 应用案例"></a>3.2.2 应用案例</h3><p>瓶颈TSP问题（不追求总巡回路线最短，希望在巡回路线中单次行程尽可能短）、Chebyshev多项式拟合问题</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;3-2-差分进化算法&quot;&gt;&lt;a href=&quot;#3-2-差分进化算法&quot; class=&quot;headerlink&quot; title=&quot;3.2 差分进化算法&quot;&gt;&lt;/a&gt;3.2 差分进化算法&lt;/h2&gt;&lt;p&gt;差分进化（Differential Evolution, DE）算法是在求解Chebyshev多项式拟合问题时提出的，算法主要通过基于差分形式的变异操作和基于概率选择的交叉操作进行优化搜索。DE算法最初的设计方法源于遗传退火算法，主要操作包括变异、交叉和选择，但具体实现方法与遗传算法有本质区别。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Optimization Algorithms" scheme="https://dlc1994.github.io/categories/Optimization-Algorithms/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>智能优化算法（7）：禁忌搜索算法</title>
    <link href="https://dlc1994.github.io/2020/07/17/ckratpwl0000k04velp2t035s/"/>
    <id>https://dlc1994.github.io/2020/07/17/ckratpwl0000k04velp2t035s/</id>
    <published>2020-07-17T10:07:01.000Z</published>
    <updated>2020-07-17T10:13:54.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-1-禁忌搜索算法"><a href="#3-1-禁忌搜索算法" class="headerlink" title="3.1 禁忌搜索算法"></a>3.1 禁忌搜索算法</h2><p>禁忌搜索（Tabu Search, TS）算法是局部搜索算法的拓展，采用禁忌表来记录已经到达过的局部最优点，使得在以后一段时期内的搜索中，不再重复搜索这些解，以此跳出局部极值点。<br><a id="more"></a></p><h3 id="3-1-1-算法原理"><a href="#3-1-1-算法原理" class="headerlink" title="3.1.1 算法原理"></a>3.1.1 算法原理</h3><p>区别于模拟退火算法通过温度调整算法从搜索空间的一个点移动到另一个点的概率来避免局部极值，在禁忌搜索算法中，是通过禁忌表驱动算法探索搜索空间的位置区域来避免早熟收敛。</p><p><strong>局部最优解</strong>：给定一个最优化问题实例$(F, f)$的一个邻域$N$，一个可行解$x\in F$，若$\forall g \in N(x)$ 有 $f(x)\le f(g)$，称$x$为关于$N$的局部最优解。</p><p><strong>邻域</strong>：对于组合优化问题$(D,F,f)$，其中$D$为所有解构成的状态空间，$F$为$D$上的可行域，$f$为目标函数，则一个邻域函数可定义为一种映射，即：</p><script type="math/tex; mode=display">N:x\in D -> N(x) \in 2^D</script><p>其中，$2^D$表示所有子集的集合,$N(x)$为$x$的邻域。</p><p>局部搜索算法本质上说是基于贪婪策略的搜索算法，容易实现，但是算法往往会陷入局部极值，无法保证获得全局最优解，为避免早熟收敛，禁忌搜索算法通过禁忌策略扩大寻优范围，提高算法全局优化能力。</p><h3 id="3-1-2-算法模型"><a href="#3-1-2-算法模型" class="headerlink" title="3.1.2 算法模型"></a>3.1.2 算法模型</h3><p>禁忌搜索算法第一次在优化过程中使用了记忆功能，使用禁忌表来避免重复搜索，扩大搜索区域。</p><p><strong>1. 禁忌表</strong></p><p>禁忌表由禁忌对象和禁忌长度组成，禁忌对象是产生解变化的因素，而禁忌长度是禁忌对象被禁次数。</p><p>禁忌对象分为解的简单变化、解向量分量变化、目标值变化</p><ul><li>解的简单变化。从解空间中的$x$到$y$</li><li>解向量分量的变化。解向量有$n$维，其中一维或者某几维发生变化</li><li>目标值变化。具有相同目标值的解认为是同一状态，</li></ul><p><strong>2. 禁忌长度</strong></p><p>禁忌长度就是被禁对象不允许被选择的迭代次数。</p><p>设置禁忌长度$t$的方法主要有两种：</p><ul><li>$t$为常数。</li><li>$t$随迭代次数调整</li></ul><p>研究表明，禁忌长度较大时，算法可以在更多的位置区域进行优化搜索，全局探索性能较好；禁忌长度较小时，算法可以进行精细搜索，局部开发能力较强。动态调整的禁忌长度比固定不变的禁忌长度能够让算法具有更好的性能。</p><p><strong>3. 特设准则</strong></p><p>优化过程中，可能会出现邻域解全是被禁对象，或者解禁某个对象后最优值发生改进。因此，可以将某个被禁对象解禁。</p><p>设置常用方法主要有以下几种：</p><ul><li>基于评价值准则：如果邻域解的评价值优于历史当前最优值</li><li>基于最小错误原则：如果邻域解全是被禁对象，而且不满足评价值准则，那么可以从所有邻域解中选一个最优的</li><li>基于影响力准则：有些对象的变化对目标值影响较大</li></ul><p>TS的流程图：<br><img src="/2020/07/17/ckratpwl0000k04velp2t035s/TS.jpg" alt="TS"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;3-1-禁忌搜索算法&quot;&gt;&lt;a href=&quot;#3-1-禁忌搜索算法&quot; class=&quot;headerlink&quot; title=&quot;3.1 禁忌搜索算法&quot;&gt;&lt;/a&gt;3.1 禁忌搜索算法&lt;/h2&gt;&lt;p&gt;禁忌搜索（Tabu Search, TS）算法是局部搜索算法的拓展，采用禁忌表来记录已经到达过的局部最优点，使得在以后一段时期内的搜索中，不再重复搜索这些解，以此跳出局部极值点。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Optimization Algorithms" scheme="https://dlc1994.github.io/categories/Optimization-Algorithms/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>智能优化算法（6）：其他基于物理学原理的优化算法</title>
    <link href="https://dlc1994.github.io/2020/07/17/ckratpwl0000x04vegwrpup76/"/>
    <id>https://dlc1994.github.io/2020/07/17/ckratpwl0000x04vegwrpup76/</id>
    <published>2020-07-17T10:03:37.000Z</published>
    <updated>2020-07-17T10:06:48.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-2-其他基于物理学原理的优化算法"><a href="#2-2-其他基于物理学原理的优化算法" class="headerlink" title="2.2 其他基于物理学原理的优化算法"></a>2.2 其他基于物理学原理的优化算法</h2><h3 id="2-2-1-引力搜索算法"><a href="#2-2-1-引力搜索算法" class="headerlink" title="2.2.1 引力搜索算法"></a>2.2.1 引力搜索算法</h3><p>受万有引力定律启发，学着提出了一种新型的群体智能优化算法——引力搜索算法（Gravitational Search Algorithm, GSA）。<br><a id="more"></a></p><p>万有引力定律：自然界中任何两个物体都是相互吸引的，引力的大小跟这两个物体的质量的乘积成正比，跟它们的距离的二次方成反比，数学表达式为：</p><script type="math/tex; mode=display">F=G\frac{m_1 m_2}{r^2}</script><p>其中，$F$表示两个物体间的引力，$G$表示万有引力常数，$m_1$和$m_2$分别表示物体1和物体2的质量，$r$表示两个物体间的距离。</p><p>引力搜索算法在求解优化问题时，搜索个体的位置和问题的解相对应，个体质量用于评价个体的优劣，位置越好，质量越大。由于引力作用，个体之间相互吸引并且朝着质量较大的个体方向移动，个体运动遵循牛顿第二定律，随着运动不断进行，最终这个群体都会聚集在质量最大个体的周围，从而找到质量最大的个体，而质量最大的个体占据最优位置，因此算法可以获得问题的最优解。</p><p>算法流程如下图所示：<br><img src="/2020/07/17/ckratpwl0000x04vegwrpup76/GSA.jpg" alt="GSA"></p><p>应用案例：<br>投资者偏好条件下概率准则投资组合问题</p><p><strong>智能优化算法一般不要求目标函数连续性和可微性，甚至有时连有没有解析表达式都不要求，并且对计算中数据的不确定性也有很强的适应能力。</strong></p><h2 id="2-2-2-混沌优化算法"><a href="#2-2-2-混沌优化算法" class="headerlink" title="2.2.2 混沌优化算法"></a>2.2.2 混沌优化算法</h2><p>基于混沌现象（貌似无规律的复杂运动形态）的独特性质——遍历性、随机性以及规律性，我国学者李兵提出混沌优化算法，通过载波方法将混沌状态和决策变量相对应，然后将混沌运动的遍历范围映射到决策变量的的取值范围，最后利用混沌变量进行优化搜索。</p><p>混沌优化算法的几种特征：</p><ol><li>初值敏感性</li><li>遍历性</li><li>规律性</li><li>随机性</li></ol><p>算法基本步骤：</p><ol><li>算法初始化。</li><li>第一次载波。</li><li>用混沌变量进行迭代搜索。</li><li>经过若干次搜索后优化目标函数值没有发生改变，进行第二次搜索。</li><li>运用二次载波后的混沌变量进行迭代搜搜。</li><li>满足终止条件，终止搜索；否则返回步骤5。</li></ol><p>应用案例：<br>求解天体力学Kepler方程</p><h2 id="2-2-3-随机分形搜索算法"><a href="#2-2-3-随机分形搜索算法" class="headerlink" title="2.2.3 随机分形搜索算法"></a>2.2.3 随机分形搜索算法</h2><p>随机分形搜索算法（Stochastic Fractal Search Algorithm, SFS）采用高斯随机游走模型，基于个体当前位置进行扩散，并根据适应度函数对个体位置做进一步更新。</p><p>分形：自相似性，部分与整体具有相似性，图案之中递归的套着图案。</p><p>随机分形搜索算法将微粒类比为寻优个体，扩散过程类比为优化过程，寻优个体的位置和待优化问题的解相对应，且个体位置的优劣将通过目标函数值的大小进行评价。</p><p>主要步骤：</p><ol><li>设置算法参数，进行种群初始化</li><li>计算个体适应度函数值，找到当前最佳点BP</li><li>执行扩散过程，对于每一个扩散的个体，根据选择的高斯游走模型生成新个体的新位置</li><li>进行群体第一次更新</li><li>进行群体第二次更新</li><li>判断终止条件，不满足则执行步骤2</li></ol><p>应用案例：<br>CEC2010测试函数库</p><h2 id="2-2-4-光学优化算法"><a href="#2-2-4-光学优化算法" class="headerlink" title="2.2.4 光学优化算法"></a>2.2.4 光学优化算法</h2><p>光学优化算法（Optics Inspired Optimization, OIO）2015年才提出，假设初始解为一系列初始光源点，经球面镜函数反射，得到相应的像点，这一系列像点，作为下一次搜索的光源点，不断反射搜索，即可找到最优解。</p><p>应用案例：<br>城市排水工程——暴雨强度公式参数优化</p><h2 id="2-2-5-量子优化算法"><a href="#2-2-5-量子优化算法" class="headerlink" title="2.2.5 量子优化算法"></a>2.2.5 量子优化算法</h2><p>量子计算（Quantum computing, QC），遇事不决，量子力学。</p><p>量子优化算法可以和很多优化算法结合，比如量子神经计算、量子遗传算法、量子退火算法等，与其他优化算法相比建模方式有所区别，编码方式也不同</p><p>应用案例：<br>VRP问题</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2-2-其他基于物理学原理的优化算法&quot;&gt;&lt;a href=&quot;#2-2-其他基于物理学原理的优化算法&quot; class=&quot;headerlink&quot; title=&quot;2.2 其他基于物理学原理的优化算法&quot;&gt;&lt;/a&gt;2.2 其他基于物理学原理的优化算法&lt;/h2&gt;&lt;h3 id=&quot;2-2-1-引力搜索算法&quot;&gt;&lt;a href=&quot;#2-2-1-引力搜索算法&quot; class=&quot;headerlink&quot; title=&quot;2.2.1 引力搜索算法&quot;&gt;&lt;/a&gt;2.2.1 引力搜索算法&lt;/h3&gt;&lt;p&gt;受万有引力定律启发，学着提出了一种新型的群体智能优化算法——引力搜索算法（Gravitational Search Algorithm, GSA）。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Optimization Algorithms" scheme="https://dlc1994.github.io/categories/Optimization-Algorithms/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>智能优化算法（5）：模拟退火算法</title>
    <link href="https://dlc1994.github.io/2020/07/17/ckratpwkk000f04vexam111x5/"/>
    <id>https://dlc1994.github.io/2020/07/17/ckratpwkk000f04vexam111x5/</id>
    <published>2020-07-17T10:00:38.000Z</published>
    <updated>2020-07-17T10:03:06.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-1-模拟退火算法"><a href="#2-1-模拟退火算法" class="headerlink" title="2.1 模拟退火算法"></a>2.1 模拟退火算法</h2><p>模拟退火（Simlated Annealing, SA）算法是一种全局搜索算法，是局部搜索算法的拓展。区别于其他算法，模拟退火算法不要求每次产生的新解质量都有提高。<br><a id="more"></a></p><h3 id="2-1-1-算法原理"><a href="#2-1-1-算法原理" class="headerlink" title="2.1.1 算法原理"></a>2.1.1 算法原理</h3><p>SA源于物理退火过程的模拟，在热力学和物理学中，将固体加温至融化状态，待其徐徐冷却之后使其凝固成规整晶体的过程称为物理退火，可以分为升温过程、降温过程和等温过程三个部分：</p><ul><li>升温过程：加热过程中，温度不断升高，固体粒子热运动增强，能量也在增加；到熔点后固定融化为液态。粒子自由运动增加，从有序的结晶态转变为无序的液态，有助于消除固体内的非均匀态，使得随后的降温过程以某一平衡态为起点。</li><li>降温过程：在冷却时，温度慢慢降低，分子的热运动减弱，逐渐趋向有序。当温度到达结晶温度时，液体凝固，系统熵减小。在冷却时如果温度急剧降低物体只会冷凝为非均匀的亚稳态，系统能量也不会达到最小值。</li><li>等温过程：在物理退火中，系统在每一个温度下面达到平衡态的过程可以用封闭系统的等温过程来描述，即热力学系统在恒定温度下发生的各种物理或者化学过程。该过程可以保证每个温度下系统都能达到平衡态，最终达到固体的基态。</li></ul><h3 id="2-1-2-算法模型"><a href="#2-1-2-算法模型" class="headerlink" title="2.1.2 算法模型"></a>2.1.2 算法模型</h3><p>在SA求解优化问题时，解和目标函数类似于退火过程中物体的状态和能量函数，而最优解就是物体达到能量最低的状态。<br>物理退火过程和模拟退火算法的对应关系<br>|  物理退火过程   | 模拟退火算法  |<br>|  ——  | ——  |<br>| 系统状态  | 解 |<br>| 系统能量  | 目标函数 |<br>| 系统最低能量状态（基态）| 全局最优解|<br>| 加温过程 | 设置初始高温 |<br>| 降温过程 | 温度下降|<br>| 等温过程 | 基于Metropolis准则搜索 |</p><p>算法流程：</p><ol><li>设置初始高温和终止温度，选择任意初始解$x$</li><li>内循环，在当前温度下随机产生一个邻域解$y\in N(x)$($N(x)$表示$x$的邻域)，根据Metropolis准则，判断是否选择新解$y$。如此反复进行直到达到满足内循环停止条件。</li><li>外循环，若满足外循环终止条件算法停止</li></ol><p>为达到每个温度下的平衡态，内循环次数要足够多，但在实际应用中无法达到理论上的平衡态，通常将内循环的次数设为常数值，在外循环中，通过调整温度来控制算法的搜索过程。</p><h3 id="2-1-3-Metropolis准则"><a href="#2-1-3-Metropolis准则" class="headerlink" title="2.1.3 Metropolis准则"></a>2.1.3 Metropolis准则</h3><p>假设在温度$T$下，由当前状态$i$产生新的状态$j$，两种状态对应的能量分布为$E_i$和$E_j$，如果$E_i&gt;E_j$，那么就接受新状态$j$。如果$E_i&lt;E_j$，那么要根据系统处于新状态$j$的概率判断该状态是否为<strong>重要</strong>状态。上述概率用$r$表示，且</p><script type="math/tex; mode=display">r=\exp(-(E_j-E_i)/K_BT)</script><p>其中，$K_B$为Boltzman常数。</p><p>在[0,1]之间产生随机数$\xi$，如果$r&gt;\xi$，那么新状态$j$为重要桩体，接受该状态，否则仍然保留状态$i$。</p><h3 id="2-1-4-应用案例"><a href="#2-1-4-应用案例" class="headerlink" title="2.1.4 应用案例"></a>2.1.4 应用案例</h3><p>平面选址问题，欧氏距离选址，绝对值选址</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2-1-模拟退火算法&quot;&gt;&lt;a href=&quot;#2-1-模拟退火算法&quot; class=&quot;headerlink&quot; title=&quot;2.1 模拟退火算法&quot;&gt;&lt;/a&gt;2.1 模拟退火算法&lt;/h2&gt;&lt;p&gt;模拟退火（Simlated Annealing, SA）算法是一种全局搜索算法，是局部搜索算法的拓展。区别于其他算法，模拟退火算法不要求每次产生的新解质量都有提高。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Optimization Algorithms" scheme="https://dlc1994.github.io/categories/Optimization-Algorithms/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>智能优化算法（4）：人工蜂群优化算法与其他基于生物学原理的优化算法</title>
    <link href="https://dlc1994.github.io/2020/07/17/ckratpwkk000304veaia269ma/"/>
    <id>https://dlc1994.github.io/2020/07/17/ckratpwkk000304veaia269ma/</id>
    <published>2020-07-17T09:57:20.000Z</published>
    <updated>2020-07-17T10:00:14.271Z</updated>
    
    <content type="html"><![CDATA[<p>人工蜂群算法（Artificial Bee Colony Algorithm, ABC），是模拟工蜂的觅食行为提出的，由三个基本部分组成，包括蜜源、雇佣蜂和未雇佣蜂；定义两种行为，包括招募蜜蜂到蜜源和放弃蜜源。<br><a id="more"></a></p><p>蜜源：由含蜜量的多少、距离蜂巢的远近以及采集花蜜的难易程度决定。在人工蜂群算法中对应适应度值，蜜源的质量直接决定了目标函数的优劣。</p><p>雇佣蜂：（Employed Bees），也称为引领蜂，主要任务是勘探蜜源，数量与发现的蜜源数量相同，任务是将每一个蜜源信息传递到蜂巢的其他蜜蜂。</p><p>非雇佣蜂：分为跟随蜂（Onlooker Bees）和侦察蜂（Scout Bees）。初始时刻，跟随蜂的数量和雇佣蜂相同，在蜂巢中等待雇佣蜂传递回信息后按照一定的策略选择蜜源，并进行开采；侦查蜂在蜂巢附近探索新的蜜源，如果探索到的蜜源优于已选择蜜源则对其进行替换。</p><h3 id="1-4-1-算法模型"><a href="#1-4-1-算法模型" class="headerlink" title="1.4.1 算法模型"></a>1.4.1 算法模型</h3><p>对各引领蜂的位置进行初始化，随机产生$2N$个位置，并取较为优异的$N$个位置作为蜜源位置，引领蜂根据采蜜经验，在领域范围内利用下式产生一个新位置，评估新位置的蜜源质量，即当前位置的适应度值。若蜜源质量高于原蜜源质量，则新位置替换原位置。</p><script type="math/tex; mode=display">v_{ij}=x_{ij}+\phi (x_{ij}-x_{kj}) \tag{1}</script><p>其中$v_{ij}$是新位置，$x_{ij}$是原位置，$x_{kj}$是随机选取的邻居蜜源位置；$\phi$是在$[-1,1]$上服从均匀分布的随机数；$k=1,2,…,BN$(BN为种群规模)；$j={1,2,…,n}$（$n$为维数）。</p><p>引领蜂通过跳摇摆舞将蜜源信息分享给跟随蜂，跟随蜂利用下式通过轮盘赌机制来选择一个蜜源，在利用式(1)在此蜜源附近随机产生新蜜源新位置，比较新位置和原位置的蜜源质量，若新位置的蜜源质量更好，则保存新位置。</p><script type="math/tex; mode=display">p_i = fit_i/\sum_{n=1}^BN fit_n</script><script type="math/tex; mode=display">fit_i=\left\{\begin{aligned}\frac{1}{1+f_i}, f_i\ge 0 \\1+|f_i|,fi<0\end{aligned}\right.\tag{2}</script><p>其中，$fit_i$指当前蜜源位置的适应度值。</p><p>如果一个蜜源经过limit代后，其适应度都没有任何改变，则当前蜜源放弃。此外，当前蜜源处的引领蜂变成侦查蜂，侦查蜂利用式（3）进行随机搜索新蜜源：</p><script type="math/tex; mode=display">x_{ij}=x_j^{\min}+rand[0,1](x_j^{\max}-x_j^{min})</script><p>反复进行上述搜索过程，直到算法迭代次数$t$达到预定的最大迭代次数，或者最好解达到预定误差精度时算法结束。流程如下图所示：<br><img src="/2020/07/17/ckratpwkk000304veaia269ma/ABC.jpg" alt="ABC"></p><h3 id="1-4-2-应用案例"><a href="#1-4-2-应用案例" class="headerlink" title="1.4.2 应用案例"></a>1.4.2 应用案例</h3><p>电子商务自动谈判研究-多Agent自动谈判模型</p><h2 id="其他基于生物学原理的优化算法"><a href="#其他基于生物学原理的优化算法" class="headerlink" title="其他基于生物学原理的优化算法"></a>其他基于生物学原理的优化算法</h2><ul><li><strong>蝙蝠算法</strong>：多目标多选择背包问题</li><li><strong>萤火虫群优化算法</strong>：平面选址问题</li><li><strong>布谷鸟优化算法</strong>：函数优化和多维背包问题，测试函数整体比PSO好很多</li><li><strong>人工鱼群算法</strong>：电力系统无功优化、波浪发电系统最优负载、出租车智能调度、大规模多背包问题、机器人路径规划</li><li><strong>细菌觅食优化算法</strong>：城市轨道交通调度优化、永磁同步电机、贝叶斯网络结构学习、柔性作业车间调度问题、投资组合、输电网规划</li><li><strong>生物地理学优化算法</strong>：</li><li><strong>模拟植物生长算法</strong>：多目标旅行商问题</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人工蜂群算法（Artificial Bee Colony Algorithm, ABC），是模拟工蜂的觅食行为提出的，由三个基本部分组成，包括蜜源、雇佣蜂和未雇佣蜂；定义两种行为，包括招募蜜蜂到蜜源和放弃蜜源。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Optimization Algorithms" scheme="https://dlc1994.github.io/categories/Optimization-Algorithms/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>智能优化算法（3）：微粒群优化算法</title>
    <link href="https://dlc1994.github.io/2020/07/17/ckratpwkk000g04vehl28xg35/"/>
    <id>https://dlc1994.github.io/2020/07/17/ckratpwkk000g04vehl28xg35/</id>
    <published>2020-07-17T09:50:11.000Z</published>
    <updated>2020-07-17T09:56:37.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-3-微粒群优化算法"><a href="#1-3-微粒群优化算法" class="headerlink" title="1.3 微粒群优化算法"></a>1.3 微粒群优化算法</h2><p>微粒群优化（Particle Swarm Optimization, PSO）算法，或称为粒子群优化算法，是一种基于鸟群觅食行为规律提出的群体智能优化算法。算法概念简明，易于实现。<br><a id="more"></a></p><p>在群体觅食过程中，群体中的每一个个体都会受益于所有成员在这个过程中发现和积累的经验。而基于信息交流和共享的个体检的协作正式微粒群优化算法进行优化搜索的基础。</p><p>微粒群算法模拟鸟类觅食模型，将优化问题的搜搜空间类比作鸟类的飞行空间，所需要找到的最优解相当于食物，算法将每只鸟抽象为没有质量的微粒，每个微粒有位置和速度两个特征向量，位置代表候选解，解的优劣通过适应度函数大小进行评价；微粒速度决定飞行方向和速率。</p><p>优化过程中，微粒和位置和其他算法一样需要随机初始化，通过迭代进行更新，每次迭代需要通过两个<strong>极值</strong>进行更新，第一个是每个微粒当前所找到的最好的解，称为<strong>个体极值</strong>；第二个极值是整个群体找到的最好的解，称为<strong>全局极值</strong>。每个微粒根据自身经验和群体经验进行更新。</p><h3 id="1-3-1-算法模型"><a href="#1-3-1-算法模型" class="headerlink" title="1.3.1 算法模型"></a>1.3.1 算法模型</h3><p>设待求解的优化问题维度为$N$，微粒群体规模为$M$，在微粒群优化算法中，$x_i = (x_{i1}, x_{i2}, x_{i3}, …, x_{iN})$表示第$i$个微粒的位置；$v_i=(v_{i1},v_{i2},…,v_{iN})$表示第$i$个微粒的速度；$p_i=(p_{i1},p_{i2},…,p_{iN})$表示第$i$个微粒所搜寻到的最好的位置；$g_i=(g_{1},g_{2},…,g_{N})$表示整个群体所搜寻到的最好的位置。</p><p>Eberhart和Kennedy最初提出的基本微粒群优化算法采用如下迭代方程进行速度和位置的更新：</p><script type="math/tex; mode=display">v_{id}(t+1) = v_{id}(t)+c_1r_1(p_{id}(t)-x_{id}(t))+c_2r_2(g_{d}(t)-x_{d}(t))</script><script type="math/tex; mode=display">x_{id}(t+1) = x_{id}(t)+v_{id}(t+1)</script><p>其中，$i=1,2,…,M;d=1,2,…,N;c_1$和$c_2$是学习因子;$t$表示迭代次数；$r_1$和$r_2$是在$[0,1]$上服从均匀分布的随机数。</p><p>在速度更新方程中，第一项表示微粒根据自身的速度进行惯性运动；第二项表示微粒根据自身经验进行调整，称为<strong>认知</strong>部分；第三项表示微粒根据其他微粒的经验进行调整，称为<strong>社会</strong>部分。需要指出的是，为了防止微粒的速度过大或者过小，需要限定速度的范围：</p><script type="math/tex; mode=display">v_{id}(t+1) > v_{\max} \rightarrow v_{id}(t+1) = v_{\max}</script><script type="math/tex; mode=display">v_{id}(t+1) < -v_{\max} \rightarrow v_{id}(t+1) = -v_{\max}</script><p>在求解边界约束问题上，如果更新后位置越界，常见的修正方法是将其限定在边界上。在公式1中，$g$是整个群体的最好位置。上述算法称为微粒群优化算法的全局版本；此外，也可以将微粒领域内的最好位置设为$g$，则称为局部版本；全局版本算法优化速度快，但是容易陷入局部最优；而局部版本算法优化速度慢，但容易找到更优解。</p><p>算法基本流程：<br><img src="/2020/07/17/ckratpwkk000g04vehl28xg35/PSO.jpg" alt="PSO"></p><h3 id="1-3-2-算法分析"><a href="#1-3-2-算法分析" class="headerlink" title="1.3.2 算法分析"></a>1.3.2 算法分析</h3><h4 id="学习因子"><a href="#学习因子" class="headerlink" title="学习因子"></a>学习因子</h4><p>学习因子$c_1_$和$c_2$是微粒根据自身经验和社会经验对其运动进行更新的权重。如果令$c_1$为0，那么微粒缺乏自身经验，这是算法的优化速度可能比较快，但容易陷入局部极值；如果令$c_2$为0，那么优化信息无法在群体内传播，微粒搜索到最优解的概率非常低；如果同时为0，那么算法优化性能会急剧下降。</p><h4 id="领域拓扑结构"><a href="#领域拓扑结构" class="headerlink" title="领域拓扑结构"></a>领域拓扑结构</h4><p>微粒群间的信息交流是算法的重要组成部分，通过为止共享，每个微粒能够向比自身位置更好的方向运动，而领域拓扑就决定了信息交流的方向。拓扑类型有：</p><ul><li>环型（每个微粒受近邻影响，只向最好近邻位置运动）</li><li>星型（全局领域拓扑，完全图，计算复杂度较高）</li><li>齿型（发散的，中心向最好微粒逼近，再把经验传递给其他微粒，其他微粒两两不相连）</li></ul><p>研究发现，环型拓扑收敛速度慢，容易找到全局最优解；星型拓扑收敛速度快，容易陷入局部极值；齿型拓扑优化效果差。这三种属于静态拓扑，还有动态拓扑——优化最小距离、逐步增长、重新组合。</p><p>在基本微粒群优化算法的基础上，有人提出了带惯性权重和收缩因子的两种算法版本：</p><p><strong>惯性权重</strong></p><script type="math/tex; mode=display">v_{id}(t+1) = wv_{id}(t)+c_1r_1(p_{id}(t)-x_{id}(t))+c_2r_2(g_{d}(t)-x_{d}(t))</script><p>其中$w$是惯性权重，用于对速度的控制；较大的惯性权重保证算法具有较强的全局探索能力，较小的惯性权重能保证算法具有较强的局部开发能力。目前，使惯性权重随迭代次数线性递减是最基本的策略，带惯性权重的优化算法是目前主流的算法版本。</p><p><strong>收缩因子</strong></p><script type="math/tex; mode=display">v_{id}(t+1) = \chi (v_{id}(t)+c_1r_1(p_{id}(t)-x_{id}(t))+c_2r_2(g_{d}(t)-x_{d}(t)))</script><p>其中收缩因子$\chi$是$c_1$和$c_2$的函数，函数表达式为：</p><script type="math/tex; mode=display">\chi = \frac{2}{|2-\mu -\sqrt{\mu^2-4\mu}|}</script><p>其中$\mu = c_1+c_2&gt;4$</p><h3 id="1-3-3-应用案例"><a href="#1-3-3-应用案例" class="headerlink" title="1.3.3 应用案例"></a>1.3.3 应用案例</h3><p>多目标优化</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-3-微粒群优化算法&quot;&gt;&lt;a href=&quot;#1-3-微粒群优化算法&quot; class=&quot;headerlink&quot; title=&quot;1.3 微粒群优化算法&quot;&gt;&lt;/a&gt;1.3 微粒群优化算法&lt;/h2&gt;&lt;p&gt;微粒群优化（Particle Swarm Optimization, PSO）算法，或称为粒子群优化算法，是一种基于鸟群觅食行为规律提出的群体智能优化算法。算法概念简明，易于实现。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Optimization Algorithms" scheme="https://dlc1994.github.io/categories/Optimization-Algorithms/"/>
    
    
      <category term="Algorithms" scheme="https://dlc1994.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>智能优化算法（2）：蚁群算法</title>
    <link href="https://dlc1994.github.io/2020/07/03/ckratpwl0000j04ve05csrdgb/"/>
    <id>https://dlc1994.github.io/2020/07/03/ckratpwl0000j04ve05csrdgb/</id>
    <published>2020-07-03T03:23:00.000Z</published>
    <updated>2020-07-03T03:26:42.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-2-蚁群优化算法"><a href="#1-2-蚁群优化算法" class="headerlink" title="1.2 蚁群优化算法"></a>1.2 蚁群优化算法</h2><p>蚁群优化（Ant Colony Optimization, ACO）算法是源自大自然生物界的仿真类算法，其思想吸收了蚁群觅食过程中的行为特性。蚁群算法在TSP问题、二次分配问题、图着色问题、车辆调度问题、通信网络中的负载均衡问题等表现出良好的优化性能。<br><a id="more"></a></p><p>大自然中的蚂蚁没有视觉，依赖于同类散发在环境中的信息素决定自己何去何从，孤立的蚂蚁沿着同伴的信息素轨迹移动，同时释放自己的信息素，从而增强了该路线上的信息素数量，随着越来越多的蚂蚁通过该路线，一条较佳的路线就形成了（这条路径不一定最短，但对于NP-hard问题而言足够了）。</p><h3 id="1-2-1-算法模型"><a href="#1-2-1-算法模型" class="headerlink" title="1.2.1 算法模型"></a>1.2.1 算法模型</h3><p>以旅行商问题（Traveling Salesman Problem, TSP）为例，在图论中称为最小Hamilton问题。</p><p>记$G = (V,E)$为赋权图，$V=(1,2,3,…,N)$为顶点集，$E$为边集，各顶点间的距离$d_{ij}$已知$(d_{ij}&gt;0,d_{ii}=\infty,i,j\in V)$，设</p><script type="math/tex; mode=display">x_{ij} = 1, 若(i,j)在最优回路上；否则为0</script><p>则经典的TSP问题可以表示如下：</p><script type="math/tex; mode=display">\min Z = \sum_{i=1}^{n}\sum_{j=1}^{n}d_{ij}x_{ij}</script><p>服从如下几个约束：</p><ul><li>约束1：$\sum_{j=1}^{n}x_{ij}=1, i\in V$</li><li>约束2：$\sum_{i=1}^{n}x_{ij}=1, j\in V$</li><li>约束3：$\sum_{i\in S}\sum_{j\in S}x_{ij} \le |S|-1, \forall S \subset V$</li><li>约束4：$x_{ij}\in \{0, 1\}$</li></ul><p>其中$|S|$为集合中所含图的顶点数；约束1和2对于每个点来说只有一条边进一条边出，也就是任意两个点间只有一条最优路线；约束3保证了没有任何子回路的产生。</p><p>当$d_{ij} = d_{ji}$时，问题被称为对称型TSP；当对于所有$1\le i, j,k \le n$时，有不等式$d_{ij}+d_{jk}\ge d_{ik}$成立，问题被称为是满足三角形不等式的，记为$\Delta$TSP。三角形不等式在很多情况下是满足的，即使不满足也可以转换为闭包形式求等价TSP最优解。</p><p>蚁群优化算法基本模型：</p><ol><li>蚂蚁群体总是寻找最小费用可行解</li><li>蚂蚁具有记忆性，存储当前路径的信息，构造可行解、评价解的质量、路径反向追踪</li><li>当前状态的蚂蚁可以移动到可行领域任意一点</li><li>每个蚂蚁赋予一个初始状态和若干个终止条件</li><li>蚂蚁从初始状态到可行领域状态，以递推方式构造解，当有一个蚂蚁满足至少一个终止条件时构造过程结束</li><li>蚂蚁按某种概率决策规则移动至领域结点</li><li>移动后信息素轨迹被更新，过程称为“单步在线信息素更新”</li><li>一旦构造出一个解，蚂蚁沿原路方向追踪，更新信息素轨迹，称为“在线延迟信息素更新”</li></ol><h3 id="1-2-2-算法分析"><a href="#1-2-2-算法分析" class="headerlink" title="1.2.2 算法分析"></a>1.2.2 算法分析</h3><p>算法复杂度是$O(nc\cdot n^2\cdot m)$，m为蚂蚁个数，nc为迭代次数或者搜索次数，n为顶点数。算法运行效果受到$\alpha, \beta$等参数影响，其中$\beta$的影响在于体现信息素轨迹的持久性，数值过小意味着信息消失过快；数值过大容易落入局部最优点，因此其数值通常取0.7左右。</p><p>在基本的蚁群优化算法上，可以与其他启发式算法相结合，最典型的就是嵌入局部搜索算法，在各个蚂蚁形成自己的路线后，用局部调整方法（2-opt, 3-opt）加以改进，此外，与遗传算法、模拟退火和禁忌搜索等结合也有一定的成效。</p><p>混合蚁群优化算法主要步骤：</p><ol><li><strong>Begin</strong></li><li>蚂蚁初始化；</li><li>LOOP：</li><li>$\quad$蚂蚁路径构造；</li><li>$\quad$对某个蚂蚁实施局部搜索算法</li><li>$\quad$蚂蚁轨迹更新</li><li>$\quad$若迭代次数未到，转LOOP；</li><li>输出当前最好解</li><li><strong>End</strong></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-2-蚁群优化算法&quot;&gt;&lt;a href=&quot;#1-2-蚁群优化算法&quot; class=&quot;headerlink&quot; title=&quot;1.2 蚁群优化算法&quot;&gt;&lt;/a&gt;1.2 蚁群优化算法&lt;/h2&gt;&lt;p&gt;蚁群优化（Ant Colony Optimization, ACO）算法是源自大自然生物界的仿真类算法，其思想吸收了蚁群觅食过程中的行为特性。蚁群算法在TSP问题、二次分配问题、图着色问题、车辆调度问题、通信网络中的负载均衡问题等表现出良好的优化性能。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Optimization Algorithms" scheme="https://dlc1994.github.io/categories/Optimization-Algorithms/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>智能优化算法（1）：遗传算法</title>
    <link href="https://dlc1994.github.io/2020/07/03/ckratpwkk000804vegak18kcu/"/>
    <id>https://dlc1994.github.io/2020/07/03/ckratpwkk000804vegak18kcu/</id>
    <published>2020-07-03T03:11:53.000Z</published>
    <updated>2020-07-03T03:41:35.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-遗传算法"><a href="#1-1-遗传算法" class="headerlink" title="1.1 遗传算法"></a>1.1 遗传算法</h2><p>遗传算法（Genetic algorithm, GA），模拟生物在自然环境中遗传和进化的<strong>自适应</strong>（对遗传参数的自适应调整）<strong>全局优化</strong>（随机变异不断寻找全局最优解）算法，基本思想是“优胜劣汰”，是应用最广泛和效果最显著的智能优化算法。<br><a id="more"></a></p><h3 id="1-1-1-编码方法"><a href="#1-1-1-编码方法" class="headerlink" title="1.1.1 编码方法"></a>1.1.1 编码方法</h3><p>算法模型通过对个体（individual，也即solution）进行二进制编码（01编码）、自然数编码、实数编码和树型编码。在对个体进行适应度计算时需要进行解码，实现问题的解空间与算法搜索空间的相互转换。</p><h3 id="1-1-2-适应度函数"><a href="#1-1-2-适应度函数" class="headerlink" title="1.1.2 适应度函数"></a>1.1.2 适应度函数</h3><p>每个个体都有一个适应度函数（Fitness），对这个个体的优劣进行定量评价，适应度函数是算法执行“适者生存、优胜劣汰”的依据。适应度函数需要根据目标函数进行设置，令$g(x)$表示目标函数，令$G(x)$表示适应度函数，从目标函数$g(x)$映射到适应度函数$G(x)$的过程称为<strong>标定</strong>。</p><p>对于最大值优化问题，可直接将$g(x)$设定为适应度函数$G(x)$，即$G(x)=g(x)$；对于最小值优化问题，$G(x)=-\min g(x)$；在遗传算法规定中，适应度函数为正值，但上述二式无法保证，因此需要加上最小值或者最大值以及分段函数。</p><h3 id="1-1-3-选择操作"><a href="#1-1-3-选择操作" class="headerlink" title="1.1.3 选择操作"></a>1.1.3 选择操作</h3><p>选择（Selection）是从当前群体中选择适应度函数值大的个体，这些优良个体有可能作为父代繁殖下一代，<strong>个体适应度函数越大，被选择作为父代的概率越大</strong>（有可能！）</p><p>选择算法有很多，最基本的是轮盘赌算法：</p><script type="math/tex; mode=display">P_i = \frac{F_i}{\sum_{i=1}^{N}F_i}</script><p>其中，$P_i$表示个体被选择的概率；$F_i$表示个体的适应度函数值；$N$表示种群规模。</p><p>根据选择概率$P_i$将圆盘形赌轮分为$N$份，第$i$个扇形的中心角为$2\pi P_i$。随机产生0到1之间服从均匀分布的数$r$，落在第$i$个扇形的累计概率为$Q_i = \sum_{j=1}^i P_j$，则选择个体$i$，重复$N$次，就可以选择$N$个个体。</p><h3 id="1-1-4-交叉操作"><a href="#1-1-4-交叉操作" class="headerlink" title="1.1.4 交叉操作"></a>1.1.4 交叉操作</h3><p>两个个体通过交叉（Crossover）互换染色体部分基因而重组产生新的个体，也就是产生新解。交叉前需要进行随机配对。</p><p>一般情况下，对二进制编码的个体采用点交叉的方法，也就是在两个配对字符串随机选择一个或者多个交叉点，互换部分子串从而产生新的字符串</p><p><img src="/2020/07/03/ckratpwkk000804vegak18kcu/crossover.jpg" alt="crossover"></p><p>两个个体是否进行交叉操作由交叉概率决定，<strong>较大的交叉概率可以使遗传算法产生更多新解，保持群体多样性，并能防止算法过早成熟，但是交叉概率过大会使算法过多搜索不必要的解区域，消耗过多的计算时间</strong>，一般取值在0.9左右。</p><h3 id="1-1-5-变异操作"><a href="#1-1-5-变异操作" class="headerlink" title="1.1.5 变异操作"></a>1.1.5 变异操作</h3><p>生物进化中，某些染色体可能会发生基因突变（Mutation），从而产生新的染色体，这也是产生新解的另外一种重要方式。<strong>交叉操作相当于进行全局探索，变异操作相当于进行局部开发，这也是智能优化算法必备的两种搜索能力</strong>。</p><p>个体能否变异取决于变异概率，过低会使得部分有用基因无法进入染色体，不能提高解的质量；过大会使子代丧失父代优良基因，导致算法失去从过去搜索经验的学习能力，一般情况下，变异概率取值为0.005左右。</p><p>值得注意的是，<strong>Rudolph通过马尔科夫链相关理论证明仅采用选择、交叉和变异三个操作的遗传算法不能收敛到全局最优解，而采用精英保留策略的遗传算法是全局收敛的</strong>。</p><p>算法的整体流程如下图所示：</p><p><img src="/2020/07/03/ckratpwkk000804vegak18kcu/GA.jpg" alt="GA"></p><h3 id="1-1-6-算法分析"><a href="#1-1-6-算法分析" class="headerlink" title="1.1.6 算法分析"></a>1.1.6 算法分析</h3><p>一个好的智能算法，关键在于全局探索和局部开发能力的平衡。全局探索的目的是对解空间进行更全面的探索，局部开发主要目的是对已知区域进行更精细的搜索，希望获得质量更好的新解。</p><p>遗传算法可以通过设置选择压力实现全局探索和局部开发的平衡。在算法运行初始阶段，设置较小的选择压力可以使算法具有较好的全局探索能力，进行广域搜索；算法运行后期，设置较大的选择压力可以使算法进行比较精细的局部搜索。</p><p>选择压力的设置可以从适应度函数标定和选择策略。</p><p>适应度函数标定，在算法早期，应当缩小个体适应度差距，减少淘汰率；算法运行最后阶段，扩大个体适应度差距，保证算法能在高适应度个体对应解区域进行集中搜索，加快算法收敛速度。常用方法有：</p><ul><li>线性尺度变换 $H = aF+b$</li><li>$\sigma$截断法 $H = F+(\hat F - c\sigma)$</li><li>幂律尺度变换 $H = F^\alpha$</li></ul><p>选择策略，低选择压力可选择多种类型的个体，加强对未知解区域的搜索，避免算法陷入局部极值，但算法优化速度会变得缓慢；高选择压力可选择优良个体，加快优化速度但群体多样性会下降，减少搜索到全局最优值的概率。除了轮盘赌算法外，选择策略还有：</p><ul><li>分级选择法</li><li>锦标赛选择法</li><li>Boltzmann选择法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-1-遗传算法&quot;&gt;&lt;a href=&quot;#1-1-遗传算法&quot; class=&quot;headerlink&quot; title=&quot;1.1 遗传算法&quot;&gt;&lt;/a&gt;1.1 遗传算法&lt;/h2&gt;&lt;p&gt;遗传算法（Genetic algorithm, GA），模拟生物在自然环境中遗传和进化的&lt;strong&gt;自适应&lt;/strong&gt;（对遗传参数的自适应调整）&lt;strong&gt;全局优化&lt;/strong&gt;（随机变异不断寻找全局最优解）算法，基本思想是“优胜劣汰”，是应用最广泛和效果最显著的智能优化算法。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Optimization Algorithms" scheme="https://dlc1994.github.io/categories/Optimization-Algorithms/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【转载】Manacher&#39;s algorithm (马拉车算法)</title>
    <link href="https://dlc1994.github.io/2020/04/05/ckratpwl0000q04vecindkoov/"/>
    <id>https://dlc1994.github.io/2020/04/05/ckratpwl0000q04vecindkoov/</id>
    <published>2020-04-05T07:24:30.000Z</published>
    <updated>2020-04-05T08:48:45.276Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ethsonliu.com/2018/04/kmp.html">Manacher’s算法(C++代码实现)</a><br><a id="more"></a></p><blockquote><p> 文章作者：刘毅 (Ethson Liu)</p><p>发布日期：2018-04-03</p><p>原文链接：<a href="https://ethsonliu.com/2018/04/manacher.html">https://ethsonliu.com/2018/04/manacher.html</a></p></blockquote><h2 id="一：背景"><a href="#一：背景" class="headerlink" title="一：背景"></a>一：背景</h2><p>给定一个字符串，求出其最长回文子串。例如：</p><ol><li>s=”abcd”，最长回文长度为 1；</li><li>s=”ababa”，最长回文长度为 5；</li><li>s=”abccb”，最长回文长度为 4，即 bccb。</li></ol><p>以上问题的传统思路大概是，遍历每一个字符，以该字符为中心向两边查找。其时间复杂度为 $O(n^2)$，效率很差。</p><p>1975 年，一个叫 Manacher 的人发明了一个算法，Manacher 算法（中文名：马拉车算法），该算法可以把时间复杂度提升到 $O(n)$。下面来看看马拉车算法是如何工作的。</p><h2 id="二：算法过程分析"><a href="#二：算法过程分析" class="headerlink" title="二：算法过程分析"></a>二：算法过程分析</h2><p>由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：在字符串首尾，及各字符间各插入一个字符（前提这个字符未出现在串里）。</p><p>举个例子：<code>s=&quot;abbahopxpo&quot;</code>，转换为<code>s_new=&quot;$#a#b#b#a#h#o#p#x#p#o#&quot;</code>（这里的字符 $ 只是为了防止越界，下面代码会有说明），如此，s 里起初有一个偶回文<code>abba</code>和一个奇回文<code>opxpo</code>，被转换为<code>#a#b#b#a#</code>和<code>#o#p#x#p#o#</code>，长度都转换成了<strong>奇数</strong>。</p><p>定义一个辅助数组<code>int p[]</code>，其中<code>p[i]</code>表示以 i 为中心的最长回文的半径，例如：</p><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th></tr></thead><tbody><tr><td style="text-align:center">s_new[i]</td><td style="text-align:center">$</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">h</td><td style="text-align:center">#</td><td style="text-align:center">o</td><td style="text-align:center">#</td><td style="text-align:center">p</td><td style="text-align:center">#</td><td style="text-align:center">x</td><td style="text-align:center">#</td><td style="text-align:center">p</td><td style="text-align:center">#</td></tr><tr><td style="text-align:center">p[i]</td><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">4</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr></tbody></table></div><p>可以看出，<code>p[i] - 1</code>正好是原字符串中最长回文串的长度。</p><p>接下来的重点就是求解 p 数组，如下图：<br><img src="https://resource.ethsonliu.com/image/20180403_02.png" alt=""><br>设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是<code>mx = id + p[id]</code>。</p><p>假设我们现在求<code>p[i]</code>，也就是以 i 为中心的最长回文半径，如果<code>i &lt; mx</code>，如上图，那么：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &lt; mx)  </span><br><span class="line">    p[i] = min(p[<span class="number">2</span> * id - i], mx - i);</span><br></pre></td></tr></table></figure><p><code>2 * id - i</code>为 i 关于 id 的对称点，即上图的 j 点，而<strong><code>p[j]</code>表示以 j 为中心的最长回文半径</strong>，因此我们可以利用<code>p[j]</code>来加快查找。</p><h2 id="三：代码"><a href="#三：代码" class="headerlink" title="三：代码"></a>三：代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">char</span> s_new[<span class="number">2000</span>];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">2000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">s_new[<span class="number">0</span>] = <span class="string">'$'</span>;</span><br><span class="line">s_new[<span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">s_new[j++] = s[i];</span><br><span class="line">s_new[j++] = <span class="string">'#'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s_new[j] = <span class="string">'\0'</span>;  <span class="comment">// 别忘了哦</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> j;  <span class="comment">// 返回 s_new 的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = Init();  <span class="comment">// 取得新字符串长度并完成向 s_new 的转换</span></span><br><span class="line"><span class="keyword">int</span> max_len = <span class="number">-1</span>;  <span class="comment">// 最长回文长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; mx)</span><br><span class="line">p[i] = min(p[<span class="number">2</span> * id - i], mx - i);  <span class="comment">// 需搞清楚上面那张图含义, mx 和 2*id-i 的含义</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (s_new[i - p[i]] == s_new[i + p[i]])  <span class="comment">// 不需边界判断，因为左有'$',右有'\0'</span></span><br><span class="line">p[i]++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们每走一步 i，都要和 mx 比较，我们希望 mx 尽可能的远，这样才能更有机会执行 if (i &lt; mx)这句代码，从而提高效率</span></span><br><span class="line"><span class="keyword">if</span> (mx &lt; i + p[i])</span><br><span class="line">&#123;</span><br><span class="line">id = i;</span><br><span class="line">mx = i + p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">max_len = max(max_len, p[i] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">printf</span>(<span class="string">"请输入字符串：\n"</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"最长回文长度为 %d\n\n"</span>, Manacher());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四：算法复杂度分析"><a href="#四：算法复杂度分析" class="headerlink" title="四：算法复杂度分析"></a>四：算法复杂度分析</h2><p>文章开头已经提及，Manacher 算法为线性算法，即使最差情况下其时间复杂度亦为 $O(n)$，在进行证明之前，我们还需要更加深入地理解上述算法过程。</p><p>根据回文的性质，<code>p[i]</code>的值基于以下三种情况得出：</p><p>（1）：<strong>j 的回文串有一部分在 id 的之外</strong>，如下图：<br><img src="https://resource.ethsonliu.com/image/20180403_03.png" alt=""><br>上图中，黑线为 id 的回文，i 与 j 关于 id 对称，红线为 j 的回文。那么根据代码此时<code>p[i] = mx - i</code>，即紫线。那么<code>p[i]</code>还可以更大么？答案是不可能！见下图：<br><img src="https://resource.ethsonliu.com/image/20180403_04.png" alt=""><br>假设右侧新增的紫色部分是<code>p[i]</code>可以增加的部分，那么根据回文的性质，a 等于 d ，也就是说 id 的回文不仅仅是黑线，而是黑线+两条紫线，矛盾，所以假设不成立，故<code>p[i] = mx - i</code>，不可以再增加一分。</p><p>（2）：<strong>j 回文串全部在 id 的内部</strong>，如下图：<br><img src="https://resource.ethsonliu.com/image/20180403_05.png" alt=""><br>根据代码，此时<code>p[i] = p[j]</code>，那么<code>p[i]</code>还可以更大么？答案亦是不可能！见下图：<br><img src="https://resource.ethsonliu.com/image/20180403_06.png" alt=""><br>假设右侧新增的红色部分是<code>p[i]</code>可以增加的部分，那么根据回文的性质，a 等于 b ，也就是说 j 的回文应该再加上 a 和 b ，矛盾，所以假设不成立，故<code>p[i] = p[j]</code>，也不可以再增加一分。</p><p>（3）：<strong>j 回文串左端正好与 id 的回文串左端重合</strong>，见下图：<br><img src="https://resource.ethsonliu.com/image/20180403_07.png" alt=""><br>根据代码，此时<code>p[i] = p[j]</code>或<code>p[i] = mx - i</code>，并且<code>p[i]</code>还可以继续增加，所以需要</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (s_new[i - p[i]] == s_new[i + p[i]]) </span><br><span class="line">    p[i]++;</span><br></pre></td></tr></table></figure><p>根据（1）（2）（3），很容易推出 Manacher 算法的最坏情况，即为字符串内全是相同字符的时候。在这里我们重点研究 Manacher() 中的 for 语句，推算发现 for 语句内平均访问每个字符 5 次，即时间复杂度为：$T_{worst}(n)=O(n)$。</p><p>同理，我们也很容易知道最佳情况下的时间复杂度，即字符串内字符各不相同的时候。推算得平均访问每个字符 4 次，即时间复杂度为：$T_{best}(n)=O(n)$。</p><p>综上，<strong>Manacher 算法的时间复杂度为 $O(n)$</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ethsonliu.com/2018/04/kmp.html&quot;&gt;Manacher’s算法(C++代码实现)&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Data Structure" scheme="https://dlc1994.github.io/categories/Algorithm-and-Data-Structure/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
      <category term="C/C++" scheme="https://dlc1994.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔记</title>
    <link href="https://dlc1994.github.io/2020/03/30/ckratpwl0000t04vea5vytau9/"/>
    <id>https://dlc1994.github.io/2020/03/30/ckratpwl0000t04vea5vytau9/</id>
    <published>2020-03-30T08:06:27.000Z</published>
    <updated>2020-07-17T09:55:27.106Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习笔记精编版，秋招时的学习笔记<br>  <a id="more"></a></p><h1 id="传统机器学习"><a href="#传统机器学习" class="headerlink" title="传统机器学习"></a>传统机器学习</h1><h2 id="Logistic-Regression和percetron的异同"><a href="#Logistic-Regression和percetron的异同" class="headerlink" title="Logistic Regression和percetron的异同"></a>Logistic Regression和percetron的异同</h2><ol><li>二者都是线性分类器</li><li>损失函数不同，LR是极大似然（交叉熵，对数似然函数，logistic损失（误差平方和损失）目标函数非凸），感知机使用的是均方损失函数（即最小化错误点到分离平面的距离）</li><li>逻辑斯蒂比感知机的优点在于对于激活函数的改进。LR为sigmoid函数，连续可导，概率解释能力，分类更好<br>感知机为阶跃函数，分段函数，分类粗糙，线性分类器参数学习，错误驱动的在线学习算法<br>损失函数L(w;x,y)=max(0, -ywx),如果训练集线性可分，算法必定收敛<br>不足：1.泛化能力不能保证；2.样本顺序敏感；3.不线性可分不收敛<br>改进：参数平均：投票感知机、平均感知机<br>拓展到多分类：构建输入输出联合空间特征函数，将样本(x,y)映射到特征向量空间<br>C分类问题，特征函数φ(x,y)=vec(yx),y为类别的one-hot向量表示</li><li>LR的最大损失函数推导<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/lr.png" alt="lr"><h2 id="最大似然概率"><a href="#最大似然概率" class="headerlink" title="最大似然概率"></a>最大似然概率</h2>p(x|θ) 是条件概率的表示方法，θ 是前置条件，理解为在 θ 的前提下，事件 x 发生的概率，相对应的似然为L(θ|x)可以理解为已知结果为 x ，参数为 θ对应的概率，即：L(θ|x)=P(x|θ)<br>需要说明的是两者在数值上相等，但是意义并不相同，L 是关于 θ 的函数，而 P 则是关于 x 的函数<br>机器学习领域，我们更关注的是似然函数的最大值，我们需要根据已知事件来找出产生这种结果最有可能的条件，目的当然是根据这个最有可能的条件去推测未知事件的概率<br>对数函数不改变原函数的单调性和极值位置，而且根据对数函数的性质可以将乘积转换为加减式，这可以大大简化求导的过程：</li></ol><h2 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h2><ol><li>线性可分支持向量机（硬间隔）<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/svm-hard.png" alt="lr"></li><li>线性支持向量机（软间隔）<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/svm-soft.png" alt="lr"><br>线性可分支持向量机的解W唯一但b不唯一<br>线性支持向量机学习等价于最小化二阶范数正则化的合页函数<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/heye.png" alt="lr"><br>合页损失函数（正确分类且函数间隔大于1，损失为0，max(z,0)）<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/heye2.png" alt="lr"></li><li>非线性支持向量机<br>通过非线性变换转化为高维特征空间中的线性分类问题，即核函数</li><li>序列最小化优化（SMO）算法<br>支持向量机的学习快速算法，固定αi之外的所有参数，然后求αi上的极值；不断重复直至收敛。</li><li><strong>和LR的异同</strong>（<a href="https://www.cnblogs.com/zhizhan/p/5038747.html）">https://www.cnblogs.com/zhizhan/p/5038747.html）</a></li></ol><ul><li>不考虑核函数，LR和SVM都是线性分类算法，分类决策面是线性的</li><li>本质是损失函数不同，LR是对数似然函数（基于概率），SVM是合页损失函数（基于几何间隔）</li><li>SVM只考虑边界点，LR考虑全局，所以LR一般不用核函数</li><li>SVM依赖数据距离测度，需要先做normalization，LR不受影响</li><li>SVM损失函数自带正则（结构风险最小化），LR需要添加</li></ul><h2 id="One-Hot-Encoding-（dummy-variables"><a href="#One-Hot-Encoding-（dummy-variables" class="headerlink" title="One-Hot Encoding （dummy variables)"></a>One-Hot Encoding （dummy variables)</h2><ol><li>一组编码[0 0 1 0]，一个为1其他为0，处理离散分类特征</li><li>许多算法基于向量空间计算，取值拓展到欧氏空间，扩充特征</li><li>特征空间大时，可结合PCA</li><li>树模型不太需要one-hot编码，对DT来说是增加树的深度</li></ol><h2 id="生成模型"><a href="#生成模型" class="headerlink" title="生成模型"></a>生成模型</h2><ol><li>监督生成模型<br>朴素贝叶斯、隐马尔科夫、条件随机场</li><li>非监督生成模型<br>受限玻尔兹曼机、GAN、自回归、变分自编码器、深度信念网络<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/struc.png" alt="lr"><br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/class.png" alt="lr"></li></ol><h2 id="模型融合：Stacking-和-Blending"><a href="#模型融合：Stacking-和-Blending" class="headerlink" title="模型融合：Stacking 和 Blending"></a>模型融合：Stacking 和 Blending</h2><ol><li>Stacking stacking是一种分层模型集成框架。以两层为例，第一层由多个基学习器组成，其输入为原始训练集，第二层的模型则是以第一层基学习器的输出作为特征加入训练集进行再训练，从而得到完整的stacking模型。</li></ol><ul><li>样例：假设我们有Training data（有label）和Testing data（无label），我们需要建立起模型对Testing data的label进行预测，我们利用两个基模型KNN和SVM进行stacking，首先我们需要训练好两个基模型</li><li>一、KNN（Base model 1） 5-fold Cross-Validation + Grid Search确定K的大小</li><li>二、SVM（Base model 2） 5-fold Cross-Validation + Grid Search确定参数 type 和 cost</li><li>三、Stacking（Meta Ensembling）<br>将training data划分成5个testing folds<br>为training data和testing中的每一个样本添加空属性M1、M2（model 1、2的输出），记为train_meta 和 test_meta<br>对于每一个test fold:<br>3.1)将其他4个folds作为一个traing fold，将此training fold作为model 1的输入，对test fold进行预测，将结果存放进train_meta的M1中，类似model 2 的结果存在M2中<br>3.2)将整个training data作为base model的输入，对testing data进行预测，model 1、2的结果分别存在test_meta的M1、M2中<br>将train_meta作为一个新模型S（也就是stacking model）的输入，对test_meta进行预测</li><li>stacking方法从一开始就得确定一个Kfold，这个Kfold将伴随对基模型的调参、生成元特征以及对元模型的调参，贯穿整个stacking流程<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/blending.png" alt="lr"></li></ul><ol><li>Blending Blending与Stacking大致相同，只是Blending的主要区别在于训练集不是通过K-Fold的CV策略来获得预测值从而生成第二阶段模型的特征，而是建立一个Holdout集，例如10%的训练数据，第二阶段的stacker模型就基于第一阶段模型对这10%训练数据的预测值进行拟合。说白了，就是把Stacking流程中的K-Fold CV 改成 HoldOut CV。</li></ol><h2 id="Adaboost-XGBoost-Bagging-LightBoost"><a href="#Adaboost-XGBoost-Bagging-LightBoost" class="headerlink" title="Adaboost,XGBoost,Bagging,LightBoost"></a>Adaboost,XGBoost,Bagging,LightBoost</h2><ol><li>Boost算法 初始样本权重，每次训练得到模型赋予错分样本更大的权重，N次迭代后对N个模型进行加权叠加或投票，得到预测结果；串行过程，不好并行化，计算复杂度高，不适合高维稀疏特征</li><li>XGBoost </li></ol><ul><li>GBDT以CART作为基分类器，XGBoost支持线性分类器（L1，L2的逻辑回归或线性回归）</li><li>GBDT优化使用一阶导数，XGBoost对代价函数进行二阶泰勒展开，支持自定义代价函数</li><li>XGBoost加入正则项，包括树的叶子节点个数、叶子节点上score值（正则化是从bias-variance考虑，可以降低模型variance，降低模型复杂度，防止过拟合，传统GBDT没有?）</li><li>列采样（每个模型随机选取一些列），借鉴随机森林，目的是降低过拟合</li><li>Shrinkage（缩减），相当于学习速率（xgboost中的eta）。xgboost在进行完一次迭代后，会将叶子节点的权重乘上该系数，主要是为了削弱每棵树的影响，让后面有更大的学习空间</li><li>并行化。不是像bagging，仍然是boost方式，并行是在特征排序上，</li><li>xgboost在训练之前，预先对数据进行排序，然后保存成block结构，后面的迭代中重复的使用这个结构，大大的减少了计算量。在进行节点分裂时，计算每个特征的信息增益，各个特征的增益计算就可以开多线程计算。</li><li>分裂节点公式：<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/split.png" alt="lr"></li></ul><ol><li>lightGBM </li></ol><ul><li>训练速度更快，效率更高。</li><li>降低内存使用率。</li><li>更好的准确性。</li><li>支持并行和GPU学习。</li><li>能够处理大规模数据。</li><li>与XGBoost GBDT区别：<br>xgboost采用预排序算法进行特征分割，比较简单；LightGBM用的是histogram（直方图），将连续特征（属性）值存储到离散的bin中，加快训练速度和减少内存使用量<br>稀疏特征优化<br>xgboost是level-wise，多线程同时分类同一层叶子，但不加区分，开销大；lightGBM是leaf-wise的，每次找分类增益最大进行分裂，限制最大深度，防止过拟合<br>并行优化（feature parallel, data parallel, voting parallel）</li></ul><ol><li>GBDT</li></ol><ul><li>GBDT用的回归树</li><li>GBDT 是以决策树为基学习器、采用 Boosting 策略的一种集成学习模型</li><li>与提升树的区别：残差的计算不同，提升树使用的是真正的残差，梯度提升树用当前模型的负梯度来拟合残差。</li><li>核心是每棵树学习的是之前所有树结论和的残差，所有树累加起来做最终结论</li><li>本质上，Shrinkage为每棵树设置了一个weight，累加时要乘以这个weight，但和Gradient并没有关系。<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/gbdt.png" alt="lr"></li></ul><ol><li>随机森林 Bagging的典型应用；随机采样（行、列），防止过拟合；剪枝、限制树深度<br>优点</li></ol><ul><li>在当前的很多数据集上，相对其他算法有着很大的优势，表现良好</li><li>它能够处理很高维度（feature很多）的数据，并且不用做特征选择 PS：特征子集是随机选择的</li><li>在训练完后，它能够给出哪些feature比较重要 PS：<a href="http://blog.csdn.net/keepreder/article/details/47277517">http://blog.csdn.net/keepreder/article/details/47277517</a></li><li>在创建随机森林的时候，对generlization error使用的是无偏估计，模型泛化能力强</li><li>训练速度快，容易做成并行化方法 PS：训练时树与树之间是相互独立的</li><li>在训练过程中，能够检测到feature间的互相影响</li><li>实现比较简单</li><li>对于不平衡的数据集来说，它可以平衡误差。</li><li>如果有很大一部分的特征遗失，仍可以维持准确度。<br>缺点：<br>1、随机森林已经被证明在某些噪音较大的分类或回归问题上会过拟合<br>2、对于有不同取值的属性的数据，取值划分较多的属性会对随机森林产生更大的影响，所以随机森林在这种数据上产出的属性权值是不可信的。</li></ul><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><ol><li>决策树学习算法：特征选择、决策树的生成、剪枝（条件概率分布）</li><li>ID3算法：信息增益；C4.5：信息增益比</li><li>CART分类：基尼系数；CART回归：平方损失函数，用平方误差最小的准则（最小二乘法）求解每个单元上的最优输出值（每个叶子节点上的预测值为所有样本的平均值）。</li><li>决策树的生成通常使用 信息增益最大、信息增益比最大或基尼指数最小作为特征选择的准则。</li></ol><h2 id="过拟合和欠拟合"><a href="#过拟合和欠拟合" class="headerlink" title="过拟合和欠拟合"></a>过拟合和欠拟合</h2><ul><li>正则化 L1（L=∑|w|）和L2(L=||w||^2)；L1的稀疏性，指的就是在加了L1正则项后，模型的解w，有很多分量都是0。引入L2正则时，代价函数在0处的导数仍是d0，无变化。而引入L1正则后，代价函数在0处的导数有一个突变。从d0+λ到d0−λ，若d0+λ和d0−λ异号，则在0处会是一个极小值点。代价函数求导。因此，优化时，很可能优化到该极小值点上，即w=0处。</li><li>提前停止 当测试集误差不再下降时停止可以避免过拟合</li><li>dropout</li><li>偏差-方差分解 在模型能力和复杂度之间取得一个较好的平衡</li><li><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/bias.png" alt="lr"></li><li>偏差高，模型拟合能力不够：增加数据特征、提高模型复杂度、减少正则化系数</li><li>方差高，模型过拟合（训练集错误低，验证集错误高）：降低模型复杂度，加大正则化系数，引入先验、集成模型</li><li><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/bias2.png" alt="lr"></li></ul><h2 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h2><ol><li>经验风险最小化 真实标签与预测标签的差异；最小二乘估计（最小均方误差）；XX^T必须满秩，即rank(XX^T)=d+1，X中每行特征之间线性不相关；样本数小于特征数也不可逆，存在多组解；当XX^T不可逆时，可用PCA消除相关性</li></ol><ul><li><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/estimate.png" alt="lr"></li></ul><ol><li>结构风险最小化 正则化；岭回归（w=(XX^T+λI）^(-1)Xy，使其秩不为0，可看出结构风险最小化准则的LSE；</li></ol><ul><li><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/xx.png" alt="lr"></li></ul><ol><li>最大似然估计 MLE是指找到一组参数w使得似然函数p(y|X,w, σ) 最大，等价于对数似然函数log p(y|X,w, σ) 最大。</li><li>最大后验估计 贝叶斯估计；MAP是指最优参数为后验分布p(w|X, y, ν, σ) 中概率密度最高的参数w。当ν → ∞时，先验分布p(w|ν) 退化为均匀分布，称为无信息先验（non-informative prior），最大后验估计退化为最大似然估计。</li></ol><ul><li><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/back-estimate.png" alt="lr"></li></ul><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>交叉熵（cross entropy) <a href="https://blog.csdn.net/mieleizhi0522/article/details/80200126">https://blog.csdn.net/mieleizhi0522/article/details/80200126</a></p><ul><li><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/loss1.png" alt="lr"></li><li><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/loss2.png" alt="lr"></li><li><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/loss3.png" alt="lr"></li></ul><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><ul><li>特征选择和特征抽取的优点是可以用较少的特征来表示原始特征中的大部分相关信息，去掉噪声信息，并进而提高计算效率和减小维度灾难</li><li>特征选择 选取原始特征集合的一个有效子集，使得基于这个特征子集训练出来的模型准确率最高；子集搜索—前向搜索，反向搜索、L1正则化</li><li>特征抽取 构造一个新的特征空间，并将原始特征投影在新的空间中。线性判断分析（LDA，监督）、PCA（无监督）</li></ul><h2 id="评价标准"><a href="#评价标准" class="headerlink" title="评价标准"></a>评价标准</h2><p>分类问题，常见的评价标准有正确率、准确率、召回率和F值，AUC,ROC,PR曲线</p><ul><li>混淆矩阵</li><li><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/evaluate1.png" alt="lr"></li><li><p><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/evaluate2.png" alt="lr"></p></li><li><p>ROC(Receiver operating characteristic) AUC(Area under the curve)<br><a href="https://tracholar.github.io/machine-learning/2018/01/26/auc.html">https://tracholar.github.io/machine-learning/2018/01/26/auc.html</a><br>准确率、召回率、F1值等依赖于判决阈值的评估指标，AUC没有</p></li><li>AUC可以看做随机从正负样本中选取一对正负样本，其中正样本的得分大于负样本的概率！<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/evaluate3.png" alt="lr"></li></ul><h2 id="超参优化"><a href="#超参优化" class="headerlink" title="超参优化"></a>超参优化</h2><ol><li>超参优化</li></ol><ul><li>网络结构，包括神经元之间的连接关系、层数、每层的神经元数量、激活函数的类型等；</li><li>优化参数，包括优化方法、学习率、小批量的样本数量等；</li><li>正则化系数。</li></ul><ol><li>超参设置方法：人工搜索、网格搜索和随机搜索。<br>网格搜索和随机搜索都没有利用不同超参数组合之间的相关性，即如果模型的超参数组合比较类似，其模型性能也是比较接近的。因此这两种搜索方式一般都比较低效。</li><li>自适应的超参数优化方法：贝叶斯优化和动态资源分配</li><li>贝叶斯优化的一个缺点是高斯过程建模需要计算协方差矩阵的逆，时间复杂度是O(n3)，因此不能很好地处理高维情况。深层神经网络的超参数一般比较多，为了使用贝叶斯优化来搜索神经网络的超参数，需要一些更高效的高斯过程建模</li><li>动态资源分配通过一组超参数的学习曲线来预估这组超参数配置是否有希望得到比较好的结果。逐次减半，将超参数优化看作是一种非随机的最优臂问题</li><li>神经架构搜索</li></ol><h2 id="网络正则化"><a href="#网络正则化" class="headerlink" title="网络正则化"></a>网络正则化</h2><p>传统的机器学习中，提高泛化能力的方法主要是限制模型复杂度，比如采用ℓ1 和ℓ2 正则化等方式。在训练深层神经网络时，特别是在过度参数（Over-Parameterized）（过度参数是指模型参数的数量远远大于训练数据的数量）时，ℓ1 和ℓ2 正则化的效果往往不如浅层机器学习模型中显著。因此训练深度学习模型时，往往还会使用其它的正则化方法，比如数据增强、提前停止、丢弃法、集成法等。<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/nomal1.png" alt="lr"></p><ul><li>权重衰减<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/nomal2.png" alt="lr"></li><li>提前停止</li><li>丢弃法（dropout) 随机丢弃一部分神经元（对应连接边）</li></ul><ol><li>集成学习的解释（每做一次丢弃，相当于从原始的网络中采样得到一个子网络）、贝叶斯学习的解释</li><li>循环神经网络上的dropout 当在循环神经网络上应用丢弃法，不能直接对每个时刻的隐状态进行随机丢弃，这样会损害循环网络在时间维度上记忆能力。一种简单的方法是对非时间维度的连接（即非循环连接）进行随机丢失</li></ol><ul><li>数据增强</li></ul><ol><li>通过数据增强（Data Augmentation）来增加数据量，提高模型鲁棒性，避免过拟合</li><li>旋转（Rotation）：将图像按顺时针或逆时针方向随机旋转一定角度；</li><li>翻转（Flip）：将图像沿水平或垂直方法随机翻转一定角度；</li><li>缩放（Zoom In/Out）：将图像放大或缩小一定比例；</li><li>平移（Shift）：将图像沿水平或垂直方法平移一定步长；</li><li>加噪声（Noise）：加入随机噪声。</li><li>标签平滑</li></ol><ul><li>注意力机制<br>一个和注意力有关的例子是鸡尾酒会效应。当一个人在吵闹的鸡尾酒会上和朋友聊天时，尽管周围噪音干扰很多，他还是可以听到朋友的谈话内容，而忽略其他人的声音（聚焦式注意力）。同时，如果未注意到的背景声中有重要的词（比如他的名字），他会马上注意到（显著性注意力）。</li></ul><ol><li>可以将最大汇聚（max pooling）、门控（gating）机制来近似地看作是自下而上的基于显著性的注意力机制</li><li>注意力机制的计算可以分为两步：一是在所有输入信息上计算注意力分布，二是根据注意力分布来计算输入信息的加权平均</li></ol><h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><p>深层神经网络是一个高度非线性的模型，其风险函数是一个非凸函数，因此风险最小化是一个非凸优化问题，会存在很多局部最优点。</p><ul><li>低维空间的非凸优化问题主要是存在一些局部最优点。</li><li>在高维空间中，非凸优化的难点并不在于如何逃离局部最优点，而是如何逃离鞍点。鞍点的梯度是0，但是在一些维度上是最高点，在另一些维度上是最低点</li><li>深层神经网络的参数非常多，并且有一定的冗余性，这导致每单个参数对最终损失的影响都比较小，这导致了损失函数在局部最优点附近是一个平坦的区域，称为平坦最小值</li></ul><ol><li>梯度下降法及其变种优缺点【An overview of gradient descent optimization algorithms】</li></ol><ul><li>发展历程——SGD -&gt; SGDM -&gt; NAG -&gt;AdaGrad -&gt; AdaDelta -&gt; Adam -&gt; Nadam</li><li>BGD的时间复杂度是O(mn)<br>其中m是一次迭代计算的样本数（所有样本），n是样本特征数。</li><li>SGB的时间复杂度是O(n)好吧？</li><li>SGD一次迭代计算的样本数为1，n为样本特征数</li><li>BatchGD 全数据集用于训练，有大量冗余计算；很慢且消耗内存；可以保证到达局部最优（非凸）或全局最优（凸）</li><li>StochasticGD 一次用一个样本，取消冗余计算；更快、可在线；以高variance更新导致目标函数严重震荡，可能跳出局部最优点找到更好的，也可能不收敛（慢慢减少学习率）</li><li>Mini-batchGD 一次用一部分，结合两者优势；减少参数更新variance，稳定收敛；利用矩阵优势，计算梯度效率更高？<br>挑战：学习率的选择策略——预定义、动态调整；不同特征的学习率（低频特征步长更大）；鞍点</li><li>Momentum 加速相关方向抑制震荡；更新公式与前一次更新值有关；下降像放球一样，在同一个方向上会越来越快，在不同梯度方向会减少更新；更快收敛和更少震荡<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/gd1.png" alt="lr"></li><li>NesterovAcceleratedGreadient 动量法盲目跟随斜坡；NAG上升前先减速，对梯度下降方向有粗略预测；用到了二阶信息，上一个下降点的二阶导（黄色部分）<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/gd2.png" alt="lr"></li><li><p>Adagrad 调整学习率（低频更新大，高频更新小，词嵌入）；适合处理稀疏数据；鲁棒性提升；参数更新率不同per-parameter update;Gt,ii为对角矩阵，对角元素为过去梯度的平方和，可向量化；不需要人为调整学习率；缺陷在于平方梯度在分母，随着训练学习率会变很小，后面不再更新<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/gd3.png" alt="lr"><br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/gd4.png" alt="lr"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Adagrad update</span><br><span class="line">cache += dx*82</span><br><span class="line">x += - learning_rate * dx / (np.sqrt(cache) + 1e-7)</span><br></pre></td></tr></table></figure></li><li><p>Adagrad update<br>cache += dx<em>82<br>x += - learning_rate </em> dx / (np.sqrt(cache) + 1e-7) </p></li><li><p>Adadelta Adagrad的拓展，旨在减少它单调递减的学习率；不收集过去所有梯度，而是收集过去固定值w大小的梯度量；</p></li><li>RMSprop 也是Adagrad的改进，是Adadelta的第一步推导；一种泄露机制</li><li><p><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/gd5.png" alt="lr"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># RMSPorp</span><br><span class="line">cache = decay_rate * cache + (1 - decay_reate) * dx**2</span><br><span class="line">x += - learning_rate * dx / (np.sqrt(cache) + 1e-7)</span><br></pre></td></tr></table></figure></li><li><p>Adaptive Moment Estimation (Adam) Adagrad和RMSprop的结合：<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/gd6.png" alt="lr"><br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/gd7.png" alt="lr"></p></li></ul><p>m与v分别是梯度的一阶矩（带权平均）和二阶矩（带权有偏方差），初始为0向量。Adam的作者发现它们(接近于0向量)，特别是在衰减因子(衰减率)β1,β2接近于1时。为了改进这个问题，对m与v进行偏差修正(bias-corrected)，偏差修正取决于时间步长t</p><ul><li><p>Adam (bias-corrected)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m = beta1 * m + (1-beta1) * dx</span><br><span class="line">v  = beta2 * v  + (1-beta2) * (dx**2)</span><br><span class="line">m /= 1-beta1**t</span><br><span class="line">v /= 1-beta2**t</span><br><span class="line">x += - learning_rate * m / (np.sqrt(v)) + le-7)</span><br></pre></td></tr></table></figure></li><li><p>Nadam Adam和NAG的结合（既调整学习率和粗略预测未来方向）</p></li><li><p>优化器的选择 稀疏数据用自适应学习率方法（ada系列）；RMSprop,Adadelta和Adam比较相似；SGD用的很多？SGD优化时间长，依赖于初始化和退火调度，可能陷于鞍点</p></li></ul><ol><li>用什么优化根本不重要，因为paper的contribution不在优化问题上面。</li><li>控制变量法，如果baseline是用SGD的，自然也用SGD去对比，不然怎么知道是model的差异还是optimization的差异？</li><li>选择Adam还是SGD是工程问题不是科学问题。Adam比SGD好，是通过cross validation得出的不是通过数学推导得出的。</li><li>SGD和Adam没有本质区别，顶多是自行车和变速山地车的区别，多了一些trick罢了。</li><li>SGD在一些场景下效果比其他的好。</li></ol><ul><li>一些tricks </li></ul><ol><li>随机化 防止样本顺序带来的影响或偏差，更好的学习</li><li>Batch normalization（批归一化）在深度神经网络训练过程中使得每一层神经网络的输入保持相同分布，为解决“Internal Covariate Shift”问题——因为深层神经网络在做非线性变换前的<strong>激活输入值（就是那个x=WU+B，U是输入）随着网络深度加深或者在训练过程中，其分布逐渐发生偏移或者变动，之所以训练收敛慢，一般是整体分布逐渐往非线性函数的取值区间的上下限两端靠近</strong>（对于Sigmoid函数来说，意味着激活输入值WU+B是大的负值或正值），所以这导致反向传播时低层神经网络的梯度消失对于每个隐层神经元，把逐渐向非线性函数映射后向取值区间极限饱和区靠拢的输入分布强制拉回到均值为0方差为1的比较标准的正态分布，使得非线性变换函数的输入值落入对输入比较敏感的区域，以此避免<strong>梯度消失</strong>问题。<br>位于X=WU+B激活值获得之后，非线性函数变换</li></ol><ul><li>Scale and shift: 对净输入z(l) 的标准归一化会使得其取值集中的0 附近，如果使用sigmoid型激活函数时，这个取值区间刚好是接近线性变换的区间，减弱了神经网络的非线性性质。因此，为了使得归一化不对网络的表示能力造成负面影响，通过一个附加的缩放和平移变换改变取值区间。</li><li>mini-batch期望和方差：目前主要的训练方法是基于小批量的随机梯度下降方法，z(l) 的期望和方差通常用当前小批量样本集的均值和方差近似估计。</li><li>局限性：批量归一化是对一个中间层的单个神经元进行归一化操作，因此要求小批量样本的数量不能太小，否则难以计算单个神经元的统计信息。此外，如果一个神经元的净输入的分布在神经网络中是动态变化的，比如循环神经网络，那么就无法应用批量归一化操作。</li><li>层归一化LN：层归一化是对一个中间层的所有神经元进行归一化。<br>对于K 个样本的一个小批量集合Z(l) = [z(1,l); · · · ; z(K,l)]，层归一化是对矩阵Z(l) 对每一列进行归一化，而批量归一化是对每一行进行归一化</li><li>权重归一化：对神经网络的连接权重进行归一化，通过再参数化（Reparameterization）方法，将<br>连接权重分解为长度和方向两种参数</li><li>局部响应归一化：基于卷积的图像处理中。局部响应归一化和层归一化都是对同层的神经元进行归一化。不同的是局部响应归一化应用在激活函数之后，只是对邻近的神经元进行局部归一化，并且不减去均值。<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/ln.png" alt="lr"></li></ul><ol><li>提前停止</li><li>梯度噪声 使网络对于糟糕初始化更鲁棒，对训练复杂很深的网络有用<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/ln2.png" alt="lr"></li></ol><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/activation.png" alt="lr"></p><ul><li>Sigmoid S曲线；值域0-1；求导；两端饱和函数；非零中心化的输出会使得其后一层的神经元的输入发生偏置偏移（Bias Shift），并进一步使得梯度下降的收敛速度变慢。</li><li>Logistic函数 σ(x)=(1+exp(-x))^-1</li><li>Tanh函数 放大平移的Logistic函数；值域为（-1,1）；tanh(x)=2σ(2x)-1</li><li>Logistic 函数和Tanh 函数都是Sigmoid 型函数，具有饱和性，但是计算开销较大。因为这两个函数都是在中间（0 附近）近似线性，两端饱和<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/activation2.png" alt="lr"></li><li>ReLU修正线性单元 </li></ul><ol><li>原始ReLU ReLU(x)=max(0,x)；<br>优点：1.神经元运算简单，计算上更高效；2.单侧抑制、宽兴奋边界；3.Sigmoid会导致非稀疏网络，ReLU稀疏性好；4.ReLU左饱和，右导数为1，缓解梯度消失，加速梯度收敛；<br>缺点：1.输出非0中心化，给后层网络引入偏置偏移，影响梯度下降效率；2.死亡ReLU问题</li><li>LeakyReLU LeakyReLU(x)=max(0,x)+γmin(0,x)</li><li>PReLU PReLU=max(0, x) + γ_i min(0, x),可学习参数</li><li>ELU ELU=max(0, x) + min(0, γ(exp(x) − 1))</li><li>Softplus函数 Softplus(x) = log(1 + exp(x)).单侧抑制、宽兴奋边界，没有稀疏激活性<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/activation3.png" alt="lr"></li></ol><ul><li>Swish函数 自门控激活函数 swish(x) = xσ(βx)</li><li>Maxout单元  maxout单元的输入是上一层神经元的全部原始输入，是一个向量x = [x1; x2; · · · , xd]；</li></ul><h2 id="梯度消失和梯度爆炸"><a href="#梯度消失和梯度爆炸" class="headerlink" title="梯度消失和梯度爆炸"></a>梯度消失和梯度爆炸</h2><p>原因：深度神经网络和反向传播，根据损失函数计算的误差通过梯度反向传播的方式，指导深度网络权值的更新优化。</p><ol><li>梯度消失</li></ol><ul><li>网络太深层</li><li>采用了不合适的损失函数</li></ul><ol><li>梯度爆炸</li></ol><ul><li>网络太深</li><li>权值初始化值太大<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/gradient.png" alt="lr"></li></ul><ol><li>解决方案：</li></ol><ul><li>预训练加微调</li><li>梯度剪切，权重正则（针对梯度爆炸）</li><li>使用不同的激活函数</li><li>Batch normalization</li><li>残差结构</li><li>使用LSTM或GRU （有点像残差网络）</li><li>梯度截断  当梯度的模大于一定阈值时，就对梯度进行截断；分为按值截断、按模截断</li></ul><h2 id="卷积神经网络作用及发展"><a href="#卷积神经网络作用及发展" class="headerlink" title="卷积神经网络作用及发展"></a>卷积神经网络作用及发展</h2><h3 id="CNN与DNN区别：卷积、池化"><a href="#CNN与DNN区别：卷积、池化" class="headerlink" title="CNN与DNN区别：卷积、池化"></a>CNN与DNN区别：卷积、池化</h3><ul><li>卷积作用：局部感受野（提升表达能力和泛化能力），参数共享（减少运算量）</li><li>1*1卷积核作用：不影响输入输出维度，增加网络非线性表达能力，降低参数量</li><li>池化（下采样）：最大，平均；减少参数</li><li>激活函数：提升表达能力和泛化能力</li><li>Dropout:随机舍弃某些权重，降低模型复杂度，预防过拟合</li><li>LeNet(传统CNN)-&gt;AlexNet（数据增广，dropout,relu,局部响应归一化LRN）-&gt;VGG(深)-&gt;GoogLeNet(inception增加网络宽度和深度)-&gt;ResNet(shortcut，残差网络，防止梯度消失)-&gt;DenseNet(密集连接，任何两层都有直接的连接，内存占用大)</li></ul><h3 id="卷积神经网络计算"><a href="#卷积神经网络计算" class="headerlink" title="卷积神经网络计算"></a>卷积神经网络计算</h3><ul><li>卷积：n<em>m的图像，k</em>k的滤波器，卷积后为(n-k+1)<em>(m-k+1)，参数量k</em>k+1</li><li>Padding：卷积得到原图像size，加入层数为p=(k-1)/2</li><li>步长stride：(n+2p-k)/s+1，s为步长</li><li>单卷积核：三通道的过滤器与图像卷积，对k<em>k</em>3个数去加权计算和，不是分层计算</li><li>多卷积核：j个k<em>k</em>3的滤波器，得到(n-k+1)<em>(m-k+1)</em>j层输出，参数量k<em>k</em>3*j+j</li><li>池化：改变输入输出，不会有参数，n<em>m的图像，k</em>k的滤波器,s为步长，输出(n+2p-k)/s+1</li><li>全连接层：FC1 * FC2</li></ul><h3 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h3><ul><li>任务模式：序列到类别（分类）、同步序列到序列（词性标注）、异步序列到序列（编码器解码器、机器翻译）</li><li><p>参数学习：随时间反向传播（BPTT），实时循环学习算法（RTRL、前向传播）</p></li><li><p>两种算法比较：RTRL算法和BPTT算法都是基于梯度下降的算法，分别通过前<br>向模式和反向模式应用链式法则来计算梯度。在循环神经网络中，一般网络输<br>出维度远低于输入维度，因此BPTT算法的计算量会更小，但是BPTT算法需<br>要保存所有时刻的中间梯度，空间复杂度较高。RTRL算法不需要梯度回传，因<br>此非常适合用于需要在线学习或无限序列的任务中。</p></li><li>长期依赖问题：如果t时刻的输出yt 依赖于t−k 时刻的输入xt−k，当间隔k 比较大时，简单神经网络很难建模这种长距离的依赖关系，称为长期依赖问题</li><li>梯度爆炸：权重衰减（通过给参数增加ℓ1 或ℓ2 范数的正则化项来限制参数的取值范<br>围，从而使得γ ≤ 1）、梯度截断（当梯度的模大于一定阈值时，就将它截断成为一个较小的数）</li><li>梯度消失（RNN主要问题）：改变模型，ht = ht−1 + g(xt, ht−1; θ), (6.50)<br>这样ht 和ht−1 之间为既有线性关系，也有非线性关系，但有记忆容量问题—增加额外存储，选择性遗忘</li><li>LSTM和GRU：基于门控的循环神经网络</li><li>LSTM:LSTM网络引入一个新的内部状态（internal state）ct 专门进行<br>线性的循环信息传递，同时（非线性）输出信息给隐藏层的外部状态ht。<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/lstm1.png" alt="lr"><br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/lstm2.png" alt="lr"></li><li>LSTM网络中的“门”是一种“软”门，取值在(0, 1) 之间，表示以一定的比例运行信息通过。</li><li>输入门：输入门it 控制当前时刻的候选状态˜ct 有多少信息需要保存</li><li>遗忘门：遗忘门ft 控制上一个时刻的内部状态ct−1 需要遗忘多少信息</li><li>输出门：输出门ot 控制当前时刻的内部状态ct 有多少信息需要输出给外部状态ht。<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/lstm3.png" alt="lr"><br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/lstm4.png" alt="lr"></li></ul><p>LSTM网络中，记忆单元c 可以在某个时刻捕捉到某个关键信息，并有能力将此关键信息保存一定的时间间隔。记忆单元c 中保存信息的生命周期要长于短期记忆h，但又远远短于长期记忆，因此称为长的短期记忆（long short-term memory）。</p><h3 id="LSTM变体："><a href="#LSTM变体：" class="headerlink" title="LSTM变体："></a>LSTM变体：</h3><ul><li>无遗忘门的LSTM Schmidhuber最早提出，ct会不断累加</li><li>peephole连接 三个门不但依赖于输入xt 和上一时刻的隐状态ht−1，也依赖于上一个时刻的记忆单元ct−1。</li><li><p>耦合输入门和遗忘门 LSTM网络中的输入门和遗忘门有些互补关系，同时用两个门比较冗余。</p></li><li><p>门控循环单元（GRU)   GRU将输入门与和遗忘门合并成一个门：更新门。同时，GRU也不引入额外的记忆单元，直接在当前状态ht 和历史状态ht−1 之间引入线性依赖关系。</p></li></ul><p>深层循环神经网络  增加循环神经网络的深度主要是增加同一时刻网络输入到输出之间的路径xt →yt，比如增加隐状态到输出ht → yt，以及输入到隐状态xt → ht 之间的路径的深度。</p><ul><li>堆叠循环神经网络<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/lstm5.png" alt="lr"><br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/lstm6.png" alt="lr"></li><li>双向循环神经网络  一个时刻的输出不但和过去时刻的信息有关，也和后续时刻的信息有关。比如给定一个句子，其中一个词的词性由它的上下文决定<br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/lstm7.png" alt="lr"><br><img src="/2020/03/30/ckratpwl0000t04vea5vytau9/lstm8.png" alt="lr"></li></ul><h3 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h3><p>参数初始化</p><ul><li>在感知器和logistic 回归的训练中，我们一般将参数全部初始化为0</li><li>对称权重：神经网络训练，前向计算时所有隐层神经元激活值相同，导致深层无区分性</li><li>参数初始化过小：多层传递信号慢慢消失；使sigmoid丢失非线性（0附近近似线性）</li><li>参数初始化过大：sigmoid后激活值变得饱和，导致梯度接近于0</li><li>常用初始化方法：Gassian分布初始化、均匀分布初始化（Xavier 初始化）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习笔记精编版，秋招时的学习笔记&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="https://dlc1994.github.io/categories/Machine-Learning/"/>
    
    
      <category term="Gradient Decent Methods" scheme="https://dlc1994.github.io/tags/Gradient-Decent-Methods/"/>
    
  </entry>
  
  <entry>
    <title>clion连接postgresql</title>
    <link href="https://dlc1994.github.io/2020/03/21/ckratpwl0000l04veb5iuurpm/"/>
    <id>https://dlc1994.github.io/2020/03/21/ckratpwl0000l04veb5iuurpm/</id>
    <published>2020-03-21T04:12:20.000Z</published>
    <updated>2020-03-21T04:23:54.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Clion连接postgresql"><a href="#Clion连接postgresql" class="headerlink" title="Clion连接postgresql"></a>Clion连接postgresql</h1><p><a href="https://www.jetbrains.com/clion/">Clion</a>是<code>Jetbrains</code>家的面向跨平台开发的<code>C/C++</code>集成开发环境. 有时候开发需要连接到数据库进行<code>query</code>查询.<br><a id="more"></a></p><h2 id="安装postgresql"><a href="#安装postgresql" class="headerlink" title="安装postgresql"></a>安装postgresql</h2><p><a href="https://www.runoob.com/postgresql/windows-install-postgresql.html">教程</a><br>可用菜单栏上的<code>pgAdmin</code>查询自己的数据库名、端口</p><h2 id="安装Clion"><a href="#安装Clion" class="headerlink" title="安装Clion"></a>安装Clion</h2><p>参考详细文档<a href="https://www.jetbrains.com/clion">Clion使用</a></p><h2 id="设置database连接"><a href="#设置database连接" class="headerlink" title="设置database连接"></a>设置database连接</h2><ol><li><p>clion界面右侧-&gt;<code>+</code>号-&gt;<code>Data Source</code>-&gt;<code>PostgreSQL</code></p></li><li><p>检查数据库信息，用户名和密码是否正确，点击<code>Test Connection</code>，成功可返回；不成功查看下一步。</p></li><li><p>若无法连接外网，点击下方的<code>Download</code>，无法下载，但要把网址上的<code>.jar</code>包下载下来，后面用到；点击左侧<code>drivers</code>-&gt;<code>PostgreSQL</code>，在<code>Dirver files</code>下点击<code>+</code>号，加载刚下载的<code>jar</code>包，然后左侧的<code>Data source</code>，点击<code>Test Connection</code>可以看到数据库具体信息。</p></li></ol><ul><li>有时候<code>clion</code>首页会重新让输入数据库用户名和密码，输入即可</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Clion连接postgresql&quot;&gt;&lt;a href=&quot;#Clion连接postgresql&quot; class=&quot;headerlink&quot; title=&quot;Clion连接postgresql&quot;&gt;&lt;/a&gt;Clion连接postgresql&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.jetbrains.com/clion/&quot;&gt;Clion&lt;/a&gt;是&lt;code&gt;Jetbrains&lt;/code&gt;家的面向跨平台开发的&lt;code&gt;C/C++&lt;/code&gt;集成开发环境. 有时候开发需要连接到数据库进行&lt;code&gt;query&lt;/code&gt;查询.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Development" scheme="https://dlc1994.github.io/categories/Development/"/>
    
    
      <category term="Clion" scheme="https://dlc1994.github.io/tags/Clion/"/>
    
      <category term="Database" scheme="https://dlc1994.github.io/tags/Database/"/>
    
      <category term="Postgresql" scheme="https://dlc1994.github.io/tags/Postgresql/"/>
    
  </entry>
  
  <entry>
    <title>【转载】Knuth–Morris–Pratt algorithm (KMP算法)</title>
    <link href="https://dlc1994.github.io/2020/03/19/ckratpwkk000d04velsgpcisa/"/>
    <id>https://dlc1994.github.io/2020/03/19/ckratpwkk000d04velsgpcisa/</id>
    <published>2020-03-19T07:24:30.000Z</published>
    <updated>2020-04-05T08:38:26.498Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ethsonliu.com/2018/04/kmp.html">KMP算法(C++代码实现)</a><br><a id="more"></a></p><blockquote><p> 文章作者：刘毅 (Ethson Liu)</p><p>发布日期：2018-04-04</p><p>原文链接：<a href="https://ethsonliu.com/2018/04/kmp.html">https://ethsonliu.com/2018/04/kmp.html</a></p></blockquote><h2 id="一：背景"><a href="#一：背景" class="headerlink" title="一：背景"></a>一：背景</h2><p>给定一个字符串，求出其最长回文子串。例如：</p><ol><li>s=”abcd”，最长回文长度为 1；</li><li>s=”ababa”，最长回文长度为 5；</li><li>s=”abccb”，最长回文长度为 4，即 bccb。</li></ol><p>以上问题的传统思路大概是，遍历每一个字符，以该字符为中心向两边查找。其时间复杂度为 $O(n^2)$，效率很差。</p><p>1975 年，一个叫 Manacher 的人发明了一个算法，Manacher 算法（中文名：马拉车算法），该算法可以把时间复杂度提升到 $O(n)$。下面来看看马拉车算法是如何工作的。</p><h2 id="二：算法过程分析"><a href="#二：算法过程分析" class="headerlink" title="二：算法过程分析"></a>二：算法过程分析</h2><p>由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：在字符串首尾，及各字符间各插入一个字符（前提这个字符未出现在串里）。</p><p>举个例子：<code>s=&quot;abbahopxpo&quot;</code>，转换为<code>s_new=&quot;$#a#b#b#a#h#o#p#x#p#o#&quot;</code>（这里的字符 $ 只是为了防止越界，下面代码会有说明），如此，s 里起初有一个偶回文<code>abba</code>和一个奇回文<code>opxpo</code>，被转换为<code>#a#b#b#a#</code>和<code>#o#p#x#p#o#</code>，长度都转换成了<strong>奇数</strong>。</p><p>定义一个辅助数组<code>int p[]</code>，其中<code>p[i]</code>表示以 i 为中心的最长回文的半径，例如：</p><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th></tr></thead><tbody><tr><td style="text-align:center">s_new[i]</td><td style="text-align:center">$</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">h</td><td style="text-align:center">#</td><td style="text-align:center">o</td><td style="text-align:center">#</td><td style="text-align:center">p</td><td style="text-align:center">#</td><td style="text-align:center">x</td><td style="text-align:center">#</td><td style="text-align:center">p</td><td style="text-align:center">#</td></tr><tr><td style="text-align:center">p[i]</td><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">4</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr></tbody></table></div><p>可以看出，<code>p[i] - 1</code>正好是原字符串中最长回文串的长度。</p><p>接下来的重点就是求解 p 数组，如下图：<br><img src="https://resource.ethsonliu.com/image/20180403_02.png" alt=""><br>设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是<code>mx = id + p[id]</code>。</p><p>假设我们现在求<code>p[i]</code>，也就是以 i 为中心的最长回文半径，如果<code>i &lt; mx</code>，如上图，那么：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &lt; mx)  </span><br><span class="line">    p[i] = min(p[<span class="number">2</span> * id - i], mx - i);</span><br></pre></td></tr></table></figure><p><code>2 * id - i</code>为 i 关于 id 的对称点，即上图的 j 点，而<strong><code>p[j]</code>表示以 j 为中心的最长回文半径</strong>，因此我们可以利用<code>p[j]</code>来加快查找。</p><h2 id="三：代码"><a href="#三：代码" class="headerlink" title="三：代码"></a>三：代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">char</span> s_new[<span class="number">2000</span>];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">2000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">s_new[<span class="number">0</span>] = <span class="string">'$'</span>;</span><br><span class="line">s_new[<span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">s_new[j++] = s[i];</span><br><span class="line">s_new[j++] = <span class="string">'#'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s_new[j] = <span class="string">'\0'</span>;  <span class="comment">// 别忘了哦</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> j;  <span class="comment">// 返回 s_new 的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = Init();  <span class="comment">// 取得新字符串长度并完成向 s_new 的转换</span></span><br><span class="line"><span class="keyword">int</span> max_len = <span class="number">-1</span>;  <span class="comment">// 最长回文长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; mx)</span><br><span class="line">p[i] = min(p[<span class="number">2</span> * id - i], mx - i);  <span class="comment">// 需搞清楚上面那张图含义, mx 和 2*id-i 的含义</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (s_new[i - p[i]] == s_new[i + p[i]])  <span class="comment">// 不需边界判断，因为左有'$',右有'\0'</span></span><br><span class="line">p[i]++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们每走一步 i，都要和 mx 比较，我们希望 mx 尽可能的远，这样才能更有机会执行 if (i &lt; mx)这句代码，从而提高效率</span></span><br><span class="line"><span class="keyword">if</span> (mx &lt; i + p[i])</span><br><span class="line">&#123;</span><br><span class="line">id = i;</span><br><span class="line">mx = i + p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">max_len = max(max_len, p[i] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">printf</span>(<span class="string">"请输入字符串：\n"</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"最长回文长度为 %d\n\n"</span>, Manacher());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四：算法复杂度分析"><a href="#四：算法复杂度分析" class="headerlink" title="四：算法复杂度分析"></a>四：算法复杂度分析</h2><p>文章开头已经提及，Manacher 算法为线性算法，即使最差情况下其时间复杂度亦为 $O(n)$，在进行证明之前，我们还需要更加深入地理解上述算法过程。</p><p>根据回文的性质，<code>p[i]</code>的值基于以下三种情况得出：</p><p>（1）：<strong>j 的回文串有一部分在 id 的之外</strong>，如下图：<br><img src="https://resource.ethsonliu.com/image/20180403_03.png" alt=""><br>上图中，黑线为 id 的回文，i 与 j 关于 id 对称，红线为 j 的回文。那么根据代码此时<code>p[i] = mx - i</code>，即紫线。那么<code>p[i]</code>还可以更大么？答案是不可能！见下图：<br><img src="https://resource.ethsonliu.com/image/20180403_04.png" alt=""><br>假设右侧新增的紫色部分是<code>p[i]</code>可以增加的部分，那么根据回文的性质，a 等于 d ，也就是说 id 的回文不仅仅是黑线，而是黑线+两条紫线，矛盾，所以假设不成立，故<code>p[i] = mx - i</code>，不可以再增加一分。</p><p>（2）：<strong>j 回文串全部在 id 的内部</strong>，如下图：<br><img src="https://resource.ethsonliu.com/image/20180403_05.png" alt=""><br>根据代码，此时<code>p[i] = p[j]</code>，那么<code>p[i]</code>还可以更大么？答案亦是不可能！见下图：<br><img src="https://resource.ethsonliu.com/image/20180403_06.png" alt=""><br>假设右侧新增的红色部分是<code>p[i]</code>可以增加的部分，那么根据回文的性质，a 等于 b ，也就是说 j 的回文应该再加上 a 和 b ，矛盾，所以假设不成立，故<code>p[i] = p[j]</code>，也不可以再增加一分。</p><p>（3）：<strong>j 回文串左端正好与 id 的回文串左端重合</strong>，见下图：<br><img src="https://resource.ethsonliu.com/image/20180403_07.png" alt=""><br>根据代码，此时<code>p[i] = p[j]</code>或<code>p[i] = mx - i</code>，并且<code>p[i]</code>还可以继续增加，所以需要</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (s_new[i - p[i]] == s_new[i + p[i]]) </span><br><span class="line">    p[i]++;</span><br></pre></td></tr></table></figure><p>根据（1）（2）（3），很容易推出 Manacher 算法的最坏情况，即为字符串内全是相同字符的时候。在这里我们重点研究 Manacher() 中的 for 语句，推算发现 for 语句内平均访问每个字符 5 次，即时间复杂度为：$T_{worst}(n)=O(n)$。</p><p>同理，我们也很容易知道最佳情况下的时间复杂度，即字符串内字符各不相同的时候。推算得平均访问每个字符 4 次，即时间复杂度为：$T_{best}(n)=O(n)$。</p><p>综上，<strong>Manacher 算法的时间复杂度为 $O(n)$</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ethsonliu.com/2018/04/kmp.html&quot;&gt;KMP算法(C++代码实现)&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Data Structure" scheme="https://dlc1994.github.io/categories/Algorithm-and-Data-Structure/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
      <category term="C/C++" scheme="https://dlc1994.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>中国第二届高性能云计算大赛（MAXP)——京东云数据算法赛</title>
    <link href="https://dlc1994.github.io/2020/03/19/ckratpwkk000c04ve8cetw20q/"/>
    <id>https://dlc1994.github.io/2020/03/19/ckratpwkk000c04ve8cetw20q/</id>
    <published>2020-03-19T07:20:45.000Z</published>
    <updated>2020-03-21T03:57:32.078Z</updated>
    
    <content type="html"><![CDATA[<p>中国第二届高性能云计算大赛（MAXP)——京东云数据算法赛<br><a id="more"></a></p><p><img src="/2020/03/19/ckratpwkk000c04ve8cetw20q/0001.jpg" alt="1"></p><p><img src="/2020/03/19/ckratpwkk000c04ve8cetw20q/0002.jpg" alt="2"></p><p><img src="/2020/03/19/ckratpwkk000c04ve8cetw20q/0003.jpg" alt="3"></p><p><img src="/2020/03/19/ckratpwkk000c04ve8cetw20q/0004.jpg" alt="4"></p><p><img src="/2020/03/19/ckratpwkk000c04ve8cetw20q/0005.jpg" alt="5"></p><p><img src="/2020/03/19/ckratpwkk000c04ve8cetw20q/0006.jpg" alt="6"></p><p><img src="/2020/03/19/ckratpwkk000c04ve8cetw20q/0007.jpg" alt="7"></p><p><img src="/2020/03/19/ckratpwkk000c04ve8cetw20q/0008.jpg" alt="8"></p><p><img src="/2020/03/19/ckratpwkk000c04ve8cetw20q/0009.jpg" alt="9"></p><p><img src="/2020/03/19/ckratpwkk000c04ve8cetw20q/0009.jpg" alt="10"></p><p><img src="/2020/03/19/ckratpwkk000c04ve8cetw20q/0011.jpg" alt="11"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中国第二届高性能云计算大赛（MAXP)——京东云数据算法赛&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Competition" scheme="https://dlc1994.github.io/categories/Competition/"/>
    
    
      <category term="Python" scheme="https://dlc1994.github.io/tags/Python/"/>
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Postgresql+postgis地图开发说明</title>
    <link href="https://dlc1994.github.io/2020/03/19/ckratpwl0001104vedatm0sxd/"/>
    <id>https://dlc1994.github.io/2020/03/19/ckratpwl0001104vedatm0sxd/</id>
    <published>2020-03-19T07:20:45.000Z</published>
    <updated>2020-03-19T11:32:15.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Postgresql-postgis地图开发说明"><a href="#Postgresql-postgis地图开发说明" class="headerlink" title="Postgresql+postgis地图开发说明"></a><code>Postgresql+postgis</code>地图开发说明</h1><p>实习期间需要部署路网数据库查询服务，<code>windows</code>和<code>ubuntu</code>下的安装部署大同小异，现以postgresql 10+postgis 2.5.0为例<br><a id="more"></a></p><h2 id="1-安装postgresql-postgis部署地图数据查询服务"><a href="#1-安装postgresql-postgis部署地图数据查询服务" class="headerlink" title="1. 安装postgresql+postgis部署地图数据查询服务"></a>1. 安装<code>postgresql+postgis</code>部署地图数据查询服务</h2><p><code>ubuntu: sudo apt install libpq-dev postgresql-server-dev-10 postgresql-server-dev-all</code></p><p><code>windows</code>:参考博客<a href="https://blog.csdn.net/antma/article/details/83579920">csdn blog</a></p><h2 id="2-下载openstreetmap地图osm数据"><a href="#2-下载openstreetmap地图osm数据" class="headerlink" title="2. 下载openstreetmap地图osm数据"></a>2. 下载<code>openstreetmap</code>地图<code>osm</code>数据</h2><ul><li><p>下载国家地图数据，在<code>www.openstreetmap.org</code>，无法具体到省份城市</p></li><li><p>下载具体省份城市地图下载可参考<a href="https://blog.csdn.net/xxzj_zz2017/article/details/79524627">省市地图</a></p></li><li><p>更小区域地图下载，可使用<code>www.openstreetmap.org</code>限定经纬度直接导出</p></li></ul><h2 id="3-创建数据库，并支持postgis和pgrouting"><a href="#3-创建数据库，并支持postgis和pgrouting" class="headerlink" title="3. 创建数据库，并支持postgis和pgrouting"></a>3. 创建数据库，并支持<code>postgis</code>和<code>pgrouting</code></h2><ul><li>方式一，命令行</li></ul><p><code>createdb -U postgres XXX</code>（数据库名称，后续都用XXX代替）</p><p>进入数据库<code>\c XXX</code>,输入以下语句使数据库支持空间分析和空间查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE EXTENSION postgis; </span><br><span class="line">CREATE EXTENSION pgrouting;</span><br><span class="line">CREATE EXTENSION postgis_topology; </span><br><span class="line">CREATE EXTENSION fuzzystrmatch; </span><br><span class="line">CREATE EXTENSION postgis_tiger_geocoder; </span><br><span class="line">CREATE EXTENSION address_standardizer;</span><br></pre></td></tr></table></figure><ul><li>方式二：在<code>pgAdmin</code>中打开，直接以<code>postgis</code>数据库为模版创建数据库，这样创建的数据库直接支持空间查询和空间分析。</li></ul><h2 id="4-将osm数据导入数据库blog"><a href="#4-将osm数据导入数据库blog" class="headerlink" title="4. 将osm数据导入数据库blog"></a>4. 将<code>osm</code>数据导入数据库<a href="https://blog.csdn.net/cao812755156/article/details/80919521">blog</a></h2><h3 id="4-1-安装OSM数据导入工具osm2pgsql"><a href="#4-1-安装OSM数据导入工具osm2pgsql" class="headerlink" title="4.1    安装OSM数据导入工具osm2pgsql"></a>4.1    安装<code>OSM</code>数据导入工具<code>osm2pgsql</code></h3><p>(<code>Ubuntu</code>操作)：</p><p><code>sudo apt install osm2pgsql</code></p><p>(<code>windows</code>操作)：</p><ul><li><p><code>osm2pgsql</code>下载地址：<code>http://customdebug.com/osm/osm2pgsql.zip</code></p></li><li><p><code>default.style</code>文件:<code>https://github.com/openstreetmap/osm2pgsql/blob/master/default.style</code></p></li><li><p><code>osm2pgsql</code>下载好之后解压，解压完成之后，将下载的<code>default.style</code>放入到<code>.\osm2pgsql\x64</code>文件夹下</p></li></ul><h3 id="4-2-进入数据库"><a href="#4-2-进入数据库" class="headerlink" title="4.2    进入数据库"></a>4.2    进入数据库</h3><p><code>windows</code>: <code>cmd</code>输入<code>psql -U postgres -d XXX</code>进入数据库</p><p><code>ubuntu</code>: <code>psql -U user_name -d database_name -h localhost</code></p><h3 id="4-3-为了避免后面出现要输入密码或者出现Error-Connection-to-database-failed-fe-sendauth-no-password-supplied错误，将文件pg-hba-conf（文件路径：-PostgreSQL-10-data）里面的md5，下图所示的两个md5改为trust"><a href="#4-3-为了避免后面出现要输入密码或者出现Error-Connection-to-database-failed-fe-sendauth-no-password-supplied错误，将文件pg-hba-conf（文件路径：-PostgreSQL-10-data）里面的md5，下图所示的两个md5改为trust" class="headerlink" title="4.3    为了避免后面出现要输入密码或者出现Error: Connection to database failed: fe_sendauth: no password supplied错误，将文件pg_hba.conf（文件路径：...\PostgreSQL\10\data）里面的md5，下图所示的两个md5改为trust"></a>4.3    为了避免后面出现要输入密码或者出现<code>Error: Connection to database failed: fe_sendauth: no password supplied</code>错误，将文件<code>pg_hba.conf</code>（文件路径：<code>...\PostgreSQL\10\data</code>）里面的<code>md5</code>，下图所示的两个<code>md5</code>改为<code>trust</code></h3><h3 id="4-4-windwos-加载postgis对象和函数定义（postgis-sql）"><a href="#4-4-windwos-加载postgis对象和函数定义（postgis-sql）" class="headerlink" title="4.4    (windwos)加载postgis对象和函数定义（postgis.sql）"></a>4.4    (<code>windwos</code>)加载<code>postgis</code>对象和函数定义（<code>postgis.sql</code>）</h3><ul><li><p>在数据库安装位置<code>bin</code>文件夹下打开<code>dos</code>窗口，输入命令<code>psql -U postgres -d osm -f</code> “此处为postgis.sql文件的路径”。</p></li><li><p><code>postgis.sql</code>文件在<code>...PostgreSQL\10\share\contrib\postgis-2.5</code>文件夹下</p></li></ul><h3 id="4-5-windows-加载EPSG坐标系统定义（spatial-ref-sys-sql）"><a href="#4-5-windows-加载EPSG坐标系统定义（spatial-ref-sys-sql）" class="headerlink" title="4.5    (windows)加载EPSG坐标系统定义（spatial_ref_sys.sql）"></a>4.5    (<code>windows</code>)加载<code>EPSG</code>坐标系统定义（spatial_ref_sys.sql）</h3><ul><li><p>在<code>dos</code>窗口下输入命令<code>psql -U postgres -d osm -f</code> 此处为<code>postgis.sql</code>文件的路径</p></li><li><p><code>postgis.sql</code>文件在<code>...PostgreSQL\10\share\contrib\postgis-2.4</code>文件夹下</p></li></ul><h3 id="4-6-导入OSM数据"><a href="#4-6-导入OSM数据" class="headerlink" title="4.6    导入OSM数据"></a>4.6    导入<code>OSM</code>数据</h3><ul><li><p><code>ubuntu</code></p><p><code>osm2pgsql -d XXX –U username -P portID -C 12000 -S /home/china-latest.osm.pbf -H localhost -W</code></p></li><li><p><code>windows</code></p><p>在下载的<code>osm2pgsql</code>的<code>.\osm2pgsql\x64</code>文件夹下打开<code>dos</code>窗口，输入命令<code>osm2pgsql -d XXX –U username -P portID -C 12000 -S &quot;C:\develop\postsql-gis\osm2pgsql\x64\default.style&quot; china-latest.osm.pbf</code></p></li></ul><h3 id="4-7-验证数据是否成功"><a href="#4-7-验证数据是否成功" class="headerlink" title="4.7    验证数据是否成功"></a>4.7    验证数据是否成功</h3><ul><li><p>(<code>linux</code>) <code>\d</code>发现多了几张<code>table</code>和<code>view</code>说明导入成功</p></li><li><p>(<code>windows</code>) 从菜单栏的<code>postgressql</code>打开<code>pgAdmin</code>，发现<code>XXX</code>库中多了4张表，说明导入成功</p></li></ul><h2 id="5-创建路网拓扑图和查询数据表"><a href="#5-创建路网拓扑图和查询数据表" class="headerlink" title="5. 创建路网拓扑图和查询数据表"></a>5. <a href="http://www.itboth.com/d/NNzYfq/postgis-postgresql-dijkstra-pgrouting-opengis">创建路网拓扑图和查询数据表</a></h2><h3 id="5-1-创建数据表，选择指定列，并重新排序gid"><a href="#5-1-创建数据表，选择指定列，并重新排序gid" class="headerlink" title="5.1    创建数据表，选择指定列，并重新排序gid"></a>5.1    创建数据表，选择指定列，并重新排序gid</h3><ul><li><p>选择指定列：<code>CREATE TABLE XXX AS (SELECT osm_id,name,ref,highway,oneway,bridge,way FROM planet_osm_roads);</code></p></li><li><p>添加起点id：<code>ALTER TABLE XXX ADD COLUMN source integer;</code></p></li><li><p>添加终点id：<code>ALTER TABLE XXX ADD COLUMN target integer;</code></p></li><li><p>添加道路权重值: <code>ALTER TABLE XXX ADD COLUMN length double precision;</code></p></li><li><p>创建序列：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE SEQUENCE test_id_seq</span><br><span class="line">START WITH 1</span><br><span class="line">INCREMENT BY 1</span><br><span class="line">NO MINVALUE</span><br><span class="line">NO MAXVALUE</span><br><span class="line">CACHE 1;</span><br></pre></td></tr></table></figure><ul><li>更新自增ID：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table XXX add column gid int;</span><br><span class="line">alter table XXX alter column gid set default nextval(&apos;test_id_seq&apos;);</span><br><span class="line">update XXX set gid=nextval(&apos;test_id_seq&apos;);</span><br></pre></td></tr></table></figure><ul><li>修改数据表中列名way为geom: <code>alter table XXX rename way to geom</code></li></ul><h3 id="5-2-创建路网拓扑-SELECT-pgr-createTopology-39-XXX-39-0-00001-39-geom-39-39-gid-39"><a href="#5-2-创建路网拓扑-SELECT-pgr-createTopology-39-XXX-39-0-00001-39-geom-39-39-gid-39" class="headerlink" title="5.2    创建路网拓扑 SELECT pgr_createTopology(&#39;XXX&#39;,0.00001, &#39;geom&#39;, &#39;gid&#39;);"></a>5.2    创建路网拓扑 <code>SELECT pgr_createTopology(&#39;XXX&#39;,0.00001, &#39;geom&#39;, &#39;gid&#39;);</code></h3><h3 id="5-3-为length赋值-update-XXX-set-length-st-length-geom"><a href="#5-3-为length赋值-update-XXX-set-length-st-length-geom" class="headerlink" title="5.3    为length赋值 update XXX set length =st_length(geom);"></a>5.3    为length赋值 update XXX set length =st_length(geom);</h3><h2 id="6-使用QGIS加载数据表和在线地图"><a href="#6-使用QGIS加载数据表和在线地图" class="headerlink" title="6. 使用QGIS加载数据表和在线地图"></a>6. 使用QGIS加载数据表和在线地图</h2><h3 id="6-1-QGIS连接postgressql"><a href="#6-1-QGIS连接postgressql" class="headerlink" title="6.1    QGIS连接postgressql"></a>6.1    <a href="https://www.jianshu.com/p/1f213e67b066">QGIS连接postgressql</a></h3><ul><li><p>连接PostGIS数据源——数据库管理器——导入数据——加载数据</p></li><li><p>输入数据库名称 端口 用户名和密码</p></li><li><p>双击数据表即可显示图层</p></li></ul><h3 id="6-2-安装在线地图插件显示地图图层"><a href="#6-2-安装在线地图插件显示地图图层" class="headerlink" title="6.2    安装在线地图插件显示地图图层"></a>6.2    <a href="https://blog.csdn.net/hetongde/article/details/79087010">安装在线地图插件显示地图图层</a></h3><ul><li>打开QGIS，在插件下搜QGIS cloud插件，选择 add background layer 即可添加google map，bing map，openstreet map 作为底图</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Postgresql-postgis地图开发说明&quot;&gt;&lt;a href=&quot;#Postgresql-postgis地图开发说明&quot; class=&quot;headerlink&quot; title=&quot;Postgresql+postgis地图开发说明&quot;&gt;&lt;/a&gt;&lt;code&gt;Postgresql+postgis&lt;/code&gt;地图开发说明&lt;/h1&gt;&lt;p&gt;实习期间需要部署路网数据库查询服务，&lt;code&gt;windows&lt;/code&gt;和&lt;code&gt;ubuntu&lt;/code&gt;下的安装部署大同小异，现以postgresql 10+postgis 2.5.0为例&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Development" scheme="https://dlc1994.github.io/categories/Development/"/>
    
    
      <category term="Database" scheme="https://dlc1994.github.io/tags/Database/"/>
    
      <category term="Postgresql" scheme="https://dlc1994.github.io/tags/Postgresql/"/>
    
      <category term="Map" scheme="https://dlc1994.github.io/tags/Map/"/>
    
      <category term="Postgis" scheme="https://dlc1994.github.io/tags/Postgis/"/>
    
  </entry>
  
</feed>
