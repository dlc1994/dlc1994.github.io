<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LC-Garden</title>
  
  <subtitle>博客没维护好，丢失源文件了，之后慢慢加回来吧</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dlc1994.github.io/"/>
  <updated>2020-03-21T04:19:32.701Z</updated>
  <id>https://dlc1994.github.io/</id>
  
  <author>
    <name>Lingcheng Dai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>clion连接postgresql</title>
    <link href="https://dlc1994.github.io/2020/03/21/ck813u1i2000ekkun6egq6bvh/"/>
    <id>https://dlc1994.github.io/2020/03/21/ck813u1i2000ekkun6egq6bvh/</id>
    <published>2020-03-21T04:12:20.000Z</published>
    <updated>2020-03-21T04:19:32.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Clion连接postgresql"><a href="#Clion连接postgresql" class="headerlink" title="Clion连接postgresql"></a>Clion连接postgresql</h1><p><a href="https://www.jetbrains.com/clion/">Clion</a>是<code>Jetbrains</code>家的面向跨平台开发的<code>C/C++</code>集成开发环境. 有时候开发需要连接到数据库进行<code>query</code>查询.</p><h2 id="安装postgresql"><a href="#安装postgresql" class="headerlink" title="安装postgresql"></a>安装postgresql</h2><p><a href="https://www.runoob.com/postgresql/windows-install-postgresql.html">教程</a><br>可用菜单栏上的<code>pgAdmin</code>查询自己的数据库名、端口</p><h2 id="安装Clion"><a href="#安装Clion" class="headerlink" title="安装Clion"></a>安装Clion</h2><p>参考详细文档<a href="https://www.jetbrains.com/clion">Clion使用</a></p><h2 id="设置database连接"><a href="#设置database连接" class="headerlink" title="设置database连接"></a>设置database连接</h2><ol><li><p>clion界面右侧-&gt;<code>+</code>号-&gt;<code>Data Source</code>-&gt;<code>PostgreSQL</code></p></li><li><p>检查数据库信息，用户名和密码是否正确，点击<code>Test Connection</code>，成功可返回；不成功查看下一步。</p></li><li><p>若无法连接外网，点击下方的<code>Download</code>，无法下载，但要把网址上的<code>.jar</code>包下载下来，后面用到；点击左侧<code>drivers</code>-&gt;<code>PostgreSQL</code>，在<code>Dirver files</code>下点击<code>+</code>号，加载刚下载的<code>jar</code>包，然后左侧的<code>Data source</code>，点击<code>Test Connection</code>可以看到数据库具体信息。</p></li></ol><ul><li>有时候<code>clion</code>首页会重新让输入数据库用户名和密码，输入即可</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Clion连接postgresql&quot;&gt;&lt;a href=&quot;#Clion连接postgresql&quot; class=&quot;headerlink&quot; title=&quot;Clion连接postgresql&quot;&gt;&lt;/a&gt;Clion连接postgresql&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="Development" scheme="https://dlc1994.github.io/categories/Development/"/>
    
    
      <category term="Clion" scheme="https://dlc1994.github.io/tags/Clion/"/>
    
      <category term="Database" scheme="https://dlc1994.github.io/tags/Database/"/>
    
      <category term="Postgresql" scheme="https://dlc1994.github.io/tags/Postgresql/"/>
    
  </entry>
  
  <entry>
    <title>Knuth–Morris–Pratt algorithm (C++)</title>
    <link href="https://dlc1994.github.io/2020/03/19/ck813u1ht0008kkun28r4s1qj/"/>
    <id>https://dlc1994.github.io/2020/03/19/ck813u1ht0008kkun28r4s1qj/</id>
    <published>2020-03-19T07:24:30.000Z</published>
    <updated>2020-03-19T11:29:44.232Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ethsonliu.com/2018/04/kmp.html">KMP算法(C++)</a><br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace::std;</span><br><span class="line"></span><br><span class="line">void getNext(string p, vector&lt;int&gt; &amp;next) &#123;</span><br><span class="line">    int i = 0, j = -1; // i为p的下标</span><br><span class="line">    next[0] = -1;</span><br><span class="line">    int length = p.size();</span><br><span class="line">    while (i &lt; length-1) &#123;</span><br><span class="line">        if (j == -1 || p[i] == p[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void getNextVal(string p, vector&lt;int&gt; &amp;next) &#123;</span><br><span class="line">    int i = 0, j = -1; // i为p的下标</span><br><span class="line">    next[0] = -1;</span><br><span class="line">    int length = p.size();</span><br><span class="line">    while (i &lt; length-1) &#123;</span><br><span class="line">        if (j == -1 || p[i] == p[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line"></span><br><span class="line">            if (p[i] != p[j]) &#123;</span><br><span class="line">                next[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                next[i] = next[j]; // 相同继续往前找真前缀</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int KMP(string s, string p) &#123;</span><br><span class="line">    vector&lt;int&gt; v(p.size(), -1);</span><br><span class="line">    getNext(p, v);</span><br><span class="line">    int i = 0, j = 0; // s, p的下标</span><br><span class="line">    int s_len = s.size(), p_len = p.size();</span><br><span class="line">    while (i&lt;s_len &amp;&amp; j&lt;p_len) &#123;</span><br><span class="line">        if (j==-1 || s[i]==p[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            j = v[j]; // 当前字符匹配失败，跳转</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (j == p_len) return i-j;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; KMP(&quot;bbc abcdab abcdabcdabde&quot;, &quot;abcdabd&quot;) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ethsonliu.com/2018/04/kmp.html&quot;&gt;KMP算法(C++)&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Data Structure" scheme="https://dlc1994.github.io/categories/Algorithm-and-Data-Structure/"/>
    
    
      <category term="C/C++" scheme="https://dlc1994.github.io/tags/C-C/"/>
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>中国第二届高性能云计算大赛（MAXP)——京东云数据算法赛</title>
    <link href="https://dlc1994.github.io/2020/03/19/ck813u1hz000ckkunev1kby5z/"/>
    <id>https://dlc1994.github.io/2020/03/19/ck813u1hz000ckkunev1kby5z/</id>
    <published>2020-03-19T07:20:45.000Z</published>
    <updated>2020-03-21T03:57:32.078Z</updated>
    
    <content type="html"><![CDATA[<p>中国第二届高性能云计算大赛（MAXP)——京东云数据算法赛<br><a id="more"></a></p><p><img src="/2020/03/19/ck813u1hz000ckkunev1kby5z/0001.jpg" alt="1"></p><p><img src="/2020/03/19/ck813u1hz000ckkunev1kby5z/0002.jpg" alt="2"></p><p><img src="/2020/03/19/ck813u1hz000ckkunev1kby5z/0003.jpg" alt="3"></p><p><img src="/2020/03/19/ck813u1hz000ckkunev1kby5z/0004.jpg" alt="4"></p><p><img src="/2020/03/19/ck813u1hz000ckkunev1kby5z/0005.jpg" alt="5"></p><p><img src="/2020/03/19/ck813u1hz000ckkunev1kby5z/0006.jpg" alt="6"></p><p><img src="/2020/03/19/ck813u1hz000ckkunev1kby5z/0007.jpg" alt="7"></p><p><img src="/2020/03/19/ck813u1hz000ckkunev1kby5z/0008.jpg" alt="8"></p><p><img src="/2020/03/19/ck813u1hz000ckkunev1kby5z/0009.jpg" alt="9"></p><p><img src="/2020/03/19/ck813u1hz000ckkunev1kby5z/0009.jpg" alt="10"></p><p><img src="/2020/03/19/ck813u1hz000ckkunev1kby5z/0011.jpg" alt="11"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中国第二届高性能云计算大赛（MAXP)——京东云数据算法赛&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Competition" scheme="https://dlc1994.github.io/categories/Competition/"/>
    
    
      <category term="Python" scheme="https://dlc1994.github.io/tags/Python/"/>
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Postgresql+postgis地图开发说明</title>
    <link href="https://dlc1994.github.io/2020/03/19/ck813u1i4000hkkunrcc2mm6z/"/>
    <id>https://dlc1994.github.io/2020/03/19/ck813u1i4000hkkunrcc2mm6z/</id>
    <published>2020-03-19T07:20:45.000Z</published>
    <updated>2020-03-19T11:32:15.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Postgresql-postgis地图开发说明"><a href="#Postgresql-postgis地图开发说明" class="headerlink" title="Postgresql+postgis地图开发说明"></a><code>Postgresql+postgis</code>地图开发说明</h1><p>实习期间需要部署路网数据库查询服务，<code>windows</code>和<code>ubuntu</code>下的安装部署大同小异，现以postgresql 10+postgis 2.5.0为例<br><a id="more"></a></p><h2 id="1-安装postgresql-postgis部署地图数据查询服务"><a href="#1-安装postgresql-postgis部署地图数据查询服务" class="headerlink" title="1. 安装postgresql+postgis部署地图数据查询服务"></a>1. 安装<code>postgresql+postgis</code>部署地图数据查询服务</h2><p><code>ubuntu: sudo apt install libpq-dev postgresql-server-dev-10 postgresql-server-dev-all</code></p><p><code>windows</code>:参考博客<a href="https://blog.csdn.net/antma/article/details/83579920">csdn blog</a></p><h2 id="2-下载openstreetmap地图osm数据"><a href="#2-下载openstreetmap地图osm数据" class="headerlink" title="2. 下载openstreetmap地图osm数据"></a>2. 下载<code>openstreetmap</code>地图<code>osm</code>数据</h2><ul><li><p>下载国家地图数据，在<code>www.openstreetmap.org</code>，无法具体到省份城市</p></li><li><p>下载具体省份城市地图下载可参考<a href="https://blog.csdn.net/xxzj_zz2017/article/details/79524627">省市地图</a></p></li><li><p>更小区域地图下载，可使用<code>www.openstreetmap.org</code>限定经纬度直接导出</p></li></ul><h2 id="3-创建数据库，并支持postgis和pgrouting"><a href="#3-创建数据库，并支持postgis和pgrouting" class="headerlink" title="3. 创建数据库，并支持postgis和pgrouting"></a>3. 创建数据库，并支持<code>postgis</code>和<code>pgrouting</code></h2><ul><li>方式一，命令行</li></ul><p><code>createdb -U postgres XXX</code>（数据库名称，后续都用XXX代替）</p><p>进入数据库<code>\c XXX</code>,输入以下语句使数据库支持空间分析和空间查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE EXTENSION postgis; </span><br><span class="line">CREATE EXTENSION pgrouting;</span><br><span class="line">CREATE EXTENSION postgis_topology; </span><br><span class="line">CREATE EXTENSION fuzzystrmatch; </span><br><span class="line">CREATE EXTENSION postgis_tiger_geocoder; </span><br><span class="line">CREATE EXTENSION address_standardizer;</span><br></pre></td></tr></table></figure><ul><li>方式二：在<code>pgAdmin</code>中打开，直接以<code>postgis</code>数据库为模版创建数据库，这样创建的数据库直接支持空间查询和空间分析。</li></ul><h2 id="4-将osm数据导入数据库blog"><a href="#4-将osm数据导入数据库blog" class="headerlink" title="4. 将osm数据导入数据库blog"></a>4. 将<code>osm</code>数据导入数据库<a href="https://blog.csdn.net/cao812755156/article/details/80919521">blog</a></h2><h3 id="4-1-安装OSM数据导入工具osm2pgsql"><a href="#4-1-安装OSM数据导入工具osm2pgsql" class="headerlink" title="4.1    安装OSM数据导入工具osm2pgsql"></a>4.1    安装<code>OSM</code>数据导入工具<code>osm2pgsql</code></h3><p>(<code>Ubuntu</code>操作)：</p><p><code>sudo apt install osm2pgsql</code></p><p>(<code>windows</code>操作)：</p><ul><li><p><code>osm2pgsql</code>下载地址：<code>http://customdebug.com/osm/osm2pgsql.zip</code></p></li><li><p><code>default.style</code>文件:<code>https://github.com/openstreetmap/osm2pgsql/blob/master/default.style</code></p></li><li><p><code>osm2pgsql</code>下载好之后解压，解压完成之后，将下载的<code>default.style</code>放入到<code>.\osm2pgsql\x64</code>文件夹下</p></li></ul><h3 id="4-2-进入数据库"><a href="#4-2-进入数据库" class="headerlink" title="4.2    进入数据库"></a>4.2    进入数据库</h3><p><code>windows</code>: <code>cmd</code>输入<code>psql -U postgres -d XXX</code>进入数据库</p><p><code>ubuntu</code>: <code>psql -U user_name -d database_name -h localhost</code></p><h3 id="4-3-为了避免后面出现要输入密码或者出现Error-Connection-to-database-failed-fe-sendauth-no-password-supplied错误，将文件pg-hba-conf（文件路径：-PostgreSQL-10-data）里面的md5，下图所示的两个md5改为trust"><a href="#4-3-为了避免后面出现要输入密码或者出现Error-Connection-to-database-failed-fe-sendauth-no-password-supplied错误，将文件pg-hba-conf（文件路径：-PostgreSQL-10-data）里面的md5，下图所示的两个md5改为trust" class="headerlink" title="4.3    为了避免后面出现要输入密码或者出现Error: Connection to database failed: fe_sendauth: no password supplied错误，将文件pg_hba.conf（文件路径：...\PostgreSQL\10\data）里面的md5，下图所示的两个md5改为trust"></a>4.3    为了避免后面出现要输入密码或者出现<code>Error: Connection to database failed: fe_sendauth: no password supplied</code>错误，将文件<code>pg_hba.conf</code>（文件路径：<code>...\PostgreSQL\10\data</code>）里面的<code>md5</code>，下图所示的两个<code>md5</code>改为<code>trust</code></h3><h3 id="4-4-windwos-加载postgis对象和函数定义（postgis-sql）"><a href="#4-4-windwos-加载postgis对象和函数定义（postgis-sql）" class="headerlink" title="4.4    (windwos)加载postgis对象和函数定义（postgis.sql）"></a>4.4    (<code>windwos</code>)加载<code>postgis</code>对象和函数定义（<code>postgis.sql</code>）</h3><ul><li><p>在数据库安装位置<code>bin</code>文件夹下打开<code>dos</code>窗口，输入命令<code>psql -U postgres -d osm -f</code> “此处为postgis.sql文件的路径”。</p></li><li><p><code>postgis.sql</code>文件在<code>...PostgreSQL\10\share\contrib\postgis-2.5</code>文件夹下</p></li></ul><h3 id="4-5-windows-加载EPSG坐标系统定义（spatial-ref-sys-sql）"><a href="#4-5-windows-加载EPSG坐标系统定义（spatial-ref-sys-sql）" class="headerlink" title="4.5    (windows)加载EPSG坐标系统定义（spatial_ref_sys.sql）"></a>4.5    (<code>windows</code>)加载<code>EPSG</code>坐标系统定义（spatial_ref_sys.sql）</h3><ul><li><p>在<code>dos</code>窗口下输入命令<code>psql -U postgres -d osm -f</code> 此处为<code>postgis.sql</code>文件的路径</p></li><li><p><code>postgis.sql</code>文件在<code>...PostgreSQL\10\share\contrib\postgis-2.4</code>文件夹下</p></li></ul><h3 id="4-6-导入OSM数据"><a href="#4-6-导入OSM数据" class="headerlink" title="4.6    导入OSM数据"></a>4.6    导入<code>OSM</code>数据</h3><ul><li><p><code>ubuntu</code></p><p><code>osm2pgsql -d XXX –U username -P portID -C 12000 -S /home/china-latest.osm.pbf -H localhost -W</code></p></li><li><p><code>windows</code></p><p>在下载的<code>osm2pgsql</code>的<code>.\osm2pgsql\x64</code>文件夹下打开<code>dos</code>窗口，输入命令<code>osm2pgsql -d XXX –U username -P portID -C 12000 -S &quot;C:\develop\postsql-gis\osm2pgsql\x64\default.style&quot; china-latest.osm.pbf</code></p></li></ul><h3 id="4-7-验证数据是否成功"><a href="#4-7-验证数据是否成功" class="headerlink" title="4.7    验证数据是否成功"></a>4.7    验证数据是否成功</h3><ul><li><p>(<code>linux</code>) <code>\d</code>发现多了几张<code>table</code>和<code>view</code>说明导入成功</p></li><li><p>(<code>windows</code>) 从菜单栏的<code>postgressql</code>打开<code>pgAdmin</code>，发现<code>XXX</code>库中多了4张表，说明导入成功</p></li></ul><h2 id="5-创建路网拓扑图和查询数据表"><a href="#5-创建路网拓扑图和查询数据表" class="headerlink" title="5. 创建路网拓扑图和查询数据表"></a>5. <a href="http://www.itboth.com/d/NNzYfq/postgis-postgresql-dijkstra-pgrouting-opengis">创建路网拓扑图和查询数据表</a></h2><h3 id="5-1-创建数据表，选择指定列，并重新排序gid"><a href="#5-1-创建数据表，选择指定列，并重新排序gid" class="headerlink" title="5.1    创建数据表，选择指定列，并重新排序gid"></a>5.1    创建数据表，选择指定列，并重新排序gid</h3><ul><li><p>选择指定列：<code>CREATE TABLE XXX AS (SELECT osm_id,name,ref,highway,oneway,bridge,way FROM planet_osm_roads);</code></p></li><li><p>添加起点id：<code>ALTER TABLE XXX ADD COLUMN source integer;</code></p></li><li><p>添加终点id：<code>ALTER TABLE XXX ADD COLUMN target integer;</code></p></li><li><p>添加道路权重值: <code>ALTER TABLE XXX ADD COLUMN length double precision;</code></p></li><li><p>创建序列：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE SEQUENCE test_id_seq</span><br><span class="line">START WITH 1</span><br><span class="line">INCREMENT BY 1</span><br><span class="line">NO MINVALUE</span><br><span class="line">NO MAXVALUE</span><br><span class="line">CACHE 1;</span><br></pre></td></tr></table></figure><ul><li>更新自增ID：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table XXX add column gid int;</span><br><span class="line">alter table XXX alter column gid set default nextval(&apos;test_id_seq&apos;);</span><br><span class="line">update XXX set gid=nextval(&apos;test_id_seq&apos;);</span><br></pre></td></tr></table></figure><ul><li>修改数据表中列名way为geom: <code>alter table XXX rename way to geom</code></li></ul><h3 id="5-2-创建路网拓扑-SELECT-pgr-createTopology-39-XXX-39-0-00001-39-geom-39-39-gid-39"><a href="#5-2-创建路网拓扑-SELECT-pgr-createTopology-39-XXX-39-0-00001-39-geom-39-39-gid-39" class="headerlink" title="5.2    创建路网拓扑 SELECT pgr_createTopology(&#39;XXX&#39;,0.00001, &#39;geom&#39;, &#39;gid&#39;);"></a>5.2    创建路网拓扑 <code>SELECT pgr_createTopology(&#39;XXX&#39;,0.00001, &#39;geom&#39;, &#39;gid&#39;);</code></h3><h3 id="5-3-为length赋值-update-XXX-set-length-st-length-geom"><a href="#5-3-为length赋值-update-XXX-set-length-st-length-geom" class="headerlink" title="5.3    为length赋值 update XXX set length =st_length(geom);"></a>5.3    为length赋值 update XXX set length =st_length(geom);</h3><h2 id="6-使用QGIS加载数据表和在线地图"><a href="#6-使用QGIS加载数据表和在线地图" class="headerlink" title="6. 使用QGIS加载数据表和在线地图"></a>6. 使用QGIS加载数据表和在线地图</h2><h3 id="6-1-QGIS连接postgressql"><a href="#6-1-QGIS连接postgressql" class="headerlink" title="6.1    QGIS连接postgressql"></a>6.1    <a href="https://www.jianshu.com/p/1f213e67b066">QGIS连接postgressql</a></h3><ul><li><p>连接PostGIS数据源——数据库管理器——导入数据——加载数据</p></li><li><p>输入数据库名称 端口 用户名和密码</p></li><li><p>双击数据表即可显示图层</p></li></ul><h3 id="6-2-安装在线地图插件显示地图图层"><a href="#6-2-安装在线地图插件显示地图图层" class="headerlink" title="6.2    安装在线地图插件显示地图图层"></a>6.2    <a href="https://blog.csdn.net/hetongde/article/details/79087010">安装在线地图插件显示地图图层</a></h3><ul><li>打开QGIS，在插件下搜QGIS cloud插件，选择 add background layer 即可添加google map，bing map，openstreet map 作为底图</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Postgresql-postgis地图开发说明&quot;&gt;&lt;a href=&quot;#Postgresql-postgis地图开发说明&quot; class=&quot;headerlink&quot; title=&quot;Postgresql+postgis地图开发说明&quot;&gt;&lt;/a&gt;&lt;code&gt;Postgresql+postgis&lt;/code&gt;地图开发说明&lt;/h1&gt;&lt;p&gt;实习期间需要部署路网数据库查询服务，&lt;code&gt;windows&lt;/code&gt;和&lt;code&gt;ubuntu&lt;/code&gt;下的安装部署大同小异，现以postgresql 10+postgis 2.5.0为例&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Development" scheme="https://dlc1994.github.io/categories/Development/"/>
    
    
      <category term="Database" scheme="https://dlc1994.github.io/tags/Database/"/>
    
      <category term="Postgresql" scheme="https://dlc1994.github.io/tags/Postgresql/"/>
    
      <category term="Map" scheme="https://dlc1994.github.io/tags/Map/"/>
    
      <category term="Postgis" scheme="https://dlc1994.github.io/tags/Postgis/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解(C++)</title>
    <link href="https://dlc1994.github.io/2020/03/06/ck813u1ip000mkkun2nvvx1kr/"/>
    <id>https://dlc1994.github.io/2020/03/06/ck813u1ip000mkkun2nvvx1kr/</id>
    <published>2020-03-06T13:27:23.000Z</published>
    <updated>2020-03-06T11:33:35.374Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer各题目的C++解法<br><a id="more"></a><br><!-- TOC --></p><ul><li><a href="#剑指offer-1-二维数组查找">剑指offer 1 二维数组查找</a></li><li><a href="#剑指offer-2-替换空格">剑指offer 2 替换空格</a></li><li><a href="#剑指offer-3-从尾到头打印链表">剑指offer 3 从尾到头打印链表</a></li><li><a href="#剑指offer-4-重建二叉树">剑指offer 4 重建二叉树</a></li><li><a href="#剑指offer-5-用两个栈实现队列">剑指offer 5 用两个栈实现队列</a></li><li><a href="#剑指offer-6-旋转数组的最小值">剑指offer 6 旋转数组的最小值</a></li><li><a href="#剑指offer-7-斐波那契数列">剑指offer 7 斐波那契数列</a></li><li><a href="#剑指offer-8-跳台阶">剑指offer 8 跳台阶</a></li><li><a href="#剑指offer-9-变态跳台阶">剑指offer 9 变态跳台阶</a></li><li><a href="#剑指offer-10-矩形覆盖">剑指offer 10 矩形覆盖</a></li><li><a href="#剑指offer-11-二进制中1的个数">剑指offer 11 二进制中1的个数**</a></li><li><a href="#剑指offer-12-求base的exponent次方">剑指offer 12 求base的exponent次方</a></li><li><a href="#剑指offer-13-调整数组奇偶顺序">剑指offer 13 调整数组奇偶顺序</a></li><li><a href="#剑指offer-14-链表倒数第k个结点">剑指offer 14 链表倒数第k个结点</a></li><li><a href="#剑指offer-15-反转链表">剑指offer 15 反转链表</a></li><li><a href="#剑指offer-16-合并两个排序的链表">剑指offer 16 合并两个排序的链表</a></li><li><a href="#剑指offer-17-树的子结构">剑指offer 17 树的子结构</a></li><li><a href="#剑指offer-18-二叉树的镜像">剑指offer 18 二叉树的镜像</a></li><li><a href="#剑指offer-19-顺时针打印矩阵">剑指offer 19 顺时针打印矩阵</a></li><li><a href="#剑指offer-20-包含min函数的栈">剑指offer 20 包含Min函数的栈</a></li><li><a href="#剑指offer-21-栈的压入弹出序列">剑指offer 21 栈的压入、弹出序列</a></li><li><a href="#剑指offer-22-从上往下打印二叉树">剑指offer 22 从上往下打印二叉树</a></li><li><a href="#剑指offer-23-二叉搜索树的后序遍历序列">剑指offer 23 二叉搜索树的后序遍历序列</a></li><li><a href="#剑指offer-24-二叉树中和为某一值的所有路径">剑指offer 24 二叉树中和为某一值的所有路径</a></li><li><a href="#剑指offer-25-复杂链表的复制">剑指offer 25 复杂链表的复制</a></li><li><a href="#剑指offer-26-二叉搜索树转双端链表">剑指offer 26 二叉搜索树转双端链表**</a></li><li><a href="#剑指offer-27-字符串的排列">剑指offer 27 字符串的排列</a></li><li><a href="#剑指offer-28-数组中出现超过一半的数">剑指offer 28 数组中出现超过一半的数</a></li><li><a href="#剑指offer-29-最小的k个数">剑指offer 29 最小的k个数**</a></li><li><a href="#剑指offer-30-连续子数组最大和">剑指offer 30 连续子数组最大和</a></li><li><a href="#剑指offer-31-整数中1的个数">剑指offer 31 整数中1的个数</a></li><li><a href="#剑指offer-32-把数组排成最小的数">剑指offer 32 把数组排成最小的数**</a></li><li><a href="#剑指offer-33-丑数">剑指offer 33 丑数</a></li><li><a href="#剑指offer-34-第一次出现的字符">剑指offer 34 第一次出现的字符</a></li><li><a href="#剑指offer-35-数组中的逆序对">剑指offer 35 数组中的逆序对**</a></li><li><a href="#剑指offer-36-两个链表的第一个公共结点">剑指offer 36 两个链表的第一个公共结点</a></li><li><a href="#剑指offer-37-数组在排序数组出现的次数">剑指offer 37 数组在排序数组出现的次数</a></li><li><a href="#剑指offer-38-二叉树深度">剑指offer 38 二叉树深度</a></li><li><a href="#剑指offer-39-判断平衡二叉树">剑指offer 39 判断平衡二叉树</a></li><li><a href="#剑指offer-40-数组中只出现一次的数字">剑指offer 40 数组中只出现一次的数字</a></li><li><a href="#剑指offer-41-和为s的连续正数序列">剑指offer 41 和为S的连续正数序列</a></li><li><a href="#剑指offer-42-和为s的两个数">剑指offer 42 和为S的两个数</a></li><li><a href="#剑指offer-43-左旋转字符串">剑指offer 43 左旋转字符串</a></li><li><a href="#剑指offer-44-翻转单词顺序列">剑指offer 44 翻转单词顺序列</a></li><li><a href="#剑指offer-45-扑克牌顺子">剑指offer 45 扑克牌顺子</a></li><li><a href="#剑指offer-46-孩子们的游戏圆圈里最后剩下的数">剑指offer 46 孩子们的游戏（圆圈里最后剩下的数）</a></li><li><a href="#剑指offer-47-求12n">剑指offer 47 求1+2+…+n</a></li><li><a href="#剑指offer-48-不用加减乘除做加法">剑指offer 48 不用加减乘除做加法</a></li><li><a href="#剑指offer-49-把字符串转换为整数">剑指offer 49 把字符串转换为整数</a></li><li><a href="#剑指offer-50-数组中重复的数字">剑指offer 50 数组中重复的数字</a></li><li><a href="#剑指offer-51-构建乘积数组">剑指offer 51 构建乘积数组</a></li><li><a href="#剑指offer-52-正则表达式匹配">剑指offer 52 正则表达式匹配</a></li><li><a href="#剑指offer-53-表示数值的字符串">剑指offer 53 表示数值的字符串</a></li><li><a href="#剑指offer-54-字符流中第一个不重复的字符">剑指offer 54 字符流中第一个不重复的字符</a></li><li><a href="#剑指offer-55-链表中环的入口节点">剑指offer 55 链表中环的入口节点</a></li><li><a href="#剑指offer-56-删除链表中重复的节点">剑指offer 56 删除链表中重复的节点</a></li><li><a href="#剑指offer-57-二叉树的下一个节点">剑指offer 57 二叉树的下一个节点</a></li><li><a href="#剑指offer-58-对称的二叉树">剑指offer 58 对称的二叉树</a></li><li><a href="#剑指offer-59-之字形打印二叉树">剑指offer 59 之字形打印二叉树</a></li><li><a href="#剑指offer-60-把二叉树打印成多行层序遍历">剑指offer 60 把二叉树打印成多行（层序遍历）</a></li><li><a href="#剑指offer-61-序列化二叉树">剑指offer 61 序列化二叉树</a></li><li><a href="#剑指offer-62-二叉搜索树的第k个结点">剑指offer 62 二叉搜索树的第k个结点</a></li><li><a href="#剑指offer-63-数据流中的中位数">剑指offer 63 数据流中的中位数</a></li><li><a href="#剑指offer-64-滑动窗口的最大值">剑指offer 64 滑动窗口的最大值</a></li><li><a href="#剑指offer-65-矩阵中的路径">剑指offer 65 矩阵中的路径</a></li><li><a href="#剑指offer-66-机器人的动作范围">剑指offer 66 机器人的动作范围</a></li><li><a href="#剑指offer-67-剪绳子">剑指offer 67 剪绳子</a></li></ul><!-- /TOC --><div style="page-break-after: always;"></div><h1 id="剑指offer-1-二维数组查找"><a href="#剑指offer-1-二维数组查找" class="headerlink" title="剑指offer 1 二维数组查找"></a>剑指offer 1 二维数组查找</h1><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 左下往右上查找，快速定位地图经纬度 O(n+m)</span><br><span class="line">bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</span><br><span class="line">    int rows = array.size(), cols = array[0].size();</span><br><span class="line">    int row=rows-1,col=0;</span><br><span class="line">    while(row&gt;=0 &amp;&amp; col&lt;cols)&#123;</span><br><span class="line">            if(array[row][col]==target) return true;</span><br><span class="line">            else if(array[row][col]&gt;target) row--;</span><br><span class="line">            else col++;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 二分法 O(nlogm) O(n+m)</span><br><span class="line">bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</span><br><span class="line">    if(array.size()==0) return false;</span><br><span class="line">        int nrows = array.size(), ncols= array[0].size();</span><br><span class="line">        for(int i=0;i&lt;nrows;i++)&#123;</span><br><span class="line">            int low=0;</span><br><span class="line">            int high=ncols-1;</span><br><span class="line">            while(low&lt;=high)&#123;</span><br><span class="line">                int mid=(low+high)/2;</span><br><span class="line">                if(target&gt;array[i][mid])</span><br><span class="line">                    low=mid+1;</span><br><span class="line">                else if(target&lt;array[i][mid])</span><br><span class="line">                    high=mid-1;</span><br><span class="line">                else</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-2-替换空格"><a href="#剑指offer-2-替换空格" class="headerlink" title="剑指offer 2 替换空格"></a>剑指offer 2 替换空格</h1><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// O(n)</span><br><span class="line">void replaceSpace(char *str,int length) &#123;</span><br><span class="line">    int count=0;</span><br><span class="line">    for(int i=0;i&lt;length;i++)&#123;</span><br><span class="line">        if(str[i]==&apos; &apos;)</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=length-1;i&gt;=0;i--)&#123;</span><br><span class="line">        if(str[i]!=&apos; &apos;)&#123;</span><br><span class="line">            str[i+2*count]=str[i]; //非空格在新数组的位置 </span><br><span class="line">            //0 1 2 3 4 5 6 7 8  </span><br><span class="line">            //0 # 3 # 4     </span><br><span class="line">            //0 % 2 0 3 % 2 0 4</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            count--;</span><br><span class="line">            str[i+2*count]=&apos;%&apos;;</span><br><span class="line">            str[i+2*count+1]=&apos;2&apos;;</span><br><span class="line">            str[i+2*count+2]=&apos;0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-3-从尾到头打印链表"><a href="#剑指offer-3-从尾到头打印链表" class="headerlink" title="剑指offer 3 从尾到头打印链表"></a>剑指offer 3 从尾到头打印链表</h1><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//递归</span><br><span class="line">vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    if(head!=NULL)&#123;</span><br><span class="line">        if(head-&gt;next!=NULL)&#123;</span><br><span class="line">            res = printListFromTailToHead(head-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(head-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">//栈</span><br><span class="line">vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    stack&lt;int&gt; sta;</span><br><span class="line">    while(head!=NULL)&#123;</span><br><span class="line">        sta.push(head-&gt;val);</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!sta.empty())&#123;</span><br><span class="line">        res.push_back(sta.top());</span><br><span class="line">        sta.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">// **链表原地反转**</span><br><span class="line">vector&lt;int&gt; printListFromTailToHead(struct ListNode* head) &#123;</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    ListNode *buf=head;</span><br><span class="line">    ListNode *pre=buf;</span><br><span class="line">    if(head==NULL)</span><br><span class="line">        return vec;</span><br><span class="line">    while(head-&gt;next!=NULL)&#123;</span><br><span class="line">        buf=head-&gt;next;</span><br><span class="line">        head-&gt;next=buf-&gt;next;</span><br><span class="line">        buf-&gt;next=pre;</span><br><span class="line">        pre=buf;</span><br><span class="line">    &#125;</span><br><span class="line">    while(buf)&#123;</span><br><span class="line">        vec.push_back(buf-&gt;val);</span><br><span class="line">        buf=buf-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-4-重建二叉树"><a href="#剑指offer-4-重建二叉树" class="headerlink" title="剑指offer 4 重建二叉树"></a>剑指offer 4 重建二叉树</h1><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">    TreeNode* root = helper(pre, 0, pre.size()-1, vin, 0, vin.size()-1);</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* helper(vector&lt;int&gt; pre, int startpre, int endpre, vector&lt;int&gt; vin, int startvin, int endvin)&#123;</span><br><span class="line">    if(startpre&gt;endpre||startvin&gt;endvin)</span><br><span class="line">        return NULL;</span><br><span class="line">    TreeNode* root=new TreeNode(pre[startpre]);</span><br><span class="line">    for(int i=startvin;i&lt;=endvin;i++)&#123;</span><br><span class="line">        if(vin[i]==pre[startpre])&#123;</span><br><span class="line">            root-&gt;left = helper(pre, startpre+1, startpre+i-startvin, vin, startvin, i-1);</span><br><span class="line">            root-&gt;right = helper(pre, startpre+i-startvin+1, endpre, vin, i+1, endvin);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-5-用两个栈实现队列"><a href="#剑指offer-5-用两个栈实现队列" class="headerlink" title="剑指offer 5 用两个栈实现队列"></a>剑指offer 5 用两个栈实现队列</h1><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int&gt; stack1;</span><br><span class="line">stack&lt;int&gt; stack2;</span><br><span class="line">void push(int node) &#123;</span><br><span class="line">    stack1.push(node);</span><br><span class="line">&#125;</span><br><span class="line">//栈1不空，全部压入栈2，栈2的top则可以输出；</span><br><span class="line">//然后把栈2再压回栈1</span><br><span class="line">int pop() &#123;</span><br><span class="line">    while(!stack1.empty())&#123;</span><br><span class="line">        int a = stack1.top();</span><br><span class="line">        stack1.pop();</span><br><span class="line">        stack2.push(a);</span><br><span class="line">    &#125;</span><br><span class="line">    int res = stack2.top();</span><br><span class="line">    stack2.pop();</span><br><span class="line">    while(!stack2.empty())&#123;</span><br><span class="line">        stack1.push(stack2.top());</span><br><span class="line">        stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果栈2不空，栈2的top即为输出，否则把栈1全部压入栈2</span><br><span class="line">int pop() &#123;</span><br><span class="line">    if(stack2.empty())&#123;</span><br><span class="line">        while(!stack1.empty())&#123;</span><br><span class="line">            int a = stack1.top();</span><br><span class="line">            stack1.pop();</span><br><span class="line">            stack2.push(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int res = stack2.top();</span><br><span class="line">    stack2.pop();</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-6-旋转数组的最小值"><a href="#剑指offer-6-旋转数组的最小值" class="headerlink" title="剑指offer 6 旋转数组的最小值"></a>剑指offer 6 旋转数组的最小值</h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//O(N)</span><br><span class="line">int minNumberInRotateArray(int[] array) &#123;</span><br><span class="line">  if (array.length == 0)</span><br><span class="line">      return 0;</span><br><span class="line">  for (int i = 0; i &lt; array.length - 1; i++) &#123;</span><br><span class="line">      if (array[i] &gt; array[i + 1])</span><br><span class="line">          return array[i + 1];</span><br><span class="line">  &#125;</span><br><span class="line">  return array[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// O(logn) 二分法</span><br><span class="line">int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">    if(rotateArray.size()==0) return 0;</span><br><span class="line">    int low=0, high=rotateArray.size()-1;</span><br><span class="line">    while(low&lt;high)&#123;</span><br><span class="line">        int mid=(low+high)/2;</span><br><span class="line">        if(rotateArray[mid]&gt;rotateArray[high]) low=mid+1;</span><br><span class="line">        else if(rotateArray[mid]==rotateArray[high]) high--;</span><br><span class="line">        else high=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return rotateArray[high];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-7-斐波那契数列"><a href="#剑指offer-7-斐波那契数列" class="headerlink" title="剑指offer 7 斐波那契数列"></a>剑指offer 7 斐波那契数列</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//斐波那契数列</span><br><span class="line">0 1 2 3 4 ...</span><br><span class="line">0 1 1 2 3 ...</span><br><span class="line">//递归</span><br><span class="line">int Fibonacci(int n) &#123;</span><br><span class="line">    if(n==0) return 0;</span><br><span class="line">    if(n==1) return 1;</span><br><span class="line">    return Fibonacci(n-1)+Fibonacci(n-2);</span><br><span class="line">&#125;</span><br><span class="line">//循环 时间复杂度O(N) 空间复杂度O(1)</span><br><span class="line">int Fibonacci(int n) &#123;</span><br><span class="line">    if(n==0) return 0;</span><br><span class="line">    if(n==1) return 1;</span><br><span class="line">    int pre=0, now=1;</span><br><span class="line">    while(n&gt;1)&#123;</span><br><span class="line">        int tmp = pre+now;</span><br><span class="line">        pre = now;</span><br><span class="line">        now = tmp;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    return now;</span><br><span class="line">&#125;</span><br><span class="line">//动态规划 时间复杂度O(N) 空间复杂度O(N)</span><br><span class="line">int Fibonacci(int n) &#123;</span><br><span class="line">    if(n==0) return 0;</span><br><span class="line">    if(n==1) return 1;</span><br><span class="line">    vector&lt;int&gt; dp(n+1,0);</span><br><span class="line">    dp[0]=0;</span><br><span class="line">    dp[1]=1;</span><br><span class="line">    for(int i=2;i&lt;=n;++i)&#123;</span><br><span class="line">        dp[i]=dp[i-1]+dp[i-2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after: always;"></div><h1 id="剑指offer-8-跳台阶"><a href="#剑指offer-8-跳台阶" class="headerlink" title="剑指offer 8 跳台阶"></a>剑指offer 8 跳台阶</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//斐波那契数列 DP O(N)</span><br><span class="line">int jumpFloor(int number) &#123;</span><br><span class="line">    if(number&lt;2) return number;</span><br><span class="line">    int pre=1, now=2;</span><br><span class="line">    for(int i=3;i&lt;=number;i++)&#123;</span><br><span class="line">        int tmp = pre+now;</span><br><span class="line">        pre = now;</span><br><span class="line">        now=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-9-变态跳台阶"><a href="#剑指offer-9-变态跳台阶" class="headerlink" title="剑指offer 9 变态跳台阶"></a>剑指offer 9 变态跳台阶</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int jumpFloorII(int number) &#123;</span><br><span class="line">    if(number==0) return 0;</span><br><span class="line">    int res=1;</span><br><span class="line">    while(number--&gt;1)&#123;</span><br><span class="line">        res*=2;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">//移位 左移一位*2，左移n-1位即 2^(n-1)</span><br><span class="line">int res = 1&lt;&lt;(number-1)</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-10-矩形覆盖"><a href="#剑指offer-10-矩形覆盖" class="headerlink" title="剑指offer 10 矩形覆盖"></a>剑指offer 10 矩形覆盖</h1><p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，有多少种方法？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//还是斐波那契数列</span><br><span class="line"> f(n) = f(n-1) + f(n-2)， (n &gt; 2)。</span><br></pre></td></tr></table></figure></p><p>更一般的结论，如果用1*m的方块覆盖m*n区域，递推关系式为f(n) = f(n-1) + f(n-m)，(n &gt; m)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 循环</span><br><span class="line">int rectCover(int number) &#123;</span><br><span class="line">    if(number&lt;=2) return number;</span><br><span class="line">    int pre=1, now=2;</span><br><span class="line">    for(int i=3;i&lt;=number;++i)&#123;</span><br><span class="line">        int tmp=pre+now;</span><br><span class="line">        pre=now;</span><br><span class="line">        now=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return now;</span><br><span class="line">&#125;</span><br><span class="line">// 递归</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public int RectCover(int target) &#123;</span><br><span class="line">        if (target &lt; 1) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else if (target == 1 || target == 2) &#123;</span><br><span class="line">            return target;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return RectCover(target-1) + RectCover(target-2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// dp</span><br><span class="line">int rectCover(int number) &#123;</span><br><span class="line">    if ( number &lt; 1 ) return 0;</span><br><span class="line">    int g = 1, f = 2;</span><br><span class="line">    while ( --number ) &#123;</span><br><span class="line">        f = f + g;</span><br><span class="line">        g = f - g;</span><br><span class="line">    &#125;</span><br><span class="line">    return g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-11-二进制中1的个数"><a href="#剑指offer-11-二进制中1的个数" class="headerlink" title="剑指offer 11 二进制中1的个数**"></a>剑指offer 11 二进制中1的个数**</h1><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</span><br><span class="line">int NumberOf1(int n) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while (n != 0) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        n = (n - 1) &amp; n;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-12-求base的exponent次方"><a href="#剑指offer-12-求base的exponent次方" class="headerlink" title="剑指offer 12 求base的exponent次方"></a>剑指offer 12 求base的exponent次方</h1><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 简单快速幂</span><br><span class="line">double Power(double base, int exponent) &#123;</span><br><span class="line">    long long p = abs((long long)exponent);</span><br><span class="line">    double r = 1.0;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        if(p &amp; 1) r *= base;</span><br><span class="line">        base *= base;</span><br><span class="line">        p &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return exponent &lt; 0 ? 1/ r : r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一种方法：使用递归，时间复杂度O(logn)<br>当n为偶数，a^n =（a^n/2）*（a^n/2）</p><p>当n为奇数，a^n = a ^ [( n - 1) / 2] <em> a ^ [(n-1)/2] </em> a</p><p>举例：</p><p>2^11 = 2^1 <em> 2^2 </em> 2^8</p><p>2^1011 = 2^0001 <em> 2^0010 </em> 2^1000</p><p>第二种方法：累乘，时间复杂度为O(n)</p><div style="page-break-after: always;"></div><h1 id="剑指offer-13-调整数组奇偶顺序"><a href="#剑指offer-13-调整数组奇偶顺序" class="headerlink" title="剑指offer 13 调整数组奇偶顺序"></a>剑指offer 13 调整数组奇偶顺序</h1><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// O(2n) O(n) </span><br><span class="line">void reOrderArray(vector&lt;int&gt; &amp;array) &#123;</span><br><span class="line">  if(array.size()==0) return;</span><br><span class="line">  vector&lt;int&gt; res(array.size(),0);</span><br><span class="line">  int s=0,e=array.size()-1;</span><br><span class="line">  for(int i=0;i&lt;array.size();++i)&#123;</span><br><span class="line">    if(array[i]%2==1)&#123;</span><br><span class="line">      res[s++]=array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=array.size()-1;i&gt;=0;--i)&#123;</span><br><span class="line">    if(array[i]%2==0)&#123;</span><br><span class="line">      res[e--]=array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  array=res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// O(n*n) O(1) 插排想法</span><br><span class="line">void reOrderArray1(vector&lt;int&gt; &amp;array)&#123;</span><br><span class="line">  if(array.size()&lt;=1) return;</span><br><span class="line">  for(int i=0;i&lt;array.size();i++)&#123;</span><br><span class="line">    if(array[i]%2==1)&#123;</span><br><span class="line">      int tmp=array[i];</span><br><span class="line">      int j=i-1;</span><br><span class="line">      while(j&gt;=0 &amp;&amp; array[j]%2==0)&#123;</span><br><span class="line">        array[j+1]=array[j];</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">      array[j+1]  =tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 开辟2个数组分别存奇数和偶数 O(n) O(2n)</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-14-链表倒数第k个结点"><a href="#剑指offer-14-链表倒数第k个结点" class="headerlink" title="剑指offer 14 链表倒数第k个结点"></a>剑指offer 14 链表倒数第k个结点</h1><p>输入一个链表，输出该链表中倒数第k个结点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// 遍历再数 O(2n-k)</span><br><span class="line">ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123;</span><br><span class="line">    if(k&lt;=0) return NULL;</span><br><span class="line">    int cnt=0, start=0;</span><br><span class="line">    ListNode* root=pListHead;</span><br><span class="line">    while(pListHead!=NULL)&#123;</span><br><span class="line">        pListHead=pListHead-&gt;next;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(k&gt;cnt) return NULL;</span><br><span class="line">    while(start!=cnt-k)&#123;</span><br><span class="line">        root=root-&gt;next;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历再数 O(n)</span><br><span class="line">ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123;</span><br><span class="line">    if(k&lt;=0 || pListHead==NULL) return NULL;</span><br><span class="line">    ListNode *fast=pListHead;</span><br><span class="line">    ListNode *slow=pListHead;</span><br><span class="line">    while(k--&gt;0)&#123;</span><br><span class="line">if(fast==nullptr) return nullptr;</span><br><span class="line">        fast=fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">while(fast!=NULL)&#123;</span><br><span class="line">fast=fast-&gt;next;</span><br><span class="line">slow=slow-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归</span><br><span class="line">ListNode* FindKthToTail2(ListNode* pListHead, unsigned int k) &#123;</span><br><span class="line">if(pListHead==NULL) return NULL;</span><br><span class="line">ListNode* node=FindKthToTail(pListHead-&gt;next,k);</span><br><span class="line">if(node!=NULL) return node;</span><br><span class="line">cnt++;</span><br><span class="line">if(cnt==k) return pListHead;</span><br><span class="line">else return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-15-反转链表"><a href="#剑指offer-15-反转链表" class="headerlink" title="剑指offer 15 反转链表"></a>剑指offer 15 反转链表</h1><p>输入一个链表，反转链表后，输出新链表的表头。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public ListNode ReverseList(ListNode head) &#123;</span><br><span class="line">    if(head==null)</span><br><span class="line">        return null;</span><br><span class="line">    //head为当前节点，如果当前节点为空的话，那就什么也不做，直接返回null；</span><br><span class="line">    ListNode pre = null;</span><br><span class="line">    ListNode next = null;</span><br><span class="line">    //当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点</span><br><span class="line">    //需要pre和next的目的是让当前节点从pre-&gt;head-&gt;next1-&gt;next2变成pre&lt;-head next1-&gt;next2</span><br><span class="line">    //即pre让节点可以反转所指方向，但反转之后如果不用next节点保存next1节点的话，此单链表就此断开了</span><br><span class="line">    //所以需要用到pre和next两个节点</span><br><span class="line">    //1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line">    //1&lt;-2&lt;-3 4-&gt;5</span><br><span class="line">    while(head!=null)&#123;</span><br><span class="line">        //做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre</span><br><span class="line">        //如此就可以做到反转链表的效果</span><br><span class="line">        //先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂</span><br><span class="line">        next = head.next;</span><br><span class="line">        //保存完next，就可以让head从指向next变成指向pre了，代码如下</span><br><span class="line">        head.next = pre;</span><br><span class="line">        //head指向pre后，就继续依次反转下一个节点</span><br><span class="line">        //让pre，head，next依次向后移动一个节点，继续下一次的指针反转</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果head为null的时候，pre就为最后一个节点了，但是链表已经反转完毕，pre就是反转后链表的第一个节点</span><br><span class="line">    //直接输出pre就是我们想要得到的反转后的链表</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-16-合并两个排序的链表"><a href="#剑指offer-16-合并两个排序的链表" class="headerlink" title="剑指offer 16 合并两个排序的链表"></a>剑指offer 16 合并两个排序的链表</h1><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//递归</span><br><span class="line">ListNode* Merge(ListNode* pHead1, ListNode* pHead2)&#123;</span><br><span class="line">  if(pHead1==NULL) return pHead2;</span><br><span class="line">  if(pHead2==nullptr) return pHead1;</span><br><span class="line">      if(pHead1-&gt;val&gt;pHead2-&gt;val) &#123;</span><br><span class="line">    pHead2-&gt;next=Merge(pHead1, pHead2-&gt;next);</span><br><span class="line">    return pHead2;</span><br><span class="line">  &#125;</span><br><span class="line">  if(pHead1-&gt;val&lt;pHead2-&gt;val) &#123;</span><br><span class="line">    pHead1-&gt;next=Merge(pHead1-&gt;next, pHead2);</span><br><span class="line">    return pHead1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 循环</span><br><span class="line">if(list1 == null) return list2;</span><br><span class="line">if(list2 == null) return list1;</span><br><span class="line">ListNode mergeHead = null;</span><br><span class="line">ListNode current = null;</span><br><span class="line">while(list1!=null &amp;&amp; list2!=null)&#123;</span><br><span class="line">    if(list1.val &lt;= list2.val)&#123;</span><br><span class="line">        if(mergeHead == null)&#123;</span><br><span class="line">           mergeHead = current = list1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">           current.next = list1;</span><br><span class="line">           current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        list1 = list1.next;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        if(mergeHead == null)&#123;</span><br><span class="line">           mergeHead = current = list2;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">           current.next = list2;</span><br><span class="line">           current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        list2 = list2.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if(list1 == null) current.next = list2;</span><br><span class="line">else current.next = list1;</span><br><span class="line">return mergeHead;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-17-树的子结构"><a href="#剑指offer-17-树的子结构" class="headerlink" title="剑指offer 17 树的子结构"></a>剑指offer 17 树的子结构</h1><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)</span><br><span class="line">&#123;</span><br><span class="line">    bool result=false;</span><br><span class="line">    if(pRoot1!=NULL &amp;&amp; pRoot2!=NULL)&#123;</span><br><span class="line">        if(pRoot1-&gt;val==pRoot2-&gt;val) result=Tree1HaveTree2(pRoot1, pRoot2);</span><br><span class="line">        if(!result) &#123;</span><br><span class="line">            result=Tree1HaveTree2(pRoot1-&gt;left, pRoot2) || Tree1HaveTree2(pRoot1-&gt;right, pRoot2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">bool Tree1HaveTree2(TreeNode* pRoot1, TreeNode* pRoot2)&#123;</span><br><span class="line">    if(pRoot2==NULL) return true;</span><br><span class="line">    if(pRoot1==NULL) return false;</span><br><span class="line">    if(pRoot1-&gt;val!=pRoot2-&gt;val) return false;</span><br><span class="line">    return Tree1HaveTree2(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; Tree1HaveTree2(pRoot1-&gt;right,pRoot2-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-18-二叉树的镜像"><a href="#剑指offer-18-二叉树的镜像" class="headerlink" title="剑指offer 18 二叉树的镜像"></a>剑指offer 18 二叉树的镜像</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void Mirror(TreeNode *pRoot) &#123;</span><br><span class="line">    if (pRoot==NULL) return;</span><br><span class="line">    else &#123;</span><br><span class="line">        TreeNode *tmp=pRoot-&gt;left;</span><br><span class="line">        pRoot-&gt;left = pRoot-&gt;right;</span><br><span class="line">        pRoot-&gt;right = tmp;</span><br><span class="line">        Mirror(pRoot-&gt;left);</span><br><span class="line">        Mirror(pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after: always;"></div><h1 id="剑指offer-19-顺时针打印矩阵"><a href="#剑指offer-19-顺时针打印矩阵" class="headerlink" title="剑指offer 19 顺时针打印矩阵"></a>剑指offer 19 顺时针打印矩阵</h1><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123;</span><br><span class="line">    int row = matrix.size();</span><br><span class="line">    int col = matrix[0].size();</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">        </span><br><span class="line">    // 输入的二维数组非法，返回空的数组</span><br><span class="line">    if (row == 0 || col == 0)  return res;</span><br><span class="line">        </span><br><span class="line">    // 定义四个关键变量，表示左上和右下的打印范围</span><br><span class="line">    int left = 0, top = 0, right = col - 1, bottom = row - 1;</span><br><span class="line">    while (left &lt;= right &amp;&amp; top &lt;= bottom)</span><br><span class="line">    &#123;</span><br><span class="line">        // left to right</span><br><span class="line">        for (int i = left; i &lt;= right; ++i)  res.push_back(matrix[top][i]);</span><br><span class="line">        // top to bottom</span><br><span class="line">        for (int i = top + 1; i &lt;= bottom; ++i)  res.push_back(matrix[i][right]);</span><br><span class="line">        // right to left</span><br><span class="line">        if (top != bottom)</span><br><span class="line">        for (int i = right - 1; i &gt;= left; --i)  res.push_back(matrix[bottom][i]);</span><br><span class="line">        // bottom to top</span><br><span class="line">        if (left != right)</span><br><span class="line">        for (int i = bottom - 1; i &gt; top; --i)  res.push_back(matrix[i][left]);</span><br><span class="line">        left++,top++,right--,bottom--;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-20-包含Min函数的栈"><a href="#剑指offer-20-包含Min函数的栈" class="headerlink" title="剑指offer 20 包含Min函数的栈"></a>剑指offer 20 包含Min函数的栈</h1><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int&gt; stack1, stack2;</span><br><span class="line">void push(int value) &#123;</span><br><span class="line">    stack1.push(value);</span><br><span class="line">    if(stack2.empty()) stack2.push(value);</span><br><span class="line">    else&#123;</span><br><span class="line">        if(value&lt;stack2.top()) stack2.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void pop() &#123;</span><br><span class="line">    if(stack1.top()==stack2.top()) stack2.pop();</span><br><span class="line">    stack1.pop();</span><br><span class="line">&#125;</span><br><span class="line">int top() &#123;</span><br><span class="line">    return stack1.top();</span><br><span class="line">&#125;</span><br><span class="line">int min() &#123;</span><br><span class="line">    return stack2.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-21-栈的压入、弹出序列"><a href="#剑指offer-21-栈的压入、弹出序列" class="headerlink" title="剑指offer 21 栈的压入、弹出序列"></a>剑指offer 21 栈的压入、弹出序列</h1><p>//输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123;</span><br><span class="line">      if(pushV.empty()||popV.empty()) return false;</span><br><span class="line">  stack&lt;int&gt; Stack;</span><br><span class="line">  int popIndex=0;</span><br><span class="line">  for(int i=0;i&lt;pushV.size();++i)&#123;</span><br><span class="line">    Stack.push(pushV[i]);</span><br><span class="line">    while(!Stack.empty() &amp;&amp; Stack.top()==popV[popIndex])&#123;</span><br><span class="line">      Stack.pop();</span><br><span class="line">      popIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return Stack.empty();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-22-从上往下打印二叉树"><a href="#剑指offer-22-从上往下打印二叉树" class="headerlink" title="剑指offer 22 从上往下打印二叉树"></a>剑指offer 22 从上往下打印二叉树</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//双端队列</span><br><span class="line">vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">vector&lt;int&gt; res;</span><br><span class="line">if(root==NULL) return NULL;</span><br><span class="line">deque&lt;TreeNode*&gt; d;</span><br><span class="line">d.push_back(root);</span><br><span class="line">while(!d.empty())&#123;</span><br><span class="line">root=d.front();</span><br><span class="line">if(root!=NULL)&#123;</span><br><span class="line">res.push_back(root-&gt;val);</span><br><span class="line">d.push_back(root-&gt;left);</span><br><span class="line">d.push_back(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">d.pop_front();</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">//队列</span><br><span class="line">vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    if(root==NULL)</span><br><span class="line">        return res;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        res.push_back(q.front()-&gt;val);</span><br><span class="line">        if(q.front()-&gt;left!=NULL)</span><br><span class="line">            q.push(q.front()-&gt;left);</span><br><span class="line">        if(q.front()-&gt;right!=NULL)</span><br><span class="line">            q.push(q.front()-&gt;right);</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="page-break-after: always;"></div><h1 id="剑指offer-23-二叉搜索树的后序遍历序列"><a href="#剑指offer-23-二叉搜索树的后序遍历序列" class="headerlink" title="剑指offer 23 二叉搜索树的后序遍历序列"></a>剑指offer 23 二叉搜索树的后序遍历序列</h1><p>//输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。<br>//如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123;</span><br><span class="line">  if (sequence.empty()) &#123;</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br><span class="line">  return helper(sequence, 0, sequence.size() - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool helper(vector&lt;int&gt; &amp;sequence, int first, int last) &#123; // first和last表示树序列的开始和结束的位置</span><br><span class="line">  if(first &gt;= last)&#123;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line">  int curIdx = first;</span><br><span class="line">  int rootVal = sequence[last]; //后序遍历，根节点一定在最后，找到根节点后，就可以将树分为左右两棵子树，其中左子树中的元素都小于根节点，右子树中的元素都大于根节点</span><br><span class="line">  while(curIdx &lt; last &amp;&amp; sequence[curIdx] &lt; rootVal)&#123;</span><br><span class="line">      ++curIdx;</span><br><span class="line">  &#125;</span><br><span class="line">  int midIdx = curIdx; // 到curIdx的值大于根节点时，我们认为开始进入到右子树部分，用一个midIdx记录下当前的右子树开始的位置</span><br><span class="line">  while (curIdx &lt; last)&#123;</span><br><span class="line">      if(sequence[curIdx] &lt; rootVal)&#123;</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">      ++curIdx;</span><br><span class="line">  &#125;</span><br><span class="line">  return helper(sequence, first, midIdx - 1) &amp;&amp; helper(sequence, midIdx, last - 1); // 再分别对左子树和右子树做同样的操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-24-二叉树中和为某一值的所有路径"><a href="#剑指offer-24-二叉树中和为某一值的所有路径" class="headerlink" title="剑指offer 24 二叉树中和为某一值的所有路径"></a>剑指offer 24 二叉树中和为某一值的所有路径</h1><p>//输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。<br>//路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。<br>//(注意: 在返回值的list中，数组长度大的数组靠前)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">vector&lt;int&gt; path;</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123;</span><br><span class="line">if(root==NULL || expectNumber&lt;=0) return res;</span><br><span class="line">findHelper(root, expectNumber); </span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">void findHelper(TreeNode* root, int sum)&#123;</span><br><span class="line">if(root==NULL) return;</span><br><span class="line">path.push_back(root-&gt;val);</span><br><span class="line">if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL &amp;&amp; root-&gt;val==sum)&#123;</span><br><span class="line">res.push_back(path);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">if(root-&gt;left!=NULL)&#123;</span><br><span class="line">findHelper(root-&gt;left, sum-root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line">if(root-&gt;right!=NULL)&#123;</span><br><span class="line">findHelper(root-&gt;right, sum-root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">path.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-25-复杂链表的复制"><a href="#剑指offer-25-复杂链表的复制" class="headerlink" title="剑指offer 25 复杂链表的复制"></a>剑指offer 25 复杂链表的复制</h1><p>//输入一个复杂链表（每个节点中有节点值，以及两个指针，<br>//一个指向下一个节点，另一个特殊指针指向任意一个节点），<br>//返回结果为复制后复杂链表的head。<br>//（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct RandomListNode &#123;</span><br><span class="line">int label;</span><br><span class="line">struct RandomListNode *next, *random;</span><br><span class="line">RandomListNode(int x) :</span><br><span class="line">label(x), next(NULL), random(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    RandomListNode* Clone(RandomListNode* pHead)&#123;</span><br><span class="line">    if(pHead==NULL) return NULL;</span><br><span class="line">    RandomListNode* currentNode=pHead;</span><br><span class="line">    //复制每个结点，将其插入结点后面</span><br><span class="line">    while(currentNode!=NULL)&#123;</span><br><span class="line">    RandomListNode* cloneNode = new RandomListNode(currentNode-&gt;label);</span><br><span class="line">    RandomListNode* nextNode = currentNode-&gt;next;</span><br><span class="line">    currentNode-&gt;next=cloneNode;</span><br><span class="line">    cloneNode-&gt;next=nextNode;</span><br><span class="line">    currentNode=nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode=pHead;</span><br><span class="line">    //复制老结点的随机指针给新结点</span><br><span class="line">    while(currentNode!=NULL)&#123;</span><br><span class="line">    currentNode-&gt;next-&gt;random = currentNode-&gt;random==NULL?NULL:currentNode-&gt;random-&gt;next;</span><br><span class="line">    currentNode=currentNode-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    //拆分链表</span><br><span class="line">    currentNode=pHead;</span><br><span class="line">    RandomListNode* pCloneHead=pHead-&gt;next;</span><br><span class="line">    while(currentNode!=NULL)&#123;</span><br><span class="line">    RandomListNode* cloneNode=currentNode-&gt;next;</span><br><span class="line">    currentNode-&gt;next=cloneNode-&gt;next;</span><br><span class="line">    cloneNode-&gt;next=cloneNode-&gt;next==NULL?NULL:cloneNode-&gt;next-&gt;next;</span><br><span class="line">    currentNode=currentNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-26-二叉搜索树转双端链表"><a href="#剑指offer-26-二叉搜索树转双端链表" class="headerlink" title="剑指offer 26 二叉搜索树转双端链表**"></a>剑指offer 26 二叉搜索树转双端链表**</h1><p>//题目描述<br>//输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。<br>//要求不能创建任何新的结点，只能调整树中结点指针的指向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">TreeNode* Convert(TreeNode* pRootOfTree)&#123;</span><br><span class="line">if(pRootOfTree==NULL) return NULL;</span><br><span class="line">TreeNode* pre=NULL;</span><br><span class="line">convertHelper(pRootOfTree, pre);</span><br><span class="line">TreeNode* res=pRootOfTree;</span><br><span class="line">while(res-&gt;left)&#123;</span><br><span class="line">res=res-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">void convertHelper(TreeNode* cur, TreeNode*&amp; pre)&#123;</span><br><span class="line">if(cur==NULL) return;</span><br><span class="line">convertHelper(cur-&gt;left, pre);</span><br><span class="line">cur-&gt;left=pre;</span><br><span class="line">if(pre) pre-&gt;right=cur;</span><br><span class="line">pre=cur;</span><br><span class="line">convertHelper(cur-&gt;right, pre);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-27-字符串的排列"><a href="#剑指offer-27-字符串的排列" class="headerlink" title="剑指offer 27 字符串的排列"></a>剑指offer 27 字符串的排列</h1><p>题目描述<br>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<br>输入描述:<br>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 1、递归算法</span><br><span class="line">     *</span><br><span class="line">     * 解析：http://www.cnblogs.com/cxjchen/p/3932949.html  (感谢该文作者！)</span><br><span class="line">     *</span><br><span class="line">     * 对于无重复值的情况</span><br><span class="line">     *</span><br><span class="line">     * 固定第一个字符，递归取得首位后面的各种字符串组合；</span><br><span class="line">     * 再把第一个字符与后面每一个字符交换，并同样递归获得首位后面的字符串组合； *递归的出口，就是只剩一个字符的时候，递归的循环过程，就是从每个子串的第二个字符开始依次与第一个字符交换，然后继续处理子串。</span><br><span class="line">     *</span><br><span class="line">     * 假如有重复值呢？</span><br><span class="line">     * *由于全排列就是从第一个数字起，每个数分别与它后面的数字交换，我们先尝试加个这样的判断——如果一个数与后面的数字相同那么这两个数就不交换了。</span><br><span class="line">     * 例如abb，第一个数与后面两个数交换得bab，bba。然后abb中第二个数和第三个数相同，就不用交换了。</span><br><span class="line">     * 但是对bab，第二个数和第三个数不 同，则需要交换，得到bba。</span><br><span class="line">     * 由于这里的bba和开始第一个数与第三个数交换的结果相同了，因此这个方法不行。</span><br><span class="line">     *</span><br><span class="line">     * 换种思维，对abb，第一个数a与第二个数b交换得到bab，然后考虑第一个数与第三个数交换，此时由于第三个数等于第二个数，</span><br><span class="line">     * 所以第一个数就不再用与第三个数交换了。再考虑bab，它的第二个数与第三个数交换可以解决bba。此时全排列生成完毕！</span><br><span class="line">     *</span><br><span class="line">     *</span><br><span class="line">     * @param str</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">vector&lt;string&gt; Permutation(string str) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        if(str.empty()) return res;</span><br><span class="line">        permutationHelper(str, res, 0, str.size()-1);</span><br><span class="line">        sort(res.begin(),res.end());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">void permutationHelper(string str, vector&lt;string&gt; &amp;res, int start, int end)&#123;</span><br><span class="line">    if(start==end) &#123;</span><br><span class="line">        res.push_back(str);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=start;i&lt;=end;i++)&#123;   //从str的头到尾都换一次</span><br><span class="line">        if(is_swap(str, start, i))&#123;</span><br><span class="line">            swap(str, start, i);</span><br><span class="line">            permutationHelper(str, res, start+1, end);</span><br><span class="line">            swap(str, start, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool is_swap(string str, int l, int r)&#123;</span><br><span class="line">    bool flag=true;</span><br><span class="line">    for(int i=l;i&lt;r;i++)&#123;  //l==r则跳过循环，比如aa可以加入res</span><br><span class="line">        if(str[i]==str[r])&#123;</span><br><span class="line">            flag=false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line">void swap(string &amp;str, int l, int r)&#123;</span><br><span class="line">    char tmp=str[l];</span><br><span class="line">    str[l]=str[r];</span><br><span class="line">    str[r]=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap(char* str,int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    char tmp = str[a];</span><br><span class="line">    str[a] = str[b];</span><br><span class="line">    str[b] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">     * 2、字典序排列算法</span><br><span class="line">     *</span><br><span class="line">     * 可参考解析： http://www.cnblogs.com/pmars/archive/2013/12/04/3458289.html  （感谢作者）</span><br><span class="line">     *</span><br><span class="line">     * 一个全排列可看做一个字符串，字符串可有前缀、后缀。</span><br><span class="line">     * 生成给定全排列的下一个排列.所谓一个的下一个就是这一个与下一个之间没有其他的。</span><br><span class="line">     * 这就要求这一个与下一个有尽可能长的共同前缀，也即变化限制在尽可能短的后缀上。</span><br><span class="line">     *</span><br><span class="line">     * [例]839647521是1--9的排列。1—9的排列最前面的是123456789，最后面的987654321，</span><br><span class="line">     * 从右向左扫描若都是增的，就到了987654321，也就没有下一个了。否则找出第一次出现下降的位置。</span><br><span class="line">     *</span><br><span class="line">     * 【例】 如何得到346987521的下一个</span><br><span class="line">     * 1，从尾部往前找第一个P(i-1) &lt; P(i)的位置</span><br><span class="line">     * 3 4 6 &lt;- 9 &lt;- 8 &lt;- 7 &lt;- 5 &lt;- 2 &lt;- 1</span><br><span class="line">     * 最终找到6是第一个变小的数字，记录下6的位置i-1</span><br><span class="line">     *</span><br><span class="line">     * 2，从i位置往后找到最后一个大于6的数</span><br><span class="line">     * 3 4 6 -&gt; 9 -&gt; 8 -&gt; 7 5 2 1</span><br><span class="line">     * 最终找到7的位置，记录位置为m</span><br><span class="line">     *</span><br><span class="line">     * 3，交换位置i-1和m的值</span><br><span class="line">     * 3 4 7 9 8 6 5 2 1</span><br><span class="line">     * 4，倒序i位置后的所有数据</span><br><span class="line">     * 3 4 7 1 2 5 6 8 9</span><br><span class="line">     * 则347125689为346987521的下一个排列</span><br><span class="line">     *</span><br><span class="line">     * @param str</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line"> </span><br><span class="line">public ArrayList&lt;String&gt; Permutation2(String str)&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">        if(str==null || str.length()==0)&#123;</span><br><span class="line">            return list;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] chars = str.toCharArray();</span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">        list.add(String.valueOf(chars));</span><br><span class="line">        int len = chars.length;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            int lIndex = len-1;</span><br><span class="line">            int rIndex;</span><br><span class="line">            while(lIndex&gt;=1 &amp;&amp; chars[lIndex-1]&gt;=chars[lIndex])&#123;</span><br><span class="line">                lIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            if(lIndex == 0)</span><br><span class="line">                break;</span><br><span class="line">            rIndex = lIndex;</span><br><span class="line">            while(rIndex&lt;len &amp;&amp; chars[rIndex]&gt;chars[lIndex-1])&#123;</span><br><span class="line">                rIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(chars,lIndex-1,rIndex-1);</span><br><span class="line">            reverse(chars,lIndex);</span><br><span class="line"> </span><br><span class="line">            list.add(String.valueOf(chars));</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private void reverse(char[] chars,int k)&#123;</span><br><span class="line">    if(chars==null || chars.length&lt;=k)</span><br><span class="line">        return;</span><br><span class="line">    int len = chars.length;</span><br><span class="line">    for(int i=0;i&lt;(len-k)/2;i++)&#123;</span><br><span class="line">        int m = k+i;</span><br><span class="line">        int n = len-1-i;</span><br><span class="line">        if(m&lt;=n)&#123;</span><br><span class="line">            swap(chars,m,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-28-数组中出现超过一半的数"><a href="#剑指offer-28-数组中出现超过一半的数" class="headerlink" title="剑指offer 28 数组中出现超过一半的数"></a>剑指offer 28 数组中出现超过一半的数</h1><p>//数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">// O(n) 空间O(n) 不追求元素排序，不用map或者hashmap</span><br><span class="line">int MoreThanHalfNum_Solution2(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">int n = numbers.size();</span><br><span class="line">//map 记录出现次数</span><br><span class="line">unordered_map&lt;int, int&gt; m;</span><br><span class="line">int count;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">count = ++m[numbers[i]];</span><br><span class="line">if (count &gt; n/2) return numbers[i];</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">// O(n) O(1)</span><br><span class="line">int MoreThanHalfNum_Solution1(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">if(numbers.empty()) return 0;</span><br><span class="line">int n = numbers.size(), num=numbers[0],count=1;</span><br><span class="line">for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">if(numbers[i]==num) count++;</span><br><span class="line">else count--;</span><br><span class="line">if(count==0)&#123;</span><br><span class="line">num=numbers[i];</span><br><span class="line">count=1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">count=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">if(numbers[i]==num) count++;</span><br><span class="line">&#125;</span><br><span class="line">return (count&gt;n/2)?num:0;</span><br><span class="line">&#125;</span><br><span class="line">//快排思想 O(n)?O(logn)?</span><br><span class="line">int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">if(numbers.empty()) return 0;</span><br><span class="line">int n = numbers.size(), mid=n/2,count=1;</span><br><span class="line">int start=0,end=n-1;</span><br><span class="line">int k=partition(numbers, 0, n-1);</span><br><span class="line">while(k!=mid)&#123;</span><br><span class="line">if(k&gt;mid)&#123;</span><br><span class="line">end=k-1;</span><br><span class="line">k=partition(numbers, start, end);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">start=k+1;</span><br><span class="line">k=partition(numbers, start, end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int num=numbers[mid];</span><br><span class="line">count=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">if(numbers[i]==num) count++;</span><br><span class="line">&#125;</span><br><span class="line">return (count&gt;n/2)?num:0;</span><br><span class="line">&#125;</span><br><span class="line">int partition(vector&lt;int&gt; &amp;numbers, int s, int e)&#123;</span><br><span class="line">int pivot=numbers[s];</span><br><span class="line">int leftmark=s+1, rightmark=e;</span><br><span class="line">bool done=false;</span><br><span class="line">while(!done)&#123;</span><br><span class="line">while(leftmark&lt;=rightmark &amp;&amp; pivot&gt;=numbers[leftmark]) leftmark++;</span><br><span class="line">while(leftmark&lt;=rightmark &amp;&amp; pivot&lt;=numbers[rightmark]) rightmark--;</span><br><span class="line">if(leftmark&gt;rightmark) done=true;</span><br><span class="line">else&#123;</span><br><span class="line">swap(numbers, leftmark, rightmark);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(numbers, s, rightmark);</span><br><span class="line">return rightmark;</span><br><span class="line">&#125;</span><br><span class="line">void swap(vector&lt;int&gt; &amp;v, int s, int e)&#123;</span><br><span class="line">int tmp=v[s];</span><br><span class="line">v[s]=v[e];</span><br><span class="line">v[e]=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//拓展：输出数组中两个数量超过1/3的数 //投票法，讲道理partition应该也行1/3,2/3的位置</span><br><span class="line">vector&lt;int&gt; MoreThanOneThirdNum_Solution(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    if(numbers.empty()) return res;</span><br><span class="line">    int num1=0, num2=0, cnt1=0, cnt2=0, len = numbers.size();</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        if(numbers[i]==num1) cnt1++;</span><br><span class="line">        else if (numbers[i]==num2) cnt2++;</span><br><span class="line">        else if (cnt1==0) num1=numbers[i], cnt1=1;</span><br><span class="line">        else if (cnt2==0) num2=numbers[i], cnt2=1;</span><br><span class="line">        else cnt1--, cnt2--;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt1=0, cnt2=0;</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        if(numbers[i]==num1) cnt1++;</span><br><span class="line">        if(numbers[i]==num2) cnt2++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(cnt1&gt;len/3) res.push_back(num1);</span><br><span class="line">    if(cnt2&gt;len/3) res.push_back(num2);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-29-最小的k个数"><a href="#剑指offer-29-最小的k个数" class="headerlink" title="剑指offer 29 最小的k个数**"></a>剑指offer 29 最小的k个数**</h1><p>//输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。partition O(n)-O(n^2）?牛客超时？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">vector&lt;int&gt; res;</span><br><span class="line">if(input.empty() || k&gt;input.size()) return res;</span><br><span class="line">int len=input.size(), pos, s=0, e=len-1;</span><br><span class="line">pos=par(input, 0, len-1);</span><br><span class="line">while (pos!=k)&#123;</span><br><span class="line">if (pos&gt;k) e=pos-1,pos=par(input, s, e);</span><br><span class="line">else s=pos+1,pos=par(input, s, e);</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">res.push_back(input[i]);</span><br><span class="line">&#125;</span><br><span class="line">sort(res.begin(),res.end());</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">int par(vector&lt;int&gt; &amp;arr, int s, int e)&#123;</span><br><span class="line">int pivot=arr[s];</span><br><span class="line">int l=s+1, r=e;</span><br><span class="line">bool done=false;</span><br><span class="line">while(!done)&#123;</span><br><span class="line">while(l&lt;=r &amp;&amp; arr[l]&lt;=pivot) </span><br><span class="line">l++;</span><br><span class="line">while(l&lt;=r &amp;&amp; arr[r]&gt;=pivot) </span><br><span class="line">r--;</span><br><span class="line">if(l&gt;r) done=true;</span><br><span class="line">else swap(arr, l, r); </span><br><span class="line">&#125;</span><br><span class="line">swap(arr, s, r);</span><br><span class="line">return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//最大堆，待写</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-30-连续子数组最大和"><a href="#剑指offer-30-连续子数组最大和" class="headerlink" title="剑指offer 30 连续子数组最大和"></a>剑指offer 30 连续子数组最大和</h1><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//DP O(n) O(1)</span><br><span class="line">int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</span><br><span class="line">if(array.empty()) return 0;</span><br><span class="line">int len=array.size();</span><br><span class="line">int res=array[0], pre=array[0];</span><br><span class="line">for(int i=1;i&lt;len;i++)&#123;</span><br><span class="line">pre=max(array[i], pre+array[i]);</span><br><span class="line">if(res&lt;pre) res=pre;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-31-整数中1的个数"><a href="#剑指offer-31-整数中1的个数" class="headerlink" title="剑指offer 31 整数中1的个数"></a>剑指offer 31 整数中1的个数</h1><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数?为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int NumberOf1Between1AndN_Solution(int n)&#123;</span><br><span class="line">    if(n&lt;0) return 0;</span><br><span class="line">    int count=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i*=10)&#123;</span><br><span class="line">        int k=i*10;</span><br><span class="line">        count+=(n/k)*i+min(max(n%k-i+1, 0), i);</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p> <div style="page-break-after: always;"></div><h1 id="剑指offer-32-把数组排成最小的数"><a href="#剑指offer-32-把数组排成最小的数" class="headerlink" title="剑指offer 32 把数组排成最小的数**"></a>剑指offer 32 把数组排成最小的数**</h1><p>//输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">static bool cmp(int a, int b)&#123;</span><br><span class="line">string A=&quot;&quot;;</span><br><span class="line">string B=&quot;&quot;;</span><br><span class="line">A += to_string(a);</span><br><span class="line">A += to_string(b);</span><br><span class="line">B += to_string(b);</span><br><span class="line">B += to_string(a);</span><br><span class="line">return A&lt;B;</span><br><span class="line">&#125;</span><br><span class="line">string PrintMinNumber(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">string res=&quot;&quot;;</span><br><span class="line">if(numbers.empty()) return res;</span><br><span class="line">sort(numbers.begin(), numbers.end(), cmp);</span><br><span class="line">for(int i=0;i&lt;numbers.size();i++)&#123;</span><br><span class="line">res+=to_string(numbers[i]);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-33-丑数"><a href="#剑指offer-33-丑数" class="headerlink" title="剑指offer 33 丑数"></a>剑指offer 33 丑数</h1><p>//把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">int GetUglyNumber_Solution(int index) &#123;</span><br><span class="line">if(index&lt;1) return 0;</span><br><span class="line">vector&lt;int&gt; ugly(index, 1);</span><br><span class="line">int pointer2=0, pointer3=0, pointer5=0;</span><br><span class="line">for(int i=1;i&lt;index;i++)&#123;</span><br><span class="line">ugly[i] = findmin(ugly[pointer2]*2, ugly[pointer3]*3, ugly[pointer5]*5);</span><br><span class="line">if(ugly[pointer2]*2==ugly[i]) pointer2++;</span><br><span class="line">if(ugly[pointer3]*3==ugly[i]) pointer3++;</span><br><span class="line">if(ugly[pointer5]*5==ugly[i]) pointer5++;</span><br><span class="line">&#125;</span><br><span class="line">return ugly[index-1];</span><br><span class="line">    &#125;</span><br><span class="line">int findmin(int a, int b, int c)&#123;</span><br><span class="line">int tmp = a&gt;b?b:a;</span><br><span class="line">int tmp2 = tmp&gt;c?c:tmp;</span><br><span class="line">return tmp2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-34-第一次出现的字符"><a href="#剑指offer-34-第一次出现的字符" class="headerlink" title="剑指offer 34 第一次出现的字符"></a>剑指offer 34 第一次出现的字符</h1><p>//在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int FirstNotRepeatingChar(string str) &#123;</span><br><span class="line">  int res=-1;</span><br><span class="line">  if(str.empty()) return res;</span><br><span class="line">  int len=str.size();</span><br><span class="line">  unordered_map&lt;char, int&gt; mp;</span><br><span class="line">  for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">    mp[str[i]]++;</span><br><span class="line">    // cout&lt;&lt;mp[str[i]]&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">    cout&lt;&lt;mp[str[i]]&lt;&lt;endl;</span><br><span class="line">    if(mp[str[i]]==1)&#123;</span><br><span class="line">       res=i;break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-35-数组中的逆序对"><a href="#剑指offer-35-数组中的逆序对" class="headerlink" title="剑指offer 35 数组中的逆序对**"></a>剑指offer 35 数组中的逆序对**</h1><p>//在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007。例子：输入 1,2,3,4,5,6,7,0 输出 7<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//暴力求解 O(N*N)</span><br><span class="line">int InversePairs2(vector&lt;int&gt; data) &#123;</span><br><span class="line">    int res=0;</span><br><span class="line">    if(data.empty()) return res;</span><br><span class="line">    int len=data.size();</span><br><span class="line">    for(int i=len-1;i&gt;=0;i--)&#123;</span><br><span class="line">        for(int j=i-1;j&gt;=0;j--)&#123;</span><br><span class="line">            if(data[j]&gt;data[i]) res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">//归并排序 O(nlogn)</span><br><span class="line">int InversePairs(vector&lt;int&gt; data) &#123;</span><br><span class="line">int res=0;</span><br><span class="line">if(data.empty()) return res;</span><br><span class="line">int len=data.size();</span><br><span class="line">vector&lt;int&gt; cp(len, 0);</span><br><span class="line">for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">cp[i]=data[i];</span><br><span class="line">&#125;</span><br><span class="line">res = mergeCount(data, cp, 0, len-1);</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">int mergeCount(vector&lt;int&gt; &amp;arr, vector&lt;int&gt; &amp;cp, int s, int e)&#123;</span><br><span class="line">if(s==e) return 0;</span><br><span class="line">int mid=(s+e)&gt;&gt;1;</span><br><span class="line">int leftCount=mergeCount(arr, cp, s, mid)%1000000007;</span><br><span class="line">int rightCount=mergeCount(arr, cp, mid+1, e)%1000000007;</span><br><span class="line">int count=0,i=mid,j=e,locCopy=e;</span><br><span class="line">while(i&gt;=s &amp;&amp; j&gt;mid)&#123;</span><br><span class="line">if(arr[i]&gt;arr[j])&#123;</span><br><span class="line">count += j-mid;</span><br><span class="line">cp[locCopy--] = arr[i--];</span><br><span class="line">if(count&gt;=1000000007) count%=1000000007;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">cp[locCopy--] = arr[j--];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(;i&gt;=s;i--)&#123;</span><br><span class="line">cp[locCopy--]=arr[i];</span><br><span class="line">&#125;</span><br><span class="line">for(;j&gt;mid;j--)&#123;</span><br><span class="line">cp[locCopy--]=arr[j];</span><br><span class="line">&#125;</span><br><span class="line">for(int ss=s;ss&lt;=e;ss++)&#123;</span><br><span class="line">arr[ss]=cp[ss];</span><br><span class="line">&#125;</span><br><span class="line">return (leftCount+rightCount+count)%1000000007;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-36-两个链表的第一个公共结点"><a href="#剑指offer-36-两个链表的第一个公共结点" class="headerlink" title="剑指offer 36 两个链表的第一个公共结点"></a>剑指offer 36 两个链表的第一个公共结点</h1><p>输入两个链表，找出它们的第一个公共结点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 若有公共结点，让最长的链表先走len1-len2步，再一起走，必会相交</span><br><span class="line">ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) &#123;</span><br><span class="line">    if(pHead1==NULL || pHead2==NULL) return NULL;</span><br><span class="line">int len1 = findLinkedListLength(pHead1);</span><br><span class="line">int len2 = findLinkedListLength(pHead2);</span><br><span class="line">if(len1&gt;len2)&#123;</span><br><span class="line">pHead1=walkK(pHead1, len1-len2);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">pHead2 = walkK(pHead2, len2-len1);</span><br><span class="line">&#125;</span><br><span class="line">while(pHead1!=NULL &amp;&amp; pHead2!=NULL)&#123;</span><br><span class="line">if(pHead1==pHead2) return pHead1;</span><br><span class="line">pHead1=pHead1-&gt;next;</span><br><span class="line">pHead2=pHead2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int findLinkedListLength(ListNode* pHead)&#123;</span><br><span class="line">int res=0;</span><br><span class="line">while(pHead!=NULL)&#123;</span><br><span class="line">pHead = pHead-&gt;next;</span><br><span class="line">res++;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">ListNode* walkK(ListNode* pHead, int k)&#123;</span><br><span class="line">while(k--)&#123;</span><br><span class="line">pHead=pHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-37-数组在排序数组出现的次数"><a href="#剑指offer-37-数组在排序数组出现的次数" class="headerlink" title="剑指offer 37 数组在排序数组出现的次数"></a>剑指offer 37 数组在排序数组出现的次数</h1><p>//统计一个数字在排序数组中出现的次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// O(n) O(1)</span><br><span class="line">int GetNumberOfK1(vector&lt;int&gt; data ,int k) &#123;</span><br><span class="line">      if(data.empty()) return 0;</span><br><span class="line">  int res=0;</span><br><span class="line">  for(int i=0;i&lt;data.size();i++)&#123;</span><br><span class="line">    if(data[i]==k) res++;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">  &#125;</span><br><span class="line">// O(logn) O(1)</span><br><span class="line">int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123;</span><br><span class="line">      if(data.empty()) return 0;</span><br><span class="line">  int start=0, end=data.size()-1, res=0;</span><br><span class="line">  while(start&lt;=end)&#123;</span><br><span class="line">    int mid=(start+end)&gt;&gt;1;</span><br><span class="line">    if(data[mid]&gt;k)&#123;</span><br><span class="line">      end=mid-1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(data[mid]&lt;k) &#123;</span><br><span class="line">      start=mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      int l=mid, r=mid;</span><br><span class="line">      res++;</span><br><span class="line">      while(data[--l]==k) res++;</span><br><span class="line">      while(data[++r]==k) res++;</span><br><span class="line">      cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-38-二叉树深度"><a href="#剑指offer-38-二叉树深度" class="headerlink" title="剑指offer 38 二叉树深度"></a>剑指offer 38 二叉树深度</h1><p>//输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//递归</span><br><span class="line">int TreeDepth(TreeNode* pRoot) &#123;</span><br><span class="line">  if(pRoot==NULL) return 0;</span><br><span class="line">  return max(TreeDepth(pRoot-&gt;left), TreeDepth(pRoot-&gt;right))+1;</span><br><span class="line">&#125;</span><br><span class="line">//非递归</span><br><span class="line">int TreeDepthNotLoop(TreeNode* pRoot) &#123;</span><br><span class="line">  int res=0;</span><br><span class="line">  if(pRoot==NULL) return res;</span><br><span class="line">  queue&lt;TreeNode *&gt; q;</span><br><span class="line">  q.push(pRoot);</span><br><span class="line">  while(!q.empty()) &#123;</span><br><span class="line">    int size=q.size();</span><br><span class="line">    res++;</span><br><span class="line">    for(int i=0;i&lt;size;i++)&#123;</span><br><span class="line">        TreeNode* top=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(top-&gt;left) q.push(top-&gt;left);</span><br><span class="line">        if(top-&gt;right) q.push(top-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res; &#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-39-判断平衡二叉树"><a href="#剑指offer-39-判断平衡二叉树" class="headerlink" title="剑指offer 39 判断平衡二叉树"></a>剑指offer 39 判断平衡二叉树</h1><p>//输入一棵二叉树，判断该二叉树是否是平衡二叉树。如果二叉树的每个节点的左子树和右子树的深度不大于1，它就是平衡二叉树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool IsBalanced_Solution(TreeNode* pRoot)&#123;</span><br><span class="line">  return pos_travel(pRoot)!=-1;</span><br><span class="line">  &#125;</span><br><span class="line">int pos_travel(TreeNode* pRoot)&#123;</span><br><span class="line">  if(pRoot==NULL) return 0;</span><br><span class="line">  int left=pos_travel(pRoot-&gt;left);</span><br><span class="line">  if(left==-1) return -1;</span><br><span class="line">  int right=pos_travel(pRoot-&gt;right);</span><br><span class="line">  if(right==-1) return -1;</span><br><span class="line">  return abs(left-right)&gt;1?-1:1+max(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-40-数组中只出现一次的数字"><a href="#剑指offer-40-数组中只出现一次的数字" class="headerlink" title="剑指offer 40 数组中只出现一次的数字"></a>剑指offer 40 数组中只出现一次的数字</h1><p>//一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//input vector&lt;int&gt; arr=&#123;1,4,4,5,5,7&#125;;</span><br><span class="line">void FindNumsAppearOnce(vector &lt;int&gt; data, int* num1, int *num2) &#123;</span><br><span class="line">    if(data.empty()) return;</span><br><span class="line">    int len=data.size();</span><br><span class="line">    unordered_map &lt;int, int&gt; mp;</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        mp[data[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        if(mp[data[i]]==1)&#123;</span><br><span class="line">            res.push_back(data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *num1 = res[0];</span><br><span class="line">    *num2 = res[1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int find1From2(int[] a)&#123;</span><br><span class="line">    int len = a.length, res = 0;</span><br><span class="line">    for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="line">        res = res ^ a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-41-和为S的连续正数序列"><a href="#剑指offer-41-和为S的连续正数序列" class="headerlink" title="剑指offer 41 和为S的连续正数序列"></a>剑指offer 41 和为S的连续正数序列</h1><p>//输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; vOut;</span><br><span class="line">    vector&lt;int&gt; vIn;</span><br><span class="line">    if(sum==1) &#123;</span><br><span class="line">        vIn.push_back(1);</span><br><span class="line">        vOut.push_back(vIn);</span><br><span class="line">        return vOut;</span><br><span class="line">    &#125;</span><br><span class="line">    int left=1, right=2;</span><br><span class="line">    while(left&lt;right)&#123;</span><br><span class="line">        int k=(left+right)*(right-left+1)/2;</span><br><span class="line">        if(sum==k) &#123;</span><br><span class="line">            vector&lt;int&gt; vTmp;</span><br><span class="line">            for(int i=left;i&lt;=right;i++)&#123;</span><br><span class="line">                vTmp.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            vOut.push_back(vTmp);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(sum&gt;k) &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return vOut;</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123;</span><br><span class="line">  vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">  if(sum&lt;=2) return res;</span><br><span class="line">  int up=sqrt(2*sum);</span><br><span class="line">  for(int i=up;i&gt;=2;i--)&#123;</span><br><span class="line">    int n = sum/i;</span><br><span class="line">    if(i%2==1 &amp;&amp; sum%i==0)&#123;</span><br><span class="line">      vector&lt;int&gt; tmp;</span><br><span class="line">      for(int j=n-(i-1)/2;j&lt;=n+(i-1)/2;j++)&#123;</span><br><span class="line">        tmp.push_back(j);</span><br><span class="line">      &#125;</span><br><span class="line">      res.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    if(i%2==0 &amp;&amp; sum%i*2==i)&#123;</span><br><span class="line">      vector&lt;int&gt; tmp;</span><br><span class="line">      for(int j=n-(i-2)/2;j&lt;=n+(i-2)/2+1;j++)&#123;</span><br><span class="line">        tmp.push_back(j);</span><br><span class="line">      &#125;</span><br><span class="line">      res.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-42-和为S的两个数"><a href="#剑指offer-42-和为S的两个数" class="headerlink" title="剑指offer 42 和为S的两个数"></a>剑指offer 42 和为S的两个数</h1><p>//输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123;</span><br><span class="line">  vector&lt;int&gt; res;</span><br><span class="line">  if(array.empty()) return res;</span><br><span class="line">  int low=0, high=array.size()-1, Min=INT32_MAX;</span><br><span class="line">  while(low&lt;high)&#123;</span><br><span class="line">    cout&lt;&lt;low&lt;&lt;&quot; &quot;&lt;&lt;high&lt;&lt;endl;</span><br><span class="line">    int add = array[low]+array[high], product= array[low]*array[high];</span><br><span class="line">    if(sum==add) &#123;</span><br><span class="line">      if(product&lt;Min)&#123;</span><br><span class="line">        Min = product;</span><br><span class="line">        while(!res.empty())&#123;</span><br><span class="line">          res.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(array[low]);</span><br><span class="line">        res.push_back(array[high]);</span><br><span class="line">      &#125;</span><br><span class="line">      low++;high--;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (sum&lt;add)&#123;</span><br><span class="line">      high--;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">      low++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-43-左旋转字符串"><a href="#剑指offer-43-左旋转字符串" class="headerlink" title="剑指offer 43 左旋转字符串"></a>剑指offer 43 左旋转字符串</h1><p>//汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">string LeftRotateStringCircle(string str, int n) &#123;</span><br><span class="line">if (str.empty()) return &quot;&quot;;</span><br><span class="line">deque&lt;char&gt; q;</span><br><span class="line">for (int i=0;i&lt;str.size();i++)&#123;</span><br><span class="line">q.push_back(str[i]);</span><br><span class="line">&#125;</span><br><span class="line">while(n!=0) &#123;</span><br><span class="line">char tmp = q.front();</span><br><span class="line">q.pop_front();</span><br><span class="line">q.push_back(tmp);</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line">string res=&quot;&quot;;</span><br><span class="line">for (int i=0;i&lt;q.size();i++)&#123;</span><br><span class="line">res = res+q[i];</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">string LeftRotateString(string str, int n) &#123;</span><br><span class="line">if (str.empty()) return &quot;&quot;;</span><br><span class="line">n = n % str.size();</span><br><span class="line">reverse(str.begin(), str.end());</span><br><span class="line">reverse(str.begin(), str.begin()+str.size()-n);</span><br><span class="line">reverse(str.begin()+str.size()-n, str.end());</span><br><span class="line">return str;</span><br><span class="line">&#125;</span><br><span class="line">//自写reverse函数</span><br><span class="line">void reverse1(string&amp; str, int s, int e)&#123;</span><br><span class="line">    while (s &lt; e) &#123;</span><br><span class="line">        char temp = str[s];</span><br><span class="line">        str[s] = str[e];</span><br><span class="line">        str[e] = temp;</span><br><span class="line">        s++;</span><br><span class="line">        e--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-44-翻转单词顺序列"><a href="#剑指offer-44-翻转单词顺序列" class="headerlink" title="剑指offer 44 翻转单词顺序列"></a>剑指offer 44 翻转单词顺序列</h1><p>// “student. a am I”-&gt;“I am a student.”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">string ReverseSentence1(string str) &#123;</span><br><span class="line">string res = &quot;&quot;;</span><br><span class="line">if(str.empty()) return res;</span><br><span class="line">vector &lt;string&gt; s;</span><br><span class="line">int index=0;</span><br><span class="line">string tmp=&quot;&quot;;</span><br><span class="line">while(index &lt; str.size())&#123;</span><br><span class="line">if (str[index]==&apos; &apos;) &#123;</span><br><span class="line">s.push_back(tmp);</span><br><span class="line">tmp=&quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">tmp+=str[index];</span><br><span class="line">&#125;</span><br><span class="line">if(index==str.size()-1) s.push_back(tmp);</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">for (int i=s.size()-1;i&gt;=0;i--) &#123;</span><br><span class="line">res += s[i];</span><br><span class="line">if(i!=0) res += &apos; &apos;;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">string ReverseSentence(string str) &#123;</span><br><span class="line">std::reverse(str.begin(),str.end());</span><br><span class="line">int front=0;</span><br><span class="line">int back=0;</span><br><span class="line">int size = str.size();</span><br><span class="line">while(front&lt;size)&#123;</span><br><span class="line">    while(front&lt;size&amp;&amp;str[front]==&apos; &apos;)++front; //跳过空格，找第一个非空字母位置</span><br><span class="line">    back = front;</span><br><span class="line">    while(back&lt;size&amp;&amp;str[back]!=&apos; &apos;)++back; //找单词最后一个字符的位置</span><br><span class="line">    std::reverse(str.begin()+front, str.begin()+back); //反转</span><br><span class="line">    front = back;</span><br><span class="line">&#125;</span><br><span class="line">return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-45-扑克牌顺子"><a href="#剑指offer-45-扑克牌顺子" class="headerlink" title="剑指offer 45 扑克牌顺子"></a>剑指offer 45 扑克牌顺子</h1><p>//一组数字，判断是否顺子。0为任意数，如果牌能组成顺子就输出true，否则就输出false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// O(n)</span><br><span class="line">bool IsContinuous( vector&lt;int&gt; numbers ) &#123;</span><br><span class="line">    if(numbers.empty()) return false;</span><br><span class="line">    vector&lt;int&gt; arr(14, 0);</span><br><span class="line">    arr[0]=-5;</span><br><span class="line">    int Min=14, Max=-1;</span><br><span class="line">    for (int i=0;i&lt;numbers.size();i++)&#123;</span><br><span class="line">        arr[numbers[i]]++;</span><br><span class="line">        if(numbers[i]==0) continue;</span><br><span class="line">        if(arr[numbers[i]]&gt;1) return false;</span><br><span class="line">        if (numbers[i]&lt;Min) &#123;</span><br><span class="line">            Min = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if (numbers[i]&gt;Max) &#123;</span><br><span class="line">            Max = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(Max-Min&gt;4) return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">// O(nlogn)</span><br><span class="line">bool IsContinuous( vector&lt;int&gt; numbers ) &#123;</span><br><span class="line">    sort(numbers.begin(), numbers.end());</span><br><span class="line">    int cnt0 = 0, cntNeed = 0;</span><br><span class="line">    for(int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        if(numbers[i] == 0) &#123;</span><br><span class="line">            ++cnt0;</span><br><span class="line">        &#125; else if(i + 1 &lt; 5 ) &#123;</span><br><span class="line">            if(numbers[i + 1] == numbers[i]) return false;</span><br><span class="line">            cntNeed += numbers[i + 1] - numbers[i] - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(cntNeed &gt; cnt0) return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-46-孩子们的游戏（圆圈里最后剩下的数）"><a href="#剑指offer-46-孩子们的游戏（圆圈里最后剩下的数）" class="headerlink" title="剑指offer 46 孩子们的游戏（圆圈里最后剩下的数）"></a>剑指offer 46 孩子们的游戏（圆圈里最后剩下的数）</h1><p>//约瑟夫圆环。一个数m,编号为0开始报数，m-1的出列，下一个继续从0开始，直至最后一个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">int LastRemaining_Solution(int n, int m) &#123;</span><br><span class="line">  if(n==0 || m&lt;=0) return -1;</span><br><span class="line">  if (n==1) return 0;</span><br><span class="line">  vector&lt;int&gt; v;</span><br><span class="line">  for (int i=0;i&lt;n;i++) &#123;</span><br><span class="line">    v.push_back(i);</span><br><span class="line">  &#125;</span><br><span class="line">  int p = 0;</span><br><span class="line">  while(v.size()&gt;1) &#123;</span><br><span class="line">    n = v.size();</span><br><span class="line">    p = (p+m) % n - 1;</span><br><span class="line">    if (p == -1) p = n-1;</span><br><span class="line">    v.erase(v.begin()+p);</span><br><span class="line">  &#125;</span><br><span class="line">  return v[0];</span><br><span class="line">  &#125;</span><br><span class="line">//公式dp</span><br><span class="line">  int LastRemaining_Solution1(unsigned int n, unsigned int m)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">      if(n &lt;= 0 &amp;&amp; m &lt;= 0) return -1; //蛋疼的特殊条件</span><br><span class="line">      int t = 0;</span><br><span class="line">      for(int i = 2; i &lt;= n; i++)</span><br><span class="line">          t = (t + m) % i;</span><br><span class="line">      return t;</span><br><span class="line">  &#125;</span><br><span class="line">//模拟循环链表</span><br><span class="line">int LastRemaining_Solution2(int n, int m)//n为人数</span><br><span class="line">&#123;</span><br><span class="line">  if(n&lt;1||m&lt;1)</span><br><span class="line">      return -1;</span><br><span class="line">  list&lt;int&gt; numbers;</span><br><span class="line">  for(int i=0;i&lt;n;i++)</span><br><span class="line">      numbers.push_back(i);</span><br><span class="line">  list&lt;int&gt;::iterator current=numbers.begin();</span><br><span class="line">  while(numbers.size()&gt;1)</span><br><span class="line">  &#123;</span><br><span class="line">      for(int i=1;i&lt;m;i++)//走m-1步到达第m个数处</span><br><span class="line">      &#123;</span><br><span class="line">          ++current;</span><br><span class="line">          if(current==numbers.end())</span><br><span class="line">              current=numbers.begin();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      list&lt;int&gt;::iterator next=++current;</span><br><span class="line">      if(next==numbers.end())</span><br><span class="line">          next=numbers.begin();</span><br><span class="line">      --current;</span><br><span class="line">      numbers.erase(current);</span><br><span class="line">      current=next;</span><br><span class="line">  &#125;</span><br><span class="line">  return *current;//对迭代器取值，等价于对指针取值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-47-求1-2-…-n"><a href="#剑指offer-47-求1-2-…-n" class="headerlink" title="剑指offer 47 求1+2+…+n"></a>剑指offer 47 求1+2+…+n</h1><p>//求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int Sum_Solution(int n) &#123;</span><br><span class="line">  if (n&lt;=0) return 0;</span><br><span class="line">  if (n==1) return 1;</span><br><span class="line">  return Sum_Solution(n-1)+n;</span><br><span class="line"> &#125;</span><br><span class="line">int Sum_Solution(int n) &#123;</span><br><span class="line">    int ans = n;</span><br><span class="line">//逻辑与有个短路特点，前面为假，后面不计算。</span><br><span class="line">    ans &amp;&amp; (ans += Sum_Solution(n - 1));</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-48-不用加减乘除做加法"><a href="#剑指offer-48-不用加减乘除做加法" class="headerlink" title="剑指offer 48 不用加减乘除做加法"></a>剑指offer 48 不用加减乘除做加法</h1><p>//求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。用三步走的方式计算二进制值相加：5-101，7-111,第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101 &amp; 111) \&lt;\&lt; 1。第三步重复上述两步， 各位相加 0 1 0 \^ 1 0 1 0 = 1 0 0 0，进位值为100 = (010 \&amp; 1010)\&lt;\&lt; 1。继续重复上述两步：1000\^100 = 1100，进位值为0，跳出循环，1100为最终结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int Add(int num1, int num2) &#123;</span><br><span class="line">    while(num2!=0)&#123;</span><br><span class="line">        int tmp = num1^num2;</span><br><span class="line">        num2 = (num1&amp;num2)&lt;&lt;1;</span><br><span class="line">        num1=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-49-把字符串转换为整数"><a href="#剑指offer-49-把字符串转换为整数" class="headerlink" title="剑指offer 49 把字符串转换为整数"></a>剑指offer 49 把字符串转换为整数</h1><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int StrToInt(string str) &#123;</span><br><span class="line">    if(str.empty()) return 0;</span><br><span class="line">    int res=0, symbol=1;</span><br><span class="line">    if(str[0]==&apos;+&apos;) &#123;</span><br><span class="line">        str[0]=&apos;0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(str[0]==&apos;-&apos;) &#123;</span><br><span class="line">        symbol=-1;</span><br><span class="line">        str[0] = &apos;0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;str.size();i++) &#123;</span><br><span class="line">        if(str[i]&lt;&apos;0&apos; || str[i]&gt;&apos;9&apos;) &#123;</span><br><span class="line">            res = 0;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        res = res*10 + str[i]-&apos;0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return symbol*res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-50-数组中重复的数字"><a href="#剑指offer-50-数组中重复的数字" class="headerlink" title="剑指offer 50 数组中重复的数字"></a>剑指offer 50 数组中重复的数字</h1><p>// 在一个长度为n的数组里的所有数字都在0到n-1的范围内.数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Parameters:</span><br><span class="line">//        numbers:     an array of integers</span><br><span class="line">//        length:      the length of array numbers</span><br><span class="line">//        duplication: (Output) the duplicated number in the array number</span><br><span class="line">bool duplicate1(int numbers[], int length, int* duplication) &#123;</span><br><span class="line">bool res=false;</span><br><span class="line">if(length==0) return res;</span><br><span class="line">unordered_map&lt;int, int&gt; mp;</span><br><span class="line">for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">if (mp.count(numbers[i])==0) &#123;</span><br><span class="line">mp[numbers[i]] ++;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">*duplication = numbers[i];</span><br><span class="line">res = true;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>//思路二：剑指offer中解法：因为数组中数字都在0~n - 1，所以若无重复数字排好序则数字i将出现在下标i的位置。<br>//解法：从头到尾扫描这个数组，当扫描到下标为i的数字m时，先比较这个数字是否等于i，是则扫描下一个数字，否则<br>//将该数字与下标为m的数字进行比较，若相等，则找到一个重复的数字，否则将两个数字交换，并继续对该位置<br>//（下标i）重复上面比较过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">bool duplicate(int numbers[], int length, int* duplication) &#123;</span><br><span class="line">bool res = false;</span><br><span class="line">if (length == 0) return res;</span><br><span class="line">int i = 0;</span><br><span class="line">while(i&lt;length) &#123;</span><br><span class="line">if (numbers[i] == i) &#123;</span><br><span class="line">i++;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if (numbers[numbers[i]] == numbers[i]) &#123;</span><br><span class="line">res = true;</span><br><span class="line">*duplication = numbers[i];</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">int tmp = numbers[i];</span><br><span class="line">numbers[i] = numbers[tmp];</span><br><span class="line">numbers[tmp] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-51-构建乘积数组"><a href="#剑指offer-51-构建乘积数组" class="headerlink" title="剑指offer 51 构建乘积数组"></a>剑指offer 51 构建乘积数组</h1><p>给定一个数组A[0, 1, …, n - 1], 请构建一个数组B[0, 1, …, n - 1],其中B中的元素B[i] = A[0] <em> A[1] </em> … <em> A[i - 1] </em> A[i + 1] <em> … </em> A[n - 1]。不能使用除法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// recurrent O(n\*n)</span><br><span class="line">vector&lt;int&gt; multiplyN2(const vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">  vector&lt;int&gt; B;</span><br><span class="line">  if (A.empty()) return B;</span><br><span class="line">  for (int i = 0; i &lt; A.size(); i++) &#123;</span><br><span class="line">    B.push_back(ABhelper(A, A.size()-1, i));</span><br><span class="line">  &#125;</span><br><span class="line">  return B;</span><br><span class="line">&#125;</span><br><span class="line">int ABhelper(vector&lt;int&gt; A, int n, int k) &#123;</span><br><span class="line">  if (n == k &amp;&amp; n == 0) return 1;</span><br><span class="line">  if (n == k &amp;&amp; n &gt; 0) return ABhelper(A, n - 1, k);</span><br><span class="line">  if (n == 0) return A[0];</span><br><span class="line">  return ABhelper(A, n - 1, k) * A[n];</span><br><span class="line">&#125;</span><br><span class="line">// 上下三角求解合并</span><br><span class="line">//链接：https://www.nowcoder.com/questionTerminal/94a4d381a68b47b7a8bed86f2975db46?f=discussion</span><br><span class="line">vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">  vector&lt;int&gt; B;</span><br><span class="line">  if (A.empty()) return B;</span><br><span class="line">  int len = A.size();</span><br><span class="line">  // cal up triangle</span><br><span class="line">  B.push_back(1);</span><br><span class="line">  for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">    B.push_back(B[i - 1] * A[i - 1]);</span><br><span class="line">  &#125;</span><br><span class="line">  // cal down triangle</span><br><span class="line">  int down =1;</span><br><span class="line">  for (int i = len - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">    down *= A[i + 1];</span><br><span class="line">    B[i] *= down;</span><br><span class="line">  &#125;</span><br><span class="line">  return B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-52-正则表达式匹配"><a href="#剑指offer-52-正则表达式匹配" class="headerlink" title="剑指offer 52 正则表达式匹配"></a>剑指offer 52 正则表达式匹配</h1><p>//请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">bool match(char* str, char* pattern)&#123;</span><br><span class="line">    if (str == NULL || pattern == NULL)  return false;</span><br><span class="line">    int strIndex = 0, patternIndex = 0;</span><br><span class="line">    return matchHelper(str, pattern);</span><br><span class="line">&#125;</span><br><span class="line">bool matchHelper(char* str, char* pattern) &#123;</span><br><span class="line">    // str到尾，pattern到尾，匹配成功</span><br><span class="line">    // 注意下指针和string字符串判断是否为空的区别</span><br><span class="line">    if (*str == &apos;\0&apos; &amp;&amp; *pattern == &apos;\0&apos;) return true;</span><br><span class="line">    // pattern为空，str不空，匹配必定失败</span><br><span class="line">    if (*pattern == &apos;\0&apos; &amp;&amp; *str != &apos;\0&apos;) return false;</span><br><span class="line"></span><br><span class="line">    // 如果pattern下一个字符不为&apos;*&apos;</span><br><span class="line">    if (*(pattern + 1) != &apos;*&apos;) &#123;</span><br><span class="line">        // 匹配成功情况：</span><br><span class="line">        // 1. 当前str字符==当前pattern字符</span><br><span class="line">        // 2. pattern为&apos;.&apos;且当前str不为空</span><br><span class="line">        if (*pattern == *str || (*pattern == &apos;.&apos; &amp;&amp; *str != &apos;\0&apos;))&#123;</span><br><span class="line">            return matchHelper(str+1, pattern+1);</span><br><span class="line">        &#125;</span><br><span class="line">        else return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果pattern下一个字符为&apos;*&apos;</span><br><span class="line">    else &#123;</span><br><span class="line">        // 继续匹配的情况：</span><br><span class="line">        // 1. 当‘*’匹配0个字符时，str当前字符不变，pattern当前字符后移两位，跳过这个‘*’符号；</span><br><span class="line">        // 2. 当‘*’匹配1个或多个时，str当前字符移向下一个，pattern当前字符不变。</span><br><span class="line">        if (*pattern == *str || (*pattern == &apos;.&apos; &amp;&amp; *str != &apos;\0&apos;)) &#123;</span><br><span class="line">            return matchHelper(str+1,pattern) || matchHelper(str, pattern+2);</span><br><span class="line">        &#125;</span><br><span class="line">        else return matchHelper(str, pattern+2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-53-表示数值的字符串"><a href="#剑指offer-53-表示数值的字符串" class="headerlink" title="剑指offer 53 表示数值的字符串"></a>剑指offer 53 表示数值的字符串</h1><p>// 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool isNumeric(char* string)</span><br><span class="line">&#123;</span><br><span class="line">    if (string == nullptr) return false;</span><br><span class="line">    // 标记符号、小数点、e是否出现过</span><br><span class="line">    bool sign = false, decimal = false, hasE = false;</span><br><span class="line">    for (int i = 0; i &lt; strlen(string); i++) &#123;</span><br><span class="line">        if (string[i] == &apos;+&apos; || string[i] == &apos;-&apos;) &#123;</span><br><span class="line">            // 第二次出现+-符号，必须紧接在e之后</span><br><span class="line">            if (sign &amp;&amp; string[i-1] != &apos;e&apos; &amp;&amp; string[i-1] != &apos;E&apos;) return false;</span><br><span class="line">            // 第一次出现+-符号，且不是在字符串开头，也必须紧接在e之后</span><br><span class="line">            if (!sign &amp;&amp; i&gt;0 &amp;&amp; string[i-1] != &apos;e&apos; &amp;&amp; string[i-1] != &apos;E&apos;) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (string[i] == &apos;e&apos; || string[i] == &apos;E&apos;) &#123;</span><br><span class="line">            // e后面一定要接数字 || 不能同时存在两个e</span><br><span class="line">            if (i == strlen(string) - 1 || hasE) return false;</span><br><span class="line">            hasE = true;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (string[i] == &apos;.&apos;) &#123;</span><br><span class="line">            // e后面不能接小数点，小数点不能出现两次</span><br><span class="line">            if (hasE || decimal) return false;</span><br><span class="line">            decimal = true;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (string[i] &lt; &apos;0&apos; || string[i] &gt; &apos;9&apos;) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-54-字符流中第一个不重复的字符"><a href="#剑指offer-54-字符流中第一个不重复的字符" class="headerlink" title="剑指offer 54 字符流中第一个不重复的字符"></a>剑指offer 54 字符流中第一个不重复的字符</h1><p>// 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。如果当前字符流没有存在出现一次的字符，返回#字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">char hash[256] = &#123;0&#125;;</span><br><span class="line">//Insert one char from stringstream</span><br><span class="line">void Insert(char ch)</span><br><span class="line">&#123;</span><br><span class="line">        s += ch;</span><br><span class="line">        hash[ch]++;</span><br><span class="line">&#125;</span><br><span class="line">//return the first appearence once char in current stringstream</span><br><span class="line">char FirstAppearingOnce()</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">        if (hash[s[i]] == 1) &#123;</span><br><span class="line">            return s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &apos;#&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-55-链表中环的入口节点"><a href="#剑指offer-55-链表中环的入口节点" class="headerlink" title="剑指offer 55 链表中环的入口节点"></a>剑指offer 55 链表中环的入口节点</h1><p>// 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ListNode* EntryNodeOfLoop(ListNode* pHead)</span><br><span class="line">&#123;</span><br><span class="line">    if (pHead == nullptr) return nullptr;</span><br><span class="line">    ListNode* fast = pHead;</span><br><span class="line">    ListNode* slow = pHead;</span><br><span class="line">    ListNode* meetingNode = nullptr;</span><br><span class="line">    while (fast-&gt;next &amp;&amp; slow) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        if (fast == slow) &#123;</span><br><span class="line">            meetingNode = fast;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (meetingNode) &#123;</span><br><span class="line">        ListNode* p1 = meetingNode;</span><br><span class="line">        ListNode* p2 = pHead;</span><br><span class="line">        while (p1 != p2) &#123;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return p1;</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-56-删除链表中重复的节点"><a href="#剑指offer-56-删除链表中重复的节点" class="headerlink" title="剑指offer 56 删除链表中重复的节点"></a>剑指offer 56 删除链表中重复的节点</h1><p>// 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ListNode* deleteDuplication(ListNode* pHead)</span><br><span class="line">&#123;</span><br><span class="line">    if (pHead == nullptr) return nullptr;</span><br><span class="line">    ListNode *root = pHead, *pre;</span><br><span class="line">    while (root != nullptr) &#123;</span><br><span class="line">        if (root-&gt;next-&gt;val != root-&gt;val) &#123;</span><br><span class="line">            pre = root;</span><br><span class="line">            root = root-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            while (root-&gt;next &amp;&amp; root-&gt;next-&gt;val == root-&gt;val) &#123;</span><br><span class="line">                root = root-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            if (root-&gt;next) &#123;</span><br><span class="line">                pre-&gt;next = root-&gt;next;</span><br><span class="line">                root = root-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                pre-&gt;next = nullptr;</span><br><span class="line">                return pHead;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-57-二叉树的下一个节点"><a href="#剑指offer-57-二叉树的下一个节点" class="headerlink" title="剑指offer 57 二叉树的下一个节点"></a>剑指offer 57 二叉树的下一个节点</h1><p>// 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TreeLinkNode* GetNext(TreeLinkNode* pNode)</span><br><span class="line">&#123;</span><br><span class="line">    if (pNode == nullptr) return pNode;</span><br><span class="line">    while (pNode-&gt;right) &#123;</span><br><span class="line">        pNode = pNode-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="剑指offer-58-对称的二叉树"><a href="#剑指offer-58-对称的二叉树" class="headerlink" title="剑指offer 58 对称的二叉树"></a>剑指offer 58 对称的二叉树</h1><p>// 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool isSymmetrical(TreeNode* pRoot)</span><br><span class="line">&#123;</span><br><span class="line">    if (pRoot == nullptr) return true;</span><br><span class="line">    return isSymmetricalHelper(pRoot-&gt;left, pRoot-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">bool isSymmetricalHelper(TreeNode* p1, TreeNode* p2) &#123;</span><br><span class="line">    if (p1 &amp;&amp; p2 == nullptr) return false;</span><br><span class="line">    else if (p2 &amp;&amp; p1 == nullptr) return false;</span><br><span class="line">    else if (p1 == nullptr &amp;&amp; p2 == nullptr) return true;</span><br><span class="line">    if (p1-&gt;val == p2-&gt;val) &#123;</span><br><span class="line">        return isSymmetricalHelper(p1-&gt;left, p2-&gt;right) &amp;&amp; isSymmetricalHelper(p2-&gt;left, p1-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    else return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-59-之字形打印二叉树"><a href="#剑指offer-59-之字形打印二叉树" class="headerlink" title="剑指offer 59 之字形打印二叉树"></a>剑指offer 59 之字形打印二叉树</h1><p>// 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; PrintZ(TreeNode* pRoot) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    if (pRoot == nullptr) return res;</span><br><span class="line">    vector&lt;TreeNode*&gt; d;</span><br><span class="line">    d.push_back(pRoot);</span><br><span class="line">    vector&lt;int&gt; init;</span><br><span class="line">    init.push_back(pRoot-&gt;val);</span><br><span class="line">    res.push_back(init);</span><br><span class="line">    int layer = 1;</span><br><span class="line">    while (!d.empty()) &#123;</span><br><span class="line">        layer++;</span><br><span class="line">        vector&lt;TreeNode*&gt; tmp;</span><br><span class="line">        for (int i = 0; i &lt; d.size(); i++) &#123;</span><br><span class="line">            if (d[i]-&gt;left) tmp.push_back(d[i]-&gt;left);</span><br><span class="line">            if (d[i]-&gt;right) tmp.push_back(d[i]-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; tmpInt;</span><br><span class="line">        for (int i = 0; i &lt; tmp.size(); i++) &#123;</span><br><span class="line">            tmpInt.push_back(tmp[i]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        if (layer % 2 == 1 &amp;&amp; !tmpInt.empty()) &#123;</span><br><span class="line">            res.push_back(tmpInt);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (layer % 2 == 0 &amp;&amp; !tmpInt.empty()) &#123;</span><br><span class="line">            reverse(tmpInt.begin(), tmpInt.end());</span><br><span class="line">            res.push_back(tmpInt);</span><br><span class="line">        &#125;</span><br><span class="line">        d = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-60-把二叉树打印成多行（层序遍历）"><a href="#剑指offer-60-把二叉树打印成多行（层序遍历）" class="headerlink" title="剑指offer 60 把二叉树打印成多行（层序遍历）"></a>剑指offer 60 把二叉树打印成多行（层序遍历）</h1><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; vec;</span><br><span class="line">    if(pRoot == NULL) return vec;</span><br><span class="line"></span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(pRoot);</span><br><span class="line"></span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int lo = 0, hi = q.size();</span><br><span class="line">        vector&lt;int&gt; c;</span><br><span class="line">        while(lo++ &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *t = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            c.push_back(t-&gt;val);</span><br><span class="line">            if(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">            if(t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        vec.push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">    return vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-61-序列化二叉树"><a href="#剑指offer-61-序列化二叉树" class="headerlink" title="剑指offer 61 序列化二叉树"></a>剑指offer 61 序列化二叉树</h1><p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p><p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">typedef TreeNode node;</span><br><span class="line">typedef TreeNode* pnode;</span><br><span class="line">typedef int* pint;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    vector&lt;int&gt; buf;</span><br><span class="line">    void dfs(pnode p)&#123;</span><br><span class="line">        if(!p) buf.push_back(0x23333);</span><br><span class="line">        else&#123;</span><br><span class="line">            buf.push_back(p -&gt; val);</span><br><span class="line">            dfs(p -&gt; left);</span><br><span class="line">            dfs(p -&gt; right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pnode dfs2(pint&amp; p)&#123;</span><br><span class="line">        if(*p == 0x23333)&#123;</span><br><span class="line">            ++p;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        pnode res = new node(*p);</span><br><span class="line">        ++p;</span><br><span class="line">        res -&gt; left = dfs2(p);</span><br><span class="line">        res -&gt; right = dfs2(p);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    char* Serialize(TreeNode *p) &#123;</span><br><span class="line">        buf.clear();</span><br><span class="line">        dfs(p);</span><br><span class="line">        int *res = new int[buf.size()];</span><br><span class="line">        for(unsigned int i = 0; i &lt; buf.size(); ++i) res[i] = buf[i];</span><br><span class="line">        return (char*)res;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* Deserialize(char *str) &#123;</span><br><span class="line">        int *p = (int*)str;</span><br><span class="line">        return dfs2(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-62-二叉搜索树的第k个结点"><a href="#剑指offer-62-二叉搜索树的第k个结点" class="headerlink" title="剑指offer 62 二叉搜索树的第k个结点"></a>剑指offer 62 二叉搜索树的第k个结点</h1><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如,(5，3，7，2，4，6，8)中，按结点数值大小顺序第三小结点的值为4。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 递归</span><br><span class="line">int cnt = 0;</span><br><span class="line">TreeNode* KthNode(TreeNode* pRoot, int k)</span><br><span class="line">&#123;</span><br><span class="line">    if (pRoot) &#123;</span><br><span class="line">        TreeNode* node = KthNode(pRoot-&gt;left, k);</span><br><span class="line">        if (node) return node;</span><br><span class="line">        cnt++;</span><br><span class="line">        if (cnt == k) return pRoot;</span><br><span class="line">        node = KthNode(pRoot-&gt;right, k);</span><br><span class="line">        if (node) return node;</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br><span class="line">// 非递归 中序遍历</span><br><span class="line">TreeNode* KthNode(TreeNode* pRoot, int k)</span><br><span class="line">&#123;</span><br><span class="line">    if (pRoot == nullptr || k &lt; 1) return nullptr;</span><br><span class="line">    stack&lt;TreeNode*&gt; S;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    TreeNode* node = pRoot;</span><br><span class="line">    while (!S.empty() || node) &#123;</span><br><span class="line">        while (node) &#123;</span><br><span class="line">            S.push(node);</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        node = S.top();</span><br><span class="line">        S.pop();</span><br><span class="line">        cnt++;</span><br><span class="line">        if (cnt == k) return node;</span><br><span class="line">        node = node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-63-数据流中的中位数"><a href="#剑指offer-63-数据流中的中位数" class="headerlink" title="剑指offer 63 数据流中的中位数"></a>剑指offer 63 数据流中的中位数</h1><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 法1：大顶堆+小顶堆 </span><br><span class="line">// 法2：AVL 平衡二叉搜索树</span><br><span class="line">// 法3：排序</span><br><span class="line">vector&lt;int&gt; dataStream;</span><br><span class="line">void Insert(int num)</span><br><span class="line">&#123;</span><br><span class="line">    dataStream.push_back(num);</span><br><span class="line">    sort(dataStream.begin(), dataStream.end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double GetMedian()</span><br><span class="line">&#123; </span><br><span class="line">    int sz = dataStream.size();</span><br><span class="line">    double res;</span><br><span class="line">    if (sz % 2 == 0) &#123;</span><br><span class="line">        res = (double) (dataStream[sz/2] + dataStream[sz/2-1]) / 2;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        res = (double) dataStream[sz/2];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-64-滑动窗口的最大值"><a href="#剑指offer-64-滑动窗口的最大值" class="headerlink" title="剑指offer 64 滑动窗口的最大值"></a>剑指offer 64 滑动窗口的最大值</h1><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 暴力法 O(n * size)</span><br><span class="line">int FindMaxVal(vector&lt;int&gt; num, int st, int ed) &#123;</span><br><span class="line">    int MaxVal = num[st];</span><br><span class="line">    for (int i = st; i &lt;= ed; i++) &#123;</span><br><span class="line">        if (num[i] &gt; MaxVal) MaxVal = num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return MaxVal;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; maxInWindows1(const vector&lt;int&gt;&amp; num, unsigned int size)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    if (num.size() == 0 || size &lt; 1) return res;</span><br><span class="line">    for (int i = 0; i &lt;= num.size()-size; i++) &#123;</span><br><span class="line">        int tmp = FindMaxVal(num, i, i+size-1);</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">// 双端队列 O(n)</span><br><span class="line">vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    if (num.size() == 0 || size &lt; 1) return res;</span><br><span class="line">    deque&lt;int&gt; d;</span><br><span class="line">    for (int i = 0; i &lt; num.size(); ++i) &#123;</span><br><span class="line">        // 从后面依次弹出队列汇总比当前num值小的元素，同时保证队首元素为当前窗口最大值下标</span><br><span class="line">        while (d.size() &amp;&amp; num[d.back()] &lt;= num[i]) &#123;</span><br><span class="line">            d.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        // 当当前窗口移出队首元素所在的位置，即队首元素坐标对应的num不在窗口中，需要弹出</span><br><span class="line">        if (d.size() &amp;&amp; i-d.front()+1 &gt; size) &#123;</span><br><span class="line">            d.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        d.push_back(i);</span><br><span class="line">        // 当滑动窗口首地址i大于等于size时才开始写入窗口最大值</span><br><span class="line">        if (i &gt;= size - 1) &#123;</span><br><span class="line">            res.push_back(num[d.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-65-矩阵中的路径"><a href="#剑指offer-65-矩阵中的路径" class="headerlink" title="剑指offer 65 矩阵中的路径"></a>剑指offer 65 矩阵中的路径</h1><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">bool dfs(char* matrix, int i, int j, int rows, int cols, char* str, vector&lt;vector&lt;bool&gt; &gt; path) &#123;</span><br><span class="line">    if (*str == &apos;\0&apos;) return true;</span><br><span class="line">    if (matrix[i * cols + j] != str[0]) return false;</span><br><span class="line"></span><br><span class="line">    bool hasPath = false;</span><br><span class="line">    if (j &gt;= 0 &amp;&amp; i &gt;=0 &amp;&amp; i &lt; rows &amp;&amp; j &lt; cols &amp;&amp; !path[i][j]</span><br><span class="line">        &amp;&amp; matrix[i * cols + j] == str[0]) &#123;</span><br><span class="line">            path[i][j] = true;</span><br><span class="line">            hasPath = dfs(matrix, i-1, j, rows, cols, str+1, path)</span><br><span class="line">                    || dfs(matrix, i+1, j, rows, cols, str+1, path)</span><br><span class="line">                    || dfs(matrix, i, j-1, rows, cols, str+1, path)</span><br><span class="line">                    || dfs(matrix, i, j+1, rows, cols, str+1, path);</span><br><span class="line">            if (!hasPath) path[i][j] = false;</span><br><span class="line">        &#125;</span><br><span class="line">    return hasPath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool hasPath(char* matrix, int rows, int cols, char* str)</span><br><span class="line">&#123;</span><br><span class="line">    if (matrix == nullptr || str == nullptr) return false;</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; path(rows, vector&lt;bool&gt;(cols, false));</span><br><span class="line">    bool res = false;</span><br><span class="line">    for (int row = 0; row &lt; rows; row++) &#123;</span><br><span class="line">        for (int col = 0; col &lt; cols; col++) &#123;</span><br><span class="line">            if (matrix[row * cols + col] == str[0]) &#123;</span><br><span class="line">                res = dfs(matrix, row, col, rows, cols, str, path);</span><br><span class="line">            &#125;</span><br><span class="line">            if (res) return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-66-机器人的动作范围"><a href="#剑指offer-66-机器人的动作范围" class="headerlink" title="剑指offer 66 机器人的动作范围"></a>剑指offer 66 机器人的动作范围</h1><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int movingCount(int threshold, int rows, int cols)</span><br><span class="line">&#123;</span><br><span class="line">    bool* flag=new bool[rows*cols];</span><br><span class="line">    for(int i=0;i&lt;rows*cols;i++)</span><br><span class="line">        flag[i]=false;</span><br><span class="line">    int count=moving(threshold,rows,cols,0,0,flag);//从（0,0）坐标开始访问;</span><br><span class="line">    delete[] flag;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">//计算最大移动位置</span><br><span class="line">int moving(int threshold,int rows,int cols,int i,int j,bool* flag) &#123;</span><br><span class="line">    int count=0;</span><br><span class="line">    if(check(threshold,rows,cols,i,j,flag)) &#123;</span><br><span class="line">        flag[i*cols+j]=true;</span><br><span class="line">        //标记访问过，这个标志flag不需要回溯，因为只要被访问过即可。</span><br><span class="line">       //因为如果能访问，访问过会加1.不能访问，也会标记下访问过。</span><br><span class="line">        count=1+moving(threshold,rows,cols,i-1,j,flag) + moving(threshold,rows,cols,i,j-1,flag)</span><br><span class="line">               +moving(threshold,rows,cols,i+1,j,flag) + moving(threshold,rows,cols,i,j+1,flag);</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">//检查当前位置是否可以访问</span><br><span class="line">bool check(int threshold,int rows,int cols,int i,int j,bool* flag) &#123;</span><br><span class="line">    if(i&gt;=0 &amp;&amp; i&lt;rows &amp;&amp; j&gt;=0 &amp;&amp; j&lt;cols</span><br><span class="line">        &amp;&amp; getSum(i)+getSum(j)&lt;=threshold</span><br><span class="line">        &amp;&amp; flag[i*cols+j]==false)</span><br><span class="line">       return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">//计算位置的数值</span><br><span class="line">int getSum(int number) &#123;</span><br><span class="line">    int sum=0;</span><br><span class="line">    while(number&gt;0) &#123;</span><br><span class="line">        sum+=number%10;</span><br><span class="line">        number/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div><h1 id="剑指offer-67-剪绳子"><a href="#剑指offer-67-剪绳子" class="headerlink" title="剑指offer 67 剪绳子"></a>剑指offer 67 剪绳子</h1><p>给你一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* 首先判断k[0]到k[m]可能有哪些数字，实际上只可能是2或者3。</span><br><span class="line"> * 5&lt;2*3,6&lt;3*3,比6更大的数字我们就更不用考虑了，肯定要继续分。</span><br><span class="line"> * 其次看2和3的数量，2的数量肯定小于3个，为什么呢？因为2*2*2&lt;3*3，那么题目就简单了。</span><br><span class="line"> * 直接用n除以3，根据得到的余数判断是一个2还是两个2还是没有2就行了。</span><br><span class="line"> * 由于题目规定m&gt;1，所以2只能是1*1，3只能是2*1，这两个特殊情况直接返回就行了。 */</span><br><span class="line">long long n_max_3(long long n) &#123;</span><br><span class="line">    if (n == 2) return 1;</span><br><span class="line">    if (n == 3) return 2;</span><br><span class="line">    long long x = n % 3;</span><br><span class="line">    long long y = n / 3;</span><br><span class="line">    if (x == 0) &#123;</span><br><span class="line">        return pow(3, y);</span><br><span class="line">    &#125; else if (x == 1) &#123;</span><br><span class="line">        return 2 * 2 * (long long) pow(3, y - 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 2 * (long long) pow(3, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div style="page-break-after: always;"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer各题目的C++解法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Data Structure" scheme="https://dlc1994.github.io/categories/Algorithm-and-Data-Structure/"/>
    
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
      <category term="C++" scheme="https://dlc1994.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://dlc1994.github.io/2020/01/08/ck813u1i3000fkkun0hzg7j7a/"/>
    <id>https://dlc1994.github.io/2020/01/08/ck813u1i3000fkkun0hzg7j7a/</id>
    <published>2020-01-08T04:50:07.000Z</published>
    <updated>2020-03-19T11:06:14.801Z</updated>
    
    <content type="html"><![CDATA[<p>Git &amp; Linux operations<br><a id="more"></a></p><h1 id="python程序后台运行"><a href="#python程序后台运行" class="headerlink" title="python程序后台运行"></a>python程序后台运行</h1><p>程序后台运行，打印结果到out.log文件<br>nohup python -u test.py &gt; out.log 2&gt;&amp;1 &amp;<br>说明：</p><ol><li>末尾的“&amp;”：表示后台运行程序</li><li>“nohup” ：保证程序不被挂起</li><li>“python”：是执行python代码的命令</li><li>“-u”：表示不启用缓存，实时输出打印信息到日志文件（如果不加-u，则会导致日志文件不会实时刷新代码中的print函数的信息）</li><li>“Job.py”：是python的源代码文件</li><li>“log.log”：是输出的日志文件</li><li>“&gt;”：是指将打印信息指定到日志文件</li><li>“2&gt;&amp;1”：将标准错误输出转变化标准输出，可以将错误信息也输出到日志文件中（0-&gt; stdin, 1-&gt;stdout, 2-&gt;stderr）</li></ol><p>查询下进程 ，可查看pid<br>ps -ef | grep xxx</p><p>终止脚本进程<br>kill -9 pid</p><p>to be continue…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git &amp;amp; Linux operations&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Development" scheme="https://dlc1994.github.io/categories/Development/"/>
    
    
      <category term="git" scheme="https://dlc1994.github.io/tags/git/"/>
    
      <category term="linux" scheme="https://dlc1994.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>链表的算法合集整理</title>
    <link href="https://dlc1994.github.io/2019/08/21/ck813u1i3000gkkund06tk3ur/"/>
    <id>https://dlc1994.github.io/2019/08/21/ck813u1i3000gkkund06tk3ur/</id>
    <published>2019-08-21T15:26:34.000Z</published>
    <updated>2020-03-19T11:07:19.825Z</updated>
    
    <content type="html"><![CDATA[<p>链表的算法合集大全(C/C++)<br><a id="more"></a></p><!-- TOC --><ul><li><a href="#1-链表结构体定义">1. 链表结构体定义</a></li><li><a href="#2-链表初始化可以快速创建样例">2. 链表初始化，可以快速创建样例</a></li><li><a href="#3-链表遍历打印检验算法正确性">3. 链表遍历打印，检验算法正确性</a></li><li><a href="#4-输出单链表倒数第-k-个节点">4. 输出单链表倒数第 K 个节点</a></li><li><a href="#5-判断链表是否有环">5. 判断链表是否有环</a></li><li><a href="#6-定位环的入口">6. 定位环的入口</a></li><li><a href="#7-计算环的长度">7. 计算环的长度</a></li><li><a href="#8-链表实现大数加法">8. 链表实现大数加法</a></li><li><a href="#9-有序链表合并">9. 有序链表合并</a></li><li><a href="#10-k个有序链表合并">10. K个有序链表合并</a></li><li><a href="#11-o1复杂度删除链表中结点">11. O(1)复杂度删除链表中结点</a></li><li><a href="#12-从尾到头打印链表">12. 从尾到头打印链表</a></li><li><a href="#13-反转链表">13. 反转链表</a></li><li><a href="#14-复杂链表的复制">14. 复杂链表的复制</a></li><li><a href="#15-逆序构造单链表">15. 逆序构造单链表</a></li><li><a href="#16-链表升序排序">16. 链表升序排序</a></li><li><a href="#17-找出单链表的中间结点">17. 找出单链表的中间结点</a></li></ul><!-- /TOC --><h1 id="1-链表结构体定义"><a href="#1-链表结构体定义" class="headerlink" title="1. 链表结构体定义"></a>1. 链表结构体定义</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">            val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-链表初始化，可以快速创建样例"><a href="#2-链表初始化，可以快速创建样例" class="headerlink" title="2. 链表初始化，可以快速创建样例"></a>2. 链表初始化，可以快速创建样例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 链表初始化，创造样例</span><br><span class="line">ListNode* linkedListInit(vector&lt;int&gt; v) &#123;</span><br><span class="line">    if (v.empty()) return NULL;</span><br><span class="line">    ListNode* root = new ListNode(v[0]);</span><br><span class="line">    ListNode* node = root;</span><br><span class="line">    int i = 1;</span><br><span class="line">    while (i&lt;v.size()) &#123;</span><br><span class="line">        node-&gt;next = new ListNode(v[i]);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-链表遍历打印，检验算法正确性"><a href="#3-链表遍历打印，检验算法正确性" class="headerlink" title="3. 链表遍历打印，检验算法正确性"></a>3. 链表遍历打印，检验算法正确性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 打印链表元素值，检验算法</span><br><span class="line">void PrintLinkedList(ListNode* root) &#123;</span><br><span class="line">    if (root == NULL) return;</span><br><span class="line">    while (root != NULL) &#123;</span><br><span class="line">        cout&lt;&lt;root-&gt;val&lt;&lt;&quot; &quot;;</span><br><span class="line">        root = root-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-输出单链表倒数第-K-个节点"><a href="#4-输出单链表倒数第-K-个节点" class="headerlink" title="4. 输出单链表倒数第 K 个节点"></a>4. 输出单链表倒数第 K 个节点</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 输出单链表倒数第 K 个节点</span><br><span class="line">// 法一：两次遍历</span><br><span class="line">ListNode* findKthTail1(ListNode *pHead, int k) &#123;</span><br><span class="line">    if (pHead == NULL || k &lt;= 0) return NULL;</span><br><span class="line">    int len = 0;</span><br><span class="line">    ListNode* root = pHead;</span><br><span class="line">    while (pHead != NULL) &#123;</span><br><span class="line">        pHead = pHead-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (len&lt;k) return NULL;</span><br><span class="line">    int countdown = len-k;</span><br><span class="line">    while (countdown--&gt;0) &#123;</span><br><span class="line">        root = root-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line">// 法二：递归**</span><br><span class="line">int cnt = 0;</span><br><span class="line">ListNode* findKthTail2(ListNode* pHead, int k) &#123;</span><br><span class="line">    if (pHead == NULL) return NULL;</span><br><span class="line">    ListNode* node = findKthTail2(pHead-&gt;next, k);</span><br><span class="line">    // 没找到就返回NULL，找到一直返回结点</span><br><span class="line">    if (node == NULL) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        if (cnt == k) return pHead;</span><br><span class="line">        else return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 法三：快慢指针***</span><br><span class="line">ListNode* findKthTail3(ListNode* pHead, int k) &#123;</span><br><span class="line">    if (pHead == NULL || k &lt;= 0) return NULL;</span><br><span class="line">    ListNode* slow = pHead;</span><br><span class="line">    ListNode* fast = pHead;</span><br><span class="line">    for(int i=0;i&lt;k;i++) &#123;  //快指针先走k步</span><br><span class="line">        if(fast) fast = fast-&gt;next;</span><br><span class="line">        else return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    while(fast) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-判断链表是否有环"><a href="#5-判断链表是否有环" class="headerlink" title="5. 判断链表是否有环"></a>5. 判断链表是否有环</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 判断链表是否有环</span><br><span class="line">// 法一：穷举比较 O(n^2)</span><br><span class="line">// 法二：哈希缓存 O(n)</span><br><span class="line">// 法三：快慢指针 O(n)~O(n^2)环很大时</span><br><span class="line">bool isExistRing3(ListNode* pHead) &#123;</span><br><span class="line">    if (pHead == NULL) return false;</span><br><span class="line">    ListNode* fast = pHead;</span><br><span class="line">    ListNode* slow = pHead;</span><br><span class="line">    while (fast-&gt;next &amp;&amp; slow) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        if (fast == slow) return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-定位环的入口"><a href="#6-定位环的入口" class="headerlink" title="6. 定位环的入口"></a>6. 定位环的入口</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 定位环的入口***hard***</span><br><span class="line">ListNode* getEntryNodeOfRing(ListNode* pHead) &#123;</span><br><span class="line">    ListNode* meetingnode = getMeetingNode(pHead);</span><br><span class="line">    if (meetingnode == NULL) return NULL; // 没环则相遇尾结点</span><br><span class="line">    ListNode* p1 = meetingnode;</span><br><span class="line">    ListNode* p2 = pHead;</span><br><span class="line">    // p1和p2以相同的速度向前移动，当p2指向环的入口节点时</span><br><span class="line">    // p1已经围绕着环走了n圈又回到了入口节点。</span><br><span class="line">    while(p1 != p2) &#123;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return p1;</span><br><span class="line">&#125;</span><br><span class="line">ListNode* getMeetingNode(ListNode* pHead) &#123;</span><br><span class="line">    if (pHead == NULL) return NULL;</span><br><span class="line">    ListNode* fast = pHead;</span><br><span class="line">    ListNode* slow = pHead;</span><br><span class="line">    while (fast-&gt;next &amp;&amp; slow) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        if (fast == slow) return slow;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-计算环的长度"><a href="#7-计算环的长度" class="headerlink" title="7. 计算环的长度"></a>7. 计算环的长度</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 计算环的长度</span><br><span class="line">// 找到slow与fast的相遇节点，令slow与fast指针从相遇节点出发，</span><br><span class="line">// 按照之前的前进规则，当slow与fast再次相遇时，slow走过的长度正好为环的长度。</span><br><span class="line">int getLengthOfRing(ListNode* pHead) &#123;</span><br><span class="line">    if (pHead == NULL) return 0;</span><br><span class="line">    ListNode* meetingnode = getMeetingNode(pHead);</span><br><span class="line">    if (meetingnode == NULL) return 0; // 防止无环</span><br><span class="line">    ListNode* fast = meetingnode-&gt;next-&gt;next;</span><br><span class="line">    ListNode* slow = meetingnode-&gt;next;</span><br><span class="line">    int length = 1;</span><br><span class="line">    while (fast != slow) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-链表实现大数加法"><a href="#8-链表实现大数加法" class="headerlink" title="8. 链表实现大数加法"></a>8. 链表实现大数加法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 链表实现大数加法</span><br><span class="line">ListNode* numberAddAsList(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">    ListNode *ret = l1, *pre = l2;</span><br><span class="line">    int up = 0; // 进位</span><br><span class="line">    while (l1 != NULL &amp;&amp; l2 != NULL) &#123;</span><br><span class="line">        l1-&gt;val = l1-&gt;val + l2-&gt;val +up;</span><br><span class="line">        up = l1-&gt;val / 10;</span><br><span class="line">        l1-&gt;val %= 10;</span><br><span class="line">        pre = l1; //记录当前结点位置</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    // 若l1到达末尾，说明l1长度小于l2</span><br><span class="line">    if (l1 == NULL) &#123;</span><br><span class="line">        pre-&gt;next = l2; // pre-&gt;next指向l2当前位置</span><br><span class="line">    &#125;</span><br><span class="line">    l1 = pre-&gt;next; // l1指针指向l2结点当前位置,即把l2拼到l1上继续计算</span><br><span class="line">    // 继续计算剩余结点，防止9999999+1这种情况</span><br><span class="line">    while (l1 != NULL) &#123;</span><br><span class="line">        l1-&gt;val = l1-&gt;val + up;</span><br><span class="line">        up = l1-&gt;val / 10;</span><br><span class="line">        l1-&gt;val %= 10;</span><br><span class="line">        pre = l1;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    // 最高位有进位，新建一个结点保留最高位</span><br><span class="line">    if (up != 0) &#123;</span><br><span class="line">        ListNode* tmp = new ListNode(up);</span><br><span class="line">        pre-&gt;next = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-有序链表合并"><a href="#9-有序链表合并" class="headerlink" title="9. 有序链表合并"></a>9. 有序链表合并</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 有序链表合并</span><br><span class="line">// 递归</span><br><span class="line">ListNode* mergeTwoOrderedListsRec(ListNode* pHead1, ListNode* pHead2)&#123;</span><br><span class="line">    if(pHead1 == NULL) return pHead2;</span><br><span class="line">    if(pHead2 == NULL) return pHead1;</span><br><span class="line">    if(pHead1-&gt;val &gt; pHead2-&gt;val) &#123;</span><br><span class="line">        pHead2-&gt;next = mergeTwoOrderedListsRec(pHead1, pHead2-&gt;next);</span><br><span class="line">        return pHead2;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        pHead1-&gt;next = mergeTwoOrderedListsRec(pHead1-&gt;next, pHead2);</span><br><span class="line">        return pHead1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 非递归</span><br><span class="line">ListNode* mergeTwoOrderedListsNotRec(ListNode* pHead1, ListNode* pHead2) &#123;</span><br><span class="line">    if (pHead1 == NULL) return pHead2;</span><br><span class="line">    else if (pHead2 == NULL) return pHead1;</span><br><span class="line">    else &#123;</span><br><span class="line">        ListNode* pTail = NULL; // 新链表最后一个结点</span><br><span class="line">        ListNode* newHead = NULL; // 合并后链表第一个结点</span><br><span class="line">        if (pHead1-&gt;val &lt; pHead2-&gt;val) &#123;</span><br><span class="line">            newHead = pHead1;</span><br><span class="line">            pHead1 = pHead1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            newHead = pHead2;</span><br><span class="line">            pHead2 = pHead2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pTail = newHead; // 指向第一个结点</span><br><span class="line">        while (pHead1 &amp;&amp; pHead2) &#123;</span><br><span class="line">            if (pHead1-&gt;val &lt;= pHead2-&gt;val) &#123;</span><br><span class="line">                pTail-&gt;next = pHead1;</span><br><span class="line">                pHead1 = pHead1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                pTail-&gt;next = pHead2;</span><br><span class="line">                pHead2 = pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pTail = pTail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (pHead1 == NULL) pTail-&gt;next = pHead2;</span><br><span class="line">        else if (pHead2 == NULL) pTail-&gt;next = pHead1;</span><br><span class="line">        return newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-K个有序链表合并"><a href="#10-K个有序链表合并" class="headerlink" title="10. K个有序链表合并"></a>10. K个有序链表合并</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// K个有序链表合并</span><br><span class="line">// 归并排序，复杂度O(nlogk)</span><br><span class="line">ListNode* mergeKsortedLists(vector&lt;ListNode*&gt; lists) &#123;</span><br><span class="line">    int amount = lists.size();</span><br><span class="line">    int gap = 1;</span><br><span class="line">    while (gap &lt; amount) &#123;</span><br><span class="line">        for (int i=0; i&lt; amount-gap; i+=gap*2) &#123;</span><br><span class="line">            lists[i] = mergeTwoOrderedListsRec(lists[i], lists[i+gap]);</span><br><span class="line">        &#125;</span><br><span class="line">        gap *= 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return amount&gt;0?lists[0]:NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-O-1-复杂度删除链表中结点"><a href="#11-O-1-复杂度删除链表中结点" class="headerlink" title="11. O(1)复杂度删除链表中结点"></a>11. O(1)复杂度删除链表中结点</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void deleteNode(ListNode **pHead, ListNode* pDelNode) &#123;</span><br><span class="line">    if (pDelNode == NULL) return;</span><br><span class="line">    if (pDelNode-&gt;next != NULL) &#123;</span><br><span class="line">        ListNode* pNext = pDelNode-&gt;next;</span><br><span class="line">        // 下一个节点的值赋给删除节点</span><br><span class="line">        pDelNode-&gt;val = pNext-&gt;val;</span><br><span class="line">        pDelNode-&gt;next = pNext-&gt;next;</span><br><span class="line">        delete pNext; // delete是删除指针指向的内容</span><br><span class="line">        pNext = NULL; // 不指向NULL会成为野指针</span><br><span class="line">    &#125;</span><br><span class="line">    else if (*pHead == pDelNode) &#123; //头结点</span><br><span class="line">        delete pDelNode;</span><br><span class="line">        pDelNode = NULL;</span><br><span class="line">        *pHead = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123; //删除尾结点</span><br><span class="line">        ListNode *pNode = *pHead;</span><br><span class="line">        while (pNode-&gt;next != pDelNode) &#123;</span><br><span class="line">            pNode = pNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pNode-&gt;next = NULL;</span><br><span class="line">        delete pDelNode;</span><br><span class="line">        pDelNode = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-从尾到头打印链表"><a href="#12-从尾到头打印链表" class="headerlink" title="12. 从尾到头打印链表"></a>12. 从尾到头打印链表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 递归</span><br><span class="line">vector&lt;int&gt; printListFromTailToHead1(ListNode* head) &#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    if(head!=NULL)&#123;</span><br><span class="line">        if(head-&gt;next!=NULL)&#123;</span><br><span class="line">            res = printListFromTailToHead1(head-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(head-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">//栈</span><br><span class="line">vector&lt;int&gt; printListFromTailToHead2(ListNode* head) &#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    stack&lt;int&gt; sta;</span><br><span class="line">    while(head!=NULL)&#123;</span><br><span class="line">        sta.push(head-&gt;val);</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!sta.empty())&#123;</span><br><span class="line">        res.push_back(sta.top());</span><br><span class="line">        sta.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">// **链表原地反转**</span><br><span class="line">vector&lt;int&gt; printListFromTailToHead3(struct ListNode* head) &#123;</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    ListNode *buf=head;</span><br><span class="line">    ListNode *pre=buf;</span><br><span class="line">    if(head==NULL)</span><br><span class="line">        return vec;</span><br><span class="line">    while(head-&gt;next!=NULL)&#123;  /*这里还没看懂*/</span><br><span class="line">        buf=head-&gt;next;</span><br><span class="line">        head-&gt;next=buf-&gt;next;</span><br><span class="line">        buf-&gt;next=pre;</span><br><span class="line">        pre=buf;</span><br><span class="line">    &#125;</span><br><span class="line">    while(buf)&#123;</span><br><span class="line">        vec.push_back(buf-&gt;val);</span><br><span class="line">        buf=buf-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="13-反转链表"><a href="#13-反转链表" class="headerlink" title="13. 反转链表"></a>13. 反转链表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 迭代（链表的原地反转）</span><br><span class="line">ListNode* reverseList1(ListNode* head) &#123;</span><br><span class="line">    ListNode* pre = NULL;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    while (cur != NULL) &#123;</span><br><span class="line">        ListNode* next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br><span class="line">// 递归</span><br><span class="line">ListNode* reverseList2(ListNode* head) &#123;</span><br><span class="line">    if (head == NULL || head-&gt;next == NULL) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* rhead = reverseList2(head-&gt;next);</span><br><span class="line">    // head-&gt;next此刻指向head后面的链表的尾节点</span><br><span class="line">    // head-&gt;next-&gt;next = head把head节点放在了尾部</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = NULL;</span><br><span class="line">    return rhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="14-复杂链表的复制"><a href="#14-复杂链表的复制" class="headerlink" title="14. 复杂链表的复制"></a>14. 复杂链表的复制</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// （每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针</span><br><span class="line">// 指向任意一个节点），返回结果为复制后复杂链表的head。</span><br><span class="line">RandomListNode* Clone(RandomListNode* pHead)&#123;</span><br><span class="line">    if(pHead==NULL) return NULL;</span><br><span class="line">    RandomListNode* currentNode=pHead;</span><br><span class="line">    //复制每个结点，将其插入结点后面</span><br><span class="line">    while(currentNode!=NULL)&#123;</span><br><span class="line">        RandomListNode* cloneNode = new RandomListNode(currentNode-&gt;label);</span><br><span class="line">        RandomListNode* nextNode = currentNode-&gt;next;</span><br><span class="line">        currentNode-&gt;next=cloneNode;</span><br><span class="line">        cloneNode-&gt;next=nextNode;</span><br><span class="line">        currentNode=nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode=pHead;</span><br><span class="line">    //复制老结点的随机指针给新结点</span><br><span class="line">    while(currentNode!=NULL)&#123;</span><br><span class="line">        currentNode-&gt;next-&gt;random = currentNode-&gt;random==NULL?NULL:currentNode-&gt;random-&gt;next;</span><br><span class="line">        currentNode=currentNode-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    //拆分链表</span><br><span class="line">    currentNode=pHead;</span><br><span class="line">    RandomListNode* pCloneHead=pHead-&gt;next;</span><br><span class="line">    while(currentNode!=NULL)&#123;</span><br><span class="line">        RandomListNode* cloneNode=currentNode-&gt;next;</span><br><span class="line">        currentNode-&gt;next=cloneNode-&gt;next;</span><br><span class="line">        cloneNode-&gt;next=cloneNode-&gt;next==NULL?NULL:cloneNode-&gt;next-&gt;next;</span><br><span class="line">        currentNode=currentNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pCloneHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="15-逆序构造单链表"><a href="#15-逆序构造单链表" class="headerlink" title="15. 逆序构造单链表"></a>15. 逆序构造单链表</h1><p>输入数据：[1,2,3,4,5],构造单链表:5-&gt;4-&gt;3-&gt;2-&gt;1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 逆序构造单链表</span><br><span class="line">ListNode* desc_construct(vector&lt;int&gt; input) &#123;</span><br><span class="line">    if (input.empty()) return NULL;</span><br><span class="line">    ListNode* pre = NULL;</span><br><span class="line">    for (int i=0;i&lt;input.size();i++) &#123;</span><br><span class="line">        ListNode* cur = new ListNode(input[i]);</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="16-链表升序排序"><a href="#16-链表升序排序" class="headerlink" title="16. 链表升序排序"></a>16. 链表升序排序</h1><p>快排是需要一个指针指向头，一个指针指向尾，然后两个指针相向运动并按一定规律交换值，最后使得支点左边小于支点，支点右边大于支点，但是对于单链表而言，指向结尾的指针很好办，但是这个指针如何往前，我们只有一个 next（这并不是一个双向链表）。</p><p>我们只需要两个指针 i 和 j，这两个指针均往 next 方向移动，移动的过程中始终保持区间 [1, i] 的 data 都小于 base（位置 0 是主元），区间 [i+1, j) 的 data 都大于等于 base，那么当 j 走到末尾的时候便完成了一次支点的寻找。若以 swap 操作即 if 判断语句成立作为基本操作，其操作数和快速排序相同，故该方法的平均时间复杂度亦为$T(n) = O(nlogn)$。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 链表升序排序</span><br><span class="line">/**</span><br><span class="line">    * @param begin 链表的第一个结点，即header-&gt;next</span><br><span class="line">    * @param end   链表的最后一个结点的next</span><br><span class="line">    */</span><br><span class="line">void asc_sort(ListNode* begin, ListNode* end) &#123;</span><br><span class="line">    // 链表为空或只有一个结点</span><br><span class="line">    if (begin == end || begin-&gt;next == end) return;</span><br><span class="line">    int base = begin-&gt;val;</span><br><span class="line">    ListNode* i = begin;</span><br><span class="line">    ListNode* j = begin-&gt;next;</span><br><span class="line">    while (j != end) &#123;</span><br><span class="line">        if (j-&gt;val &lt; base) &#123;</span><br><span class="line">            i = i-&gt;next;</span><br><span class="line">            swap(i-&gt;val, j-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        j = j-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    swap (i-&gt;val, begin-&gt;val);</span><br><span class="line">    asc_sort(begin, i);</span><br><span class="line">    asc_sort(i-&gt;next, end);</span><br><span class="line">&#125;</span><br><span class="line">// usage: asc_sort(header-&gt;next, nullptr);</span><br></pre></td></tr></table></figure><h1 id="17-找出单链表的中间结点"><a href="#17-找出单链表的中间结点" class="headerlink" title="17. 找出单链表的中间结点"></a>17. 找出单链表的中间结点</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 找出单链表的中间结点（类似倒数第k个结点）</span><br><span class="line">// 法一：遍历一次，再遍历到n/2,复杂度为O(n+n/2)</span><br><span class="line">// 法二：快慢指针</span><br><span class="line">ListNode* find_middle(ListNode* head) &#123;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链表的算法合集大全(C/C++)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Data Structure" scheme="https://dlc1994.github.io/categories/Algorithm-and-Data-Structure/"/>
    
    
      <category term="C/C++" scheme="https://dlc1994.github.io/tags/C-C/"/>
    
      <category term="Algorithm" scheme="https://dlc1994.github.io/tags/Algorithm/"/>
    
      <category term="LinkedList" scheme="https://dlc1994.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>2019中兴捧月算法大赛——无线信道估计</title>
    <link href="https://dlc1994.github.io/2019/05/24/ck813u1i8000lkkunv0a9tdbw/"/>
    <id>https://dlc1994.github.io/2019/05/24/ck813u1i8000lkkunv0a9tdbw/</id>
    <published>2019-05-24T15:02:50.000Z</published>
    <updated>2020-01-09T01:24:42.332Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/dlc1994/2019ZTE-Algorithm-Competition">Github项目：https://github.com/dlc1994/2019ZTE-Algorithm-Competition</a></p><p>本来想参加深度学习题目的，但看到用caffe，还要现学就作罢了<br><a id="more"></a></p><p>傅里叶门派有三个题目，一开始想做了智能调度，但是看了半天题目也没理解，随便提交了一个上去（最后发现一共才50多份提交，悔不当初）</p><p>看到这个有点像曲线拟合，题目就是用最少的导频数，估计带噪声的其余一共250个频点的信道值</p><p>看上去有点像曲线拟合，所以我就往曲线拟合方向做了</p><p>1 导频数用62，此时导频和误差百分比大致在50%</p><p>2 导频分开实部和虚部分开进行拟合，拟合函数使用SmoothingSpline</p><p>3 拟合出来函数是带噪声的，接下来去噪</p><p>4 用小波变换，小波基为coif5,分解层数为10层 </p><p>5 输出最终结果，感觉有点过拟合了</p><p>最后一天做了半天，只能提高到36名了，看到进决赛拿蓝剑的那些大神还是很羡慕的，应该多花些时间的，从原理上改进而不是简单的去噪拟合</p><p>大佬的思路：</p><p>1 多种组合构成个闭环优化，中兴专家做的，好像用20个导频左右拿了第一</p><p>2 用CNN，这个可能是从autoencoder方向想，但是数据集够用？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/dlc1994/2019ZTE-Algorithm-Competition&quot;&gt;Github项目：https://github.com/dlc1994/2019ZTE-Algorithm-Competition&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本来想参加深度学习题目的，但看到用caffe，还要现学就作罢了&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Competition" scheme="https://dlc1994.github.io/categories/Competition/"/>
    
    
      <category term="Matlab" scheme="https://dlc1994.github.io/tags/Matlab/"/>
    
      <category term="Wireless communications" scheme="https://dlc1994.github.io/tags/Wireless-communications/"/>
    
  </entry>
  
  <entry>
    <title>常用数据结构——栈 (python)</title>
    <link href="https://dlc1994.github.io/2019/04/29/ck813u1i6000jkkun7i2igenq/"/>
    <id>https://dlc1994.github.io/2019/04/29/ck813u1i6000jkkun7i2igenq/</id>
    <published>2019-04-29T13:27:23.000Z</published>
    <updated>2020-03-09T03:04:43.412Z</updated>
    
    <content type="html"><![CDATA[<p>本科学过c++的数据结构了，但研究生转无线通信后就忘的差不多了，现在重新复习下栈。<br><a id="more"></a><br>  栈（stack）、队列（queues）、双端队列（deques）和列表都是有序数据容器，元素添加后在容器内的位置跟其他元素添加和删除的顺序有关，像这样的容器被称作线性数据结构（linear data structure）。<br>  栈可以想象为只有一端开口的瓶子，假设每放一个东西进去都会把前面放的完全盖住，那么这时你想取出最里面的东西显然是不可能的，所以你只能把上面的一个个拿出来才能取到你想要的，这就叫做后进先出（LIFO, last-in first-out）。</p><h1 id="1-栈的主要方法及实现"><a href="#1-栈的主要方法及实现" class="headerlink" title="1. 栈的主要方法及实现"></a>1. 栈的主要方法及实现</h1><p>  栈的方法主要有下面几种：</p><ul><li><code>Stack()</code> creates a new stack that is empty. It needs no parameters and returns an empty stack.</li><li><code>push(item)</code> adds a new item to the top of the stack. It needs the item and returns nothing.</li><li><code>pop()</code> removes the top item from the stack. It needs no parameters and returns the item. The stack is modified.</li><li><code>peek()</code> returns the top item from the stack but does not remove it. It needs no parameters. The stack is not modified.</li><li><code>isEmpty()</code> tests to see whether the stack is empty. It needs no parameters and returns a boolean value.</li><li><code>size()</code> returns the number of items on the stack. It needs no parameters and returns an integer.<br>在python中是没有栈的实现的，所以栈需要自己实现，简单点可以用个list充当下，更一般的要实现上面各种方法还是面向对象创造一个类比较好，实现代码如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Stack:</span><br><span class="line">     def __init__(self):</span><br><span class="line">         self.items = []</span><br><span class="line"></span><br><span class="line">     def isEmpty(self):</span><br><span class="line">         return self.items == []</span><br><span class="line"></span><br><span class="line">     def push(self, item):</span><br><span class="line">         self.items.append(item)</span><br><span class="line"></span><br><span class="line">     def pop(self):</span><br><span class="line">         return self.items.pop()</span><br><span class="line"></span><br><span class="line">     def peek(self):</span><br><span class="line">         return self.items[len(self.items)-1]</span><br><span class="line"></span><br><span class="line">     def size(self):</span><br><span class="line">         return len(self.items)</span><br></pre></td></tr></table></figure></li></ul><h1 id="2-栈的主要应用"><a href="#2-栈的主要应用" class="headerlink" title="2. 栈的主要应用"></a>2. 栈的主要应用</h1><h2 id="2-1-字符串反转"><a href="#2-1-字符串反转" class="headerlink" title="2.1 字符串反转"></a>2.1 字符串反转</h2><p>  那么，费尽心机创造一个栈有啥用呢？首先可以用来翻转字符串，当然python有超级多方式可以反转字符串，最简单的自然是string[::-1]。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def stringReverse(self, stringstring):</span><br><span class="line">s = Stack()</span><br><span class="line">output = &quot;&quot;</span><br><span class="line">for ss in stringstring:</span><br><span class="line">s.push(ss)</span><br><span class="line">while not s.isEmpty():</span><br><span class="line">output = output + s.pop()</span><br><span class="line">return output</span><br></pre></td></tr></table></figure></p><h2 id="2-2-简单括号匹配"><a href="#2-2-简单括号匹配" class="headerlink" title="2.2 简单括号匹配"></a>2.2 简单括号匹配</h2><p>  除此之外，还有简单的括号匹配问题，也可以利用栈的特性来解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def parChecker(symbolString):</span><br><span class="line">    s = Stack()</span><br><span class="line">    balanced = True</span><br><span class="line">    index = 0</span><br><span class="line">    while index &lt; len(symbolString) and balanced:</span><br><span class="line">        symbol = symbolString[index]</span><br><span class="line">        if symbol == &quot;(&quot;:</span><br><span class="line">            s.push(symbol)</span><br><span class="line">        else:</span><br><span class="line">            if s.isEmpty():</span><br><span class="line">                balanced = False</span><br><span class="line">            else:</span><br><span class="line">                s.pop()</span><br><span class="line"></span><br><span class="line">        index = index + 1</span><br><span class="line"></span><br><span class="line">    if balanced and s.isEmpty():</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure></p><p>  其实吧，也可以不用栈解决呀（不是我杠，笔试时间也是很重要的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def parChecker(symbolString):</span><br><span class="line">    left = 0</span><br><span class="line">    right = 0</span><br><span class="line">    for s in symbolString:</span><br><span class="line">        if s == &apos;(&apos;:</span><br><span class="line">            left+=1</span><br><span class="line">        else:</span><br><span class="line">            right+=1</span><br><span class="line">    return left==right</span><br></pre></td></tr></table></figure></p><h2 id="2-3-多重括号匹配"><a href="#2-3-多重括号匹配" class="headerlink" title="2.3 多重括号匹配"></a>2.3 多重括号匹配</h2><p>  拓展到更复杂一点的括号匹配问题——多重括号匹配：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def parChecker(symbolString):</span><br><span class="line">    s = Stack()</span><br><span class="line">    balanced = True</span><br><span class="line">    index = 0</span><br><span class="line">    while index &lt; len(symbolString) and balanced:</span><br><span class="line">        symbol = symbolString[index]</span><br><span class="line">        if symbol in &quot;([&#123;&quot;:</span><br><span class="line">            s.push(symbol)</span><br><span class="line">        else:</span><br><span class="line">            if s.isEmpty():</span><br><span class="line">                balanced = False</span><br><span class="line">            else:</span><br><span class="line">                top = s.pop()</span><br><span class="line">                if not matches(top,symbol):</span><br><span class="line">                       balanced = False</span><br><span class="line">        index = index + 1</span><br><span class="line">    if balanced and s.isEmpty():</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">def matches(open,close):</span><br><span class="line">    opens = &quot;([&#123;&quot;</span><br><span class="line">    closers = &quot;)]&#125;&quot;</span><br><span class="line">    return opens.index(open) == closers.index(close)</span><br></pre></td></tr></table></figure></p><p>  当然，我又“杠”了，主要不想想这么复杂的结构2333：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def parChecker(symbolString):</span><br><span class="line">    l1,l2,l3,r1,r2,r3=0,0,0,0,0,0</span><br><span class="line">    for s in symbolString:</span><br><span class="line">        if s==&apos;&#123;&apos;:</span><br><span class="line">            l1+=1</span><br><span class="line">        elif s==&apos;&#125;&apos;:</span><br><span class="line">            r1+=1</span><br><span class="line">        elif s==&apos;(&apos;:</span><br><span class="line">            l2+=1</span><br><span class="line">        elif s==&apos;)&apos;:</span><br><span class="line">            r2+=1</span><br><span class="line">        elif s==&apos;[&apos;:</span><br><span class="line">            l3+=1</span><br><span class="line">        else:</span><br><span class="line">            r3+=1</span><br><span class="line">    return [l1,l2,l3]==[r1,r2,r3]</span><br></pre></td></tr></table></figure></p><h2 id="2-4-将十进制数转换为各种进制"><a href="#2-4-将十进制数转换为各种进制" class="headerlink" title="2.4 将十进制数转换为各种进制"></a>2.4 将十进制数转换为各种进制</h2><p>  想将10进制数（Decimal）转换为2进制（Binary）、8进制（Octal）或者16进制（Hexidecimal），就将这个数不断除进制数，然后将余数逆序输出，不想贴图了自己百度查下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def baseConverter(decNumber,base):</span><br><span class="line">    digits = &quot;0123456789ABCDEF&quot;</span><br><span class="line">    remstack = Stack()</span><br><span class="line"></span><br><span class="line">    while decNumber &gt; 0:</span><br><span class="line">        rem = decNumber % base</span><br><span class="line">        remstack.push(rem)</span><br><span class="line">        decNumber = decNumber // base</span><br><span class="line"></span><br><span class="line">    newString = &quot;&quot;</span><br><span class="line">    while not remstack.isEmpty():</span><br><span class="line">        newString = newString + digits[remstack.pop()]</span><br><span class="line"></span><br><span class="line">    return newString</span><br></pre></td></tr></table></figure></p><h2 id="2-5-中缀表达式、前后缀表达式"><a href="#2-5-中缀表达式、前后缀表达式" class="headerlink" title="2.5 中缀表达式、前后缀表达式"></a>2.5 <strong>中缀表达式、前后缀表达式</strong></h2><p>  接下来就是栈的重点操作了（就是比较复杂一点）。<br>  什么是中缀表达式呢？就是一般的表达式，比如A+B, C*D等。<br>  顾名思义，前缀表达式就是操作符在前面，后缀就是在后面，给几个例子体会一下：<br> <strong>Infix Expression</strong>        <strong>Prefix Expression</strong>    <strong>Postfix Expression</strong><br>  A + B <em> C + D        + + A </em> B C D            A B C <em> + D +<br>  (A + B) </em> (C + D)        <em> + A B + C D            A B + C D + </em><br>  A <em> B + C </em> D        + <em> A B </em> C D            A B <em> C D </em> +<br>  A + B + C + D        + + + A B C D            A B + C + D +</p><p>  将中缀表达式转换为后缀表达式，利用栈可以写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">def infixToPostfix(infixexpr):</span><br><span class="line">    prec = &#123;&#125;</span><br><span class="line">    prec[&quot;*&quot;] = 3</span><br><span class="line">    prec[&quot;/&quot;] = 3</span><br><span class="line">    prec[&quot;+&quot;] = 2</span><br><span class="line">    prec[&quot;-&quot;] = 2</span><br><span class="line">    prec[&quot;(&quot;] = 1</span><br><span class="line">    opStack = Stack()</span><br><span class="line">    postfixList = []</span><br><span class="line">    tokenList = infixexpr.split()</span><br><span class="line"></span><br><span class="line">    for token in tokenList:</span><br><span class="line">        if token in &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; or token in &quot;0123456789&quot;:</span><br><span class="line">            postfixList.append(token)</span><br><span class="line">        elif token == &apos;(&apos;:</span><br><span class="line">            opStack.push(token)</span><br><span class="line">        elif token == &apos;)&apos;:</span><br><span class="line">            topToken = opStack.pop()</span><br><span class="line">            while topToken != &apos;(&apos;:</span><br><span class="line">                postfixList.append(topToken)</span><br><span class="line">                topToken = opStack.pop()</span><br><span class="line">        else:</span><br><span class="line">            while (not opStack.isEmpty()) and \</span><br><span class="line">               (prec[opStack.peek()] &gt;= prec[token]):</span><br><span class="line">                  postfixList.append(opStack.pop())</span><br><span class="line">            opStack.push(token)</span><br><span class="line"></span><br><span class="line">    while not opStack.isEmpty():</span><br><span class="line">        postfixList.append(opStack.pop())</span><br><span class="line">    return &quot; &quot;.join(postfixList)</span><br></pre></td></tr></table></figure></p><p>  假如直接给你一个后缀表达式让你计算呢，这就是需要再写一个算法了，不过比较简单，贴上来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def postfixEval(postfixExpr):</span><br><span class="line">    operandStack = Stack()</span><br><span class="line">    tokenList = postfixExpr.split()</span><br><span class="line"></span><br><span class="line">    for token in tokenList:</span><br><span class="line">        if token in &quot;0123456789&quot;:</span><br><span class="line">            operandStack.push(int(token))</span><br><span class="line">        else:</span><br><span class="line">            operand2 = operandStack.pop()</span><br><span class="line">            operand1 = operandStack.pop()</span><br><span class="line">            result = doMath(token,operand1,operand2)</span><br><span class="line">            operandStack.push(result)</span><br><span class="line">    return operandStack.pop()</span><br><span class="line"></span><br><span class="line">def doMath(op, op1, op2):</span><br><span class="line">    if op == &quot;*&quot;:</span><br><span class="line">        return op1 * op2</span><br><span class="line">    elif op == &quot;/&quot;:</span><br><span class="line">        return op1 / op2</span><br><span class="line">    elif op == &quot;+&quot;:</span><br><span class="line">        return op1 + op2</span><br><span class="line">    else:</span><br><span class="line">        return op1 - op2</span><br></pre></td></tr></table></figure></p><p>  栈就目前学完了，后续有的话还会补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本科学过c++的数据结构了，但研究生转无线通信后就忘的差不多了，现在重新复习下栈。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Data Structure" scheme="https://dlc1994.github.io/categories/Algorithm-and-Data-Structure/"/>
    
    
      <category term="Stack" scheme="https://dlc1994.github.io/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>常用排序算法（python）</title>
    <link href="https://dlc1994.github.io/2019/04/19/ck813u1i5000ikkuni4u992wc/"/>
    <id>https://dlc1994.github.io/2019/04/19/ck813u1i5000ikkuni4u992wc/</id>
    <published>2019-04-19T13:27:23.000Z</published>
    <updated>2020-01-09T01:18:39.916Z</updated>
    
    <content type="html"><![CDATA[<p>常用排序算法（python）<br><a id="more"></a></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def bubbleSort(alist):</span><br><span class="line">    for i in range(len(alist)):</span><br><span class="line">        for j in range(len(alist)-i-1):</span><br><span class="line">            if alist[j]&gt;alist[j+1]:</span><br><span class="line">                tmp = alist[j]</span><br><span class="line">                alist[j] = alist[j+1]</span><br><span class="line">                alist[j+1] = tmp</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def selectSort(alist):</span><br><span class="line">    for i in range(len(alist)):</span><br><span class="line">        minPos = i</span><br><span class="line">        for j in range(i+1, len(alist)):</span><br><span class="line">            if alist[i]&gt;alist[j]:</span><br><span class="line">                minPos = j</span><br><span class="line">        tmp = alist[i]</span><br><span class="line">        alist[i] = alist[minPos]</span><br><span class="line">        alist[minPos] = tmp</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def insertSort(alist):</span><br><span class="line">    for i in range(1, len(alist)):</span><br><span class="line">        current = alist[i]</span><br><span class="line">        pos = i</span><br><span class="line">        while pos&gt;0 and current&lt;alist[pos-1]:</span><br><span class="line">            alist[pos] = alist[pos-1]</span><br><span class="line">            pos-=1</span><br><span class="line">        alist[pos] = current</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def shellSort(alist):</span><br><span class="line">    gap = len(alist)//2</span><br><span class="line">    while gap&gt;0:</span><br><span class="line">        for i in range(gap, len(alist)):</span><br><span class="line">            j = i</span><br><span class="line">            current = alist[i]</span><br><span class="line">            while j-gap&gt;0 and current&lt;alist[j-gap]:</span><br><span class="line">                alist[j] = alist[j-gap]</span><br><span class="line">                j = j - gap</span><br><span class="line">            alist[j] = current</span><br><span class="line">        gap = gap // 2</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def mergeSort(alist):</span><br><span class="line">    if len(alist)&gt;1:</span><br><span class="line">        mid = len(alist) // 2</span><br><span class="line">        left = alist[:mid]</span><br><span class="line">        right = alist[mid:]</span><br><span class="line">        </span><br><span class="line">        mergeSort(left)</span><br><span class="line">        mergeSort(right)</span><br><span class="line">        </span><br><span class="line">        i,j,k = 0,0,0</span><br><span class="line">        while i&lt;len(left) and j&lt;len(right):</span><br><span class="line">            if left[i]&lt;right[j]:</span><br><span class="line">                alist[k] = left[i]</span><br><span class="line">                i+=1</span><br><span class="line">            else:</span><br><span class="line">                alist[k] = right[j]</span><br><span class="line">                j+=1</span><br><span class="line">            k+=1</span><br><span class="line">        while i&lt;len(left):</span><br><span class="line">            alist[k] = left[i]</span><br><span class="line">            k+=1</span><br><span class="line">            i+=1</span><br><span class="line">        while j&lt;len(right):</span><br><span class="line">            alist[k] = right[j]</span><br><span class="line">            k+=1</span><br><span class="line">            j+=1</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def quickSort(alist):</span><br><span class="line">    quickSortHelper(alist, 0, len(alist)-1)</span><br><span class="line"></span><br><span class="line">def quickSortHelper(alist, first, last):</span><br><span class="line">    if first&lt;last:</span><br><span class="line">        splitpoint = partition(alist, first, last)</span><br><span class="line">        quickSortHelper(alist, first, splitpoint-1)</span><br><span class="line">        quickSortHelper(alist, splitpoint + 1, last)</span><br><span class="line"></span><br><span class="line">def partition(alist, first, last):</span><br><span class="line">    pivot = alist[first]</span><br><span class="line">    leftmark = first + 1</span><br><span class="line">    rightmark = last</span><br><span class="line">    done = False</span><br><span class="line">    while not done:</span><br><span class="line">        while leftmark &lt;= rightmark and alist[leftmark] &lt;= pivot:</span><br><span class="line">            leftmark += 1</span><br><span class="line">        while rightmark &gt;= leftmark and alist[rightmark] &gt;= pivot:</span><br><span class="line">            rightmark -= 1</span><br><span class="line">        if rightmark &lt; leftmark:</span><br><span class="line">            done = True</span><br><span class="line">        else:</span><br><span class="line">            tmp = alist[leftmark]</span><br><span class="line">            alist[leftmark] = alist[rightmark]</span><br><span class="line">            alist[rightmark] = tmp</span><br><span class="line">    tmp = alist[first]</span><br><span class="line">    alist[first] = alist[rightmark]</span><br><span class="line">    alist[rightmark] = tmp</span><br><span class="line">    return rightmark</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常用排序算法（python）&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Data Structure" scheme="https://dlc1994.github.io/categories/Algorithm-and-Data-Structure/"/>
    
    
      <category term="Sorting" scheme="https://dlc1994.github.io/tags/Sorting/"/>
    
  </entry>
  
  <entry>
    <title>暑期实习招聘笔试题3月(更新ing)</title>
    <link href="https://dlc1994.github.io/2019/03/16/ck813u1i7000kkkunz6v4pm21/"/>
    <id>https://dlc1994.github.io/2019/03/16/ck813u1i7000kkkunz6v4pm21/</id>
    <published>2019-03-16T13:27:23.000Z</published>
    <updated>2019-05-24T15:35:06.289Z</updated>
    
    <content type="html"><![CDATA[<p>实习笔试试题，有些没投（准备好先），拿过来先看了看<br><a id="more"></a></p><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><h1 id="2-头条笔试题"><a href="#2-头条笔试题" class="headerlink" title="2 头条笔试题"></a>2 头条笔试题</h1><p><img src="/2019/03/16/ck813u1i7000kkkunz6v4pm21/3.jpg" alt="3.jpg"><br><img src="/2019/03/16/ck813u1i7000kkkunz6v4pm21/4.jpg" alt="4.jpg"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int N;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    for(int n=0;n&lt;N;++n)&#123;</span><br><span class="line">        int L, minVal, minPos;</span><br><span class="line">        minVal = 1000;</span><br><span class="line">        minPos = 0;</span><br><span class="line">        cin&gt;&gt;L;</span><br><span class="line">        vector&lt;int&gt; v(L, 0);</span><br><span class="line">        for(int l=0;l&lt;L;l++)&#123;</span><br><span class="line">            cin&gt;&gt;v[l];</span><br><span class="line">            if(v[l]&lt;minVal)&#123;</span><br><span class="line">                minVal = v[l];</span><br><span class="line">                minPos = l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; reward(v.size(), 0);</span><br><span class="line">        reward[minPos] = 1;</span><br><span class="line">        for(int k=0;k&lt;L;k++)&#123;</span><br><span class="line">            int pos = k+minPos;</span><br><span class="line">            if (pos&gt;=L)&#123;</span><br><span class="line">                pos = pos - L;</span><br><span class="line">            &#125;</span><br><span class="line">            if(pos==0)&#123;</span><br><span class="line">                if(v[pos]&gt;v[L-1]) reward[pos] = reward[L-1]+1;</span><br><span class="line">                else if(v[pos]==v[L-1]) reward[pos] = reward[L-1] - 1;</span><br><span class="line">                else reward[pos]=reward[pos];</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(v[pos]&gt;v[pos-1]) reward[pos] = reward[pos-1]+1;</span><br><span class="line">                else if(v[pos]==v[pos-1]) reward[pos] = reward[pos-1] - 1;</span><br><span class="line">                else reward[pos]=reward[pos];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;accumulate(reward.begin(),reward.end(),0)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3-头条笔试题"><a href="#3-头条笔试题" class="headerlink" title="3 头条笔试题"></a>3 头条笔试题</h1><p><img src="/2019/03/16/ck813u1i7000kkkunz6v4pm21/5.jpg" alt="5.jpg"><br><img src="/2019/03/16/ck813u1i7000kkkunz6v4pm21/6.jpg" alt="6.jpg"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; zhaoqian(int N)&#123;</span><br><span class="line">vector&lt;int&gt; v(4,0);</span><br><span class="line">    N = 1024 - N;</span><br><span class="line">int value[4] = &#123;64, 16, 4, 1&#125;;</span><br><span class="line">for(int i=0;i&lt;(sizeof(value)/sizeof(value[0]));i++)&#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">        int a = N/value[i];</span><br><span class="line">v[i] = a;</span><br><span class="line">N = N%value[i];</span><br><span class="line">&#125;</span><br><span class="line">return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int N;</span><br><span class="line">cin&gt;&gt;N;</span><br><span class="line">vector&lt;int&gt; vv;</span><br><span class="line">vv = zhaoqian(N);</span><br><span class="line">    cout&lt;&lt;accumulate(vv.begin(), vv.end(), 0)&lt;&lt;endl;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="4-招行笔试题"><a href="#4-招行笔试题" class="headerlink" title="4 招行笔试题"></a>4 招行笔试题</h1><p>题目描述：切不等高的蛋糕，蛋糕N份，每刀切平一部分，切下来的不得超过k份，整块蛋糕切平最少需要几刀，比如如下输入<br>5 6<br>1 2 3 4 5<br>提示：第一刀可以切到2，切下来刚好是6份，剩下蛋糕为1 2 2 2 2<br>第二刀全切到1，最少需要2刀<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int N,k;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;k;</span><br><span class="line">    vector&lt;int&gt; v(N, 0);</span><br><span class="line">    for(int l=0;l&lt;N;l++)&#123;</span><br><span class="line">        cin&gt;&gt;v[l];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(v.begin(),v.end());</span><br><span class="line">    int minVal = v.front();</span><br><span class="line">    int maxVal = v.back();</span><br><span class="line">    int dao = 0;</span><br><span class="line">    bool hello = false;</span><br><span class="line">    int i = 0;</span><br><span class="line">    while(i&lt;v.size())&#123;</span><br><span class="line">        if(hello) i=0;</span><br><span class="line">        if(minVal==maxVal) break;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        bool flag = true;</span><br><span class="line">        int minVal1=v[i];</span><br><span class="line">        for(int j=v.size()-1;j&gt;i;--j)&#123;</span><br><span class="line">            sum = sum+(v[j]-minVal1);</span><br><span class="line">            if(sum&gt;k)&#123;</span><br><span class="line">                flag = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            dao++;</span><br><span class="line">            hello = true;</span><br><span class="line">            for(int g=v.size()-1;g&gt;i;g--)&#123;</span><br><span class="line">                v[g] = v[g]-(v[g]-minVal1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxVal=v.back();</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dao;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实习笔试试题，有些没投（准备好先），拿过来先看了看&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://dlc1994.github.io/categories/LeetCode/"/>
    
    
      <category term="C++" scheme="https://dlc1994.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>二叉树常用操作的实现</title>
    <link href="https://dlc1994.github.io/2019/03/09/ck813u1hn0003kkunyfrxfzr4/"/>
    <id>https://dlc1994.github.io/2019/03/09/ck813u1hn0003kkunyfrxfzr4/</id>
    <published>2019-03-09T12:23:52.000Z</published>
    <updated>2020-03-06T12:15:07.135Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树的最全总结，常考题型，持续更新<br><strong>二叉树的递归思想很重要，还有递归的复杂度分析</strong><br><a id="more"></a></p><h1 id="1-1-二叉树的初始化"><a href="#1-1-二叉树的初始化" class="headerlink" title="1.1 二叉树的初始化"></a>1.1 二叉树的初始化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#initial of BinaryTree</span><br><span class="line">class BinaryTree:</span><br><span class="line">    def __init__(self,rootObj):</span><br><span class="line">        self.val = rootObj</span><br><span class="line">        self.left = None</span><br><span class="line">        self.right = None</span><br><span class="line"></span><br><span class="line">    def insertLeft(self,newNode):</span><br><span class="line">        if self.left == None:</span><br><span class="line">            self.left = BinaryTree(newNode)</span><br><span class="line">        else:</span><br><span class="line">            t = BinaryTree(newNode)</span><br><span class="line">            t.left = self.left</span><br><span class="line">            self.left = t</span><br><span class="line"></span><br><span class="line">    def insertRight(self,newNode):</span><br><span class="line">        if self.right == None:</span><br><span class="line">            self.right = BinaryTree(newNode)</span><br><span class="line">        else:</span><br><span class="line">            t = BinaryTree(newNode)</span><br><span class="line">            t.right = self.right</span><br><span class="line">            self.right = t</span><br></pre></td></tr></table></figure><h1 id="1-2-创建一个二叉树"><a href="#1-2-创建一个二叉树" class="headerlink" title="1.2 创建一个二叉树"></a>1.2 创建一个二叉树</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#create a BinaryTree [18,7,11,3,4,5,6,#,#,#,#,1,3,2,4]</span><br><span class="line">#  18</span><br><span class="line"># 7  11</span><br><span class="line">#3 4 5 6</span><br><span class="line">#   1 3 2 4</span><br><span class="line"></span><br><span class="line">root = BinaryTree(18)</span><br><span class="line">root.left = BinaryTree(7)</span><br><span class="line">root.right = BinaryTree(11)</span><br><span class="line">root.left.left = BinaryTree(3)</span><br><span class="line">root.left.right = BinaryTree(4)</span><br><span class="line">root.right.left = BinaryTree(5)</span><br><span class="line">root.right.right = BinaryTree(6)</span><br><span class="line">root.right.left.left = BinaryTree(1)</span><br><span class="line">root.right.left.right = BinaryTree(3)</span><br><span class="line">root.right.right.left = BinaryTree(2)</span><br><span class="line">root.right.right.right = BinaryTree(4)</span><br></pre></td></tr></table></figure><h1 id="1-3-前序遍历"><a href="#1-3-前序遍历" class="headerlink" title="1.3 前序遍历"></a>1.3 前序遍历</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#递归版本</span><br><span class="line">def PreOrder(self, node):</span><br><span class="line">    if node:</span><br><span class="line">        print(node.val)</span><br><span class="line">        self.PreOrder(node.left)</span><br><span class="line">        self.PreOrder(node.right)</span><br><span class="line">#循环版本</span><br><span class="line">def PreOrderLoop(self, node):</span><br><span class="line">    if node == None:</span><br><span class="line">        return</span><br><span class="line">    stack =[]</span><br><span class="line">    print(node.val)</span><br><span class="line">    stack.append(node)</span><br><span class="line">    node = node.left</span><br><span class="line">    while stack!=[] or node:</span><br><span class="line">        while node:</span><br><span class="line">            print(node.val)</span><br><span class="line">            stack.append(node)</span><br><span class="line">            node = node.left</span><br><span class="line">        node = stack[-1].right</span><br><span class="line">        stack.pop()</span><br><span class="line"></span><br><span class="line">#ouput: 18 7 3 4 11 5 1 3 6 2 4</span><br></pre></td></tr></table></figure><h1 id="1-4-中序遍历"><a href="#1-4-中序遍历" class="headerlink" title="1.4 中序遍历"></a>1.4 中序遍历</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#递归版本</span><br><span class="line">def InOrder(self, node):</span><br><span class="line">    if node:</span><br><span class="line">        self.InOrder(node.left)</span><br><span class="line">        print(node.val)</span><br><span class="line">        self.InOrder(node.right)</span><br><span class="line">#循环版本</span><br><span class="line">def InOrderLoop(self, node):</span><br><span class="line">    if node == None:</span><br><span class="line">        return None</span><br><span class="line">    stack = []</span><br><span class="line">    stack.append(node)</span><br><span class="line">    node = node.left</span><br><span class="line">    while stack!=[] or node:</span><br><span class="line">        while node:</span><br><span class="line">            stack.append(node)</span><br><span class="line">            node = node.left</span><br><span class="line">        print(stack[-1].val)</span><br><span class="line">        node = stack[-1].right</span><br><span class="line">        stack.pop()</span><br><span class="line">#output：3 7 4 18 1 5 3 11 2 6 4</span><br></pre></td></tr></table></figure><h1 id="1-5-后序遍历"><a href="#1-5-后序遍历" class="headerlink" title="1.5 后序遍历"></a>1.5 后序遍历</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#递归</span><br><span class="line">def PostOrder(self, node):</span><br><span class="line">    if node:</span><br><span class="line">        self.PostOrder(node.left)</span><br><span class="line">        self.PostOrder(node.right)</span><br><span class="line">        print(node.val)</span><br><span class="line">#非递归</span><br><span class="line">def PostOrderLoop(self, node):</span><br><span class="line">    if node == None:</span><br><span class="line">        return</span><br><span class="line">    stack =[]</span><br><span class="line">    stack.append(node)</span><br><span class="line">    pre = None</span><br><span class="line">    while stack!=[]:</span><br><span class="line">        node = stack[-1]</span><br><span class="line">        if ((node.left==None and node.right==None) or</span><br><span class="line">                (pre and (pre == node.left or pre ==node.right))):</span><br><span class="line">            print(node.val)</span><br><span class="line">            pre = node</span><br><span class="line">            stack.pop()</span><br><span class="line">        else:</span><br><span class="line">            if node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            if node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">#output:3 4 7 1 3 5 2 4 6 11 18</span><br></pre></td></tr></table></figure><h1 id="1-6-层序遍历"><a href="#1-6-层序遍历" class="headerlink" title="1.6 层序遍历"></a>1.6 层序遍历</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def LevelOrder(self, node):</span><br><span class="line">    if node == None:</span><br><span class="line">        return</span><br><span class="line">    stack = []</span><br><span class="line">    stack.append(node)</span><br><span class="line">    while stack!=[]:</span><br><span class="line">        node = stack[0]</span><br><span class="line">        if node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">        if node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        print(node.val)</span><br><span class="line">        stack.pop(0)</span><br><span class="line">output: 18 7 11 3 4 5 6 1 3 2 4</span><br></pre></td></tr></table></figure><h1 id="1-7-计算节点数"><a href="#1-7-计算节点数" class="headerlink" title="1.7 计算节点数"></a>1.7 计算节点数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#递归版本</span><br><span class="line">def CountNode(self, root):</span><br><span class="line">    if root == None:</span><br><span class="line">        return 0</span><br><span class="line">    return self.CountNode(root.left) + self.CountNode(root.right) + 1</span><br><span class="line">#非递归版本</span><br><span class="line">def CountNodeNotRev(self, root):</span><br><span class="line">    if root == None:</span><br><span class="line">        return 0</span><br><span class="line">    stack = []</span><br><span class="line">    stack.append(root)</span><br><span class="line">    index = 0</span><br><span class="line">    while index&lt;len(stack):</span><br><span class="line">        if stack[index].left:</span><br><span class="line">            stack.append(stack[index].left)</span><br><span class="line">        if stack[index].right:</span><br><span class="line">            stack.append(stack[index].right)</span><br><span class="line">        index += 1</span><br><span class="line">    print(len(stack))</span><br><span class="line">output: 11</span><br></pre></td></tr></table></figure><h1 id="1-8-计算树的深度"><a href="#1-8-计算树的深度" class="headerlink" title="1.8 计算树的深度"></a>1.8 计算树的深度</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def getTreeDepth(self, root):</span><br><span class="line">    if root == None:</span><br><span class="line">        return 0</span><br><span class="line">    left = self.getTreeDepth(root.left) + 1</span><br><span class="line">    right = self.getTreeDepth(root.right) + 1</span><br><span class="line">    return left if left&gt;right else right</span><br></pre></td></tr></table></figure><h1 id="1-9-计算树的叶子树"><a href="#1-9-计算树的叶子树" class="headerlink" title="1.9 计算树的叶子树"></a>1.9 计算树的叶子树</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def countLeaves(self, root):</span><br><span class="line">    if root == None:</span><br><span class="line">        return 0</span><br><span class="line">    if root.left==None and root.right==None:</span><br><span class="line">        return 1</span><br><span class="line">    return self.countLeaves(root.left)+self.countLeaves(root.right)</span><br></pre></td></tr></table></figure><h1 id="1-10-获取第K层节点数"><a href="#1-10-获取第K层节点数" class="headerlink" title="1.10 获取第K层节点数"></a>1.10 获取第K层节点数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def getKLevel(self, root, K):</span><br><span class="line">    if root == None: return 0</span><br><span class="line">    if K == 1: return 1</span><br><span class="line">    return self.getKLevel(root.left, K-1)+self.getKLevel(root.right, K-1)</span><br></pre></td></tr></table></figure><h1 id="1-11-判断两颗二叉树是否相同"><a href="#1-11-判断两颗二叉树是否相同" class="headerlink" title="1.11 判断两颗二叉树是否相同"></a>1.11 判断两颗二叉树是否相同</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def StrucCmp(self, root1, root2):</span><br><span class="line">    if root1 == None and root2 == None: return True</span><br><span class="line">    elif root1 ==None or root2 == None: return False</span><br><span class="line">    return self.StrucCmp(root1.left, root2.left) and self.StrucCmp(root1.right, root2.right)</span><br></pre></td></tr></table></figure><h1 id="1-12-二叉树的镜像"><a href="#1-12-二叉树的镜像" class="headerlink" title="1.12 二叉树的镜像"></a>1.12 二叉树的镜像</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def Mirror(self, root):</span><br><span class="line">    if root == None: return</span><br><span class="line">    tmp = root.left</span><br><span class="line">    root.left = root.right</span><br><span class="line">    root.right = tmp</span><br><span class="line">    self.Mirror(root.left)</span><br><span class="line">    self.Mirror(root.right)</span><br></pre></td></tr></table></figure><h1 id="1-13-找最低公共祖先节点"><a href="#1-13-找最低公共祖先节点" class="headerlink" title="1.13 找最低公共祖先节点"></a>1.13 找最低公共祖先节点</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def findLCA(self, root, node1, node2):</span><br><span class="line">    if root == None: return</span><br><span class="line">    if root == node1 or root == node2: return root</span><br><span class="line">    left = self.findLCA(root.left, node1, node2)</span><br><span class="line">    right = self.findLCA(root.right, node1, node2)</span><br><span class="line">    if left and right:</span><br><span class="line">        return root</span><br><span class="line">    return left if left else right</span><br></pre></td></tr></table></figure><h1 id="1-14-获取两个节点的距离"><a href="#1-14-获取两个节点的距离" class="headerlink" title="1.14 获取两个节点的距离"></a>1.14 获取两个节点的距离</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def getDist(self, root, node1, node2):</span><br><span class="line">    lca = self.findLCA(root, node1, node2) #找最低公共祖宗节点</span><br><span class="line">    level1 = self.FindLevel(lca, node1) #祖节点到两个节点的距离</span><br><span class="line">    level2 = self.FindLevel(lca, node2)</span><br><span class="line">    return level1+level2</span><br><span class="line">def FindLevel(self, node, target):</span><br><span class="line">    if node == None: return -1</span><br><span class="line">    if node == target: return 0</span><br><span class="line">    level = self.FindLevel(node.left, target)</span><br><span class="line">    if level == -1: level = self.FindLevel(node.right, target)</span><br><span class="line">    if level != -1: return level + 1</span><br><span class="line">    return -1</span><br></pre></td></tr></table></figure><h1 id="1-20-找一个节点的所有祖宗节点"><a href="#1-20-找一个节点的所有祖宗节点" class="headerlink" title="1.20 找一个节点的所有祖宗节点"></a>1.20 找一个节点的所有祖宗节点</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def findAllAncestor(self, root, target):</span><br><span class="line">    if root == None: return False</span><br><span class="line">    if root == target: return True</span><br><span class="line">    if self.findAllAncestor(root.left, target) or self.findAllAncestor(root.right, target):</span><br><span class="line">        print(root.val)</span><br><span class="line">        return True</span><br><span class="line">    return False</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树的最全总结，常考题型，持续更新&lt;br&gt;&lt;strong&gt;二叉树的递归思想很重要，还有递归的复杂度分析&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Data Structure" scheme="https://dlc1994.github.io/categories/Algorithm-and-Data-Structure/"/>
    
    
      <category term="Python" scheme="https://dlc1994.github.io/tags/Python/"/>
    
      <category term="Binary Tree" scheme="https://dlc1994.github.io/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>Linear Regression</title>
    <link href="https://dlc1994.github.io/2018/11/28/ck813u1hy000bkkunu1nzkb06/"/>
    <id>https://dlc1994.github.io/2018/11/28/ck813u1hy000bkkunu1nzkb06/</id>
    <published>2018-11-28T12:23:52.000Z</published>
    <updated>2020-03-21T04:03:37.702Z</updated>
    
    <content type="html"><![CDATA[<p>  就从最简单的线性回归模型（Linear Regression model）开始学习吧。<br>  <a id="more"></a><br>  从这个模型的名字我们可以看出，因变量和变量之间的关系是线性的，预测值可以通过计算输入特征的权重给出：</p><script type="math/tex; mode=display">\hat{y} = \theta_0+\theta_1x_1+\theta_2x_2+...+\theta_nx_n</script><p>其中，$\hat{y}$是预测值，$n$是特征数量，$\theta_0$是bias，$x_i$是第$i$个特征值，$\theta_j$是第$j$个特征的模型参数。如果获取了模型的所有参数，给定一个样本我们就可以用上面这个公式模型得到预测值。<br>  为了表达更简洁，一般用向量表示：</p><script type="math/tex; mode=display">\hat{y} = h_{\mathbf{\theta}}(\mathbf{x}) = \mathbf{\theta}^T \mathbf{x}</script><p>其中$h_{\mathbf{\theta}}()$是hypothesis function是关于$\mathbf{\theta}$的假设函数，$\mathbf{\theta} = [\theta_0;\theta_1;…;\theta_n]$，$\mathbf{x} = [x_0, x_1, x_2, …, x_n]$并且$x_0=1$。<br>  我们的目标当然是想要所有预测值都跟实际值相等，因此，目标函数或者称代价函数建模为：</p><script type="math/tex; mode=display">\text{MSE}(\mathbf{X},h_{\mathbf{\theta}}) = \frac{1}{m}\sum_{i=1}^{m}\left(\mathbf{\theta}^T\cdot\mathbf{x}^{(i)}-y^{(i)}\right)^2</script><p>其中$\mathbf{X}$为所有样本的集合，数量为$m$。</p><h1 id="标准闭式解"><a href="#标准闭式解" class="headerlink" title="标准闭式解"></a>标准闭式解</h1><p>  基于均方误差最小化来进行模型求解的方法称为“最小二乘法”（least square method）。在线性回归中，最小二乘法就是试图找到一条直线，使所有样本到直线上的欧氏距离之和最小。<br>  一般地，我们利用最小二乘法对$\mathbf{\theta}$进行估计。数据集$\mathbf{X}$表示为：</p><script type="math/tex; mode=display">\mathbf{X}=\left(\begin{array}{ccc}       1 & x_{11} & x_{12} &  \cdots\  & x_{1d}\\      1 & x_{21} & x_{22} &  \cdots\  & x_{23} \\     \vdots & \vdots & \vdots & \ddots & \vdots\\    1 & x_{m1} & x_{m2} &  \cdots\  & x_{md}\\   \end{array}\right)=\left(\begin{array}{ccc}       1 & \mathbf{x}_1^T \\      1 & \mathbf{x}_2^T \\     \vdots & \vdots \\    1 & \mathbf{x}_m^T \\   \end{array}\right)</script><p>  然后把实际值也写成向量模式$\mathbf{y}=(y_1;y_2;…;y_m)$，因此优化问题为：</p><script type="math/tex; mode=display">\mathbf{\theta}^*=\underset{\mathbf{\theta}}{\text{arg}\min}(\mathbf{y}-\mathbf{\theta}^T\mathbf{X})^T(\mathbf{y}-\mathbf{\theta}^T\mathbf{X})</script><p>  令$E_{\mathbf{\theta}}=(\mathbf{y}-\mathbf{\theta}^T\mathbf{X})^T(\mathbf{y}-\mathbf{\theta}^T\mathbf{X})$，对$\mathbf{\theta}$求导可得：</p><script type="math/tex; mode=display">\frac{\partial E_{\mathbf{\theta}}}{\partial \mathbf{\theta}}=2\mathbf{X}^T(\mathbf{\theta}^T\mathbf{X}-\mathbf{y})</script><p>  令上式等于0可解得</p><script type="math/tex; mode=display">\mathbf{\theta}^*=(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{y}</script><p>  如果$\mathbf{X}^T\mathbf{X}$不可逆怎么办，这可能是由于矩阵中存在冗余特征，在线性代数里说明矩阵并非线性不相关，因此可以删除多余特征；也有可能是由于特征数大于等于样本数，也就是$m \le n$，可以通过删除一些特征或者使用正则化（regularization，后续介绍）。<br>  给出python一个实现例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line"></span><br><span class="line">X = 2 * np.random.rand(100, 1)</span><br><span class="line">y = 2 + 6 * X + np.random.randn(100, 1)</span><br><span class="line"></span><br><span class="line">X_b = np.c_[np.ones((100, 1)), X] # add x0 = 1 to each instance</span><br><span class="line">theta_best = np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(y)</span><br><span class="line">print(theta_best)</span><br><span class="line"># [[1.74568681] [6.27246194]]</span><br><span class="line"></span><br><span class="line">X_new = np.array([[0], [2]])</span><br><span class="line">X_new_b = np.c_[np.ones((2, 1)), X_new] # add x0 = 1 to each instance</span><br><span class="line">y_predict = X_new_b.dot(theta_best)</span><br><span class="line">print(y_predict) #[[ 1.74568681] [14.29061069]]</span><br><span class="line"></span><br><span class="line">plt.plot(X_new, y_predict, &quot;r-&quot;)</span><br><span class="line">plt.plot(X, y, &quot;b.&quot;)</span><br><span class="line">plt.axis([0, 2, 0, 15])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2018/11/28/ck813u1hy000bkkunu1nzkb06/1.png" alt="Linear Regression"><br>  如果用sklearn实现的话，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.linear_model import LinearRegression</span><br><span class="line">&gt;&gt;&gt; lin_reg = LinearRegression()</span><br><span class="line">&gt;&gt;&gt; lin_reg.fit(X, y)</span><br><span class="line">&gt;&gt;&gt; lin_reg.intercept_, lin_reg.coef_</span><br><span class="line">(array([ 4.21509616]), array([[ 2.77011339]]))</span><br><span class="line">&gt;&gt;&gt; lin_reg.predict(X_new)</span><br><span class="line">array([[ 4.21509616],</span><br><span class="line">[ 9.75532293]])</span><br></pre></td></tr></table></figure></p><p>  这种方式实现的计算复杂度只要在矩阵求逆上，对于一个$n \times n$的矩阵，求逆复杂度大约是$O(n^{2.4})$到$O(n^{3})$，当特征数量很大时（比如100,000以上时），标准闭式解会变得很慢；另一方面，对于样本数量其复杂度是$O(m)$，也就是线性的；此外，模型训练完成后，预测的复杂度对于样本数量和特征数量复杂度都很快。</p><h1 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h1><p>  梯度下降法是十分常用的优化算法，目的是通过迭代过程不断更新参数进而最小化代价函数，每次优化的方向都是斜率绝对值最大的方向。<br><strong>Note：</strong></p><ul><li>需要谨慎选择步长（step size）或者叫做学习率（learning rate），太小的话，需要许多次迭代才能走到最优点，而步子太大，则有可能跨过最优点，然后陷入震荡。</li><li>凸优化问题找到最优点比较容易，而非凸问题则容易陷入局部最优点或者陷入平台（plateau)。线性回归问题是个凸优化问题。</li><li>最好在使用梯度下降法前对数据进行标准化处理，不然“碗”太长需要更多的迭代次数。</li><li>问题参数越多，维度越大，参数空间越大，搜索最优解也就越难。</li></ul><h2 id="Batch-Gradient-Descent"><a href="#Batch-Gradient-Descent" class="headerlink" title="Batch Gradient Descent"></a>Batch Gradient Descent</h2><p>  Batch是批的意思，批梯度下降就是在每次迭代过程中把所有数据都来计算代价函数的偏导，也就是梯度。代价函数对于参数$\theta_j$的偏导为：</p><script type="math/tex; mode=display">\frac{\partial \text{MSE}(\theta)}{\partial{\theta}_j}=\frac{2}{m}\sum_{i=1}^{m}\left(\theta^T \cdot \mathbf{x}^{(i)}-y^{(i)}\right)x_j^{(i)}</script><p>  用向量来表示梯度下降为：</p><script type="math/tex; mode=display">\nabla_{\theta}\text{MSE}(\theta)=\left(\begin{array}{ccc}\frac{\partial \text{MSE}(\theta)}{\partial \theta_0}\\\frac{\partial \text{MSE}(\theta)}{\partial \theta_1}\\\vdots\\\frac{\partial \text{MSE}(\theta)}{\partial \theta_0}\end{array}\right)=\frac{2}{m}\mathbf{X}^T\cdot(\mathbf{X}\cdot \theta-\mathbf{y})</script><p>  由此，我们可以得到梯度下降的步骤：</p><script type="math/tex; mode=display">\theta^{(n+1)} = \theta^{(n)}-\eta \nabla_{\theta}\text{MSE}(\theta)</script><p>  推导出这个公式之后就可以实现了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">eta = 0.1 # learning rate</span><br><span class="line">n_iterations = 1000</span><br><span class="line">m = 100</span><br><span class="line">theta = np.random.randn(2,1) # random initialization</span><br><span class="line">for iteration in range(n_iterations):</span><br><span class="line">gradients = 2/m * X_b.T.dot(X_b.dot(theta) - y)</span><br><span class="line">theta = theta - eta * gradients</span><br></pre></td></tr></table></figure></p><h2 id="Stochastic-Gradient-Descent"><a href="#Stochastic-Gradient-Descent" class="headerlink" title="Stochastic Gradient Descent"></a>Stochastic Gradient Descent</h2><p>  在前面讲过，BGD在每次迭代中是把所有数据都用于计算的，因此当数据量很大时，算法会变得难以忍受的慢，因此需要使用其他梯度下降算法。随机梯度下降法跟批梯度下降是两个极端，SGD在每次迭代中会随机从训练集中选择一个样本，然后只用这个样本计算并更新梯度。因此，这个算法计算比BGD快很多很多；但也由于其随机特性，优化曲线不会“直接”向着最优点前进，而是来回波动，但最终会抵达最优值附近。其算法如下图所示：<br><img src="/2018/11/28/ck813u1hy000bkkunu1nzkb06/2.jpg" alt="SGD"><br>  Python实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n_epochs = 50</span><br><span class="line">t0, t1 = 5, 50 # learning schedule hyperparameters</span><br><span class="line">def learning_schedule(t):</span><br><span class="line">return t0 / (t + t1)</span><br><span class="line">theta = np.random.randn(2,1) # random initialization</span><br><span class="line">for epoch in range(n_epochs):</span><br><span class="line">for i in range(m):</span><br><span class="line">random_index = np.random.randint(m)</span><br><span class="line">xi = X_b[random_index:random_index+1]</span><br><span class="line">        yi = y[random_index:random_index+1]</span><br><span class="line">        gradients = 2 * xi.T.dot(xi.dot(theta) - yi)</span><br><span class="line">        eta = learning_schedule(epoch * m + i)</span><br><span class="line">        theta = theta - eta * gradients</span><br><span class="line">print(theta)</span><br></pre></td></tr></table></figure></p><p>  如果用sklearn来实现的话，代码就简单多了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.linear_model import SGDRegressor</span><br><span class="line">sgd_reg = SGDRegressor(n_iter=50, penalty=None, eta0=0.1)</span><br><span class="line">sgd_reg.fit(X, y.ravel())</span><br><span class="line">print(sgd_reg.intercept_, sgd_reg.coef_)</span><br></pre></td></tr></table></figure></p><p><strong>NOTE:</strong> epoch是指把所有数据样本都遍历一遍，iteration表示更新一次参数，batch则是指数据样本的大小，在SGD中，iteration=batch=1，epoch=num_X/batch</p><h2 id="Mini-batch-Gradient-Descent"><a href="#Mini-batch-Gradient-Descent" class="headerlink" title="Mini-batch Gradient Descent"></a>Mini-batch Gradient Descent</h2><p>  Mini-batch GD介于SGD和BGD之间，也就是每次用来更新参数的样本不是一也不是所有（吴恩达说在2-400之间，他倾向于用10），它吸收了BGD和SGD的优缺点的折中，收敛更快，随机性较小，但也难抵达最优值，其算法流程如下图所示：</p><p><img src="/2018/11/28/ck813u1hy000bkkunu1nzkb06/3.jpg" alt="Mini-batch GD"></p><p>  这里介绍的标准闭式解只适用于线性回归问题，但梯度下降法可以用来训练许多模型，在深度学习中也有广泛应用，将他们比较如下：</p><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Large m</th><th>Out-of-core Support</th><th>Large n</th><th>Hyperparameters</th><th>Scaling Required</th><th>Sklearn</th></tr></thead><tbody><tr><td>Normal Equation</td><td>Fast</td><td>No</td><td>Slow</td><td>0</td><td>No</td><td>LinearRegression</td></tr><tr><td>Batch GD</td><td>Slow</td><td>No</td><td>Fast</td><td>2</td><td>Yes</td><td>n/a</td></tr><tr><td>Stochastic GD</td><td>Fast</td><td>Yes</td><td>Fast</td><td>$\ge$2</td><td>Yes</td><td>SGDRegressor</td></tr><tr><td>Mini-batch GD</td><td>Fast</td><td>Yes</td><td>Fast</td><td>$\ge $2</td><td>Yes</td><td>n/a</td></tr></tbody></table></div><h2 id="Polynomial-Regression"><a href="#Polynomial-Regression" class="headerlink" title="Polynomial Regression"></a>Polynomial Regression</h2><p>  如果数据并非一条直线呢，那么还可以用线性模型吗？实际上是可以的，主要方法就是把一个特征拓展成多维的，比如$x^2, x^3,…, x^k$，然后将其作为另一个维度的特征，比如$x_1 = x, x_2 = x^2$，那么就可以用线性模型按照上面的方法进行训练了，用sklearn实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from sklearn.preprocessing import PolynomialFeatures</span><br><span class="line">from sklearn.linear_model import LinearRegression</span><br><span class="line"></span><br><span class="line">m = 100</span><br><span class="line">X = 6 * np.random.rand(m, 1) - 3</span><br><span class="line">y = 1 * X**2 + X + 2 + np.random.randn(m, 1)</span><br><span class="line">plt.scatter(X, y)</span><br><span class="line"></span><br><span class="line">poly_features = PolynomialFeatures(degree=2, include_bias=False)</span><br><span class="line">X_poly = poly_features.fit_transform(X)</span><br><span class="line">lin_reg = LinearRegression()</span><br><span class="line">lin_reg.fit(X_poly, y)</span><br><span class="line">print(lin_reg.intercept_, lin_reg.coef_)</span><br><span class="line">xx = np.array((range(-3, 4)))</span><br><span class="line">print(xx)</span><br><span class="line">yy = xx*0.98134428+xx*xx*0.94365742+1.94555083</span><br><span class="line">plt.plot(xx, yy, c=&apos;r&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2018/11/28/ck813u1hy000bkkunu1nzkb06/4.png" alt="Polynomial Regression"><br>  此外，需要注意，<code>PolynomialFeatures(degree=d)</code>会把一个包含n个特征的矩阵转化为包含$\frac{(n+d)!}{d!n!}$个特征的矩阵，即如果对于两个特征a和b，令degree=3，那么特征不仅有$a^2$，$a^3$，$b^2$，$b^3$，还会有$ab$，$a^2b$和$ab^2$.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  就从最简单的线性回归模型（Linear Regression model）开始学习吧。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="https://dlc1994.github.io/categories/Machine-Learning/"/>
    
    
      <category term="Python" scheme="https://dlc1994.github.io/tags/Python/"/>
    
      <category term="Linear Regression" scheme="https://dlc1994.github.io/tags/Linear-Regression/"/>
    
      <category term="Polynomial Regression" scheme="https://dlc1994.github.io/tags/Polynomial-Regression/"/>
    
      <category term="Gradient Decent Methods" scheme="https://dlc1994.github.io/tags/Gradient-Decent-Methods/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to Machine Learning</title>
    <link href="https://dlc1994.github.io/2018/11/28/ck813u1hr0007kkun5280c890/"/>
    <id>https://dlc1994.github.io/2018/11/28/ck813u1hr0007kkun5280c890/</id>
    <published>2018-11-28T12:13:53.000Z</published>
    <updated>2020-03-21T04:01:10.618Z</updated>
    
    <content type="html"><![CDATA[<p>  做了与机器学习相关的项目好久了，但对机器学习一直没有一个系统的认识，导致在切入一些新的领域时力有不逮，总感觉理解有偏差或者理解困难，因此想系统地、详细地学习机器学习，就从周志华的西瓜书和Andrew Ng的机器学习视频开始吧。<br><a id="more"></a><br>  众所周知， 机器学习是研究计算机怎样模拟或实现人类的学习行为，以获取新是研究计算机怎样模拟或实现人类的学习行为。<br>  来自卡内基梅隆大学的Tom Mitchell提出的关于机器学习的定义较为人所接受，他定义的机器学习是，一个程序被认为能从经验E中学习，解决任务T，达到性能度量值P，当且仅当，有了经验E后，经过P评判，程序在处理T时的性能有所提升。<br>  一般而言，我把机器学习分为<strong>监督学习</strong>、<strong>无监督学习</strong>和<strong>增强学习</strong>，而深度学习和大数据是拓展也是紧密的关联，如下图所示：<br><img src="/2018/11/28/ck813u1hr0007kkun5280c890/1.jpg" alt="classification"><br>  监督学习，顾名思义，就是有人指导你，告诉你这个学习正确与否。专业点来讲，就是数据集中每个样本都会带有一个正确答案，比如在西瓜分类里，“红瓤，有蒂”带有标签“甜”，“黄瓤，无蒂”带有标签“不甜”；在回归里，房价预测里每个样本都带有房价。<strong>分类和回归的区别在于预测的是一组离散的结果，而回归可以预测连续的输出。</strong><br><img src="/2018/11/28/ck813u1hr0007kkun5280c890/2.jpg" alt="Supervisedlearning and Unsupervisedlearning"><br>  无监督学习，从上图可以看出，我们事先不知道样本是哪一类或者是哪一个值，也就是没有任何的标签或“答案”。一个比较著名的例子就是鸡尾酒宴问题：许多人坐在一起参加鸡尾酒会，大家都在同一时间说话，声音此起彼伏，重重叠叠，要想分离出不同人说话的声音，就是一个聚类问题，也是无监督学习问题。这个例子可能比较难懂，再说一个就是在无线通信中，有时会根据用户的行为特征对用户进行分类，便于进行一些资源的调度和统一管理，而如何判断一堆用户里哪些用户是类似的，比如上班族、学生党、旅客等，这就是一个典型的聚类问题。<br>  增强学习则是要解决这样的问题，一个能感知环境的自治agent，怎样通过学习选择能达到其目标的最优动作。当agent（机器人，下棋，在无线领域则可以是用户、基站和operator）在环境中作出某个动作时，会产生不同的奖励值或者惩罚值，agent的任务就是从这个非直接的，有延迟的回报中学习，以便后续的动作产生最大的累积效应。<br><img src="/2018/11/28/ck813u1hr0007kkun5280c890/3.jpg" alt="Reinforcementlearning"><br>  在后续的文章中，我们会对各个算法有比较详细的学习过程，敬请期待啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  做了与机器学习相关的项目好久了，但对机器学习一直没有一个系统的认识，导致在切入一些新的领域时力有不逮，总感觉理解有偏差或者理解困难，因此想系统地、详细地学习机器学习，就从周志华的西瓜书和Andrew Ng的机器学习视频开始吧。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="https://dlc1994.github.io/categories/Machine-Learning/"/>
    
    
      <category term="Python" scheme="https://dlc1994.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Solutions</title>
    <link href="https://dlc1994.github.io/2018/07/30/ck813u1hx000akkun04we40xl/"/>
    <id>https://dlc1994.github.io/2018/07/30/ck813u1hx000akkun04we40xl/</id>
    <published>2018-07-30T04:50:07.000Z</published>
    <updated>2020-01-09T01:14:23.402Z</updated>
    
    <content type="html"><![CDATA[<p>Here are my solutions to the LeetCode problems, linking to my <a href="https://github.com/dlc1994">Github</a> repository:<br><a id="more"></a></p><h1 id="EASY"><a href="#EASY" class="headerlink" title="EASY"></a>EASY</h1><ul><li><a href="https://github.com/dlc1994/LeetCode/blob/master/twoSums.py">Leetcode 1   Two Sum</a> </li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/PalindromeNumber.py">Leetcode 9   Palindrome Number</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/leetcode13%20roman2integer.py">Leetcode 13  roman2integer</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/longestCommonPrefix.py">Leetcode 14  longestcommonprefix</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/validParenthese.py">Leetcode 20  valid parentheses</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/leetcode21%20merge2sortedlist.py">Leetcode 21  merge2sortedlist</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/hamming.py">Leetcode 461 Hamming Distance</a> </li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/lowerCase.py">Leetcode 709 To Lower Case</a> </li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/JewerAndStones.py">Leetcode 771 Jewels and Stones</a> </li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/MorseCode.py">Leetcode 804 Unique Morse Code Words</a> </li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/circle.py">Circle</a> </li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/flipping%20image.py">Leetcode 832 Flipping an Image</a> </li></ul><h1 id="MEDIUM"><a href="#MEDIUM" class="headerlink" title="MEDIUM"></a>MEDIUM</h1><ul><li><a href="https://github.com/dlc1994/LeetCode/blob/master/leecode12%20int2roman.py">Leetcode 12  int2roman</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/leetcode21%20merge2sortedlist.py">Leetcode 21  merge2sortedlist</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/leetcode22%20generateParentheses.py">Leetcode 22  generateParentheses</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/leetcode%2029%20%20DivideTwoIntegers.py">Leetcode 29  DivideTwoIntegers</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/leetcode%2033%20%20SearchInRotatedSortedArray.py">Leetcode 33  SearchInRotatedSortedArray</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/leetcode%2034%20%20FindFirstAndLastPositionInSortedArray.py">Leetcode 34  FindFirstAndLastPositionInSortedArray</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/leetcode%2036%20%20ValidSudoku.py">Leetcode 36  SearchInRotatedSortedArray</a></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/LongestPalindSubstring.py">Leetcode 516 LongestPalindSubstring</a><h1 id="HARD"><a href="#HARD" class="headerlink" title="HARD"></a>HARD</h1></li><li><a href="https://github.com/dlc1994/LeetCode/blob/master/leetcode23%20mergeKsortedlist.py">Leetcode 23  mergeKsortedlists</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Here are my solutions to the LeetCode problems, linking to my &lt;a href=&quot;https://github.com/dlc1994&quot;&gt;Github&lt;/a&gt; repository:&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://dlc1994.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://dlc1994.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://dlc1994.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Water Filling Algorithm and Matlab Simulation</title>
    <link href="https://dlc1994.github.io/2018/07/18/ck813u1i1000dkkun3byyamrz/"/>
    <id>https://dlc1994.github.io/2018/07/18/ck813u1i1000dkkun3byyamrz/</id>
    <published>2018-07-18T15:33:07.000Z</published>
    <updated>2020-03-21T04:04:10.283Z</updated>
    
    <content type="html"><![CDATA[<p><strong>注水算法</strong>是根据某种准则，并根据信道状况对发送功率进行自适应分配，通常是信道状况好的时刻，多分配功率，信道差的时候，少分配功率，从而最大化传输速率。<br><a id="more"></a><br>当接收端完全已知CSI（信道状态信息）而发送端未知CSI时，发送天线阵列中的功率平均分配是合理的。</p><p><strong>实现功率的“注水”分配，发送端必须知道CSI。</strong></p><p>直观而言，就如下图所示：</p><p><img src="/2018/07/18/ck813u1i1000dkkun3byyamrz/1.png" alt="water filling"></p><p>图1 注水原理示意图（白色平台越高代表信道条件越差，注入的水就越少）</p><p>注水原理可以建模为下述优化问题：</p><script type="math/tex; mode=display">\begin{align}  & \underset{P_1,P_2,...,P_N}{\mathop{\max }}\,\text{          }{C_{sum}}=\sum_{n=1}^{N}{\log \left( 1+\frac{P_n{\left| {h_n} \right|}^2}{N_0} \right)}  \\ & \text{subject to      }\sum_{n=1}^{N}{P_n}={P}_{sum},n=1,2,...,N \\end{align}</script><p>其中${C}_{sum}$表示系统总信道容量，$N$为信道数，${P}_{n}$为第$n$个信道的功率，${h}_{n}$为第$n$个信道的信道增益，${N}_{0}$为噪声功率谱密度，${P}_{sum}$为传输总功率，也就是总水量。</p><p>该优化问题为凸优化问题，可以用拉格朗日乘数法求得全局最优解。</p><script type="math/tex; mode=display">\mathcal{L}(\lambda ,{P_1},{P_2},...,{P_N})=\sum_{n=1}^{N}{\log \left( 1+\frac{P_n{\left| {h_n} \right|}^2}{N_0} \right)}+\lambda (\sum_{n=1}^{N}{P_n}-P_{sum})</script><p>令$\frac{\partial \mathcal{L} }{\partial P_n}=\frac{\partial \mathcal{L} }{\partial \lambda }=0$，解得<strong>最优功率分配方案</strong>为：</p><script type="math/tex; mode=display">P_{n}^{*}={\left( \frac{1}{\lambda }-\frac{N_0}{\left| {h}_{n} \right|}^{2} \right)}^{+}</script><p>其中${(\centerdot )}^{+}$表示取值非负。</p><p><strong>MATLAB实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">clear all;</span><br><span class="line">channel_n=10;                         %channel number</span><br><span class="line">M=[5,10,20,50];                        %transmitted power</span><br><span class="line">N0=0.5;          </span><br><span class="line">h_1= random(&apos;rayleigh&apos;,1,1,channel_n);    %Rayleigh fading</span><br><span class="line">h_2=h_1.^2;                           %|h|.^2</span><br><span class="line">h_2_sorted=sort(h_2);                   %sort the channel gain</span><br><span class="line">h=h_2_sorted/N0;  </span><br><span class="line">syms lamda</span><br><span class="line">for m=1:length(M)</span><br><span class="line">    fprintf(&apos;transmitted power is %d watt&apos;,M(m));</span><br><span class="line">    for k=1:channel_n</span><br><span class="line">     p=zeros(1,channel_n);</span><br><span class="line">   sum=0;</span><br><span class="line">    for i=k:channel_n</span><br><span class="line">        sum=sum+(1/lamda-1/h(i));</span><br><span class="line">    end</span><br><span class="line">    f=sum-M(m);</span><br><span class="line">    x=solve(f,lamda);                    %find lamda</span><br><span class="line">    if k==1</span><br><span class="line">        if vpa(x)&gt;0 &amp;&amp; vpa(x)&lt;h(k)</span><br><span class="line">        for i=k:channel_n</span><br><span class="line">            p(i)=1/x-1/h(i);              %allocate power</span><br><span class="line">            capacity=capacity+log2(1+p(i)*h(i));%compute the capacity</span><br><span class="line">        end</span><br><span class="line">         p(i)=vpa(p(i),3)  </span><br><span class="line">         capacity=vpa(capacity,3)</span><br><span class="line">        end</span><br><span class="line">    else </span><br><span class="line">        if vpa(x)&gt;h(k-1) &amp;&amp; vpa(x)&lt;h(k)</span><br><span class="line">            capacity=0;</span><br><span class="line">        for i=k:channel_n</span><br><span class="line">            p(i)=1/x-1/h(i);               %allocate power</span><br><span class="line">            capacity=capacity+log2(1+p(i)*h(i)); %compute the capacity</span><br><span class="line">        end</span><br><span class="line">        p(i)=vpa(p(i),3)   </span><br><span class="line">        capacity=vpa(capacity,3)</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;注水算法&lt;/strong&gt;是根据某种准则，并根据信道状况对发送功率进行自适应分配，通常是信道状况好的时刻，多分配功率，信道差的时候，少分配功率，从而最大化传输速率。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Wireless Communications" scheme="https://dlc1994.github.io/categories/Wireless-Communications/"/>
    
    
      <category term="Algorithms" scheme="https://dlc1994.github.io/tags/Algorithms/"/>
    
      <category term="Matlab" scheme="https://dlc1994.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>How to Make a Visual Mark Up and Revision of Significant Differences between Two Latex Files by Latexdiff</title>
    <link href="https://dlc1994.github.io/2018/06/19/ck813u1hv0009kkun4dlsc8lm/"/>
    <id>https://dlc1994.github.io/2018/06/19/ck813u1hv0009kkun4dlsc8lm/</id>
    <published>2018-06-19T15:34:10.000Z</published>
    <updated>2020-03-21T04:02:10.399Z</updated>
    
    <content type="html"><![CDATA[<p>Recently my survey was rejected and required minor revision, while I have to submit a revised article with the “editing mode” feature turned on. Because I use Miktex+Texstudio to edit my paper in windows 10, <code>Latexdiff</code> is considered of course.<br><a id="more"></a></p><blockquote><p><code>Latexdiff</code> is a Perl script for visual mark up and revision of significant differences between two LATEX files. Various options are available for visual mark up using standard LATEX packages such as <u>color</u>. Changes not di­rectly af­fect­ing vis­i­ble text, for ex­am­ple in for­mat­ting com­mands, are still marked in the LATEX source. A rudi­men­tary re­vi­sion fa­cilil­ity is pro­vided by an­other Perl script, la­texre­vise, which ac­cepts or re­jects all changes. Man­ual edit­ing of the dif­fer­ence file can be used to over­ride this de­fault be­haviour and ac­cept or re­ject se­lected changes only. </p></blockquote><h2 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1:"></a>Step 1:</h2><p>For a pure rookie, first of all, you need to install <a href="http://www.ctex.org/CTeXDownload/">CTEX</a> (for Chinese users) or <a href="https://miktex.org/download">Miktex</a>. </p><h2 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2:"></a>Step 2:</h2><p>Then, <code>win+R</code> and open <code>cmd</code>, input command <code>latexdiff</code>, if returns</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 and only 2 non-option arguments required. Write latexdiff -h to get help</span><br></pre></td></tr></table></figure><p>Congrats! You have successfully installed <code>latexdiff</code> and you can turn to <strong>Step 3.3</strong>.</p><h2 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3:"></a>Step 3:</h2><p>Otherwise, don’t worry, I encountered the same situation as you. Do as follows.</p><h3 id="3-1-Install-Latexdiff-Package"><a href="#3-1-Install-Latexdiff-Package" class="headerlink" title="3.1 Install Latexdiff Package"></a>3.1 Install <code>Latexdiff</code> Package</h3><p>After you install a Tex, open <code>Start Menu-&gt;Ctex or Miktex-&gt;Package Manager (Admin)</code>.</p><p>Search <code>Latexdiff</code> in column <code>Name:</code> as follows</p><p><img src="/2018/06/19/ck813u1hv0009kkun4dlsc8lm/3.png" alt="Install latexdiff"></p><p>Click the <code>+</code> button and install it.</p><h3 id="3-2-Install-Perl"><a href="#3-2-Install-Perl" class="headerlink" title="3.2 Install Perl"></a>3.2 Install <code>Perl</code></h3><p><code>Latexdiff</code> is a <code>Perl</code> script, so you can go to <a href="https://www.perl.org/get.html">Perl</a> download corresponding version in your computer. Technically, <code>ActivePerl</code> and <code>StrawberryPerl</code> is both ok. </p><p>Same steps in <strong>Step 2</strong>, if you have problem as </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">latexdiff: The Perl script could not be found.  </span><br><span class="line">latexdiff: Data: scripts/latexdiff/perl/latexdiff.pl</span><br></pre></td></tr></table></figure><p>It’s  a common problem and you can find the answer in </p><p><a href="http://blog.sina.com.cn/s/blog_3ecd13560102vh95.html">这里</a> or <a href="http://tex.stackexchange.com/questions/106785/installation-usage-of-latexdiff-on-windows-7">Here</a>.</p><p>It is worth mentioning that if you have the following problem which confused me for a long time</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">latexmk: the script engine could not be found </span><br><span class="line">latexdiff: data: scriptengine=&quot;perl.exe&quot;</span><br></pre></td></tr></table></figure><p>Actually I have no idea how I successfully solve it. You may do the trials as what I have done.</p><ol><li>Check the System Path of <code>Perl</code> and <code>Tex</code>, especially according to <code>x86</code> or <code>x64</code></li><li>Reinstall <code>Perl</code>, if not work, change to <code>ActivePerl</code> or <code>StrawberryPerl</code></li><li>Restart your windows after you make some changes</li></ol><h3 id="3-3-Latexdiff"><a href="#3-3-Latexdiff" class="headerlink" title="3.3 Latexdiff"></a>3.3 <code>Latexdiff</code></h3><p>Put your origin tex version (e.g., <code>old.tex</code>) and your modified tex version (e.g., <code>new.tex</code>) in a same file. <code>cmd</code> to this path, and input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">latexdiff old.tex new.tex &gt;diff.tex</span><br></pre></td></tr></table></figure><p>where <code>diff.tex</code> is the editted version, add the required files to this path and compile it. Then you can have the results</p><p><img src="/2018/06/19/ck813u1hv0009kkun4dlsc8lm/2.png" alt="Final pdf"></p><p>If you encounter some errors in compiling, just google it because they are just some common LATEX errors. Enjoy.</p><p>!!!Tips: if you suffer any problem, first go to google or baidu it. </p><p><strong>Please discover the truth by yourself.</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Recently my survey was rejected and required minor revision, while I have to submit a revised article with the “editing mode” feature turned on. Because I use Miktex+Texstudio to edit my paper in windows 10, &lt;code&gt;Latexdiff&lt;/code&gt; is considered of course.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Paper Work" scheme="https://dlc1994.github.io/categories/Paper-Work/"/>
    
    
      <category term="Latex" scheme="https://dlc1994.github.io/tags/Latex/"/>
    
  </entry>
  
  <entry>
    <title>A Stupid Mistake I Made about Sorting in Python DataFrame</title>
    <link href="https://dlc1994.github.io/2018/06/12/ck813u1hg0001kkunwi0yygpr/"/>
    <id>https://dlc1994.github.io/2018/06/12/ck813u1hg0001kkunwi0yygpr/</id>
    <published>2018-06-12T02:47:31.000Z</published>
    <updated>2020-03-06T12:08:15.351Z</updated>
    
    <content type="html"><![CDATA[<p>One day when I try to sort a <code>DataFrame</code> by a column, an amazing mistake happens!<br><a id="more"></a><br>I will reproduce this stupid thing here. Firstly, make a dataframe example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   a  b  c</span><br><span class="line">0  9  4  6</span><br><span class="line">1  2  7  5</span><br><span class="line">2  5 -3  8</span><br><span class="line">3  1  2  3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(&#123;&quot;a&quot;:[9,2,5,1],&quot;b&quot;:[4,7,-3,2],&quot;c&quot;:[6,5,8,3]&#125;)</span><br><span class="line">frame.sort_values(&apos;a&apos;,inplace=True)</span><br><span class="line">print(frame)</span><br></pre></td></tr></table></figure><p>What do you think the result will be? What I expect it will get is like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   a  b  c</span><br><span class="line">3  1  2  3</span><br><span class="line">1  2  7  5</span><br><span class="line">2  5 -3  8</span><br><span class="line">0  9  4  6</span><br></pre></td></tr></table></figure><p>However, what I actually get is</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   a  b  c</span><br><span class="line">0  9  4  6</span><br><span class="line">1  2  7  5</span><br><span class="line">2  5 -3  8</span><br><span class="line">3  1  2  3</span><br></pre></td></tr></table></figure><p>I get really confused, so I try all the <em>arg</em> in function </p><blockquote><p>DataFrame.sort_values(by, axis=0, ascending=True, inplace=False, kind=’quicksort’, na_position=’last’)</p></blockquote><p>I find out that only if the <code>inplace=</code> is set to True, the result is as expected. But the usage of this function I searched in google, did not meantion this parameter.</p><p>Therefore, I look for an instruction of <code>inplace</code>， and I find that the <code>inplace</code> parameter is a generic term w.r.t pandas and not specific to <code>sort_values</code> alone. You can see it in several functions like <code>pd.fillna, pd.replace</code> etc. Whenever the <code>inplace</code> is set to True, it modifies the existing data frame and you need not assign it to a new data frame. </p><p>Ohhhh… Then I find out where the mistake really lies in. In my previous code, the DataFrame <code>frame</code> I sorted has not been modified only if the parameter <code>inplace</code> is set to True, so I modify the code as follow:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(&#123;&quot;a&quot;:[9,2,5,1],&quot;b&quot;:[4,7,-3,2],&quot;c&quot;:[6,5,8,3]&#125;)</span><br><span class="line">df = frame.sort_values(&apos;a&apos;,inplace=True)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p> The problem is solved! How stupid I was! </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;One day when I try to sort a &lt;code&gt;DataFrame&lt;/code&gt; by a column, an amazing mistake happens!&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Data Processing" scheme="https://dlc1994.github.io/categories/Data-Processing/"/>
    
    
      <category term="Python" scheme="https://dlc1994.github.io/tags/Python/"/>
    
      <category term="DataFrame" scheme="https://dlc1994.github.io/tags/DataFrame/"/>
    
      <category term="Sorting" scheme="https://dlc1994.github.io/tags/Sorting/"/>
    
  </entry>
  
  <entry>
    <title>Hexo: setup a static blog</title>
    <link href="https://dlc1994.github.io/2018/06/12/ck813u1hp0005kkun0s3zey67/"/>
    <id>https://dlc1994.github.io/2018/06/12/ck813u1hp0005kkun0s3zey67/</id>
    <published>2018-06-12T01:46:53.000Z</published>
    <updated>2020-03-21T04:00:09.575Z</updated>
    
    <content type="html"><![CDATA[<p>​    Before we start, you have to know what is the difference between <strong>static</strong> site and <strong>dynamic</strong> site. Let’s take a look at the definition in Wiki:<br><a id="more"></a></p><blockquote><p>A <strong>static web page</strong> (sometimes called a <strong>flat page/stationary page</strong>) is a <a href="https://en.wikipedia.org/wiki/Web_page">web page</a> that is delivered to the user exactly as stored, in contrast to <a href="https://en.wikipedia.org/wiki/Dynamic_web_page">dynamic web pages</a> which are generated by a <a href="https://en.wikipedia.org/wiki/Web_application">web application</a>. Consequently, a static web page displays the same information for all users, from all contexts, subject to modern capabilities of a web server to negotiate content-type or language of the document where such versions are available and the server is configured to do so. It’s pros and cons are listed as follows:</p><p> <strong>Advantages of a static website</strong></p><ul><li>Provide improved security over dynamic websites</li><li>Improved performance for end users compared to dynamic websites</li><li>Fewer or no dependencies on systems such as databases or other application servers</li></ul><p><strong>Disadvantages of a static website</strong></p><ul><li>Dynamic functionality has to be added separately</li></ul></blockquote><p>​    <strong>Dynamic site is not our topic here. I wil talk about how to deploy a hexo blog in Github repository under the environment of Window 10.</strong> </p><h1 id="1-Github-initialization"><a href="#1-Github-initialization" class="headerlink" title="1. Github initialization"></a>1. Github initialization</h1><p>​    From the very beginning, you have to create a <a href="https://github.com/">GitHub</a> account and new a repository, note that the repository name need to be the same with your owner name (the alarm is appeared cause I have already newed a same one).</p><p><img src="/2018/06/12/ck813u1hp0005kkun0s3zey67/2.jpg" alt="Create a repository"></p><p><strong>REMEMBER</strong> the repository address (two kinds of address—- <code>SSH: git@github.com:dlc1994/dlc1994.github.io.git</code> and <code>HTTPS: https://github.com/dlc1994/dlc1994.github.io.git</code>). The configuration of SSH can be seen in <a href="https://www.cnblogs.com/superGG1990/p/6844952.html">here</a>, and HTTPS has no need of extra operation.</p><p>Install <a href="https://git-scm.com/">Git</a> tool and the rest of operations is done through this tool.</p><h1 id="2-Install-the-necessary-components"><a href="#2-Install-the-necessary-components" class="headerlink" title="2. Install the necessary components"></a>2. Install the necessary components</h1><p>After that, install <a href="https://nodejs.org/en/">Node.js</a>, in case of the low speed, you can also download it in <a href="http://nodejs.cn/download/">here</a>.</p><p>Now it’s time to install Hexo in your machine, click right-hand button anywhere and open <code>Git Bash</code>, then input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install hexo-deployer-git  --save</span><br></pre></td></tr></table></figure><p>Wait a minute you can check if the component is installed successfully. Input directly in <code>Git Bash</code>, or <code>Win+R</code> and input <code>cmd</code>, then input codes as follow:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>If return the version number then you can go on, otherwise just google your mistake during your installation.</p><p>After Hexo is installed, go to the place where you want to save your blog and open <code>Git Bash</code>. Input <code>hexo init</code>, you can find that a lot of files are created. </p><h1 id="3-Create-your-first-blog"><a href="#3-Create-your-first-blog" class="headerlink" title="3. Create your first blog"></a>3. Create your first blog</h1><p>Use file editor like <a href="https://notepad-plus-plus.org/download/v7.5.6.html">Notepad++</a>, open file <code>_config.yml</code>, find the codes and edit it as you want</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: DLC&apos;s Blog          #your blog name</span><br><span class="line">subtitle: Find myself in the darkest place #your blog subtitle</span><br><span class="line">description: Personal Blog#description of your blog</span><br><span class="line">keywords:</span><br><span class="line">author: </span><br><span class="line">language: </span><br><span class="line">timezone: Asia/Shanghai</span><br><span class="line"></span><br><span class="line">theme: landscape    #your blog theme, I will talk about how to change it to `Next`</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: </span><br><span class="line">  repository: git@github.com:dlc1994/dlc1994.github.io.git  #your repository address</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>In <code>Git Bash</code>, input <code>hexo g</code> and <code>hexo s</code>, it will return (perfectly)</p><p><code>Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</code></p><p>Open your browser and input <code>localhost:4000</code> in address bar, you can see that (Ok it is really ugly)</p><p><img src="/2018/06/12/ck813u1hp0005kkun0s3zey67/4.png" alt="Your First Blog"></p><p>Lastly, you have to deploy it to your github repository, continue to input <code>hexo d</code>. Luckily, there is no error and you can see it in your repository address like <code>git@github.com:dlc1994/dlc1994.github.io.git</code>. If not, go to google for help.</p><p>Create a new blog use <code>hexo new &quot;postname&quot;</code> or in your blog path <code>blogpath\source\_posts</code> new a <code>.md</code> file and edit it use Markdown (<a href="https://www.typora.io/">Typora</a> is recommended here).</p><p>More commands can be found <a href="https://hexo.io/docs/commands.html">here</a>. I will update the process of blog beautification in my next blogs.</p><p>!!!Tips: if you suffer any problem, first go to google or baidu it. </p><p><strong>Please discover the truth by yourself.</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    Before we start, you have to know what is the difference between &lt;strong&gt;static&lt;/strong&gt; site and &lt;strong&gt;dynamic&lt;/strong&gt; site. Let’s take a look at the definition in Wiki:&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="HEXO" scheme="https://dlc1994.github.io/categories/HEXO/"/>
    
    
      <category term="Hexo" scheme="https://dlc1994.github.io/tags/Hexo/"/>
    
      <category term="Markdown" scheme="https://dlc1994.github.io/tags/Markdown/"/>
    
  </entry>
  
</feed>
