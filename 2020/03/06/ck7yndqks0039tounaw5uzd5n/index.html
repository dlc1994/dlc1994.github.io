<!DOCTYPE html>
<html  lang="en">
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />

<meta name="generator" content="Hexo 3.7.1" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>剑指offer题解(C++) - LC-Garden</title>


    <meta name="description" content="剑指offer各题目的C++解法">
<meta name="keywords" content="Algorithm,C++">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer题解(C++)">
<meta property="og:url" content="https://dlc1994.github.io/2020/03/06/ck7yndqks0039tounaw5uzd5n/index.html">
<meta property="og:site_name" content="LC-Garden">
<meta property="og:description" content="剑指offer各题目的C++解法">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://dlc1994.github.io/gallery/thumbnails/nowcoder.jpg">
<meta property="og:updated_time" content="2020-03-06T11:33:35.374Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="剑指offer题解(C++)">
<meta name="twitter:description" content="剑指offer各题目的C++解法">
<meta name="twitter:image" content="https://dlc1994.github.io/gallery/thumbnails/nowcoder.jpg">







<link rel="icon" href="/images/head.jpg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
<style>body>.footer,body>.navbar,body>.section{opacity:0}</style>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">

    
    
    
    
<link rel="stylesheet" href="/css/back-to-top.css">

    
    
    
    
    
    
    
    <link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
    
    <script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    


<link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
<body class="is-3-column">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/head.jpg" alt="剑指offer题解(C++)" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">Home</a>
                
                <a class="navbar-item"
                href="/archives">Archives</a>
                
                <a class="navbar-item"
                href="/categories">Categories</a>
                
                <a class="navbar-item"
                href="/tags">Tags</a>
                
                <a class="navbar-item"
                href="/about">About</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    <a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/dlc1994">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                <a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;">
                    <i class="fas fa-list-ul"></i>
                </a>
                
                
                <a class="navbar-item search" title="Search" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-6-widescreen has-order-2 column-main">
<div class="card">
    
    <div class="card-image">
        <span  class="image is-7by1">
            <img class="thumbnail" src="/gallery/thumbnails/nowcoder.jpg" alt="剑指offer题解(C++)">
        </span>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-03-06T13:27:23.000Z">2020-03-06</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Algorithm-and-Data-Structure/">Algorithm and Data Structure</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    an hour read (About 13106 words)
                </span>
                
                
                <span class="level-item has-text-grey" id="busuanzi_container_page_pv">
                    <i class="far fa-eye"></i>
                    <span id="busuanzi_value_page_pv">0</span> visits
                </span>
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                剑指offer题解(C++)
            
        </h1>
        <div class="content">
            <p>剑指offer各题目的C++解法<br><a id="more"></a><br><!-- TOC --></p>
<ul>
<li><a href="#剑指offer-1-二维数组查找">剑指offer 1 二维数组查找</a></li>
<li><a href="#剑指offer-2-替换空格">剑指offer 2 替换空格</a></li>
<li><a href="#剑指offer-3-从尾到头打印链表">剑指offer 3 从尾到头打印链表</a></li>
<li><a href="#剑指offer-4-重建二叉树">剑指offer 4 重建二叉树</a></li>
<li><a href="#剑指offer-5-用两个栈实现队列">剑指offer 5 用两个栈实现队列</a></li>
<li><a href="#剑指offer-6-旋转数组的最小值">剑指offer 6 旋转数组的最小值</a></li>
<li><a href="#剑指offer-7-斐波那契数列">剑指offer 7 斐波那契数列</a></li>
<li><a href="#剑指offer-8-跳台阶">剑指offer 8 跳台阶</a></li>
<li><a href="#剑指offer-9-变态跳台阶">剑指offer 9 变态跳台阶</a></li>
<li><a href="#剑指offer-10-矩形覆盖">剑指offer 10 矩形覆盖</a></li>
<li><a href="#剑指offer-11-二进制中1的个数">剑指offer 11 二进制中1的个数**</a></li>
<li><a href="#剑指offer-12-求base的exponent次方">剑指offer 12 求base的exponent次方</a></li>
<li><a href="#剑指offer-13-调整数组奇偶顺序">剑指offer 13 调整数组奇偶顺序</a></li>
<li><a href="#剑指offer-14-链表倒数第k个结点">剑指offer 14 链表倒数第k个结点</a></li>
<li><a href="#剑指offer-15-反转链表">剑指offer 15 反转链表</a></li>
<li><a href="#剑指offer-16-合并两个排序的链表">剑指offer 16 合并两个排序的链表</a></li>
<li><a href="#剑指offer-17-树的子结构">剑指offer 17 树的子结构</a></li>
<li><a href="#剑指offer-18-二叉树的镜像">剑指offer 18 二叉树的镜像</a></li>
<li><a href="#剑指offer-19-顺时针打印矩阵">剑指offer 19 顺时针打印矩阵</a></li>
<li><a href="#剑指offer-20-包含min函数的栈">剑指offer 20 包含Min函数的栈</a></li>
<li><a href="#剑指offer-21-栈的压入弹出序列">剑指offer 21 栈的压入、弹出序列</a></li>
<li><a href="#剑指offer-22-从上往下打印二叉树">剑指offer 22 从上往下打印二叉树</a></li>
<li><a href="#剑指offer-23-二叉搜索树的后序遍历序列">剑指offer 23 二叉搜索树的后序遍历序列</a></li>
<li><a href="#剑指offer-24-二叉树中和为某一值的所有路径">剑指offer 24 二叉树中和为某一值的所有路径</a></li>
<li><a href="#剑指offer-25-复杂链表的复制">剑指offer 25 复杂链表的复制</a></li>
<li><a href="#剑指offer-26-二叉搜索树转双端链表">剑指offer 26 二叉搜索树转双端链表**</a></li>
<li><a href="#剑指offer-27-字符串的排列">剑指offer 27 字符串的排列</a></li>
<li><a href="#剑指offer-28-数组中出现超过一半的数">剑指offer 28 数组中出现超过一半的数</a></li>
<li><a href="#剑指offer-29-最小的k个数">剑指offer 29 最小的k个数**</a></li>
<li><a href="#剑指offer-30-连续子数组最大和">剑指offer 30 连续子数组最大和</a></li>
<li><a href="#剑指offer-31-整数中1的个数">剑指offer 31 整数中1的个数</a></li>
<li><a href="#剑指offer-32-把数组排成最小的数">剑指offer 32 把数组排成最小的数**</a></li>
<li><a href="#剑指offer-33-丑数">剑指offer 33 丑数</a></li>
<li><a href="#剑指offer-34-第一次出现的字符">剑指offer 34 第一次出现的字符</a></li>
<li><a href="#剑指offer-35-数组中的逆序对">剑指offer 35 数组中的逆序对**</a></li>
<li><a href="#剑指offer-36-两个链表的第一个公共结点">剑指offer 36 两个链表的第一个公共结点</a></li>
<li><a href="#剑指offer-37-数组在排序数组出现的次数">剑指offer 37 数组在排序数组出现的次数</a></li>
<li><a href="#剑指offer-38-二叉树深度">剑指offer 38 二叉树深度</a></li>
<li><a href="#剑指offer-39-判断平衡二叉树">剑指offer 39 判断平衡二叉树</a></li>
<li><a href="#剑指offer-40-数组中只出现一次的数字">剑指offer 40 数组中只出现一次的数字</a></li>
<li><a href="#剑指offer-41-和为s的连续正数序列">剑指offer 41 和为S的连续正数序列</a></li>
<li><a href="#剑指offer-42-和为s的两个数">剑指offer 42 和为S的两个数</a></li>
<li><a href="#剑指offer-43-左旋转字符串">剑指offer 43 左旋转字符串</a></li>
<li><a href="#剑指offer-44-翻转单词顺序列">剑指offer 44 翻转单词顺序列</a></li>
<li><a href="#剑指offer-45-扑克牌顺子">剑指offer 45 扑克牌顺子</a></li>
<li><a href="#剑指offer-46-孩子们的游戏圆圈里最后剩下的数">剑指offer 46 孩子们的游戏（圆圈里最后剩下的数）</a></li>
<li><a href="#剑指offer-47-求12n">剑指offer 47 求1+2+…+n</a></li>
<li><a href="#剑指offer-48-不用加减乘除做加法">剑指offer 48 不用加减乘除做加法</a></li>
<li><a href="#剑指offer-49-把字符串转换为整数">剑指offer 49 把字符串转换为整数</a></li>
<li><a href="#剑指offer-50-数组中重复的数字">剑指offer 50 数组中重复的数字</a></li>
<li><a href="#剑指offer-51-构建乘积数组">剑指offer 51 构建乘积数组</a></li>
<li><a href="#剑指offer-52-正则表达式匹配">剑指offer 52 正则表达式匹配</a></li>
<li><a href="#剑指offer-53-表示数值的字符串">剑指offer 53 表示数值的字符串</a></li>
<li><a href="#剑指offer-54-字符流中第一个不重复的字符">剑指offer 54 字符流中第一个不重复的字符</a></li>
<li><a href="#剑指offer-55-链表中环的入口节点">剑指offer 55 链表中环的入口节点</a></li>
<li><a href="#剑指offer-56-删除链表中重复的节点">剑指offer 56 删除链表中重复的节点</a></li>
<li><a href="#剑指offer-57-二叉树的下一个节点">剑指offer 57 二叉树的下一个节点</a></li>
<li><a href="#剑指offer-58-对称的二叉树">剑指offer 58 对称的二叉树</a></li>
<li><a href="#剑指offer-59-之字形打印二叉树">剑指offer 59 之字形打印二叉树</a></li>
<li><a href="#剑指offer-60-把二叉树打印成多行层序遍历">剑指offer 60 把二叉树打印成多行（层序遍历）</a></li>
<li><a href="#剑指offer-61-序列化二叉树">剑指offer 61 序列化二叉树</a></li>
<li><a href="#剑指offer-62-二叉搜索树的第k个结点">剑指offer 62 二叉搜索树的第k个结点</a></li>
<li><a href="#剑指offer-63-数据流中的中位数">剑指offer 63 数据流中的中位数</a></li>
<li><a href="#剑指offer-64-滑动窗口的最大值">剑指offer 64 滑动窗口的最大值</a></li>
<li><a href="#剑指offer-65-矩阵中的路径">剑指offer 65 矩阵中的路径</a></li>
<li><a href="#剑指offer-66-机器人的动作范围">剑指offer 66 机器人的动作范围</a></li>
<li><a href="#剑指offer-67-剪绳子">剑指offer 67 剪绳子</a></li>
</ul>
<!-- /TOC -->
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-1-二维数组查找"><a href="#剑指offer-1-二维数组查找" class="headerlink" title="剑指offer 1 二维数组查找"></a>剑指offer 1 二维数组查找</h1><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 左下往右上查找，快速定位地图经纬度 O(n+m)</span><br><span class="line">bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</span><br><span class="line">    int rows = array.size(), cols = array[0].size();</span><br><span class="line">    int row=rows-1,col=0;</span><br><span class="line">    while(row&gt;=0 &amp;&amp; col&lt;cols)&#123;</span><br><span class="line">            if(array[row][col]==target) return true;</span><br><span class="line">            else if(array[row][col]&gt;target) row--;</span><br><span class="line">            else col++;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 二分法 O(nlogm) O(n+m)</span><br><span class="line">bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</span><br><span class="line">    if(array.size()==0) return false;</span><br><span class="line">        int nrows = array.size(), ncols= array[0].size();</span><br><span class="line">        for(int i=0;i&lt;nrows;i++)&#123;</span><br><span class="line">            int low=0;</span><br><span class="line">            int high=ncols-1;</span><br><span class="line">            while(low&lt;=high)&#123;</span><br><span class="line">                int mid=(low+high)/2;</span><br><span class="line">                if(target&gt;array[i][mid])</span><br><span class="line">                    low=mid+1;</span><br><span class="line">                else if(target&lt;array[i][mid])</span><br><span class="line">                    high=mid-1;</span><br><span class="line">                else</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-2-替换空格"><a href="#剑指offer-2-替换空格" class="headerlink" title="剑指offer 2 替换空格"></a>剑指offer 2 替换空格</h1><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// O(n)</span><br><span class="line">void replaceSpace(char *str,int length) &#123;</span><br><span class="line">    int count=0;</span><br><span class="line">    for(int i=0;i&lt;length;i++)&#123;</span><br><span class="line">        if(str[i]==&apos; &apos;)</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=length-1;i&gt;=0;i--)&#123;</span><br><span class="line">        if(str[i]!=&apos; &apos;)&#123;</span><br><span class="line">            str[i+2*count]=str[i]; //非空格在新数组的位置 </span><br><span class="line">            //0 1 2 3 4 5 6 7 8  </span><br><span class="line">            //0 # 3 # 4     </span><br><span class="line">            //0 % 2 0 3 % 2 0 4</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            count--;</span><br><span class="line">            str[i+2*count]=&apos;%&apos;;</span><br><span class="line">            str[i+2*count+1]=&apos;2&apos;;</span><br><span class="line">            str[i+2*count+2]=&apos;0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-3-从尾到头打印链表"><a href="#剑指offer-3-从尾到头打印链表" class="headerlink" title="剑指offer 3 从尾到头打印链表"></a>剑指offer 3 从尾到头打印链表</h1><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//递归</span><br><span class="line">vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    if(head!=NULL)&#123;</span><br><span class="line">        if(head-&gt;next!=NULL)&#123;</span><br><span class="line">            res = printListFromTailToHead(head-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(head-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">//栈</span><br><span class="line">vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    stack&lt;int&gt; sta;</span><br><span class="line">    while(head!=NULL)&#123;</span><br><span class="line">        sta.push(head-&gt;val);</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!sta.empty())&#123;</span><br><span class="line">        res.push_back(sta.top());</span><br><span class="line">        sta.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">// **链表原地反转**</span><br><span class="line">vector&lt;int&gt; printListFromTailToHead(struct ListNode* head) &#123;</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    ListNode *buf=head;</span><br><span class="line">    ListNode *pre=buf;</span><br><span class="line">    if(head==NULL)</span><br><span class="line">        return vec;</span><br><span class="line">    while(head-&gt;next!=NULL)&#123;</span><br><span class="line">        buf=head-&gt;next;</span><br><span class="line">        head-&gt;next=buf-&gt;next;</span><br><span class="line">        buf-&gt;next=pre;</span><br><span class="line">        pre=buf;</span><br><span class="line">    &#125;</span><br><span class="line">    while(buf)&#123;</span><br><span class="line">        vec.push_back(buf-&gt;val);</span><br><span class="line">        buf=buf-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-4-重建二叉树"><a href="#剑指offer-4-重建二叉树" class="headerlink" title="剑指offer 4 重建二叉树"></a>剑指offer 4 重建二叉树</h1><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">    TreeNode* root = helper(pre, 0, pre.size()-1, vin, 0, vin.size()-1);</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* helper(vector&lt;int&gt; pre, int startpre, int endpre, vector&lt;int&gt; vin, int startvin, int endvin)&#123;</span><br><span class="line">    if(startpre&gt;endpre||startvin&gt;endvin)</span><br><span class="line">        return NULL;</span><br><span class="line">    TreeNode* root=new TreeNode(pre[startpre]);</span><br><span class="line">    for(int i=startvin;i&lt;=endvin;i++)&#123;</span><br><span class="line">        if(vin[i]==pre[startpre])&#123;</span><br><span class="line">            root-&gt;left = helper(pre, startpre+1, startpre+i-startvin, vin, startvin, i-1);</span><br><span class="line">            root-&gt;right = helper(pre, startpre+i-startvin+1, endpre, vin, i+1, endvin);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-5-用两个栈实现队列"><a href="#剑指offer-5-用两个栈实现队列" class="headerlink" title="剑指offer 5 用两个栈实现队列"></a>剑指offer 5 用两个栈实现队列</h1><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int&gt; stack1;</span><br><span class="line">stack&lt;int&gt; stack2;</span><br><span class="line">void push(int node) &#123;</span><br><span class="line">    stack1.push(node);</span><br><span class="line">&#125;</span><br><span class="line">//栈1不空，全部压入栈2，栈2的top则可以输出；</span><br><span class="line">//然后把栈2再压回栈1</span><br><span class="line">int pop() &#123;</span><br><span class="line">    while(!stack1.empty())&#123;</span><br><span class="line">        int a = stack1.top();</span><br><span class="line">        stack1.pop();</span><br><span class="line">        stack2.push(a);</span><br><span class="line">    &#125;</span><br><span class="line">    int res = stack2.top();</span><br><span class="line">    stack2.pop();</span><br><span class="line">    while(!stack2.empty())&#123;</span><br><span class="line">        stack1.push(stack2.top());</span><br><span class="line">        stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果栈2不空，栈2的top即为输出，否则把栈1全部压入栈2</span><br><span class="line">int pop() &#123;</span><br><span class="line">    if(stack2.empty())&#123;</span><br><span class="line">        while(!stack1.empty())&#123;</span><br><span class="line">            int a = stack1.top();</span><br><span class="line">            stack1.pop();</span><br><span class="line">            stack2.push(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int res = stack2.top();</span><br><span class="line">    stack2.pop();</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-6-旋转数组的最小值"><a href="#剑指offer-6-旋转数组的最小值" class="headerlink" title="剑指offer 6 旋转数组的最小值"></a>剑指offer 6 旋转数组的最小值</h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//O(N)</span><br><span class="line">int minNumberInRotateArray(int[] array) &#123;</span><br><span class="line">  if (array.length == 0)</span><br><span class="line">      return 0;</span><br><span class="line">  for (int i = 0; i &lt; array.length - 1; i++) &#123;</span><br><span class="line">      if (array[i] &gt; array[i + 1])</span><br><span class="line">          return array[i + 1];</span><br><span class="line">  &#125;</span><br><span class="line">  return array[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// O(logn) 二分法</span><br><span class="line">int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">    if(rotateArray.size()==0) return 0;</span><br><span class="line">    int low=0, high=rotateArray.size()-1;</span><br><span class="line">    while(low&lt;high)&#123;</span><br><span class="line">        int mid=(low+high)/2;</span><br><span class="line">        if(rotateArray[mid]&gt;rotateArray[high]) low=mid+1;</span><br><span class="line">        else if(rotateArray[mid]==rotateArray[high]) high--;</span><br><span class="line">        else high=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return rotateArray[high];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-7-斐波那契数列"><a href="#剑指offer-7-斐波那契数列" class="headerlink" title="剑指offer 7 斐波那契数列"></a>剑指offer 7 斐波那契数列</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//斐波那契数列</span><br><span class="line">0 1 2 3 4 ...</span><br><span class="line">0 1 1 2 3 ...</span><br><span class="line">//递归</span><br><span class="line">int Fibonacci(int n) &#123;</span><br><span class="line">    if(n==0) return 0;</span><br><span class="line">    if(n==1) return 1;</span><br><span class="line">    return Fibonacci(n-1)+Fibonacci(n-2);</span><br><span class="line">&#125;</span><br><span class="line">//循环 时间复杂度O(N) 空间复杂度O(1)</span><br><span class="line">int Fibonacci(int n) &#123;</span><br><span class="line">    if(n==0) return 0;</span><br><span class="line">    if(n==1) return 1;</span><br><span class="line">    int pre=0, now=1;</span><br><span class="line">    while(n&gt;1)&#123;</span><br><span class="line">        int tmp = pre+now;</span><br><span class="line">        pre = now;</span><br><span class="line">        now = tmp;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    return now;</span><br><span class="line">&#125;</span><br><span class="line">//动态规划 时间复杂度O(N) 空间复杂度O(N)</span><br><span class="line">int Fibonacci(int n) &#123;</span><br><span class="line">    if(n==0) return 0;</span><br><span class="line">    if(n==1) return 1;</span><br><span class="line">    vector&lt;int&gt; dp(n+1,0);</span><br><span class="line">    dp[0]=0;</span><br><span class="line">    dp[1]=1;</span><br><span class="line">    for(int i=2;i&lt;=n;++i)&#123;</span><br><span class="line">        dp[i]=dp[i-1]+dp[i-2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-8-跳台阶"><a href="#剑指offer-8-跳台阶" class="headerlink" title="剑指offer 8 跳台阶"></a>剑指offer 8 跳台阶</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//斐波那契数列 DP O(N)</span><br><span class="line">int jumpFloor(int number) &#123;</span><br><span class="line">    if(number&lt;2) return number;</span><br><span class="line">    int pre=1, now=2;</span><br><span class="line">    for(int i=3;i&lt;=number;i++)&#123;</span><br><span class="line">        int tmp = pre+now;</span><br><span class="line">        pre = now;</span><br><span class="line">        now=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="剑指offer-9-变态跳台阶"><a href="#剑指offer-9-变态跳台阶" class="headerlink" title="剑指offer 9 变态跳台阶"></a>剑指offer 9 变态跳台阶</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int jumpFloorII(int number) &#123;</span><br><span class="line">    if(number==0) return 0;</span><br><span class="line">    int res=1;</span><br><span class="line">    while(number--&gt;1)&#123;</span><br><span class="line">        res*=2;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">//移位 左移一位*2，左移n-1位即 2^(n-1)</span><br><span class="line">int res = 1&lt;&lt;(number-1)</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-10-矩形覆盖"><a href="#剑指offer-10-矩形覆盖" class="headerlink" title="剑指offer 10 矩形覆盖"></a>剑指offer 10 矩形覆盖</h1><p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，有多少种方法？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//还是斐波那契数列</span><br><span class="line"> f(n) = f(n-1) + f(n-2)， (n &gt; 2)。</span><br></pre></td></tr></table></figure></p>
<p>更一般的结论，如果用1*m的方块覆盖m*n区域，递推关系式为f(n) = f(n-1) + f(n-m)，(n &gt; m)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 循环</span><br><span class="line">int rectCover(int number) &#123;</span><br><span class="line">    if(number&lt;=2) return number;</span><br><span class="line">    int pre=1, now=2;</span><br><span class="line">    for(int i=3;i&lt;=number;++i)&#123;</span><br><span class="line">        int tmp=pre+now;</span><br><span class="line">        pre=now;</span><br><span class="line">        now=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return now;</span><br><span class="line">&#125;</span><br><span class="line">// 递归</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public int RectCover(int target) &#123;</span><br><span class="line">        if (target &lt; 1) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else if (target == 1 || target == 2) &#123;</span><br><span class="line">            return target;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return RectCover(target-1) + RectCover(target-2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// dp</span><br><span class="line">int rectCover(int number) &#123;</span><br><span class="line">    if ( number &lt; 1 ) return 0;</span><br><span class="line">    int g = 1, f = 2;</span><br><span class="line">    while ( --number ) &#123;</span><br><span class="line">        f = f + g;</span><br><span class="line">        g = f - g;</span><br><span class="line">    &#125;</span><br><span class="line">    return g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-11-二进制中1的个数"><a href="#剑指offer-11-二进制中1的个数" class="headerlink" title="剑指offer 11 二进制中1的个数**"></a>剑指offer 11 二进制中1的个数**</h1><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</span><br><span class="line">int NumberOf1(int n) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while (n != 0) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        n = (n - 1) &amp; n;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="剑指offer-12-求base的exponent次方"><a href="#剑指offer-12-求base的exponent次方" class="headerlink" title="剑指offer 12 求base的exponent次方"></a>剑指offer 12 求base的exponent次方</h1><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 简单快速幂</span><br><span class="line">double Power(double base, int exponent) &#123;</span><br><span class="line">    long long p = abs((long long)exponent);</span><br><span class="line">    double r = 1.0;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        if(p &amp; 1) r *= base;</span><br><span class="line">        base *= base;</span><br><span class="line">        p &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return exponent &lt; 0 ? 1/ r : r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一种方法：使用递归，时间复杂度O(logn)<br>当n为偶数，a^n =（a^n/2）*（a^n/2）</p>
<p>当n为奇数，a^n = a ^ [( n - 1) / 2] <em> a ^ [(n-1)/2] </em> a</p>
<p>举例：</p>
<p>2^11 = 2^1 <em> 2^2 </em> 2^8</p>
<p>2^1011 = 2^0001 <em> 2^0010 </em> 2^1000</p>
<p>第二种方法：累乘，时间复杂度为O(n)</p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-13-调整数组奇偶顺序"><a href="#剑指offer-13-调整数组奇偶顺序" class="headerlink" title="剑指offer 13 调整数组奇偶顺序"></a>剑指offer 13 调整数组奇偶顺序</h1><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// O(2n) O(n) </span><br><span class="line">void reOrderArray(vector&lt;int&gt; &amp;array) &#123;</span><br><span class="line">  if(array.size()==0) return;</span><br><span class="line">  vector&lt;int&gt; res(array.size(),0);</span><br><span class="line">  int s=0,e=array.size()-1;</span><br><span class="line">  for(int i=0;i&lt;array.size();++i)&#123;</span><br><span class="line">    if(array[i]%2==1)&#123;</span><br><span class="line">      res[s++]=array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=array.size()-1;i&gt;=0;--i)&#123;</span><br><span class="line">    if(array[i]%2==0)&#123;</span><br><span class="line">      res[e--]=array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  array=res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// O(n*n) O(1) 插排想法</span><br><span class="line">void reOrderArray1(vector&lt;int&gt; &amp;array)&#123;</span><br><span class="line">  if(array.size()&lt;=1) return;</span><br><span class="line">  for(int i=0;i&lt;array.size();i++)&#123;</span><br><span class="line">    if(array[i]%2==1)&#123;</span><br><span class="line">      int tmp=array[i];</span><br><span class="line">      int j=i-1;</span><br><span class="line">      while(j&gt;=0 &amp;&amp; array[j]%2==0)&#123;</span><br><span class="line">        array[j+1]=array[j];</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">      array[j+1]  =tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 开辟2个数组分别存奇数和偶数 O(n) O(2n)</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-14-链表倒数第k个结点"><a href="#剑指offer-14-链表倒数第k个结点" class="headerlink" title="剑指offer 14 链表倒数第k个结点"></a>剑指offer 14 链表倒数第k个结点</h1><p>输入一个链表，输出该链表中倒数第k个结点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// 遍历再数 O(2n-k)</span><br><span class="line">ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123;</span><br><span class="line">    if(k&lt;=0) return NULL;</span><br><span class="line">    int cnt=0, start=0;</span><br><span class="line">    ListNode* root=pListHead;</span><br><span class="line">    while(pListHead!=NULL)&#123;</span><br><span class="line">        pListHead=pListHead-&gt;next;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(k&gt;cnt) return NULL;</span><br><span class="line">    while(start!=cnt-k)&#123;</span><br><span class="line">        root=root-&gt;next;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历再数 O(n)</span><br><span class="line">ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123;</span><br><span class="line">    if(k&lt;=0 || pListHead==NULL) return NULL;</span><br><span class="line">    ListNode *fast=pListHead;</span><br><span class="line">    ListNode *slow=pListHead;</span><br><span class="line">    while(k--&gt;0)&#123;</span><br><span class="line">		if(fast==nullptr) return nullptr;</span><br><span class="line">        fast=fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">	while(fast!=NULL)&#123;</span><br><span class="line">		fast=fast-&gt;next;</span><br><span class="line">		slow=slow-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	return slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归</span><br><span class="line">ListNode* FindKthToTail2(ListNode* pListHead, unsigned int k) &#123;</span><br><span class="line">	if(pListHead==NULL) return NULL;</span><br><span class="line">	ListNode* node=FindKthToTail(pListHead-&gt;next,k);</span><br><span class="line">	if(node!=NULL) return node;</span><br><span class="line">	cnt++;</span><br><span class="line">	if(cnt==k) return pListHead;</span><br><span class="line">	else return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-15-反转链表"><a href="#剑指offer-15-反转链表" class="headerlink" title="剑指offer 15 反转链表"></a>剑指offer 15 反转链表</h1><p>输入一个链表，反转链表后，输出新链表的表头。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public ListNode ReverseList(ListNode head) &#123;</span><br><span class="line">    if(head==null)</span><br><span class="line">        return null;</span><br><span class="line">    //head为当前节点，如果当前节点为空的话，那就什么也不做，直接返回null；</span><br><span class="line">    ListNode pre = null;</span><br><span class="line">    ListNode next = null;</span><br><span class="line">    //当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点</span><br><span class="line">    //需要pre和next的目的是让当前节点从pre-&gt;head-&gt;next1-&gt;next2变成pre&lt;-head next1-&gt;next2</span><br><span class="line">    //即pre让节点可以反转所指方向，但反转之后如果不用next节点保存next1节点的话，此单链表就此断开了</span><br><span class="line">    //所以需要用到pre和next两个节点</span><br><span class="line">    //1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line">    //1&lt;-2&lt;-3 4-&gt;5</span><br><span class="line">    while(head!=null)&#123;</span><br><span class="line">        //做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre</span><br><span class="line">        //如此就可以做到反转链表的效果</span><br><span class="line">        //先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂</span><br><span class="line">        next = head.next;</span><br><span class="line">        //保存完next，就可以让head从指向next变成指向pre了，代码如下</span><br><span class="line">        head.next = pre;</span><br><span class="line">        //head指向pre后，就继续依次反转下一个节点</span><br><span class="line">        //让pre，head，next依次向后移动一个节点，继续下一次的指针反转</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果head为null的时候，pre就为最后一个节点了，但是链表已经反转完毕，pre就是反转后链表的第一个节点</span><br><span class="line">    //直接输出pre就是我们想要得到的反转后的链表</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-16-合并两个排序的链表"><a href="#剑指offer-16-合并两个排序的链表" class="headerlink" title="剑指offer 16 合并两个排序的链表"></a>剑指offer 16 合并两个排序的链表</h1><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//递归</span><br><span class="line">ListNode* Merge(ListNode* pHead1, ListNode* pHead2)&#123;</span><br><span class="line">  if(pHead1==NULL) return pHead2;</span><br><span class="line">  if(pHead2==nullptr) return pHead1;</span><br><span class="line">      if(pHead1-&gt;val&gt;pHead2-&gt;val) &#123;</span><br><span class="line">    pHead2-&gt;next=Merge(pHead1, pHead2-&gt;next);</span><br><span class="line">    return pHead2;</span><br><span class="line">  &#125;</span><br><span class="line">  if(pHead1-&gt;val&lt;pHead2-&gt;val) &#123;</span><br><span class="line">    pHead1-&gt;next=Merge(pHead1-&gt;next, pHead2);</span><br><span class="line">    return pHead1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 循环</span><br><span class="line">if(list1 == null) return list2;</span><br><span class="line">if(list2 == null) return list1;</span><br><span class="line">ListNode mergeHead = null;</span><br><span class="line">ListNode current = null;</span><br><span class="line">while(list1!=null &amp;&amp; list2!=null)&#123;</span><br><span class="line">    if(list1.val &lt;= list2.val)&#123;</span><br><span class="line">        if(mergeHead == null)&#123;</span><br><span class="line">           mergeHead = current = list1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">           current.next = list1;</span><br><span class="line">           current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        list1 = list1.next;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        if(mergeHead == null)&#123;</span><br><span class="line">           mergeHead = current = list2;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">           current.next = list2;</span><br><span class="line">           current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        list2 = list2.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if(list1 == null) current.next = list2;</span><br><span class="line">else current.next = list1;</span><br><span class="line">return mergeHead;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-17-树的子结构"><a href="#剑指offer-17-树的子结构" class="headerlink" title="剑指offer 17 树的子结构"></a>剑指offer 17 树的子结构</h1><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)</span><br><span class="line">&#123;</span><br><span class="line">    bool result=false;</span><br><span class="line">    if(pRoot1!=NULL &amp;&amp; pRoot2!=NULL)&#123;</span><br><span class="line">        if(pRoot1-&gt;val==pRoot2-&gt;val) result=Tree1HaveTree2(pRoot1, pRoot2);</span><br><span class="line">        if(!result) &#123;</span><br><span class="line">            result=Tree1HaveTree2(pRoot1-&gt;left, pRoot2) || Tree1HaveTree2(pRoot1-&gt;right, pRoot2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">bool Tree1HaveTree2(TreeNode* pRoot1, TreeNode* pRoot2)&#123;</span><br><span class="line">    if(pRoot2==NULL) return true;</span><br><span class="line">    if(pRoot1==NULL) return false;</span><br><span class="line">    if(pRoot1-&gt;val!=pRoot2-&gt;val) return false;</span><br><span class="line">    return Tree1HaveTree2(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; Tree1HaveTree2(pRoot1-&gt;right,pRoot2-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="剑指offer-18-二叉树的镜像"><a href="#剑指offer-18-二叉树的镜像" class="headerlink" title="剑指offer 18 二叉树的镜像"></a>剑指offer 18 二叉树的镜像</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void Mirror(TreeNode *pRoot) &#123;</span><br><span class="line">    if (pRoot==NULL) return;</span><br><span class="line">    else &#123;</span><br><span class="line">        TreeNode *tmp=pRoot-&gt;left;</span><br><span class="line">        pRoot-&gt;left = pRoot-&gt;right;</span><br><span class="line">        pRoot-&gt;right = tmp;</span><br><span class="line">        Mirror(pRoot-&gt;left);</span><br><span class="line">        Mirror(pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-19-顺时针打印矩阵"><a href="#剑指offer-19-顺时针打印矩阵" class="headerlink" title="剑指offer 19 顺时针打印矩阵"></a>剑指offer 19 顺时针打印矩阵</h1><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123;</span><br><span class="line">    int row = matrix.size();</span><br><span class="line">    int col = matrix[0].size();</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">        </span><br><span class="line">    // 输入的二维数组非法，返回空的数组</span><br><span class="line">    if (row == 0 || col == 0)  return res;</span><br><span class="line">        </span><br><span class="line">    // 定义四个关键变量，表示左上和右下的打印范围</span><br><span class="line">    int left = 0, top = 0, right = col - 1, bottom = row - 1;</span><br><span class="line">    while (left &lt;= right &amp;&amp; top &lt;= bottom)</span><br><span class="line">    &#123;</span><br><span class="line">        // left to right</span><br><span class="line">        for (int i = left; i &lt;= right; ++i)  res.push_back(matrix[top][i]);</span><br><span class="line">        // top to bottom</span><br><span class="line">        for (int i = top + 1; i &lt;= bottom; ++i)  res.push_back(matrix[i][right]);</span><br><span class="line">        // right to left</span><br><span class="line">        if (top != bottom)</span><br><span class="line">        for (int i = right - 1; i &gt;= left; --i)  res.push_back(matrix[bottom][i]);</span><br><span class="line">        // bottom to top</span><br><span class="line">        if (left != right)</span><br><span class="line">        for (int i = bottom - 1; i &gt; top; --i)  res.push_back(matrix[i][left]);</span><br><span class="line">        left++,top++,right--,bottom--;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-20-包含Min函数的栈"><a href="#剑指offer-20-包含Min函数的栈" class="headerlink" title="剑指offer 20 包含Min函数的栈"></a>剑指offer 20 包含Min函数的栈</h1><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int&gt; stack1, stack2;</span><br><span class="line">void push(int value) &#123;</span><br><span class="line">    stack1.push(value);</span><br><span class="line">    if(stack2.empty()) stack2.push(value);</span><br><span class="line">    else&#123;</span><br><span class="line">        if(value&lt;stack2.top()) stack2.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void pop() &#123;</span><br><span class="line">    if(stack1.top()==stack2.top()) stack2.pop();</span><br><span class="line">    stack1.pop();</span><br><span class="line">&#125;</span><br><span class="line">int top() &#123;</span><br><span class="line">    return stack1.top();</span><br><span class="line">&#125;</span><br><span class="line">int min() &#123;</span><br><span class="line">    return stack2.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="剑指offer-21-栈的压入、弹出序列"><a href="#剑指offer-21-栈的压入、弹出序列" class="headerlink" title="剑指offer 21 栈的压入、弹出序列"></a>剑指offer 21 栈的压入、弹出序列</h1><p>//输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123;</span><br><span class="line">      if(pushV.empty()||popV.empty()) return false;</span><br><span class="line">  stack&lt;int&gt; Stack;</span><br><span class="line">  int popIndex=0;</span><br><span class="line">  for(int i=0;i&lt;pushV.size();++i)&#123;</span><br><span class="line">    Stack.push(pushV[i]);</span><br><span class="line">    while(!Stack.empty() &amp;&amp; Stack.top()==popV[popIndex])&#123;</span><br><span class="line">      Stack.pop();</span><br><span class="line">      popIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return Stack.empty();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-22-从上往下打印二叉树"><a href="#剑指offer-22-从上往下打印二叉树" class="headerlink" title="剑指offer 22 从上往下打印二叉树"></a>剑指offer 22 从上往下打印二叉树</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//双端队列</span><br><span class="line">vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">	vector&lt;int&gt; res;</span><br><span class="line">	if(root==NULL) return NULL;</span><br><span class="line">	deque&lt;TreeNode*&gt; d;</span><br><span class="line">	d.push_back(root);</span><br><span class="line">	while(!d.empty())&#123;</span><br><span class="line">		root=d.front();</span><br><span class="line">		if(root!=NULL)&#123;</span><br><span class="line">			res.push_back(root-&gt;val);</span><br><span class="line">			d.push_back(root-&gt;left);</span><br><span class="line">			d.push_back(root-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">		d.pop_front();</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">//队列</span><br><span class="line">vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    if(root==NULL)</span><br><span class="line">        return res;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        res.push_back(q.front()-&gt;val);</span><br><span class="line">        if(q.front()-&gt;left!=NULL)</span><br><span class="line">            q.push(q.front()-&gt;left);</span><br><span class="line">        if(q.front()-&gt;right!=NULL)</span><br><span class="line">            q.push(q.front()-&gt;right);</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-23-二叉搜索树的后序遍历序列"><a href="#剑指offer-23-二叉搜索树的后序遍历序列" class="headerlink" title="剑指offer 23 二叉搜索树的后序遍历序列"></a>剑指offer 23 二叉搜索树的后序遍历序列</h1><p>//输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。<br>//如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123;</span><br><span class="line">  if (sequence.empty()) &#123;</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br><span class="line">  return helper(sequence, 0, sequence.size() - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool helper(vector&lt;int&gt; &amp;sequence, int first, int last) &#123; // first和last表示树序列的开始和结束的位置</span><br><span class="line">  if(first &gt;= last)&#123;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line">  int curIdx = first;</span><br><span class="line">  int rootVal = sequence[last]; //后序遍历，根节点一定在最后，找到根节点后，就可以将树分为左右两棵子树，其中左子树中的元素都小于根节点，右子树中的元素都大于根节点</span><br><span class="line">  while(curIdx &lt; last &amp;&amp; sequence[curIdx] &lt; rootVal)&#123;</span><br><span class="line">      ++curIdx;</span><br><span class="line">  &#125;</span><br><span class="line">  int midIdx = curIdx; // 到curIdx的值大于根节点时，我们认为开始进入到右子树部分，用一个midIdx记录下当前的右子树开始的位置</span><br><span class="line">  while (curIdx &lt; last)&#123;</span><br><span class="line">      if(sequence[curIdx] &lt; rootVal)&#123;</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">      ++curIdx;</span><br><span class="line">  &#125;</span><br><span class="line">  return helper(sequence, first, midIdx - 1) &amp;&amp; helper(sequence, midIdx, last - 1); // 再分别对左子树和右子树做同样的操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-24-二叉树中和为某一值的所有路径"><a href="#剑指offer-24-二叉树中和为某一值的所有路径" class="headerlink" title="剑指offer 24 二叉树中和为某一值的所有路径"></a>剑指offer 24 二叉树中和为某一值的所有路径</h1><p>//输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。<br>//路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。<br>//(注意: 在返回值的list中，数组长度大的数组靠前)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">vector&lt;int&gt; path;</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123;</span><br><span class="line">	if(root==NULL || expectNumber&lt;=0) return res;</span><br><span class="line">	findHelper(root, expectNumber); </span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">void findHelper(TreeNode* root, int sum)&#123;</span><br><span class="line">	if(root==NULL) return;</span><br><span class="line">	path.push_back(root-&gt;val);</span><br><span class="line">	if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL &amp;&amp; root-&gt;val==sum)&#123;</span><br><span class="line">		res.push_back(path);</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		if(root-&gt;left!=NULL)&#123;</span><br><span class="line">			findHelper(root-&gt;left, sum-root-&gt;val);</span><br><span class="line">		&#125;</span><br><span class="line">		if(root-&gt;right!=NULL)&#123;</span><br><span class="line">			findHelper(root-&gt;right, sum-root-&gt;val);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	path.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-25-复杂链表的复制"><a href="#剑指offer-25-复杂链表的复制" class="headerlink" title="剑指offer 25 复杂链表的复制"></a>剑指offer 25 复杂链表的复制</h1><p>//输入一个复杂链表（每个节点中有节点值，以及两个指针，<br>//一个指向下一个节点，另一个特殊指针指向任意一个节点），<br>//返回结果为复制后复杂链表的head。<br>//（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct RandomListNode &#123;</span><br><span class="line">	int label;</span><br><span class="line">	struct RandomListNode *next, *random;</span><br><span class="line">	RandomListNode(int x) :</span><br><span class="line">		label(x), next(NULL), random(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    RandomListNode* Clone(RandomListNode* pHead)&#123;</span><br><span class="line">    	if(pHead==NULL) return NULL;</span><br><span class="line">    	RandomListNode* currentNode=pHead;</span><br><span class="line">    	//复制每个结点，将其插入结点后面</span><br><span class="line">    	while(currentNode!=NULL)&#123;</span><br><span class="line">    		RandomListNode* cloneNode = new RandomListNode(currentNode-&gt;label);</span><br><span class="line">    		RandomListNode* nextNode = currentNode-&gt;next;</span><br><span class="line">    		currentNode-&gt;next=cloneNode;</span><br><span class="line">    		cloneNode-&gt;next=nextNode;</span><br><span class="line">    		currentNode=nextNode;</span><br><span class="line">    	&#125;</span><br><span class="line">    	currentNode=pHead;</span><br><span class="line">    	//复制老结点的随机指针给新结点</span><br><span class="line">    	while(currentNode!=NULL)&#123;</span><br><span class="line">    		currentNode-&gt;next-&gt;random = currentNode-&gt;random==NULL?NULL:currentNode-&gt;random-&gt;next;</span><br><span class="line">    		currentNode=currentNode-&gt;next-&gt;next;</span><br><span class="line">    	&#125;</span><br><span class="line">    	//拆分链表</span><br><span class="line">    	currentNode=pHead;</span><br><span class="line">    	RandomListNode* pCloneHead=pHead-&gt;next;</span><br><span class="line">    	while(currentNode!=NULL)&#123;</span><br><span class="line">    		RandomListNode* cloneNode=currentNode-&gt;next;</span><br><span class="line">    		currentNode-&gt;next=cloneNode-&gt;next;</span><br><span class="line">    		cloneNode-&gt;next=cloneNode-&gt;next==NULL?NULL:cloneNode-&gt;next-&gt;next;</span><br><span class="line">    		currentNode=currentNode-&gt;next;</span><br><span class="line">    	&#125;</span><br><span class="line">    	return pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-26-二叉搜索树转双端链表"><a href="#剑指offer-26-二叉搜索树转双端链表" class="headerlink" title="剑指offer 26 二叉搜索树转双端链表**"></a>剑指offer 26 二叉搜索树转双端链表**</h1><p>//题目描述<br>//输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。<br>//要求不能创建任何新的结点，只能调整树中结点指针的指向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct TreeNode *left;</span><br><span class="line">	struct TreeNode *right;</span><br><span class="line">	TreeNode(int x) :</span><br><span class="line">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">TreeNode* Convert(TreeNode* pRootOfTree)&#123;</span><br><span class="line">if(pRootOfTree==NULL) return NULL;</span><br><span class="line">	TreeNode* pre=NULL;</span><br><span class="line">	convertHelper(pRootOfTree, pre);</span><br><span class="line">	TreeNode* res=pRootOfTree;</span><br><span class="line">	while(res-&gt;left)&#123;</span><br><span class="line">		res=res-&gt;left;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">void convertHelper(TreeNode* cur, TreeNode*&amp; pre)&#123;</span><br><span class="line">	if(cur==NULL) return;</span><br><span class="line">	convertHelper(cur-&gt;left, pre);</span><br><span class="line">	cur-&gt;left=pre;</span><br><span class="line">	if(pre) pre-&gt;right=cur;</span><br><span class="line">	pre=cur;</span><br><span class="line">	convertHelper(cur-&gt;right, pre);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-27-字符串的排列"><a href="#剑指offer-27-字符串的排列" class="headerlink" title="剑指offer 27 字符串的排列"></a>剑指offer 27 字符串的排列</h1><p>题目描述<br>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<br>输入描述:<br>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 1、递归算法</span><br><span class="line">     *</span><br><span class="line">     * 解析：http://www.cnblogs.com/cxjchen/p/3932949.html  (感谢该文作者！)</span><br><span class="line">     *</span><br><span class="line">     * 对于无重复值的情况</span><br><span class="line">     *</span><br><span class="line">     * 固定第一个字符，递归取得首位后面的各种字符串组合；</span><br><span class="line">     * 再把第一个字符与后面每一个字符交换，并同样递归获得首位后面的字符串组合； *递归的出口，就是只剩一个字符的时候，递归的循环过程，就是从每个子串的第二个字符开始依次与第一个字符交换，然后继续处理子串。</span><br><span class="line">     *</span><br><span class="line">     * 假如有重复值呢？</span><br><span class="line">     * *由于全排列就是从第一个数字起，每个数分别与它后面的数字交换，我们先尝试加个这样的判断——如果一个数与后面的数字相同那么这两个数就不交换了。</span><br><span class="line">     * 例如abb，第一个数与后面两个数交换得bab，bba。然后abb中第二个数和第三个数相同，就不用交换了。</span><br><span class="line">     * 但是对bab，第二个数和第三个数不 同，则需要交换，得到bba。</span><br><span class="line">     * 由于这里的bba和开始第一个数与第三个数交换的结果相同了，因此这个方法不行。</span><br><span class="line">     *</span><br><span class="line">     * 换种思维，对abb，第一个数a与第二个数b交换得到bab，然后考虑第一个数与第三个数交换，此时由于第三个数等于第二个数，</span><br><span class="line">     * 所以第一个数就不再用与第三个数交换了。再考虑bab，它的第二个数与第三个数交换可以解决bba。此时全排列生成完毕！</span><br><span class="line">     *</span><br><span class="line">     *</span><br><span class="line">     * @param str</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">vector&lt;string&gt; Permutation(string str) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        if(str.empty()) return res;</span><br><span class="line">        permutationHelper(str, res, 0, str.size()-1);</span><br><span class="line">        sort(res.begin(),res.end());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">void permutationHelper(string str, vector&lt;string&gt; &amp;res, int start, int end)&#123;</span><br><span class="line">    if(start==end) &#123;</span><br><span class="line">        res.push_back(str);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=start;i&lt;=end;i++)&#123;   //从str的头到尾都换一次</span><br><span class="line">        if(is_swap(str, start, i))&#123;</span><br><span class="line">            swap(str, start, i);</span><br><span class="line">            permutationHelper(str, res, start+1, end);</span><br><span class="line">            swap(str, start, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool is_swap(string str, int l, int r)&#123;</span><br><span class="line">    bool flag=true;</span><br><span class="line">    for(int i=l;i&lt;r;i++)&#123;  //l==r则跳过循环，比如aa可以加入res</span><br><span class="line">        if(str[i]==str[r])&#123;</span><br><span class="line">            flag=false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line">void swap(string &amp;str, int l, int r)&#123;</span><br><span class="line">    char tmp=str[l];</span><br><span class="line">    str[l]=str[r];</span><br><span class="line">    str[r]=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap(char* str,int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    char tmp = str[a];</span><br><span class="line">    str[a] = str[b];</span><br><span class="line">    str[b] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">     * 2、字典序排列算法</span><br><span class="line">     *</span><br><span class="line">     * 可参考解析： http://www.cnblogs.com/pmars/archive/2013/12/04/3458289.html  （感谢作者）</span><br><span class="line">     *</span><br><span class="line">     * 一个全排列可看做一个字符串，字符串可有前缀、后缀。</span><br><span class="line">     * 生成给定全排列的下一个排列.所谓一个的下一个就是这一个与下一个之间没有其他的。</span><br><span class="line">     * 这就要求这一个与下一个有尽可能长的共同前缀，也即变化限制在尽可能短的后缀上。</span><br><span class="line">     *</span><br><span class="line">     * [例]839647521是1--9的排列。1—9的排列最前面的是123456789，最后面的987654321，</span><br><span class="line">     * 从右向左扫描若都是增的，就到了987654321，也就没有下一个了。否则找出第一次出现下降的位置。</span><br><span class="line">     *</span><br><span class="line">     * 【例】 如何得到346987521的下一个</span><br><span class="line">     * 1，从尾部往前找第一个P(i-1) &lt; P(i)的位置</span><br><span class="line">     * 3 4 6 &lt;- 9 &lt;- 8 &lt;- 7 &lt;- 5 &lt;- 2 &lt;- 1</span><br><span class="line">     * 最终找到6是第一个变小的数字，记录下6的位置i-1</span><br><span class="line">     *</span><br><span class="line">     * 2，从i位置往后找到最后一个大于6的数</span><br><span class="line">     * 3 4 6 -&gt; 9 -&gt; 8 -&gt; 7 5 2 1</span><br><span class="line">     * 最终找到7的位置，记录位置为m</span><br><span class="line">     *</span><br><span class="line">     * 3，交换位置i-1和m的值</span><br><span class="line">     * 3 4 7 9 8 6 5 2 1</span><br><span class="line">     * 4，倒序i位置后的所有数据</span><br><span class="line">     * 3 4 7 1 2 5 6 8 9</span><br><span class="line">     * 则347125689为346987521的下一个排列</span><br><span class="line">     *</span><br><span class="line">     * @param str</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line"> </span><br><span class="line">public ArrayList&lt;String&gt; Permutation2(String str)&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">        if(str==null || str.length()==0)&#123;</span><br><span class="line">            return list;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] chars = str.toCharArray();</span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">        list.add(String.valueOf(chars));</span><br><span class="line">        int len = chars.length;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            int lIndex = len-1;</span><br><span class="line">            int rIndex;</span><br><span class="line">            while(lIndex&gt;=1 &amp;&amp; chars[lIndex-1]&gt;=chars[lIndex])&#123;</span><br><span class="line">                lIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            if(lIndex == 0)</span><br><span class="line">                break;</span><br><span class="line">            rIndex = lIndex;</span><br><span class="line">            while(rIndex&lt;len &amp;&amp; chars[rIndex]&gt;chars[lIndex-1])&#123;</span><br><span class="line">                rIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(chars,lIndex-1,rIndex-1);</span><br><span class="line">            reverse(chars,lIndex);</span><br><span class="line"> </span><br><span class="line">            list.add(String.valueOf(chars));</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private void reverse(char[] chars,int k)&#123;</span><br><span class="line">    if(chars==null || chars.length&lt;=k)</span><br><span class="line">        return;</span><br><span class="line">    int len = chars.length;</span><br><span class="line">    for(int i=0;i&lt;(len-k)/2;i++)&#123;</span><br><span class="line">        int m = k+i;</span><br><span class="line">        int n = len-1-i;</span><br><span class="line">        if(m&lt;=n)&#123;</span><br><span class="line">            swap(chars,m,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-28-数组中出现超过一半的数"><a href="#剑指offer-28-数组中出现超过一半的数" class="headerlink" title="剑指offer 28 数组中出现超过一半的数"></a>剑指offer 28 数组中出现超过一半的数</h1><p>//数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">// O(n) 空间O(n) 不追求元素排序，不用map或者hashmap</span><br><span class="line">int MoreThanHalfNum_Solution2(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">	int n = numbers.size();</span><br><span class="line">	//map 记录出现次数</span><br><span class="line">	unordered_map&lt;int, int&gt; m;</span><br><span class="line">	int count;</span><br><span class="line">	for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		count = ++m[numbers[i]];</span><br><span class="line">		if (count &gt; n/2) return numbers[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">// O(n) O(1)</span><br><span class="line">int MoreThanHalfNum_Solution1(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">	if(numbers.empty()) return 0;</span><br><span class="line">	int n = numbers.size(), num=numbers[0],count=1;</span><br><span class="line">	for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">		if(numbers[i]==num) count++;</span><br><span class="line">		else count--;</span><br><span class="line">		if(count==0)&#123;</span><br><span class="line">			num=numbers[i];</span><br><span class="line">			count=1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	count=0;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		if(numbers[i]==num) count++;</span><br><span class="line">	&#125;</span><br><span class="line">	return (count&gt;n/2)?num:0;</span><br><span class="line">&#125;</span><br><span class="line">//快排思想 O(n)?O(logn)?</span><br><span class="line">int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">	if(numbers.empty()) return 0;</span><br><span class="line">	int n = numbers.size(), mid=n/2,count=1;</span><br><span class="line">	int start=0,end=n-1;</span><br><span class="line">	int k=partition(numbers, 0, n-1);</span><br><span class="line">	while(k!=mid)&#123;</span><br><span class="line">		if(k&gt;mid)&#123;</span><br><span class="line">			end=k-1;</span><br><span class="line">			k=partition(numbers, start, end);</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			start=k+1;</span><br><span class="line">			k=partition(numbers, start, end);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int num=numbers[mid];</span><br><span class="line">	count=0;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		if(numbers[i]==num) count++;</span><br><span class="line">	&#125;</span><br><span class="line">	return (count&gt;n/2)?num:0;</span><br><span class="line">&#125;</span><br><span class="line">int partition(vector&lt;int&gt; &amp;numbers, int s, int e)&#123;</span><br><span class="line">	int pivot=numbers[s];</span><br><span class="line">	int leftmark=s+1, rightmark=e;</span><br><span class="line">	bool done=false;</span><br><span class="line">	while(!done)&#123;</span><br><span class="line">		while(leftmark&lt;=rightmark &amp;&amp; pivot&gt;=numbers[leftmark]) leftmark++;</span><br><span class="line">		while(leftmark&lt;=rightmark &amp;&amp; pivot&lt;=numbers[rightmark]) rightmark--;</span><br><span class="line">		if(leftmark&gt;rightmark) done=true;</span><br><span class="line">		else&#123;</span><br><span class="line">			swap(numbers, leftmark, rightmark);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(numbers, s, rightmark);</span><br><span class="line">	return rightmark;</span><br><span class="line">&#125;</span><br><span class="line">void swap(vector&lt;int&gt; &amp;v, int s, int e)&#123;</span><br><span class="line">	int tmp=v[s];</span><br><span class="line">	v[s]=v[e];</span><br><span class="line">	v[e]=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//拓展：输出数组中两个数量超过1/3的数 //投票法，讲道理partition应该也行1/3,2/3的位置</span><br><span class="line">vector&lt;int&gt; MoreThanOneThirdNum_Solution(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    if(numbers.empty()) return res;</span><br><span class="line">    int num1=0, num2=0, cnt1=0, cnt2=0, len = numbers.size();</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        if(numbers[i]==num1) cnt1++;</span><br><span class="line">        else if (numbers[i]==num2) cnt2++;</span><br><span class="line">        else if (cnt1==0) num1=numbers[i], cnt1=1;</span><br><span class="line">        else if (cnt2==0) num2=numbers[i], cnt2=1;</span><br><span class="line">        else cnt1--, cnt2--;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt1=0, cnt2=0;</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        if(numbers[i]==num1) cnt1++;</span><br><span class="line">        if(numbers[i]==num2) cnt2++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(cnt1&gt;len/3) res.push_back(num1);</span><br><span class="line">    if(cnt2&gt;len/3) res.push_back(num2);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>


<h1 id="剑指offer-29-最小的k个数"><a href="#剑指offer-29-最小的k个数" class="headerlink" title="剑指offer 29 最小的k个数**"></a>剑指offer 29 最小的k个数**</h1><p>//输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。partition O(n)-O(n^2）?牛客超时？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">	vector&lt;int&gt; res;</span><br><span class="line">	if(input.empty() || k&gt;input.size()) return res;</span><br><span class="line">	int len=input.size(), pos, s=0, e=len-1;</span><br><span class="line">	pos=par(input, 0, len-1);</span><br><span class="line">	while (pos!=k)&#123;</span><br><span class="line">		if (pos&gt;k) e=pos-1,pos=par(input, s, e);</span><br><span class="line">		else s=pos+1,pos=par(input, s, e);</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">		res.push_back(input[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(res.begin(),res.end());</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">int par(vector&lt;int&gt; &amp;arr, int s, int e)&#123;</span><br><span class="line">	int pivot=arr[s];</span><br><span class="line">	int l=s+1, r=e;</span><br><span class="line">	bool done=false;</span><br><span class="line">	while(!done)&#123;</span><br><span class="line">		while(l&lt;=r &amp;&amp; arr[l]&lt;=pivot) </span><br><span class="line">			l++;</span><br><span class="line">		while(l&lt;=r &amp;&amp; arr[r]&gt;=pivot) </span><br><span class="line">			r--;</span><br><span class="line">		if(l&gt;r) done=true;</span><br><span class="line">		else swap(arr, l, r); </span><br><span class="line">	&#125;</span><br><span class="line">	swap(arr, s, r);</span><br><span class="line">	return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//最大堆，待写</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-30-连续子数组最大和"><a href="#剑指offer-30-连续子数组最大和" class="headerlink" title="剑指offer 30 连续子数组最大和"></a>剑指offer 30 连续子数组最大和</h1><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//DP O(n) O(1)</span><br><span class="line">int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</span><br><span class="line">	if(array.empty()) return 0;</span><br><span class="line">	int len=array.size();</span><br><span class="line">	int res=array[0], pre=array[0];</span><br><span class="line">	for(int i=1;i&lt;len;i++)&#123;</span><br><span class="line">		pre=max(array[i], pre+array[i]);</span><br><span class="line">		if(res&lt;pre) res=pre;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="剑指offer-31-整数中1的个数"><a href="#剑指offer-31-整数中1的个数" class="headerlink" title="剑指offer 31 整数中1的个数"></a>剑指offer 31 整数中1的个数</h1><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数?为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int NumberOf1Between1AndN_Solution(int n)&#123;</span><br><span class="line">    if(n&lt;0) return 0;</span><br><span class="line">    int count=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i*=10)&#123;</span><br><span class="line">        int k=i*10;</span><br><span class="line">        count+=(n/k)*i+min(max(n%k-i+1, 0), i);</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
 <div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-32-把数组排成最小的数"><a href="#剑指offer-32-把数组排成最小的数" class="headerlink" title="剑指offer 32 把数组排成最小的数**"></a>剑指offer 32 把数组排成最小的数**</h1><p>//输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	static bool cmp(int a, int b)&#123;</span><br><span class="line">		string A=&quot;&quot;;</span><br><span class="line">		string B=&quot;&quot;;</span><br><span class="line">		A += to_string(a);</span><br><span class="line">		A += to_string(b);</span><br><span class="line">		B += to_string(b);</span><br><span class="line">		B += to_string(a);</span><br><span class="line">		return A&lt;B;</span><br><span class="line">	&#125;</span><br><span class="line">	string PrintMinNumber(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">		string res=&quot;&quot;;</span><br><span class="line">		if(numbers.empty()) return res;</span><br><span class="line">		sort(numbers.begin(), numbers.end(), cmp);</span><br><span class="line">		for(int i=0;i&lt;numbers.size();i++)&#123;</span><br><span class="line">			res+=to_string(numbers[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="剑指offer-33-丑数"><a href="#剑指offer-33-丑数" class="headerlink" title="剑指offer 33 丑数"></a>剑指offer 33 丑数</h1><p>//把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int GetUglyNumber_Solution(int index) &#123;</span><br><span class="line">		if(index&lt;1) return 0;</span><br><span class="line">		vector&lt;int&gt; ugly(index, 1);</span><br><span class="line">		int pointer2=0, pointer3=0, pointer5=0;</span><br><span class="line">		for(int i=1;i&lt;index;i++)&#123;</span><br><span class="line">			ugly[i] = findmin(ugly[pointer2]*2, ugly[pointer3]*3, ugly[pointer5]*5);</span><br><span class="line">			if(ugly[pointer2]*2==ugly[i]) pointer2++;</span><br><span class="line">			if(ugly[pointer3]*3==ugly[i]) pointer3++;</span><br><span class="line">			if(ugly[pointer5]*5==ugly[i]) pointer5++;</span><br><span class="line">		&#125;</span><br><span class="line">		return ugly[index-1];</span><br><span class="line">    &#125;</span><br><span class="line">int findmin(int a, int b, int c)&#123;</span><br><span class="line">		int tmp = a&gt;b?b:a;</span><br><span class="line">		int tmp2 = tmp&gt;c?c:tmp;</span><br><span class="line">		return tmp2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="剑指offer-34-第一次出现的字符"><a href="#剑指offer-34-第一次出现的字符" class="headerlink" title="剑指offer 34 第一次出现的字符"></a>剑指offer 34 第一次出现的字符</h1><p>//在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int FirstNotRepeatingChar(string str) &#123;</span><br><span class="line">  int res=-1;</span><br><span class="line">  if(str.empty()) return res;</span><br><span class="line">  int len=str.size();</span><br><span class="line">  unordered_map&lt;char, int&gt; mp;</span><br><span class="line">  for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">    mp[str[i]]++;</span><br><span class="line">    // cout&lt;&lt;mp[str[i]]&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">    cout&lt;&lt;mp[str[i]]&lt;&lt;endl;</span><br><span class="line">    if(mp[str[i]]==1)&#123;</span><br><span class="line">       res=i;break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-35-数组中的逆序对"><a href="#剑指offer-35-数组中的逆序对" class="headerlink" title="剑指offer 35 数组中的逆序对**"></a>剑指offer 35 数组中的逆序对**</h1><p>//在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007。例子：输入 1,2,3,4,5,6,7,0 输出 7<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//暴力求解 O(N*N)</span><br><span class="line">int InversePairs2(vector&lt;int&gt; data) &#123;</span><br><span class="line">    int res=0;</span><br><span class="line">    if(data.empty()) return res;</span><br><span class="line">    int len=data.size();</span><br><span class="line">    for(int i=len-1;i&gt;=0;i--)&#123;</span><br><span class="line">        for(int j=i-1;j&gt;=0;j--)&#123;</span><br><span class="line">            if(data[j]&gt;data[i]) res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">//归并排序 O(nlogn)</span><br><span class="line">int InversePairs(vector&lt;int&gt; data) &#123;</span><br><span class="line">	int res=0;</span><br><span class="line">	if(data.empty()) return res;</span><br><span class="line">	int len=data.size();</span><br><span class="line">	vector&lt;int&gt; cp(len, 0);</span><br><span class="line">	for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">		cp[i]=data[i];</span><br><span class="line">	&#125;</span><br><span class="line">	res = mergeCount(data, cp, 0, len-1);</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">int mergeCount(vector&lt;int&gt; &amp;arr, vector&lt;int&gt; &amp;cp, int s, int e)&#123;</span><br><span class="line">	if(s==e) return 0;</span><br><span class="line">	int mid=(s+e)&gt;&gt;1;</span><br><span class="line">	int leftCount=mergeCount(arr, cp, s, mid)%1000000007;</span><br><span class="line">	int rightCount=mergeCount(arr, cp, mid+1, e)%1000000007;</span><br><span class="line">	int count=0,i=mid,j=e,locCopy=e;</span><br><span class="line">	while(i&gt;=s &amp;&amp; j&gt;mid)&#123;</span><br><span class="line">		if(arr[i]&gt;arr[j])&#123;</span><br><span class="line">			count += j-mid;</span><br><span class="line">			cp[locCopy--] = arr[i--];</span><br><span class="line">			if(count&gt;=1000000007) count%=1000000007;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			cp[locCopy--] = arr[j--];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(;i&gt;=s;i--)&#123;</span><br><span class="line">		cp[locCopy--]=arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	for(;j&gt;mid;j--)&#123;</span><br><span class="line">		cp[locCopy--]=arr[j];</span><br><span class="line">	&#125;</span><br><span class="line">	for(int ss=s;ss&lt;=e;ss++)&#123;</span><br><span class="line">		arr[ss]=cp[ss];</span><br><span class="line">	&#125;</span><br><span class="line">	return (leftCount+rightCount+count)%1000000007;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="剑指offer-36-两个链表的第一个公共结点"><a href="#剑指offer-36-两个链表的第一个公共结点" class="headerlink" title="剑指offer 36 两个链表的第一个公共结点"></a>剑指offer 36 两个链表的第一个公共结点</h1><p>输入两个链表，找出它们的第一个公共结点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 若有公共结点，让最长的链表先走len1-len2步，再一起走，必会相交</span><br><span class="line">ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) &#123;</span><br><span class="line">    if(pHead1==NULL || pHead2==NULL) return NULL;</span><br><span class="line">	int len1 = findLinkedListLength(pHead1);</span><br><span class="line">	int len2 = findLinkedListLength(pHead2);</span><br><span class="line">	if(len1&gt;len2)&#123;</span><br><span class="line">		pHead1=walkK(pHead1, len1-len2);</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		pHead2 = walkK(pHead2, len2-len1);</span><br><span class="line">	&#125;</span><br><span class="line">	while(pHead1!=NULL &amp;&amp; pHead2!=NULL)&#123;</span><br><span class="line">		if(pHead1==pHead2) return pHead1;</span><br><span class="line">		pHead1=pHead1-&gt;next;</span><br><span class="line">		pHead2=pHead2-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int findLinkedListLength(ListNode* pHead)&#123;</span><br><span class="line">	int res=0;</span><br><span class="line">	while(pHead!=NULL)&#123;</span><br><span class="line">		pHead = pHead-&gt;next;</span><br><span class="line">		res++;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">ListNode* walkK(ListNode* pHead, int k)&#123;</span><br><span class="line">	while(k--)&#123;</span><br><span class="line">		pHead=pHead-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	return pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-37-数组在排序数组出现的次数"><a href="#剑指offer-37-数组在排序数组出现的次数" class="headerlink" title="剑指offer 37 数组在排序数组出现的次数"></a>剑指offer 37 数组在排序数组出现的次数</h1><p>//统计一个数字在排序数组中出现的次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// O(n) O(1)</span><br><span class="line">int GetNumberOfK1(vector&lt;int&gt; data ,int k) &#123;</span><br><span class="line">      if(data.empty()) return 0;</span><br><span class="line">  int res=0;</span><br><span class="line">  for(int i=0;i&lt;data.size();i++)&#123;</span><br><span class="line">    if(data[i]==k) res++;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">  &#125;</span><br><span class="line">// O(logn) O(1)</span><br><span class="line">int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123;</span><br><span class="line">      if(data.empty()) return 0;</span><br><span class="line">  int start=0, end=data.size()-1, res=0;</span><br><span class="line">  while(start&lt;=end)&#123;</span><br><span class="line">    int mid=(start+end)&gt;&gt;1;</span><br><span class="line">    if(data[mid]&gt;k)&#123;</span><br><span class="line">      end=mid-1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(data[mid]&lt;k) &#123;</span><br><span class="line">      start=mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      int l=mid, r=mid;</span><br><span class="line">      res++;</span><br><span class="line">      while(data[--l]==k) res++;</span><br><span class="line">      while(data[++r]==k) res++;</span><br><span class="line">      cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-38-二叉树深度"><a href="#剑指offer-38-二叉树深度" class="headerlink" title="剑指offer 38 二叉树深度"></a>剑指offer 38 二叉树深度</h1><p>//输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//递归</span><br><span class="line">int TreeDepth(TreeNode* pRoot) &#123;</span><br><span class="line">  if(pRoot==NULL) return 0;</span><br><span class="line">  return max(TreeDepth(pRoot-&gt;left), TreeDepth(pRoot-&gt;right))+1;</span><br><span class="line">&#125;</span><br><span class="line">//非递归</span><br><span class="line">int TreeDepthNotLoop(TreeNode* pRoot) &#123;</span><br><span class="line">  int res=0;</span><br><span class="line">  if(pRoot==NULL) return res;</span><br><span class="line">  queue&lt;TreeNode *&gt; q;</span><br><span class="line">  q.push(pRoot);</span><br><span class="line">  while(!q.empty()) &#123;</span><br><span class="line">    int size=q.size();</span><br><span class="line">    res++;</span><br><span class="line">    for(int i=0;i&lt;size;i++)&#123;</span><br><span class="line">        TreeNode* top=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(top-&gt;left) q.push(top-&gt;left);</span><br><span class="line">        if(top-&gt;right) q.push(top-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res; &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="剑指offer-39-判断平衡二叉树"><a href="#剑指offer-39-判断平衡二叉树" class="headerlink" title="剑指offer 39 判断平衡二叉树"></a>剑指offer 39 判断平衡二叉树</h1><p>//输入一棵二叉树，判断该二叉树是否是平衡二叉树。如果二叉树的每个节点的左子树和右子树的深度不大于1，它就是平衡二叉树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool IsBalanced_Solution(TreeNode* pRoot)&#123;</span><br><span class="line">  return pos_travel(pRoot)!=-1;</span><br><span class="line">  &#125;</span><br><span class="line">int pos_travel(TreeNode* pRoot)&#123;</span><br><span class="line">  if(pRoot==NULL) return 0;</span><br><span class="line">  int left=pos_travel(pRoot-&gt;left);</span><br><span class="line">  if(left==-1) return -1;</span><br><span class="line">  int right=pos_travel(pRoot-&gt;right);</span><br><span class="line">  if(right==-1) return -1;</span><br><span class="line">  return abs(left-right)&gt;1?-1:1+max(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-40-数组中只出现一次的数字"><a href="#剑指offer-40-数组中只出现一次的数字" class="headerlink" title="剑指offer 40 数组中只出现一次的数字"></a>剑指offer 40 数组中只出现一次的数字</h1><p>//一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//input vector&lt;int&gt; arr=&#123;1,4,4,5,5,7&#125;;</span><br><span class="line">void FindNumsAppearOnce(vector &lt;int&gt; data, int* num1, int *num2) &#123;</span><br><span class="line">    if(data.empty()) return;</span><br><span class="line">    int len=data.size();</span><br><span class="line">    unordered_map &lt;int, int&gt; mp;</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        mp[data[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        if(mp[data[i]]==1)&#123;</span><br><span class="line">            res.push_back(data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *num1 = res[0];</span><br><span class="line">    *num2 = res[1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int find1From2(int[] a)&#123;</span><br><span class="line">    int len = a.length, res = 0;</span><br><span class="line">    for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="line">        res = res ^ a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="剑指offer-41-和为S的连续正数序列"><a href="#剑指offer-41-和为S的连续正数序列" class="headerlink" title="剑指offer 41 和为S的连续正数序列"></a>剑指offer 41 和为S的连续正数序列</h1><p>//输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; vOut;</span><br><span class="line">    vector&lt;int&gt; vIn;</span><br><span class="line">    if(sum==1) &#123;</span><br><span class="line">        vIn.push_back(1);</span><br><span class="line">        vOut.push_back(vIn);</span><br><span class="line">        return vOut;</span><br><span class="line">    &#125;</span><br><span class="line">    int left=1, right=2;</span><br><span class="line">    while(left&lt;right)&#123;</span><br><span class="line">        int k=(left+right)*(right-left+1)/2;</span><br><span class="line">        if(sum==k) &#123;</span><br><span class="line">            vector&lt;int&gt; vTmp;</span><br><span class="line">            for(int i=left;i&lt;=right;i++)&#123;</span><br><span class="line">                vTmp.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            vOut.push_back(vTmp);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(sum&gt;k) &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return vOut;</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123;</span><br><span class="line">  vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">  if(sum&lt;=2) return res;</span><br><span class="line">  int up=sqrt(2*sum);</span><br><span class="line">  for(int i=up;i&gt;=2;i--)&#123;</span><br><span class="line">    int n = sum/i;</span><br><span class="line">    if(i%2==1 &amp;&amp; sum%i==0)&#123;</span><br><span class="line">      vector&lt;int&gt; tmp;</span><br><span class="line">      for(int j=n-(i-1)/2;j&lt;=n+(i-1)/2;j++)&#123;</span><br><span class="line">        tmp.push_back(j);</span><br><span class="line">      &#125;</span><br><span class="line">      res.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    if(i%2==0 &amp;&amp; sum%i*2==i)&#123;</span><br><span class="line">      vector&lt;int&gt; tmp;</span><br><span class="line">      for(int j=n-(i-2)/2;j&lt;=n+(i-2)/2+1;j++)&#123;</span><br><span class="line">        tmp.push_back(j);</span><br><span class="line">      &#125;</span><br><span class="line">      res.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-42-和为S的两个数"><a href="#剑指offer-42-和为S的两个数" class="headerlink" title="剑指offer 42 和为S的两个数"></a>剑指offer 42 和为S的两个数</h1><p>//输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123;</span><br><span class="line">  vector&lt;int&gt; res;</span><br><span class="line">  if(array.empty()) return res;</span><br><span class="line">  int low=0, high=array.size()-1, Min=INT32_MAX;</span><br><span class="line">  while(low&lt;high)&#123;</span><br><span class="line">    cout&lt;&lt;low&lt;&lt;&quot; &quot;&lt;&lt;high&lt;&lt;endl;</span><br><span class="line">    int add = array[low]+array[high], product= array[low]*array[high];</span><br><span class="line">    if(sum==add) &#123;</span><br><span class="line">      if(product&lt;Min)&#123;</span><br><span class="line">        Min = product;</span><br><span class="line">        while(!res.empty())&#123;</span><br><span class="line">          res.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(array[low]);</span><br><span class="line">        res.push_back(array[high]);</span><br><span class="line">      &#125;</span><br><span class="line">      low++;high--;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (sum&lt;add)&#123;</span><br><span class="line">      high--;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">      low++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-43-左旋转字符串"><a href="#剑指offer-43-左旋转字符串" class="headerlink" title="剑指offer 43 左旋转字符串"></a>剑指offer 43 左旋转字符串</h1><p>//汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">string LeftRotateStringCircle(string str, int n) &#123;</span><br><span class="line">	if (str.empty()) return &quot;&quot;;</span><br><span class="line">	deque&lt;char&gt; q;</span><br><span class="line">	for (int i=0;i&lt;str.size();i++)&#123;</span><br><span class="line">		q.push_back(str[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	while(n!=0) &#123;</span><br><span class="line">		char tmp = q.front();</span><br><span class="line">		q.pop_front();</span><br><span class="line">		q.push_back(tmp);</span><br><span class="line">		n--;</span><br><span class="line">	&#125;</span><br><span class="line">	string res=&quot;&quot;;</span><br><span class="line">	for (int i=0;i&lt;q.size();i++)&#123;</span><br><span class="line">		res = res+q[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">string LeftRotateString(string str, int n) &#123;</span><br><span class="line">	if (str.empty()) return &quot;&quot;;</span><br><span class="line">	n = n % str.size();</span><br><span class="line">	reverse(str.begin(), str.end());</span><br><span class="line">	reverse(str.begin(), str.begin()+str.size()-n);</span><br><span class="line">	reverse(str.begin()+str.size()-n, str.end());</span><br><span class="line">	return str;</span><br><span class="line">&#125;</span><br><span class="line">//自写reverse函数</span><br><span class="line">void reverse1(string&amp; str, int s, int e)&#123;</span><br><span class="line">    while (s &lt; e) &#123;</span><br><span class="line">        char temp = str[s];</span><br><span class="line">        str[s] = str[e];</span><br><span class="line">        str[e] = temp;</span><br><span class="line">        s++;</span><br><span class="line">        e--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-44-翻转单词顺序列"><a href="#剑指offer-44-翻转单词顺序列" class="headerlink" title="剑指offer 44 翻转单词顺序列"></a>剑指offer 44 翻转单词顺序列</h1><p>// “student. a am I”-&gt;“I am a student.”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">string ReverseSentence1(string str) &#123;</span><br><span class="line">	string res = &quot;&quot;;</span><br><span class="line">	if(str.empty()) return res;</span><br><span class="line">	vector &lt;string&gt; s;</span><br><span class="line">	int index=0;</span><br><span class="line">	string tmp=&quot;&quot;;</span><br><span class="line">	while(index &lt; str.size())&#123;</span><br><span class="line">		if (str[index]==&apos; &apos;) &#123;</span><br><span class="line">			s.push_back(tmp);</span><br><span class="line">			tmp=&quot;&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			tmp+=str[index];</span><br><span class="line">		&#125;</span><br><span class="line">		if(index==str.size()-1) s.push_back(tmp);</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i=s.size()-1;i&gt;=0;i--) &#123;</span><br><span class="line">		res += s[i];</span><br><span class="line">		if(i!=0) res += &apos; &apos;;</span><br><span class="line">	&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">string ReverseSentence(string str) &#123;</span><br><span class="line">	std::reverse(str.begin(),str.end());</span><br><span class="line">	int front=0;</span><br><span class="line">	int back=0;</span><br><span class="line">	int size = str.size();</span><br><span class="line">	while(front&lt;size)&#123;</span><br><span class="line">	    while(front&lt;size&amp;&amp;str[front]==&apos; &apos;)++front; //跳过空格，找第一个非空字母位置</span><br><span class="line">	    back = front;</span><br><span class="line">	    while(back&lt;size&amp;&amp;str[back]!=&apos; &apos;)++back; //找单词最后一个字符的位置</span><br><span class="line">	    std::reverse(str.begin()+front, str.begin()+back); //反转</span><br><span class="line">	    front = back;</span><br><span class="line">	&#125;</span><br><span class="line">	return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-45-扑克牌顺子"><a href="#剑指offer-45-扑克牌顺子" class="headerlink" title="剑指offer 45 扑克牌顺子"></a>剑指offer 45 扑克牌顺子</h1><p>//一组数字，判断是否顺子。0为任意数，如果牌能组成顺子就输出true，否则就输出false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// O(n)</span><br><span class="line">bool IsContinuous( vector&lt;int&gt; numbers ) &#123;</span><br><span class="line">    if(numbers.empty()) return false;</span><br><span class="line">    vector&lt;int&gt; arr(14, 0);</span><br><span class="line">    arr[0]=-5;</span><br><span class="line">    int Min=14, Max=-1;</span><br><span class="line">    for (int i=0;i&lt;numbers.size();i++)&#123;</span><br><span class="line">        arr[numbers[i]]++;</span><br><span class="line">        if(numbers[i]==0) continue;</span><br><span class="line">        if(arr[numbers[i]]&gt;1) return false;</span><br><span class="line">        if (numbers[i]&lt;Min) &#123;</span><br><span class="line">            Min = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if (numbers[i]&gt;Max) &#123;</span><br><span class="line">            Max = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(Max-Min&gt;4) return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">// O(nlogn)</span><br><span class="line">bool IsContinuous( vector&lt;int&gt; numbers ) &#123;</span><br><span class="line">    sort(numbers.begin(), numbers.end());</span><br><span class="line">    int cnt0 = 0, cntNeed = 0;</span><br><span class="line">    for(int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        if(numbers[i] == 0) &#123;</span><br><span class="line">            ++cnt0;</span><br><span class="line">        &#125; else if(i + 1 &lt; 5 ) &#123;</span><br><span class="line">            if(numbers[i + 1] == numbers[i]) return false;</span><br><span class="line">            cntNeed += numbers[i + 1] - numbers[i] - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(cntNeed &gt; cnt0) return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-46-孩子们的游戏（圆圈里最后剩下的数）"><a href="#剑指offer-46-孩子们的游戏（圆圈里最后剩下的数）" class="headerlink" title="剑指offer 46 孩子们的游戏（圆圈里最后剩下的数）"></a>剑指offer 46 孩子们的游戏（圆圈里最后剩下的数）</h1><p>//约瑟夫圆环。一个数m,编号为0开始报数，m-1的出列，下一个继续从0开始，直至最后一个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">int LastRemaining_Solution(int n, int m) &#123;</span><br><span class="line">  if(n==0 || m&lt;=0) return -1;</span><br><span class="line">  if (n==1) return 0;</span><br><span class="line">  vector&lt;int&gt; v;</span><br><span class="line">  for (int i=0;i&lt;n;i++) &#123;</span><br><span class="line">    v.push_back(i);</span><br><span class="line">  &#125;</span><br><span class="line">  int p = 0;</span><br><span class="line">  while(v.size()&gt;1) &#123;</span><br><span class="line">    n = v.size();</span><br><span class="line">    p = (p+m) % n - 1;</span><br><span class="line">    if (p == -1) p = n-1;</span><br><span class="line">    v.erase(v.begin()+p);</span><br><span class="line">  &#125;</span><br><span class="line">  return v[0];</span><br><span class="line">  &#125;</span><br><span class="line">//公式dp</span><br><span class="line">  int LastRemaining_Solution1(unsigned int n, unsigned int m)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">      if(n &lt;= 0 &amp;&amp; m &lt;= 0) return -1; //蛋疼的特殊条件</span><br><span class="line">      int t = 0;</span><br><span class="line">      for(int i = 2; i &lt;= n; i++)</span><br><span class="line">          t = (t + m) % i;</span><br><span class="line">      return t;</span><br><span class="line">  &#125;</span><br><span class="line">//模拟循环链表</span><br><span class="line">int LastRemaining_Solution2(int n, int m)//n为人数</span><br><span class="line">&#123;</span><br><span class="line">  if(n&lt;1||m&lt;1)</span><br><span class="line">      return -1;</span><br><span class="line">  list&lt;int&gt; numbers;</span><br><span class="line">  for(int i=0;i&lt;n;i++)</span><br><span class="line">      numbers.push_back(i);</span><br><span class="line">  list&lt;int&gt;::iterator current=numbers.begin();</span><br><span class="line">  while(numbers.size()&gt;1)</span><br><span class="line">  &#123;</span><br><span class="line">      for(int i=1;i&lt;m;i++)//走m-1步到达第m个数处</span><br><span class="line">      &#123;</span><br><span class="line">          ++current;</span><br><span class="line">          if(current==numbers.end())</span><br><span class="line">              current=numbers.begin();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      list&lt;int&gt;::iterator next=++current;</span><br><span class="line">      if(next==numbers.end())</span><br><span class="line">          next=numbers.begin();</span><br><span class="line">      --current;</span><br><span class="line">      numbers.erase(current);</span><br><span class="line">      current=next;</span><br><span class="line">  &#125;</span><br><span class="line">  return *current;//对迭代器取值，等价于对指针取值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="剑指offer-47-求1-2-…-n"><a href="#剑指offer-47-求1-2-…-n" class="headerlink" title="剑指offer 47 求1+2+…+n"></a>剑指offer 47 求1+2+…+n</h1><p>//求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int Sum_Solution(int n) &#123;</span><br><span class="line">  if (n&lt;=0) return 0;</span><br><span class="line">  if (n==1) return 1;</span><br><span class="line">  return Sum_Solution(n-1)+n;</span><br><span class="line"> &#125;</span><br><span class="line">int Sum_Solution(int n) &#123;</span><br><span class="line">    int ans = n;</span><br><span class="line">//逻辑与有个短路特点，前面为假，后面不计算。</span><br><span class="line">    ans &amp;&amp; (ans += Sum_Solution(n - 1));</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="剑指offer-48-不用加减乘除做加法"><a href="#剑指offer-48-不用加减乘除做加法" class="headerlink" title="剑指offer 48 不用加减乘除做加法"></a>剑指offer 48 不用加减乘除做加法</h1><p>//求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。用三步走的方式计算二进制值相加：5-101，7-111,第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101 &amp; 111) \&lt;\&lt; 1。第三步重复上述两步， 各位相加 0 1 0 \^ 1 0 1 0 = 1 0 0 0，进位值为100 = (010 \&amp; 1010)\&lt;\&lt; 1。继续重复上述两步：1000\^100 = 1100，进位值为0，跳出循环，1100为最终结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int Add(int num1, int num2) &#123;</span><br><span class="line">    while(num2!=0)&#123;</span><br><span class="line">        int tmp = num1^num2;</span><br><span class="line">        num2 = (num1&amp;num2)&lt;&lt;1;</span><br><span class="line">        num1=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-49-把字符串转换为整数"><a href="#剑指offer-49-把字符串转换为整数" class="headerlink" title="剑指offer 49 把字符串转换为整数"></a>剑指offer 49 把字符串转换为整数</h1><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int StrToInt(string str) &#123;</span><br><span class="line">    if(str.empty()) return 0;</span><br><span class="line">    int res=0, symbol=1;</span><br><span class="line">    if(str[0]==&apos;+&apos;) &#123;</span><br><span class="line">        str[0]=&apos;0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(str[0]==&apos;-&apos;) &#123;</span><br><span class="line">        symbol=-1;</span><br><span class="line">        str[0] = &apos;0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;str.size();i++) &#123;</span><br><span class="line">        if(str[i]&lt;&apos;0&apos; || str[i]&gt;&apos;9&apos;) &#123;</span><br><span class="line">            res = 0;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        res = res*10 + str[i]-&apos;0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return symbol*res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="剑指offer-50-数组中重复的数字"><a href="#剑指offer-50-数组中重复的数字" class="headerlink" title="剑指offer 50 数组中重复的数字"></a>剑指offer 50 数组中重复的数字</h1><p>// 在一个长度为n的数组里的所有数字都在0到n-1的范围内.数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Parameters:</span><br><span class="line">//        numbers:     an array of integers</span><br><span class="line">//        length:      the length of array numbers</span><br><span class="line">//        duplication: (Output) the duplicated number in the array number</span><br><span class="line">bool duplicate1(int numbers[], int length, int* duplication) &#123;</span><br><span class="line">	bool res=false;</span><br><span class="line">	if(length==0) return res;</span><br><span class="line">	unordered_map&lt;int, int&gt; mp;</span><br><span class="line">	for(int i=0;i&lt;length;i++) &#123;</span><br><span class="line">		if (mp.count(numbers[i])==0) &#123;</span><br><span class="line">			mp[numbers[i]] ++;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			*duplication = numbers[i];</span><br><span class="line">			res = true;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>//思路二：剑指offer中解法：因为数组中数字都在0~n - 1，所以若无重复数字排好序则数字i将出现在下标i的位置。<br>//解法：从头到尾扫描这个数组，当扫描到下标为i的数字m时，先比较这个数字是否等于i，是则扫描下一个数字，否则<br>//将该数字与下标为m的数字进行比较，若相等，则找到一个重复的数字，否则将两个数字交换，并继续对该位置<br>//（下标i）重复上面比较过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">bool duplicate(int numbers[], int length, int* duplication) &#123;</span><br><span class="line">	bool res = false;</span><br><span class="line">	if (length == 0) return res;</span><br><span class="line">	int i = 0;</span><br><span class="line">	while(i&lt;length) &#123;</span><br><span class="line">		if (numbers[i] == i) &#123;</span><br><span class="line">			i++;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		if (numbers[numbers[i]] == numbers[i]) &#123;</span><br><span class="line">			res = true;</span><br><span class="line">			*duplication = numbers[i];</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			int tmp = numbers[i];</span><br><span class="line">			numbers[i] = numbers[tmp];</span><br><span class="line">			numbers[tmp] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-51-构建乘积数组"><a href="#剑指offer-51-构建乘积数组" class="headerlink" title="剑指offer 51 构建乘积数组"></a>剑指offer 51 构建乘积数组</h1><p>给定一个数组A[0, 1, …, n - 1], 请构建一个数组B[0, 1, …, n - 1],其中B中的元素B[i] = A[0] <em> A[1] </em> … <em> A[i - 1] </em> A[i + 1] <em> … </em> A[n - 1]。不能使用除法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// recurrent O(n\*n)</span><br><span class="line">vector&lt;int&gt; multiplyN2(const vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">  vector&lt;int&gt; B;</span><br><span class="line">  if (A.empty()) return B;</span><br><span class="line">  for (int i = 0; i &lt; A.size(); i++) &#123;</span><br><span class="line">    B.push_back(ABhelper(A, A.size()-1, i));</span><br><span class="line">  &#125;</span><br><span class="line">  return B;</span><br><span class="line">&#125;</span><br><span class="line">int ABhelper(vector&lt;int&gt; A, int n, int k) &#123;</span><br><span class="line">  if (n == k &amp;&amp; n == 0) return 1;</span><br><span class="line">  if (n == k &amp;&amp; n &gt; 0) return ABhelper(A, n - 1, k);</span><br><span class="line">  if (n == 0) return A[0];</span><br><span class="line">  return ABhelper(A, n - 1, k) * A[n];</span><br><span class="line">&#125;</span><br><span class="line">// 上下三角求解合并</span><br><span class="line">//链接：https://www.nowcoder.com/questionTerminal/94a4d381a68b47b7a8bed86f2975db46?f=discussion</span><br><span class="line">vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">  vector&lt;int&gt; B;</span><br><span class="line">  if (A.empty()) return B;</span><br><span class="line">  int len = A.size();</span><br><span class="line">  // cal up triangle</span><br><span class="line">  B.push_back(1);</span><br><span class="line">  for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">    B.push_back(B[i - 1] * A[i - 1]);</span><br><span class="line">  &#125;</span><br><span class="line">  // cal down triangle</span><br><span class="line">  int down =1;</span><br><span class="line">  for (int i = len - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">    down *= A[i + 1];</span><br><span class="line">    B[i] *= down;</span><br><span class="line">  &#125;</span><br><span class="line">  return B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-52-正则表达式匹配"><a href="#剑指offer-52-正则表达式匹配" class="headerlink" title="剑指offer 52 正则表达式匹配"></a>剑指offer 52 正则表达式匹配</h1><p>//请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">bool match(char* str, char* pattern)&#123;</span><br><span class="line">    if (str == NULL || pattern == NULL)  return false;</span><br><span class="line">    int strIndex = 0, patternIndex = 0;</span><br><span class="line">    return matchHelper(str, pattern);</span><br><span class="line">&#125;</span><br><span class="line">bool matchHelper(char* str, char* pattern) &#123;</span><br><span class="line">    // str到尾，pattern到尾，匹配成功</span><br><span class="line">    // 注意下指针和string字符串判断是否为空的区别</span><br><span class="line">    if (*str == &apos;\0&apos; &amp;&amp; *pattern == &apos;\0&apos;) return true;</span><br><span class="line">    // pattern为空，str不空，匹配必定失败</span><br><span class="line">    if (*pattern == &apos;\0&apos; &amp;&amp; *str != &apos;\0&apos;) return false;</span><br><span class="line"></span><br><span class="line">    // 如果pattern下一个字符不为&apos;*&apos;</span><br><span class="line">    if (*(pattern + 1) != &apos;*&apos;) &#123;</span><br><span class="line">        // 匹配成功情况：</span><br><span class="line">        // 1. 当前str字符==当前pattern字符</span><br><span class="line">        // 2. pattern为&apos;.&apos;且当前str不为空</span><br><span class="line">        if (*pattern == *str || (*pattern == &apos;.&apos; &amp;&amp; *str != &apos;\0&apos;))&#123;</span><br><span class="line">            return matchHelper(str+1, pattern+1);</span><br><span class="line">        &#125;</span><br><span class="line">        else return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果pattern下一个字符为&apos;*&apos;</span><br><span class="line">    else &#123;</span><br><span class="line">        // 继续匹配的情况：</span><br><span class="line">        // 1. 当‘*’匹配0个字符时，str当前字符不变，pattern当前字符后移两位，跳过这个‘*’符号；</span><br><span class="line">        // 2. 当‘*’匹配1个或多个时，str当前字符移向下一个，pattern当前字符不变。</span><br><span class="line">        if (*pattern == *str || (*pattern == &apos;.&apos; &amp;&amp; *str != &apos;\0&apos;)) &#123;</span><br><span class="line">            return matchHelper(str+1,pattern) || matchHelper(str, pattern+2);</span><br><span class="line">        &#125;</span><br><span class="line">        else return matchHelper(str, pattern+2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-53-表示数值的字符串"><a href="#剑指offer-53-表示数值的字符串" class="headerlink" title="剑指offer 53 表示数值的字符串"></a>剑指offer 53 表示数值的字符串</h1><p>// 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool isNumeric(char* string)</span><br><span class="line">&#123;</span><br><span class="line">    if (string == nullptr) return false;</span><br><span class="line">    // 标记符号、小数点、e是否出现过</span><br><span class="line">    bool sign = false, decimal = false, hasE = false;</span><br><span class="line">    for (int i = 0; i &lt; strlen(string); i++) &#123;</span><br><span class="line">        if (string[i] == &apos;+&apos; || string[i] == &apos;-&apos;) &#123;</span><br><span class="line">            // 第二次出现+-符号，必须紧接在e之后</span><br><span class="line">            if (sign &amp;&amp; string[i-1] != &apos;e&apos; &amp;&amp; string[i-1] != &apos;E&apos;) return false;</span><br><span class="line">            // 第一次出现+-符号，且不是在字符串开头，也必须紧接在e之后</span><br><span class="line">            if (!sign &amp;&amp; i&gt;0 &amp;&amp; string[i-1] != &apos;e&apos; &amp;&amp; string[i-1] != &apos;E&apos;) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (string[i] == &apos;e&apos; || string[i] == &apos;E&apos;) &#123;</span><br><span class="line">            // e后面一定要接数字 || 不能同时存在两个e</span><br><span class="line">            if (i == strlen(string) - 1 || hasE) return false;</span><br><span class="line">            hasE = true;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (string[i] == &apos;.&apos;) &#123;</span><br><span class="line">            // e后面不能接小数点，小数点不能出现两次</span><br><span class="line">            if (hasE || decimal) return false;</span><br><span class="line">            decimal = true;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (string[i] &lt; &apos;0&apos; || string[i] &gt; &apos;9&apos;) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-54-字符流中第一个不重复的字符"><a href="#剑指offer-54-字符流中第一个不重复的字符" class="headerlink" title="剑指offer 54 字符流中第一个不重复的字符"></a>剑指offer 54 字符流中第一个不重复的字符</h1><p>// 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。如果当前字符流没有存在出现一次的字符，返回#字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">char hash[256] = &#123;0&#125;;</span><br><span class="line">//Insert one char from stringstream</span><br><span class="line">void Insert(char ch)</span><br><span class="line">&#123;</span><br><span class="line">        s += ch;</span><br><span class="line">        hash[ch]++;</span><br><span class="line">&#125;</span><br><span class="line">//return the first appearence once char in current stringstream</span><br><span class="line">char FirstAppearingOnce()</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">        if (hash[s[i]] == 1) &#123;</span><br><span class="line">            return s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &apos;#&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-55-链表中环的入口节点"><a href="#剑指offer-55-链表中环的入口节点" class="headerlink" title="剑指offer 55 链表中环的入口节点"></a>剑指offer 55 链表中环的入口节点</h1><p>// 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ListNode* EntryNodeOfLoop(ListNode* pHead)</span><br><span class="line">&#123;</span><br><span class="line">    if (pHead == nullptr) return nullptr;</span><br><span class="line">    ListNode* fast = pHead;</span><br><span class="line">    ListNode* slow = pHead;</span><br><span class="line">    ListNode* meetingNode = nullptr;</span><br><span class="line">    while (fast-&gt;next &amp;&amp; slow) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        if (fast == slow) &#123;</span><br><span class="line">            meetingNode = fast;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (meetingNode) &#123;</span><br><span class="line">        ListNode* p1 = meetingNode;</span><br><span class="line">        ListNode* p2 = pHead;</span><br><span class="line">        while (p1 != p2) &#123;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return p1;</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-56-删除链表中重复的节点"><a href="#剑指offer-56-删除链表中重复的节点" class="headerlink" title="剑指offer 56 删除链表中重复的节点"></a>剑指offer 56 删除链表中重复的节点</h1><p>// 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ListNode* deleteDuplication(ListNode* pHead)</span><br><span class="line">&#123;</span><br><span class="line">    if (pHead == nullptr) return nullptr;</span><br><span class="line">    ListNode *root = pHead, *pre;</span><br><span class="line">    while (root != nullptr) &#123;</span><br><span class="line">        if (root-&gt;next-&gt;val != root-&gt;val) &#123;</span><br><span class="line">            pre = root;</span><br><span class="line">            root = root-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            while (root-&gt;next &amp;&amp; root-&gt;next-&gt;val == root-&gt;val) &#123;</span><br><span class="line">                root = root-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            if (root-&gt;next) &#123;</span><br><span class="line">                pre-&gt;next = root-&gt;next;</span><br><span class="line">                root = root-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                pre-&gt;next = nullptr;</span><br><span class="line">                return pHead;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-57-二叉树的下一个节点"><a href="#剑指offer-57-二叉树的下一个节点" class="headerlink" title="剑指offer 57 二叉树的下一个节点"></a>剑指offer 57 二叉树的下一个节点</h1><p>// 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TreeLinkNode* GetNext(TreeLinkNode* pNode)</span><br><span class="line">&#123;</span><br><span class="line">    if (pNode == nullptr) return pNode;</span><br><span class="line">    while (pNode-&gt;right) &#123;</span><br><span class="line">        pNode = pNode-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="剑指offer-58-对称的二叉树"><a href="#剑指offer-58-对称的二叉树" class="headerlink" title="剑指offer 58 对称的二叉树"></a>剑指offer 58 对称的二叉树</h1><p>// 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool isSymmetrical(TreeNode* pRoot)</span><br><span class="line">&#123;</span><br><span class="line">    if (pRoot == nullptr) return true;</span><br><span class="line">    return isSymmetricalHelper(pRoot-&gt;left, pRoot-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">bool isSymmetricalHelper(TreeNode* p1, TreeNode* p2) &#123;</span><br><span class="line">    if (p1 &amp;&amp; p2 == nullptr) return false;</span><br><span class="line">    else if (p2 &amp;&amp; p1 == nullptr) return false;</span><br><span class="line">    else if (p1 == nullptr &amp;&amp; p2 == nullptr) return true;</span><br><span class="line">    if (p1-&gt;val == p2-&gt;val) &#123;</span><br><span class="line">        return isSymmetricalHelper(p1-&gt;left, p2-&gt;right) &amp;&amp; isSymmetricalHelper(p2-&gt;left, p1-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    else return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-59-之字形打印二叉树"><a href="#剑指offer-59-之字形打印二叉树" class="headerlink" title="剑指offer 59 之字形打印二叉树"></a>剑指offer 59 之字形打印二叉树</h1><p>// 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; PrintZ(TreeNode* pRoot) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    if (pRoot == nullptr) return res;</span><br><span class="line">    vector&lt;TreeNode*&gt; d;</span><br><span class="line">    d.push_back(pRoot);</span><br><span class="line">    vector&lt;int&gt; init;</span><br><span class="line">    init.push_back(pRoot-&gt;val);</span><br><span class="line">    res.push_back(init);</span><br><span class="line">    int layer = 1;</span><br><span class="line">    while (!d.empty()) &#123;</span><br><span class="line">        layer++;</span><br><span class="line">        vector&lt;TreeNode*&gt; tmp;</span><br><span class="line">        for (int i = 0; i &lt; d.size(); i++) &#123;</span><br><span class="line">            if (d[i]-&gt;left) tmp.push_back(d[i]-&gt;left);</span><br><span class="line">            if (d[i]-&gt;right) tmp.push_back(d[i]-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; tmpInt;</span><br><span class="line">        for (int i = 0; i &lt; tmp.size(); i++) &#123;</span><br><span class="line">            tmpInt.push_back(tmp[i]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        if (layer % 2 == 1 &amp;&amp; !tmpInt.empty()) &#123;</span><br><span class="line">            res.push_back(tmpInt);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (layer % 2 == 0 &amp;&amp; !tmpInt.empty()) &#123;</span><br><span class="line">            reverse(tmpInt.begin(), tmpInt.end());</span><br><span class="line">            res.push_back(tmpInt);</span><br><span class="line">        &#125;</span><br><span class="line">        d = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-60-把二叉树打印成多行（层序遍历）"><a href="#剑指offer-60-把二叉树打印成多行（层序遍历）" class="headerlink" title="剑指offer 60 把二叉树打印成多行（层序遍历）"></a>剑指offer 60 把二叉树打印成多行（层序遍历）</h1><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; vec;</span><br><span class="line">    if(pRoot == NULL) return vec;</span><br><span class="line"></span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(pRoot);</span><br><span class="line"></span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int lo = 0, hi = q.size();</span><br><span class="line">        vector&lt;int&gt; c;</span><br><span class="line">        while(lo++ &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *t = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            c.push_back(t-&gt;val);</span><br><span class="line">            if(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">            if(t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        vec.push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">    return vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-61-序列化二叉树"><a href="#剑指offer-61-序列化二叉树" class="headerlink" title="剑指offer 61 序列化二叉树"></a>剑指offer 61 序列化二叉树</h1><p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p>
<p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">typedef TreeNode node;</span><br><span class="line">typedef TreeNode* pnode;</span><br><span class="line">typedef int* pint;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    vector&lt;int&gt; buf;</span><br><span class="line">    void dfs(pnode p)&#123;</span><br><span class="line">        if(!p) buf.push_back(0x23333);</span><br><span class="line">        else&#123;</span><br><span class="line">            buf.push_back(p -&gt; val);</span><br><span class="line">            dfs(p -&gt; left);</span><br><span class="line">            dfs(p -&gt; right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pnode dfs2(pint&amp; p)&#123;</span><br><span class="line">        if(*p == 0x23333)&#123;</span><br><span class="line">            ++p;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        pnode res = new node(*p);</span><br><span class="line">        ++p;</span><br><span class="line">        res -&gt; left = dfs2(p);</span><br><span class="line">        res -&gt; right = dfs2(p);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    char* Serialize(TreeNode *p) &#123;</span><br><span class="line">        buf.clear();</span><br><span class="line">        dfs(p);</span><br><span class="line">        int *res = new int[buf.size()];</span><br><span class="line">        for(unsigned int i = 0; i &lt; buf.size(); ++i) res[i] = buf[i];</span><br><span class="line">        return (char*)res;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* Deserialize(char *str) &#123;</span><br><span class="line">        int *p = (int*)str;</span><br><span class="line">        return dfs2(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-62-二叉搜索树的第k个结点"><a href="#剑指offer-62-二叉搜索树的第k个结点" class="headerlink" title="剑指offer 62 二叉搜索树的第k个结点"></a>剑指offer 62 二叉搜索树的第k个结点</h1><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如,(5，3，7，2，4，6，8)中，按结点数值大小顺序第三小结点的值为4。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 递归</span><br><span class="line">int cnt = 0;</span><br><span class="line">TreeNode* KthNode(TreeNode* pRoot, int k)</span><br><span class="line">&#123;</span><br><span class="line">    if (pRoot) &#123;</span><br><span class="line">        TreeNode* node = KthNode(pRoot-&gt;left, k);</span><br><span class="line">        if (node) return node;</span><br><span class="line">        cnt++;</span><br><span class="line">        if (cnt == k) return pRoot;</span><br><span class="line">        node = KthNode(pRoot-&gt;right, k);</span><br><span class="line">        if (node) return node;</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br><span class="line">// 非递归 中序遍历</span><br><span class="line">TreeNode* KthNode(TreeNode* pRoot, int k)</span><br><span class="line">&#123;</span><br><span class="line">    if (pRoot == nullptr || k &lt; 1) return nullptr;</span><br><span class="line">    stack&lt;TreeNode*&gt; S;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    TreeNode* node = pRoot;</span><br><span class="line">    while (!S.empty() || node) &#123;</span><br><span class="line">        while (node) &#123;</span><br><span class="line">            S.push(node);</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        node = S.top();</span><br><span class="line">        S.pop();</span><br><span class="line">        cnt++;</span><br><span class="line">        if (cnt == k) return node;</span><br><span class="line">        node = node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-63-数据流中的中位数"><a href="#剑指offer-63-数据流中的中位数" class="headerlink" title="剑指offer 63 数据流中的中位数"></a>剑指offer 63 数据流中的中位数</h1><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 法1：大顶堆+小顶堆 </span><br><span class="line">// 法2：AVL 平衡二叉搜索树</span><br><span class="line">// 法3：排序</span><br><span class="line">vector&lt;int&gt; dataStream;</span><br><span class="line">void Insert(int num)</span><br><span class="line">&#123;</span><br><span class="line">    dataStream.push_back(num);</span><br><span class="line">    sort(dataStream.begin(), dataStream.end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double GetMedian()</span><br><span class="line">&#123; </span><br><span class="line">    int sz = dataStream.size();</span><br><span class="line">    double res;</span><br><span class="line">    if (sz % 2 == 0) &#123;</span><br><span class="line">        res = (double) (dataStream[sz/2] + dataStream[sz/2-1]) / 2;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        res = (double) dataStream[sz/2];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-64-滑动窗口的最大值"><a href="#剑指offer-64-滑动窗口的最大值" class="headerlink" title="剑指offer 64 滑动窗口的最大值"></a>剑指offer 64 滑动窗口的最大值</h1><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 暴力法 O(n * size)</span><br><span class="line">int FindMaxVal(vector&lt;int&gt; num, int st, int ed) &#123;</span><br><span class="line">    int MaxVal = num[st];</span><br><span class="line">    for (int i = st; i &lt;= ed; i++) &#123;</span><br><span class="line">        if (num[i] &gt; MaxVal) MaxVal = num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return MaxVal;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; maxInWindows1(const vector&lt;int&gt;&amp; num, unsigned int size)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    if (num.size() == 0 || size &lt; 1) return res;</span><br><span class="line">    for (int i = 0; i &lt;= num.size()-size; i++) &#123;</span><br><span class="line">        int tmp = FindMaxVal(num, i, i+size-1);</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">// 双端队列 O(n)</span><br><span class="line">vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    if (num.size() == 0 || size &lt; 1) return res;</span><br><span class="line">    deque&lt;int&gt; d;</span><br><span class="line">    for (int i = 0; i &lt; num.size(); ++i) &#123;</span><br><span class="line">        // 从后面依次弹出队列汇总比当前num值小的元素，同时保证队首元素为当前窗口最大值下标</span><br><span class="line">        while (d.size() &amp;&amp; num[d.back()] &lt;= num[i]) &#123;</span><br><span class="line">            d.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        // 当当前窗口移出队首元素所在的位置，即队首元素坐标对应的num不在窗口中，需要弹出</span><br><span class="line">        if (d.size() &amp;&amp; i-d.front()+1 &gt; size) &#123;</span><br><span class="line">            d.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        d.push_back(i);</span><br><span class="line">        // 当滑动窗口首地址i大于等于size时才开始写入窗口最大值</span><br><span class="line">        if (i &gt;= size - 1) &#123;</span><br><span class="line">            res.push_back(num[d.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-65-矩阵中的路径"><a href="#剑指offer-65-矩阵中的路径" class="headerlink" title="剑指offer 65 矩阵中的路径"></a>剑指offer 65 矩阵中的路径</h1><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">bool dfs(char* matrix, int i, int j, int rows, int cols, char* str, vector&lt;vector&lt;bool&gt; &gt; path) &#123;</span><br><span class="line">    if (*str == &apos;\0&apos;) return true;</span><br><span class="line">    if (matrix[i * cols + j] != str[0]) return false;</span><br><span class="line"></span><br><span class="line">    bool hasPath = false;</span><br><span class="line">    if (j &gt;= 0 &amp;&amp; i &gt;=0 &amp;&amp; i &lt; rows &amp;&amp; j &lt; cols &amp;&amp; !path[i][j]</span><br><span class="line">        &amp;&amp; matrix[i * cols + j] == str[0]) &#123;</span><br><span class="line">            path[i][j] = true;</span><br><span class="line">            hasPath = dfs(matrix, i-1, j, rows, cols, str+1, path)</span><br><span class="line">                    || dfs(matrix, i+1, j, rows, cols, str+1, path)</span><br><span class="line">                    || dfs(matrix, i, j-1, rows, cols, str+1, path)</span><br><span class="line">                    || dfs(matrix, i, j+1, rows, cols, str+1, path);</span><br><span class="line">            if (!hasPath) path[i][j] = false;</span><br><span class="line">        &#125;</span><br><span class="line">    return hasPath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool hasPath(char* matrix, int rows, int cols, char* str)</span><br><span class="line">&#123;</span><br><span class="line">    if (matrix == nullptr || str == nullptr) return false;</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; path(rows, vector&lt;bool&gt;(cols, false));</span><br><span class="line">    bool res = false;</span><br><span class="line">    for (int row = 0; row &lt; rows; row++) &#123;</span><br><span class="line">        for (int col = 0; col &lt; cols; col++) &#123;</span><br><span class="line">            if (matrix[row * cols + col] == str[0]) &#123;</span><br><span class="line">                res = dfs(matrix, row, col, rows, cols, str, path);</span><br><span class="line">            &#125;</span><br><span class="line">            if (res) return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-66-机器人的动作范围"><a href="#剑指offer-66-机器人的动作范围" class="headerlink" title="剑指offer 66 机器人的动作范围"></a>剑指offer 66 机器人的动作范围</h1><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int movingCount(int threshold, int rows, int cols)</span><br><span class="line">&#123;</span><br><span class="line">    bool* flag=new bool[rows*cols];</span><br><span class="line">    for(int i=0;i&lt;rows*cols;i++)</span><br><span class="line">        flag[i]=false;</span><br><span class="line">    int count=moving(threshold,rows,cols,0,0,flag);//从（0,0）坐标开始访问;</span><br><span class="line">    delete[] flag;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">//计算最大移动位置</span><br><span class="line">int moving(int threshold,int rows,int cols,int i,int j,bool* flag) &#123;</span><br><span class="line">    int count=0;</span><br><span class="line">    if(check(threshold,rows,cols,i,j,flag)) &#123;</span><br><span class="line">        flag[i*cols+j]=true;</span><br><span class="line">        //标记访问过，这个标志flag不需要回溯，因为只要被访问过即可。</span><br><span class="line">       //因为如果能访问，访问过会加1.不能访问，也会标记下访问过。</span><br><span class="line">        count=1+moving(threshold,rows,cols,i-1,j,flag) + moving(threshold,rows,cols,i,j-1,flag)</span><br><span class="line">               +moving(threshold,rows,cols,i+1,j,flag) + moving(threshold,rows,cols,i,j+1,flag);</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">//检查当前位置是否可以访问</span><br><span class="line">bool check(int threshold,int rows,int cols,int i,int j,bool* flag) &#123;</span><br><span class="line">    if(i&gt;=0 &amp;&amp; i&lt;rows &amp;&amp; j&gt;=0 &amp;&amp; j&lt;cols</span><br><span class="line">        &amp;&amp; getSum(i)+getSum(j)&lt;=threshold</span><br><span class="line">        &amp;&amp; flag[i*cols+j]==false)</span><br><span class="line">       return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">//计算位置的数值</span><br><span class="line">int getSum(int number) &#123;</span><br><span class="line">    int sum=0;</span><br><span class="line">    while(number&gt;0) &#123;</span><br><span class="line">        sum+=number%10;</span><br><span class="line">        number/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>

<h1 id="剑指offer-67-剪绳子"><a href="#剑指offer-67-剪绳子" class="headerlink" title="剑指offer 67 剪绳子"></a>剑指offer 67 剪绳子</h1><p>给你一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* 首先判断k[0]到k[m]可能有哪些数字，实际上只可能是2或者3。</span><br><span class="line"> * 5&lt;2*3,6&lt;3*3,比6更大的数字我们就更不用考虑了，肯定要继续分。</span><br><span class="line"> * 其次看2和3的数量，2的数量肯定小于3个，为什么呢？因为2*2*2&lt;3*3，那么题目就简单了。</span><br><span class="line"> * 直接用n除以3，根据得到的余数判断是一个2还是两个2还是没有2就行了。</span><br><span class="line"> * 由于题目规定m&gt;1，所以2只能是1*1，3只能是2*1，这两个特殊情况直接返回就行了。 */</span><br><span class="line">long long n_max_3(long long n) &#123;</span><br><span class="line">    if (n == 2) return 1;</span><br><span class="line">    if (n == 3) return 2;</span><br><span class="line">    long long x = n % 3;</span><br><span class="line">    long long y = n / 3;</span><br><span class="line">    if (x == 0) &#123;</span><br><span class="line">        return pow(3, y);</span><br><span class="line">    &#125; else if (x == 1) &#123;</span><br><span class="line">        return 2 * 2 * (long long) pow(3, y - 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 2 * (long long) pow(3, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div STYLE="page-break-after: always;"></div>
        </div>
        
        <div class="level is-size-7 is-uppercase">
            <div class="level-start">
                <div class="level-item">
                    <span class="is-size-6 has-text-grey has-mr-7">#</span>
                    <a class="has-link-grey -link" href="/tags/Algorithm/">Algorithm</a>, <a class="has-link-grey -link" href="/tags/C/">C++</a>
                </div>
            </div>
        </div>
        
        
        
    </div>
</div>





<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        <div class="level-start">
            <a class="level level-item has-link-grey  article-nav-prev" href="/2020/03/19/ck7yndqjo000utounrbht09ll/">
                <i class="level-item fas fa-chevron-left"></i>
                <span class="level-item">Postgresql+postgis地图开发说明</span>
            </a>
        </div>
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/2020/01/08/ck7yndqjm000ptounvfzffpzy/">
                <span class="level-item">Git</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>


</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                    <figure class="image is-128x128 has-mb-6">
                        <img class="" src="/images/xigua.jpg" alt="Lingcheng Dai">
                    </figure>
                    
                    <p class="is-size-4 is-block">
                        Lingcheng Dai
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        Live and Learn.
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>Beijing, China</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Posts
                    </p>
                    <a href="/archives">
                        <p class="title has-text-weight-normal">
                            18
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Categories
                    </p>
                    <a href="/categories">
                        <p class="title has-text-weight-normal">
                            10
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Tags
                    </p>
                    <a href="/tags">
                        <p class="title has-text-weight-normal">
                            24
                        </p>
                    </a>
                </div>
            </div>
        </nav>
        
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/dlc1994" target="_blank" rel="noopener">
                Follow</a>
        </div>
        
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="Github" href="https://github.com/dlc1994">
                
                <i class="fab fa-github"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        

    <div class="card widget" id="toc">
        <div class="card-content">
            <div class="menu">
                <h3 class="menu-label">
                    Catalogue
                </h3>
                <ul class="menu-list"><li>
        <a class="is-flex" href="#剑指offer-1-二维数组查找">
        <span class="has-mr-6">1</span>
        <span>剑指offer 1 二维数组查找</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-2-替换空格">
        <span class="has-mr-6">2</span>
        <span>剑指offer 2 替换空格</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-3-从尾到头打印链表">
        <span class="has-mr-6">3</span>
        <span>剑指offer 3 从尾到头打印链表</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-4-重建二叉树">
        <span class="has-mr-6">4</span>
        <span>剑指offer 4 重建二叉树</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-5-用两个栈实现队列">
        <span class="has-mr-6">5</span>
        <span>剑指offer 5 用两个栈实现队列</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-6-旋转数组的最小值">
        <span class="has-mr-6">6</span>
        <span>剑指offer 6 旋转数组的最小值</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-7-斐波那契数列">
        <span class="has-mr-6">7</span>
        <span>剑指offer 7 斐波那契数列</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-8-跳台阶">
        <span class="has-mr-6">8</span>
        <span>剑指offer 8 跳台阶</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-9-变态跳台阶">
        <span class="has-mr-6">9</span>
        <span>剑指offer 9 变态跳台阶</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-10-矩形覆盖">
        <span class="has-mr-6">10</span>
        <span>剑指offer 10 矩形覆盖</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-11-二进制中1的个数">
        <span class="has-mr-6">11</span>
        <span>剑指offer 11 二进制中1的个数**</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-12-求base的exponent次方">
        <span class="has-mr-6">12</span>
        <span>剑指offer 12 求base的exponent次方</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-13-调整数组奇偶顺序">
        <span class="has-mr-6">13</span>
        <span>剑指offer 13 调整数组奇偶顺序</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-14-链表倒数第k个结点">
        <span class="has-mr-6">14</span>
        <span>剑指offer 14 链表倒数第k个结点</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-15-反转链表">
        <span class="has-mr-6">15</span>
        <span>剑指offer 15 反转链表</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-16-合并两个排序的链表">
        <span class="has-mr-6">16</span>
        <span>剑指offer 16 合并两个排序的链表</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-17-树的子结构">
        <span class="has-mr-6">17</span>
        <span>剑指offer 17 树的子结构</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-18-二叉树的镜像">
        <span class="has-mr-6">18</span>
        <span>剑指offer 18 二叉树的镜像</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-19-顺时针打印矩阵">
        <span class="has-mr-6">19</span>
        <span>剑指offer 19 顺时针打印矩阵</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-20-包含Min函数的栈">
        <span class="has-mr-6">20</span>
        <span>剑指offer 20 包含Min函数的栈</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-21-栈的压入、弹出序列">
        <span class="has-mr-6">21</span>
        <span>剑指offer 21 栈的压入、弹出序列</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-22-从上往下打印二叉树">
        <span class="has-mr-6">22</span>
        <span>剑指offer 22 从上往下打印二叉树</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-23-二叉搜索树的后序遍历序列">
        <span class="has-mr-6">23</span>
        <span>剑指offer 23 二叉搜索树的后序遍历序列</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-24-二叉树中和为某一值的所有路径">
        <span class="has-mr-6">24</span>
        <span>剑指offer 24 二叉树中和为某一值的所有路径</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-25-复杂链表的复制">
        <span class="has-mr-6">25</span>
        <span>剑指offer 25 复杂链表的复制</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-26-二叉搜索树转双端链表">
        <span class="has-mr-6">26</span>
        <span>剑指offer 26 二叉搜索树转双端链表**</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-27-字符串的排列">
        <span class="has-mr-6">27</span>
        <span>剑指offer 27 字符串的排列</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-28-数组中出现超过一半的数">
        <span class="has-mr-6">28</span>
        <span>剑指offer 28 数组中出现超过一半的数</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-29-最小的k个数">
        <span class="has-mr-6">29</span>
        <span>剑指offer 29 最小的k个数**</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-30-连续子数组最大和">
        <span class="has-mr-6">30</span>
        <span>剑指offer 30 连续子数组最大和</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-31-整数中1的个数">
        <span class="has-mr-6">31</span>
        <span>剑指offer 31 整数中1的个数</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-32-把数组排成最小的数">
        <span class="has-mr-6">32</span>
        <span>剑指offer 32 把数组排成最小的数**</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-33-丑数">
        <span class="has-mr-6">33</span>
        <span>剑指offer 33 丑数</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-34-第一次出现的字符">
        <span class="has-mr-6">34</span>
        <span>剑指offer 34 第一次出现的字符</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-35-数组中的逆序对">
        <span class="has-mr-6">35</span>
        <span>剑指offer 35 数组中的逆序对**</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-36-两个链表的第一个公共结点">
        <span class="has-mr-6">36</span>
        <span>剑指offer 36 两个链表的第一个公共结点</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-37-数组在排序数组出现的次数">
        <span class="has-mr-6">37</span>
        <span>剑指offer 37 数组在排序数组出现的次数</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-38-二叉树深度">
        <span class="has-mr-6">38</span>
        <span>剑指offer 38 二叉树深度</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-39-判断平衡二叉树">
        <span class="has-mr-6">39</span>
        <span>剑指offer 39 判断平衡二叉树</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-40-数组中只出现一次的数字">
        <span class="has-mr-6">40</span>
        <span>剑指offer 40 数组中只出现一次的数字</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-41-和为S的连续正数序列">
        <span class="has-mr-6">41</span>
        <span>剑指offer 41 和为S的连续正数序列</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-42-和为S的两个数">
        <span class="has-mr-6">42</span>
        <span>剑指offer 42 和为S的两个数</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-43-左旋转字符串">
        <span class="has-mr-6">43</span>
        <span>剑指offer 43 左旋转字符串</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-44-翻转单词顺序列">
        <span class="has-mr-6">44</span>
        <span>剑指offer 44 翻转单词顺序列</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-45-扑克牌顺子">
        <span class="has-mr-6">45</span>
        <span>剑指offer 45 扑克牌顺子</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-46-孩子们的游戏（圆圈里最后剩下的数）">
        <span class="has-mr-6">46</span>
        <span>剑指offer 46 孩子们的游戏（圆圈里最后剩下的数）</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-47-求1-2-…-n">
        <span class="has-mr-6">47</span>
        <span>剑指offer 47 求1+2+…+n</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-48-不用加减乘除做加法">
        <span class="has-mr-6">48</span>
        <span>剑指offer 48 不用加减乘除做加法</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-49-把字符串转换为整数">
        <span class="has-mr-6">49</span>
        <span>剑指offer 49 把字符串转换为整数</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-50-数组中重复的数字">
        <span class="has-mr-6">50</span>
        <span>剑指offer 50 数组中重复的数字</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-51-构建乘积数组">
        <span class="has-mr-6">51</span>
        <span>剑指offer 51 构建乘积数组</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-52-正则表达式匹配">
        <span class="has-mr-6">52</span>
        <span>剑指offer 52 正则表达式匹配</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-53-表示数值的字符串">
        <span class="has-mr-6">53</span>
        <span>剑指offer 53 表示数值的字符串</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-54-字符流中第一个不重复的字符">
        <span class="has-mr-6">54</span>
        <span>剑指offer 54 字符流中第一个不重复的字符</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-55-链表中环的入口节点">
        <span class="has-mr-6">55</span>
        <span>剑指offer 55 链表中环的入口节点</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-56-删除链表中重复的节点">
        <span class="has-mr-6">56</span>
        <span>剑指offer 56 删除链表中重复的节点</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-57-二叉树的下一个节点">
        <span class="has-mr-6">57</span>
        <span>剑指offer 57 二叉树的下一个节点</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-58-对称的二叉树">
        <span class="has-mr-6">58</span>
        <span>剑指offer 58 对称的二叉树</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-59-之字形打印二叉树">
        <span class="has-mr-6">59</span>
        <span>剑指offer 59 之字形打印二叉树</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-60-把二叉树打印成多行（层序遍历）">
        <span class="has-mr-6">60</span>
        <span>剑指offer 60 把二叉树打印成多行（层序遍历）</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-61-序列化二叉树">
        <span class="has-mr-6">61</span>
        <span>剑指offer 61 序列化二叉树</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-62-二叉搜索树的第k个结点">
        <span class="has-mr-6">62</span>
        <span>剑指offer 62 二叉搜索树的第k个结点</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-63-数据流中的中位数">
        <span class="has-mr-6">63</span>
        <span>剑指offer 63 数据流中的中位数</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-64-滑动窗口的最大值">
        <span class="has-mr-6">64</span>
        <span>剑指offer 64 滑动窗口的最大值</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-65-矩阵中的路径">
        <span class="has-mr-6">65</span>
        <span>剑指offer 65 矩阵中的路径</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-66-机器人的动作范围">
        <span class="has-mr-6">66</span>
        <span>剑指offer 66 机器人的动作范围</span>
        </a></li><li>
        <a class="is-flex" href="#剑指offer-67-剪绳子">
        <span class="has-mr-6">67</span>
        <span>剑指offer 67 剪绳子</span>
        </a></li></ul>
            </div>
        </div>
    </div>

    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Links
        </h3>
        <ul class="menu-list">
        
            <li>
                <a class="level is-mobile" href="https://github.com/dlc1994" target="_blank" rel="noopener">
                    <span class="level-left">
                        <span class="level-item">Github</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">github.com</span>
                    </span>
                </a>
            </li>
        
        </ul>
        </div>
    </div>
</div>

    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Categories
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/Algorithm-and-Data-Structure/">
            <span class="level-start">
                <span class="level-item">Algorithm and Data Structure</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">6</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Competition/">
            <span class="level-start">
                <span class="level-item">Competition</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">2</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Data-Processing/">
            <span class="level-start">
                <span class="level-item">Data Processing</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Development/">
            <span class="level-start">
                <span class="level-item">Development</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Git/">
            <span class="level-start">
                <span class="level-item">Git</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/HEXO/">
            <span class="level-start">
                <span class="level-item">HEXO</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/LeetCode/">
            <span class="level-start">
                <span class="level-item">LeetCode</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">2</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Machine-Learning/">
            <span class="level-start">
                <span class="level-item">Machine Learning</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">2</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Paper-Work/">
            <span class="level-start">
                <span class="level-item">Paper Work</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Wireless-Communications/">
            <span class="level-start">
                <span class="level-item">Wireless Communications</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li>
            </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Tag Cloud
        </h3>
        <a href="/tags/Algorithm/" style="font-size: 16.67px;">Algorithm</a> <a href="/tags/Algorithms/" style="font-size: 13.33px;">Algorithms</a> <a href="/tags/Binary-Tree/" style="font-size: 10px;">Binary Tree</a> <a href="/tags/C/" style="font-size: 13.33px;">C++</a> <a href="/tags/C-C/" style="font-size: 13.33px;">C/C++</a> <a href="/tags/DataFrame/" style="font-size: 10px;">DataFrame</a> <a href="/tags/Database/" style="font-size: 10px;">Database</a> <a href="/tags/Gradient-Decent-Methods/" style="font-size: 10px;">Gradient Decent Methods</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Latex/" style="font-size: 10px;">Latex</a> <a href="/tags/Linear-Regression/" style="font-size: 10px;">Linear Regression</a> <a href="/tags/LinkedList/" style="font-size: 10px;">LinkedList</a> <a href="/tags/Map/" style="font-size: 10px;">Map</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Matlab/" style="font-size: 13.33px;">Matlab</a> <a href="/tags/Polynomial-Regression/" style="font-size: 10px;">Polynomial Regression</a> <a href="/tags/Postgis/" style="font-size: 10px;">Postgis</a> <a href="/tags/Postgresql/" style="font-size: 10px;">Postgresql</a> <a href="/tags/Python/" style="font-size: 20px;">Python</a> <a href="/tags/Sorting/" style="font-size: 13.33px;">Sorting</a> <a href="/tags/Stack/" style="font-size: 10px;">Stack</a> <a href="/tags/Wireless-communications/" style="font-size: 10px;">Wireless communications</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a>
    </div>
</div>
    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
            <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Recent
        </h3>
        
        <article class="media">
            
            <a href="/2020/03/19/ck7yndqj90009tounaawcs689/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/gallery/kmp.png" alt="Knuth–Morris–Pratt algorithm (C++)">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-03-19T15:26:34.000Z">2020-03-19</time></div>
                    <a href="/2020/03/19/ck7yndqj90009tounaawcs689/" class="title has-link-black-ter is-size-6 has-text-weight-normal">Knuth–Morris–Pratt algorithm (C++)</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Algorithm-and-Data-Structure/">Algorithm and Data Structure</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/03/19/ck7yndqji000jtounmmkop0bs/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/gallery/maxp.png" alt="中国第二届高性能云计算大赛（MAXP)——京东云数据算法赛">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-03-19T07:20:45.000Z">2020-03-19</time></div>
                    <a href="/2020/03/19/ck7yndqji000jtounmmkop0bs/" class="title has-link-black-ter is-size-6 has-text-weight-normal">中国第二届高性能云计算大赛（MAXP)——京东云数据算法赛</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Competition/">Competition</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/03/19/ck7yndqjo000utounrbht09ll/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/gallery/thumbnails/post.jpg" alt="Postgresql+postgis地图开发说明">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-03-19T07:20:45.000Z">2020-03-19</time></div>
                    <a href="/2020/03/19/ck7yndqjo000utounrbht09ll/" class="title has-link-black-ter is-size-6 has-text-weight-normal">Postgresql+postgis地图开发说明</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Development/">Development</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/03/06/ck7yndqks0039tounaw5uzd5n/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/gallery/thumbnails/nowcoder.jpg" alt="剑指offer题解(C++)">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-03-06T13:27:23.000Z">2020-03-06</time></div>
                    <a href="/2020/03/06/ck7yndqks0039tounaw5uzd5n/" class="title has-link-black-ter is-size-6 has-text-weight-normal">剑指offer题解(C++)</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Algorithm-and-Data-Structure/">Algorithm and Data Structure</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/01/08/ck7yndqjm000ptounvfzffpzy/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/gallery/thumbnails/git.jpg" alt="Git">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-01-08T04:50:07.000Z">2020-01-08</time></div>
                    <a href="/2020/01/08/ck7yndqjm000ptounvfzffpzy/" class="title has-link-black-ter is-size-6 has-text-weight-normal">Git</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Git/">Git</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Archives
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2020/03/">
                <span class="level-start">
                    <span class="level-item">March 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">4</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/01/">
                <span class="level-start">
                    <span class="level-item">January 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">August 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/05/">
                <span class="level-start">
                    <span class="level-item">May 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/04/">
                <span class="level-start">
                    <span class="level-item">April 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/03/">
                <span class="level-start">
                    <span class="level-item">March 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/11/">
                <span class="level-start">
                    <span class="level-item">November 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/07/">
                <span class="level-start">
                    <span class="level-item">July 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/06/">
                <span class="level-start">
                    <span class="level-item">June 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Tags
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Algorithm/">
                        <span class="tag">Algorithm</span>
                        <span class="tag is-grey">4</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Algorithms/">
                        <span class="tag">Algorithms</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Binary-Tree/">
                        <span class="tag">Binary Tree</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/C/">
                        <span class="tag">C++</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/C-C/">
                        <span class="tag">C/C++</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/DataFrame/">
                        <span class="tag">DataFrame</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Database/">
                        <span class="tag">Database</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Gradient-Decent-Methods/">
                        <span class="tag">Gradient Decent Methods</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Hexo/">
                        <span class="tag">Hexo</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Latex/">
                        <span class="tag">Latex</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Linear-Regression/">
                        <span class="tag">Linear Regression</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/LinkedList/">
                        <span class="tag">LinkedList</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Map/">
                        <span class="tag">Map</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Markdown/">
                        <span class="tag">Markdown</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Matlab/">
                        <span class="tag">Matlab</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Polynomial-Regression/">
                        <span class="tag">Polynomial Regression</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Postgis/">
                        <span class="tag">Postgis</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Postgresql/">
                        <span class="tag">Postgresql</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Python/">
                        <span class="tag">Python</span>
                        <span class="tag is-grey">6</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Sorting/">
                        <span class="tag">Sorting</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Stack/">
                        <span class="tag">Stack</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Wireless-communications/">
                        <span class="tag">Wireless communications</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/git/">
                        <span class="tag">git</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/linux/">
                        <span class="tag">linux</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
        
        </div>
    
</div>

                




<div class="column is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only has-order-3 column-right ">
    
        <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Recent
        </h3>
        
        <article class="media">
            
            <a href="/2020/03/19/ck7yndqj90009tounaawcs689/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/gallery/kmp.png" alt="Knuth–Morris–Pratt algorithm (C++)">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-03-19T15:26:34.000Z">2020-03-19</time></div>
                    <a href="/2020/03/19/ck7yndqj90009tounaawcs689/" class="title has-link-black-ter is-size-6 has-text-weight-normal">Knuth–Morris–Pratt algorithm (C++)</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Algorithm-and-Data-Structure/">Algorithm and Data Structure</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/03/19/ck7yndqji000jtounmmkop0bs/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/gallery/maxp.png" alt="中国第二届高性能云计算大赛（MAXP)——京东云数据算法赛">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-03-19T07:20:45.000Z">2020-03-19</time></div>
                    <a href="/2020/03/19/ck7yndqji000jtounmmkop0bs/" class="title has-link-black-ter is-size-6 has-text-weight-normal">中国第二届高性能云计算大赛（MAXP)——京东云数据算法赛</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Competition/">Competition</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/03/19/ck7yndqjo000utounrbht09ll/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/gallery/thumbnails/post.jpg" alt="Postgresql+postgis地图开发说明">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-03-19T07:20:45.000Z">2020-03-19</time></div>
                    <a href="/2020/03/19/ck7yndqjo000utounrbht09ll/" class="title has-link-black-ter is-size-6 has-text-weight-normal">Postgresql+postgis地图开发说明</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Development/">Development</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/03/06/ck7yndqks0039tounaw5uzd5n/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/gallery/thumbnails/nowcoder.jpg" alt="剑指offer题解(C++)">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-03-06T13:27:23.000Z">2020-03-06</time></div>
                    <a href="/2020/03/06/ck7yndqks0039tounaw5uzd5n/" class="title has-link-black-ter is-size-6 has-text-weight-normal">剑指offer题解(C++)</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Algorithm-and-Data-Structure/">Algorithm and Data Structure</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/01/08/ck7yndqjm000ptounvfzffpzy/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/gallery/thumbnails/git.jpg" alt="Git">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-01-08T04:50:07.000Z">2020-01-08</time></div>
                    <a href="/2020/01/08/ck7yndqjm000ptounvfzffpzy/" class="title has-link-black-ter is-size-6 has-text-weight-normal">Git</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Git/">Git</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Archives
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2020/03/">
                <span class="level-start">
                    <span class="level-item">March 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">4</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/01/">
                <span class="level-start">
                    <span class="level-item">January 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">August 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/05/">
                <span class="level-start">
                    <span class="level-item">May 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/04/">
                <span class="level-start">
                    <span class="level-item">April 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/03/">
                <span class="level-start">
                    <span class="level-item">March 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/11/">
                <span class="level-start">
                    <span class="level-item">November 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/07/">
                <span class="level-start">
                    <span class="level-item">July 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/06/">
                <span class="level-start">
                    <span class="level-item">June 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Tags
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Algorithm/">
                        <span class="tag">Algorithm</span>
                        <span class="tag is-grey">4</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Algorithms/">
                        <span class="tag">Algorithms</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Binary-Tree/">
                        <span class="tag">Binary Tree</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/C/">
                        <span class="tag">C++</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/C-C/">
                        <span class="tag">C/C++</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/DataFrame/">
                        <span class="tag">DataFrame</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Database/">
                        <span class="tag">Database</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Gradient-Decent-Methods/">
                        <span class="tag">Gradient Decent Methods</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Hexo/">
                        <span class="tag">Hexo</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Latex/">
                        <span class="tag">Latex</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Linear-Regression/">
                        <span class="tag">Linear Regression</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/LinkedList/">
                        <span class="tag">LinkedList</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Map/">
                        <span class="tag">Map</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Markdown/">
                        <span class="tag">Markdown</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Matlab/">
                        <span class="tag">Matlab</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Polynomial-Regression/">
                        <span class="tag">Polynomial Regression</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Postgis/">
                        <span class="tag">Postgis</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Postgresql/">
                        <span class="tag">Postgresql</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Python/">
                        <span class="tag">Python</span>
                        <span class="tag is-grey">6</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Sorting/">
                        <span class="tag">Sorting</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Stack/">
                        <span class="tag">Stack</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Wireless-communications/">
                        <span class="tag">Wireless communications</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/git/">
                        <span class="tag">git</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/linux/">
                        <span class="tag">linux</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
    
    
</div>

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/head.jpg" alt="剑指offer题解(C++)" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2020 Lingcheng Dai&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a>
                
                <br>
                <span id="busuanzi_container_site_uv">
                Visited by <span id="busuanzi_value_site_uv">0</span> users
                </span>
                
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/dlc1994">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("en");</script>


<script>
var IcarusThemeSettings = {
    site: {
        url: 'https://dlc1994.github.io',
        external_link: {"enable":true,"exclude":[]}
    },
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>





<script src="/js/animation.js"></script>



<script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
<script src="/js/gallery.js" defer></script>



<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>


<a id="back-to-top" title="Back to Top" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>














<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>